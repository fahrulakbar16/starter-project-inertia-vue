import{C as ow,cH as _l,d as gr,z as P$,l as B$,s as HK,U as jK,e as Rs,o as _s,a as ft,F as YI,i as z$,n as W$,f as oc,t as fa,E as V$,cF as U$,g as u2,S as G$,b as H$}from"./app-CJkCV51W.js";import qK from"./AbsenceStatuses-CyN4-Aas.js";function OS(e,t){for(var n=0;n<t.length;n++){const r=t[n];if(typeof r!="string"&&!Array.isArray(r)){for(const s in r)if(s!=="default"&&!(s in e)){const a=Object.getOwnPropertyDescriptor(r,s);a&&Object.defineProperty(e,s,a.get?a:{enumerable:!0,get:()=>r[s]})}}}return Object.freeze(Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}))}var KK=Object.defineProperty,XK=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(t,n)=>(typeof require<"u"?require:t)[n]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')}),LS=(e,t)=>{for(var n in t)KK(e,n,{get:t[n],enumerable:!0})},QK={};LS(QK,{Abs:()=>pf,Acos:()=>yd,Acosh:()=>xd,AdadeltaOptimizer:()=>rN,AdagradOptimizer:()=>sN,AdamOptimizer:()=>aN,AdamaxOptimizer:()=>iN,Add:()=>yu,AddN:()=>wd,All:()=>ff,Any:()=>mf,ArgMax:()=>gf,ArgMin:()=>bf,Asin:()=>vd,Asinh:()=>Id,Atan:()=>kd,Atan2:()=>Sd,Atanh:()=>Cd,AvgPool:()=>Nd,AvgPool3D:()=>yf,AvgPool3DGrad:()=>Hy,AvgPoolGrad:()=>Gy,BackendWasm:()=>LB,BatchMatMul:()=>Td,BatchToSpaceND:()=>xf,Bincount:()=>wf,BitwiseAnd:()=>vf,BroadcastArgs:()=>jy,BroadcastTo:()=>UF,Callback:()=>O8,CallbackList:()=>AM,Cast:()=>Ed,Ceil:()=>Ad,ClipByValue:()=>xu,Complex:()=>hw,ComplexAbs:()=>qy,Concat:()=>If,Conv2D:()=>$d,Conv2DBackpropFilter:()=>pw,Conv2DBackpropInput:()=>Rd,Conv3D:()=>_d,Conv3DBackpropFilterV2:()=>kf,Conv3DBackpropInputV2:()=>Cf,Cos:()=>Dd,Cosh:()=>Fd,CropAndResize:()=>Nf,Cumprod:()=>Sf,Cumsum:()=>Md,CustomCallback:()=>RM,DataStorage:()=>uw,DenseBincount:()=>Ky,DepthToSpace:()=>Tf,DepthwiseConv2dNative:()=>Od,DepthwiseConv2dNativeBackpropFilter:()=>fw,DepthwiseConv2dNativeBackpropInput:()=>mw,Diag:()=>Xy,Dilation2D:()=>Ld,Dilation2DBackpropFilter:()=>Mp,Dilation2DBackpropInput:()=>Fp,Draw:()=>gw,ENV:()=>VS,EarlyStopping:()=>L8,Einsum:()=>bw,Elu:()=>Bd,EluGrad:()=>Ef,Environment:()=>WF,Equal:()=>Af,Erf:()=>zd,Exp:()=>Wd,ExpandDims:()=>$f,Expm1:()=>Vd,FFT:()=>yw,Fill:()=>Qy,FlipLeftRight:()=>Rf,Floor:()=>Ud,FloorDiv:()=>Gd,FromPixels:()=>ox,FusedBatchNorm:()=>Hd,FusedConv2D:()=>Lc,FusedDepthwiseConv2D:()=>Pc,GPGPUContext:()=>q2,GatherNd:()=>Df,GatherV2:()=>_f,GraphModel:()=>jT,Greater:()=>Ff,GreaterEqual:()=>jd,History:()=>$M,IFFT:()=>xw,Identity:()=>qd,Imag:()=>ww,InputSpec:()=>Rr,IsFinite:()=>Kd,IsInf:()=>Xd,IsNan:()=>Qd,KernelBackend:()=>Vy,LRN:()=>eh,LRNGrad:()=>Wf,LayerVariable:()=>vM,LayersModel:()=>rl,LeakyRelu:()=>Yd,Less:()=>Mf,LessEqual:()=>Of,LinSpace:()=>Lf,Log:()=>Jd,Log1p:()=>Zd,LogSoftmax:()=>HF,LogicalAnd:()=>Pf,LogicalNot:()=>Bf,LogicalOr:()=>zf,LogicalXor:()=>GF,LowerBound:()=>WX,MathBackendCPU:()=>XT,MathBackendWebGL:()=>k4,MatrixBandPart:()=>VX,Max:()=>th,MaxPool:()=>rh,MaxPool3D:()=>Vf,MaxPool3DGrad:()=>Jy,MaxPoolGrad:()=>Yy,MaxPoolWithArgmax:()=>Zy,Maximum:()=>nh,Mean:()=>sh,Min:()=>ah,Minimum:()=>ih,MirrorPad:()=>oh,Mod:()=>lh,MomentumOptimizer:()=>oN,Multinomial:()=>Uf,Multiply:()=>uh,Neg:()=>Gf,NonMaxSuppressionV3:()=>jf,NonMaxSuppressionV4:()=>qf,NonMaxSuppressionV5:()=>Kf,NotEqual:()=>Hf,OP_SCOPE_SUFFIX:()=>qS,OneHot:()=>ch,OnesLike:()=>Xf,Optimizer:()=>bl,OptimizerConstructors:()=>eM,Pack:()=>Qf,PadV2:()=>dh,Pool:()=>UX,Pow:()=>hh,Prelu:()=>ph,Prod:()=>fh,RMSPropOptimizer:()=>lN,RNN:()=>yl,RaggedGather:()=>vw,RaggedRange:()=>Iw,RaggedTensorToTensor:()=>kw,Range:()=>e0,Rank:()=>jk,Real:()=>Cw,RealDiv:()=>Pd,Reciprocal:()=>mh,Reduction:()=>Ls,Relu:()=>gh,Relu6:()=>xh,Reshape:()=>Yf,ResizeBilinear:()=>yh,ResizeBilinearGrad:()=>Zf,ResizeNearestNeighbor:()=>bh,ResizeNearestNeighborGrad:()=>Jf,Reverse:()=>wh,RotateWithOffset:()=>fm,Round:()=>vh,Rsqrt:()=>Ih,SGDOptimizer:()=>iv,ScatterNd:()=>em,SearchSorted:()=>nm,Select:()=>rm,Selu:()=>kh,Sequential:()=>xv,Sigmoid:()=>Th,Sign:()=>Nh,Sin:()=>Ch,Sinh:()=>Sh,Slice:()=>sm,Softmax:()=>Rh,Softplus:()=>Eh,SpaceToBatchND:()=>am,SparseFillEmptyRows:()=>t0,SparseReshape:()=>om,SparseSegmentMean:()=>n0,SparseSegmentSum:()=>r0,SparseToDense:()=>lm,SplitV:()=>im,Sqrt:()=>Ah,Square:()=>s0,SquaredDifference:()=>_h,StaticRegexReplace:()=>a0,Step:()=>vu,StridedSlice:()=>um,StringNGrams:()=>i0,StringSplit:()=>o0,StringToHashBucketFast:()=>l0,Sub:()=>Dh,Sum:()=>$h,SymbolicTensor:()=>qi,Tan:()=>Fh,Tanh:()=>Mh,Tensor:()=>Wt,TensorBuffer:()=>_r,TensorScatterUpdate:()=>tm,Tile:()=>wu,TopK:()=>cm,Transform:()=>dm,Transpose:()=>nl,Unique:()=>u0,Unpack:()=>hm,UnsortedSegmentSum:()=>c0,UpperBound:()=>GX,Variable:()=>Bc,ZerosLike:()=>pm,_FusedMatMul:()=>Oc,abs:()=>Ar,acos:()=>JS,acosh:()=>ZS,add:()=>Se,addN:()=>x6,all:()=>Aw,any:()=>cy,argMax:()=>Uc,argMin:()=>e3,asin:()=>t3,asinh:()=>n3,atan:()=>r3,atan2:()=>s3,atanh:()=>a3,avgPool:()=>fl,avgPool3d:()=>o3,backend:()=>KS,backend_util:()=>P,basicLSTMCell:()=>k6,batchNorm:()=>Oh,batchNorm2d:()=>l3,batchNorm3d:()=>u3,batchNorm4d:()=>c3,batchToSpaceND:()=>b0,bincount:()=>d3,bitwiseAnd:()=>C6,booleanMaskAsync:()=>p5,broadcastArgs:()=>S6,broadcastTo:()=>Ec,broadcast_util:()=>mm,browser:()=>$0,buffer:()=>Ht,callbacks:()=>Bue,cast:()=>Ve,ceil:()=>h3,clipByValue:()=>vs,clone:()=>xo,complex:()=>il,concat:()=>Bn,concat1d:()=>p3,concat2d:()=>f3,concat3d:()=>m3,concat4d:()=>g3,constraints:()=>SM,conv1d:()=>$w,conv2d:()=>Vs,conv2dTranspose:()=>Rw,conv3d:()=>y3,conv3dTranspose:()=>x3,copyRegisteredKernels:()=>KX,cos:()=>y0,cosh:()=>_w,cosineWindow:()=>tv,cumprod:()=>py,cumsum:()=>Dw,customGrad:()=>Eo,data:()=>oO,denseBincount:()=>cx,deprecationWarn:()=>a6,depthToSpace:()=>w3,depthwiseConv2d:()=>Lh,deregisterOp:()=>Vue,device_util:()=>f0,diag:()=>T6,dilation2d:()=>v3,disableDeprecationWarnings:()=>CQ,dispose:()=>Lt,disposeVariables:()=>SQ,div:()=>it,divNoNan:()=>I3,dot:()=>k3,dropout:()=>J3,einsum:()=>bc,elu:()=>gm,enableDebugMode:()=>kQ,enableProdMode:()=>IQ,enclosingPowerOfTwo:()=>Z3,engine:()=>ai,ensureShape:()=>A6,env:()=>ge,equal:()=>Na,erf:()=>Fw,euclideanNorm:()=>N3,exp:()=>Is,expandDims:()=>ns,expm1:()=>T3,eye:()=>Mw,fft:()=>E0,fill:()=>Ca,findBackend:()=>RQ,findBackendFactory:()=>_Q,floor:()=>ym,floorDiv:()=>Ew,forceHalfFloat:()=>RL,fused:()=>Up,gather:()=>xm,gatherND:()=>b5,gather_util:()=>dN,getBackend:()=>i6,getGradient:()=>Gk,getKernel:()=>oy,getKernelsForBackend:()=>lx,getThreadsCount:()=>j$e,gpgpu_util:()=>lL,grad:()=>cZ,grads:()=>dZ,greater:()=>Xs,greaterEqual:()=>ml,ifft:()=>Vp,imag:()=>x0,image:()=>La,inTopKAsync:()=>y5,initializers:()=>NM,input:()=>HM,io:()=>fs,irfft:()=>Kw,isFinite:()=>E3,isInf:()=>A3,isNaN:()=>$3,keep:()=>zr,kernel_impls:()=>Lo,layers:()=>TM,leakyRelu:()=>w0,less:()=>Pp,lessEqual:()=>ku,linalg:()=>nN,linspace:()=>F6,loadGraphModel:()=>Kce,loadGraphModelSync:()=>Xce,loadLayersModel:()=>Foe,localResponseNormalization:()=>R3,log:()=>Ta,log1p:()=>v0,logSigmoid:()=>_3,logSoftmax:()=>Lw,logSumExp:()=>I0,logicalAnd:()=>di,logicalNot:()=>k0,logicalOr:()=>Pw,logicalXor:()=>D3,losses:()=>$5,lowerBound:()=>O6,matMul:()=>Ut,math:()=>W5,max:()=>Va,maxPool:()=>Zr,maxPool3d:()=>F3,maxPoolWithArgmax:()=>L6,maximum:()=>Oo,mean:()=>cr,memory:()=>Zk,meshgrid:()=>P6,metrics:()=>D8,min:()=>Lp,minimum:()=>tu,mirrorPad:()=>M3,mod:()=>O3,model:()=>Loe,models:()=>F8,moments:()=>C0,movingAverage:()=>f5,mul:()=>se,multiRNNCell:()=>B6,multinomial:()=>z6,neg:()=>Jn,nextFrame:()=>hN,norm:()=>bm,notEqual:()=>jc,oneHot:()=>Bp,ones:()=>ra,onesLike:()=>Ea,op:()=>ne,outerProduct:()=>W6,pad:()=>Ji,pad1d:()=>V6,pad2d:()=>U6,pad3d:()=>G6,pad4d:()=>H6,pool:()=>L3,pow:()=>To,prelu:()=>N0,print:()=>YS,prod:()=>P3,profile:()=>NQ,raggedGather:()=>j6,raggedRange:()=>q6,raggedTensorToTensor:()=>K6,rand:()=>X6,randomGamma:()=>Z6,randomNormal:()=>zw,randomStandardNormal:()=>e5,randomUniform:()=>Cu,randomUniformInt:()=>t5,range:()=>qc,ready:()=>AQ,real:()=>zp,reciprocal:()=>U3,registerBackend:()=>Tw,registerCallbackConstructor:()=>Boe,registerGradient:()=>jF,registerKernel:()=>d0,registerOp:()=>Wue,regularizers:()=>M8,relu:()=>Rn,relu6:()=>Ww,removeBackend:()=>$Q,reshape:()=>ae,reverse:()=>qa,reverse1d:()=>n5,reverse2d:()=>r5,reverse3d:()=>s5,reverse4d:()=>a5,rfft:()=>A0,round:()=>Vw,rsqrt:()=>Uw,scalar:()=>vt,scatterND:()=>m5,scatter_util:()=>Yw,searchSorted:()=>Bw,selu:()=>Gw,separableConv2d:()=>wm,sequential:()=>Poe,serialization:()=>Me,setBackend:()=>EQ,setPlatform:()=>DQ,setThreadsCount:()=>H$e,setWasmPath:()=>U$e,setWasmPaths:()=>G$e,setWebGLContext:()=>_9,setdiff1dAsync:()=>i5,shared:()=>QT,sigmoid:()=>ci,sign:()=>G3,signal:()=>A5,sin:()=>Hw,sinh:()=>jw,slice:()=>en,slice1d:()=>T0,slice2d:()=>qw,slice3d:()=>vm,slice4d:()=>Wp,slice_util:()=>Gr,softmax:()=>Su,softplus:()=>Ph,spaceToBatchND:()=>S0,sparse:()=>R5,sparseToDense:()=>g5,spectral:()=>E5,split:()=>sa,sqrt:()=>ls,square:()=>Pn,squaredDifference:()=>Xw,squeeze:()=>Nu,stack:()=>Dr,step:()=>Bh,stridedSlice:()=>H3,string:()=>_5,sub:()=>et,sum:()=>dt,sumOutType:()=>Nw,tan:()=>j3,tanh:()=>eu,tensor:()=>zs,tensor1d:()=>Tn,tensor2d:()=>wo,tensor3d:()=>Qw,tensor4d:()=>nu,tensor5d:()=>o5,tensor6d:()=>l5,tensorScatterUpdate:()=>c5,tensor_util:()=>Bi,test_util:()=>Q6,tidy:()=>ie,tile:()=>Ia,time:()=>TQ,topk:()=>K3,train:()=>pc,transpose:()=>Gt,truncatedNormal:()=>Zw,unique:()=>X3,unregisterGradient:()=>qX,unregisterKernel:()=>jX,unsortedSegmentSum:()=>ev,unstack:()=>br,upcastType:()=>Ha,upperBound:()=>d5,util:()=>$,valueAndGrad:()=>hZ,valueAndGrads:()=>pZ,variable:()=>Q3,variableGrads:()=>M6,version:()=>Z$e,version_converter:()=>Yce,version_core:()=>Lne,version_cpu:()=>Jhe,version_layers:()=>MN,version_wasm:()=>q$e,version_webgl:()=>W1e,webgl:()=>V1e,webgl_util:()=>R9,where:()=>os,whereAsync:()=>Y3,zeros:()=>dr,zerosLike:()=>sn});var YK=Object.create,PS=Object.defineProperty,JK=Object.getOwnPropertyDescriptor,ZK=Object.getOwnPropertyNames,eX=Object.getPrototypeOf,tX=Object.prototype.hasOwnProperty,Mr=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),Pt=(e,t)=>{for(var n in t)PS(e,n,{get:t[n],enumerable:!0})},nX=(e,t,n,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let s of ZK(t))!tX.call(e,s)&&s!==n&&PS(e,s,{get:()=>t[s],enumerable:!(r=JK(t,s))||r.enumerable});return e},bu=(e,t,n)=>(n=e!=null?YK(eX(e)):{},nX(!e||!e.__esModule?PS(n,"default",{value:e,enumerable:!0}):n,e)),rX=Mr((e,t)=>{t.exports=r;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function r(C,M,L){this.low=C|0,this.high=M|0,this.unsigned=!!L}r.prototype.__isLong__,Object.defineProperty(r.prototype,"__isLong__",{value:!0});function s(C){return(C&&C.__isLong__)===!0}r.isLong=s;var a={},i={};function o(C,M){var L,O,B;return M?(C>>>=0,(B=0<=C&&C<256)&&(O=i[C],O)?O:(L=c(C,(C|0)<0?-1:0,!0),B&&(i[C]=L),L)):(C|=0,(B=-128<=C&&C<128)&&(O=a[C],O)?O:(L=c(C,C<0?-1:0,!1),B&&(a[C]=L),L))}r.fromInt=o;function u(C,M){if(isNaN(C))return M?w:x;if(M){if(C<0)return w;if(C>=g)return E}else{if(C<=-b)return A;if(C+1>=b)return T}return C<0?u(-C,M).neg():c(C%m|0,C/m|0,M)}r.fromNumber=u;function c(C,M,L){return new r(C,M,L)}r.fromBits=c;var l=Math.pow;function d(C,M,L){if(C.length===0)throw Error("empty string");if(C==="NaN"||C==="Infinity"||C==="+Infinity"||C==="-Infinity")return x;if(typeof M=="number"?(L=M,M=!1):M=!!M,L=L||10,L<2||36<L)throw RangeError("radix");var O;if((O=C.indexOf("-"))>0)throw Error("interior hyphen");if(O===0)return d(C.substring(1),M,L).neg();for(var B=u(l(L,8)),G=x,z=0;z<C.length;z+=8){var q=Math.min(8,C.length-z),Q=parseInt(C.substring(z,z+q),L);if(q<8){var K=u(l(L,q));G=G.mul(K).add(u(Q))}else G=G.mul(B),G=G.add(u(Q))}return G.unsigned=M,G}r.fromString=d;function h(C,M){return typeof C=="number"?u(C,M):typeof C=="string"?d(C,M):c(C.low,C.high,typeof M=="boolean"?M:C.unsigned)}r.fromValue=h;var p=65536,f=1<<24,m=p*p,g=m*m,b=g/2,y=o(f),x=o(0);r.ZERO=x;var w=o(0,!0);r.UZERO=w;var v=o(1);r.ONE=v;var I=o(1,!0);r.UONE=I;var N=o(-1);r.NEG_ONE=N;var T=c(-1,2147483647,!1);r.MAX_VALUE=T;var E=c(-1,-1,!0);r.MAX_UNSIGNED_VALUE=E;var A=c(0,-2147483648,!1);r.MIN_VALUE=A;var k=r.prototype;k.toInt=function(){return this.unsigned?this.low>>>0:this.low},k.toNumber=function(){return this.unsigned?(this.high>>>0)*m+(this.low>>>0):this.high*m+(this.low>>>0)},k.toString=function(C){if(C=C||10,C<2||36<C)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(A)){var M=u(C),L=this.div(M),O=L.mul(M).sub(this);return L.toString(C)+O.toInt().toString(C)}else return"-"+this.neg().toString(C);for(var B=u(l(C,6),this.unsigned),G=this,z="";;){var q=G.div(B),Q=G.sub(q.mul(B)).toInt()>>>0,K=Q.toString(C);if(G=q,G.isZero())return K+z;for(;K.length<6;)K="0"+K;z=""+K+z}},k.getHighBits=function(){return this.high},k.getHighBitsUnsigned=function(){return this.high>>>0},k.getLowBits=function(){return this.low},k.getLowBitsUnsigned=function(){return this.low>>>0},k.getNumBitsAbs=function(){if(this.isNegative())return this.eq(A)?64:this.neg().getNumBitsAbs();for(var C=this.high!=0?this.high:this.low,M=31;M>0&&!(C&1<<M);M--);return this.high!=0?M+33:M+1},k.isZero=function(){return this.high===0&&this.low===0},k.eqz=k.isZero,k.isNegative=function(){return!this.unsigned&&this.high<0},k.isPositive=function(){return this.unsigned||this.high>=0},k.isOdd=function(){return(this.low&1)===1},k.isEven=function(){return(this.low&1)===0},k.equals=function(C){return s(C)||(C=h(C)),this.unsigned!==C.unsigned&&this.high>>>31===1&&C.high>>>31===1?!1:this.high===C.high&&this.low===C.low},k.eq=k.equals,k.notEquals=function(C){return!this.eq(C)},k.neq=k.notEquals,k.ne=k.notEquals,k.lessThan=function(C){return this.comp(C)<0},k.lt=k.lessThan,k.lessThanOrEqual=function(C){return this.comp(C)<=0},k.lte=k.lessThanOrEqual,k.le=k.lessThanOrEqual,k.greaterThan=function(C){return this.comp(C)>0},k.gt=k.greaterThan,k.greaterThanOrEqual=function(C){return this.comp(C)>=0},k.gte=k.greaterThanOrEqual,k.ge=k.greaterThanOrEqual,k.compare=function(C){if(s(C)||(C=h(C)),this.eq(C))return 0;var M=this.isNegative(),L=C.isNegative();return M&&!L?-1:!M&&L?1:this.unsigned?C.high>>>0>this.high>>>0||C.high===this.high&&C.low>>>0>this.low>>>0?-1:1:this.sub(C).isNegative()?-1:1},k.comp=k.compare,k.negate=function(){return!this.unsigned&&this.eq(A)?A:this.not().add(v)},k.neg=k.negate,k.add=function(C){s(C)||(C=h(C));var M=this.high>>>16,L=this.high&65535,O=this.low>>>16,B=this.low&65535,G=C.high>>>16,z=C.high&65535,q=C.low>>>16,Q=C.low&65535,K=0,ee=0,Y=0,de=0;return de+=B+Q,Y+=de>>>16,de&=65535,Y+=O+q,ee+=Y>>>16,Y&=65535,ee+=L+z,K+=ee>>>16,ee&=65535,K+=M+G,K&=65535,c(Y<<16|de,K<<16|ee,this.unsigned)},k.subtract=function(C){return s(C)||(C=h(C)),this.add(C.neg())},k.sub=k.subtract,k.multiply=function(C){if(this.isZero())return x;if(s(C)||(C=h(C)),n){var M=n.mul(this.low,this.high,C.low,C.high);return c(M,n.get_high(),this.unsigned)}if(C.isZero())return x;if(this.eq(A))return C.isOdd()?A:x;if(C.eq(A))return this.isOdd()?A:x;if(this.isNegative())return C.isNegative()?this.neg().mul(C.neg()):this.neg().mul(C).neg();if(C.isNegative())return this.mul(C.neg()).neg();if(this.lt(y)&&C.lt(y))return u(this.toNumber()*C.toNumber(),this.unsigned);var L=this.high>>>16,O=this.high&65535,B=this.low>>>16,G=this.low&65535,z=C.high>>>16,q=C.high&65535,Q=C.low>>>16,K=C.low&65535,ee=0,Y=0,de=0,ue=0;return ue+=G*K,de+=ue>>>16,ue&=65535,de+=B*K,Y+=de>>>16,de&=65535,de+=G*Q,Y+=de>>>16,de&=65535,Y+=O*K,ee+=Y>>>16,Y&=65535,Y+=B*Q,ee+=Y>>>16,Y&=65535,Y+=G*q,ee+=Y>>>16,Y&=65535,ee+=L*K+O*Q+B*q+G*z,ee&=65535,c(de<<16|ue,ee<<16|Y,this.unsigned)},k.mul=k.multiply,k.divide=function(C){if(s(C)||(C=h(C)),C.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&this.high===-2147483648&&C.low===-1&&C.high===-1)return this;var M=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,C.low,C.high);return c(M,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?w:x;var L,O,B;if(this.unsigned){if(C.unsigned||(C=C.toUnsigned()),C.gt(this))return w;if(C.gt(this.shru(1)))return I;B=w}else{if(this.eq(A)){if(C.eq(v)||C.eq(N))return A;if(C.eq(A))return v;var G=this.shr(1);return L=G.div(C).shl(1),L.eq(x)?C.isNegative()?v:N:(O=this.sub(C.mul(L)),B=L.add(O.div(C)),B)}else if(C.eq(A))return this.unsigned?w:x;if(this.isNegative())return C.isNegative()?this.neg().div(C.neg()):this.neg().div(C).neg();if(C.isNegative())return this.div(C.neg()).neg();B=x}for(O=this;O.gte(C);){L=Math.max(1,Math.floor(O.toNumber()/C.toNumber()));for(var z=Math.ceil(Math.log(L)/Math.LN2),q=z<=48?1:l(2,z-48),Q=u(L),K=Q.mul(C);K.isNegative()||K.gt(O);)L-=q,Q=u(L,this.unsigned),K=Q.mul(C);Q.isZero()&&(Q=v),B=B.add(Q),O=O.sub(K)}return B},k.div=k.divide,k.modulo=function(C){if(s(C)||(C=h(C)),n){var M=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,C.low,C.high);return c(M,n.get_high(),this.unsigned)}return this.sub(this.div(C).mul(C))},k.mod=k.modulo,k.rem=k.modulo,k.not=function(){return c(~this.low,~this.high,this.unsigned)},k.and=function(C){return s(C)||(C=h(C)),c(this.low&C.low,this.high&C.high,this.unsigned)},k.or=function(C){return s(C)||(C=h(C)),c(this.low|C.low,this.high|C.high,this.unsigned)},k.xor=function(C){return s(C)||(C=h(C)),c(this.low^C.low,this.high^C.high,this.unsigned)},k.shiftLeft=function(C){return s(C)&&(C=C.toInt()),(C&=63)===0?this:C<32?c(this.low<<C,this.high<<C|this.low>>>32-C,this.unsigned):c(0,this.low<<C-32,this.unsigned)},k.shl=k.shiftLeft,k.shiftRight=function(C){return s(C)&&(C=C.toInt()),(C&=63)===0?this:C<32?c(this.low>>>C|this.high<<32-C,this.high>>C,this.unsigned):c(this.high>>C-32,this.high>=0?0:-1,this.unsigned)},k.shr=k.shiftRight,k.shiftRightUnsigned=function(C){if(s(C)&&(C=C.toInt()),C&=63,C===0)return this;var M=this.high;if(C<32){var L=this.low;return c(L>>>C|M<<32-C,M>>>C,this.unsigned)}else return C===32?c(M,0,this.unsigned):c(M>>>C-32,0,this.unsigned)},k.shru=k.shiftRightUnsigned,k.shr_u=k.shiftRightUnsigned,k.toSigned=function(){return this.unsigned?c(this.low,this.high,!1):this},k.toUnsigned=function(){return this.unsigned?this:c(this.low,this.high,!0)},k.toBytes=function(C){return C?this.toBytesLE():this.toBytesBE()},k.toBytesLE=function(){var C=this.high,M=this.low;return[M&255,M>>>8&255,M>>>16&255,M>>>24,C&255,C>>>8&255,C>>>16&255,C>>>24]},k.toBytesBE=function(){var C=this.high,M=this.low;return[C>>>24,C>>>16&255,C>>>8&255,C&255,M>>>24,M>>>16&255,M>>>8&255,M&255]},r.fromBytes=function(C,M,L){return L?r.fromBytesLE(C,M):r.fromBytesBE(C,M)},r.fromBytesLE=function(C,M){return new r(C[0]|C[1]<<8|C[2]<<16|C[3]<<24,C[4]|C[5]<<8|C[6]<<16|C[7]<<24,M)},r.fromBytesBE=function(C,M){return new r(C[4]<<24|C[5]<<16|C[6]<<8|C[7],C[0]<<24|C[1]<<16|C[2]<<8|C[3],M)}}),sX=Mr(()=>{}),aX=Mr(()=>{}),iX=Mr((e,t)=>{(function(n,r,s){function a(c){var l=this,d=u();l.next=function(){var h=2091639*l.s0+l.c*23283064365386963e-26;return l.s0=l.s1,l.s1=l.s2,l.s2=h-(l.c=h|0)},l.c=1,l.s0=d(" "),l.s1=d(" "),l.s2=d(" "),l.s0-=d(c),l.s0<0&&(l.s0+=1),l.s1-=d(c),l.s1<0&&(l.s1+=1),l.s2-=d(c),l.s2<0&&(l.s2+=1),d=null}function i(c,l){return l.c=c.c,l.s0=c.s0,l.s1=c.s1,l.s2=c.s2,l}function o(c,l){var d=new a(c),h=l&&l.state,p=d.next;return p.int32=function(){return d.next()*4294967296|0},p.double=function(){return p()+(p()*2097152|0)*11102230246251565e-32},p.quick=p,h&&(typeof h=="object"&&i(h,d),p.state=function(){return i(d,{})}),p}function u(){var c=4022871197,l=function(d){d=String(d);for(var h=0;h<d.length;h++){c+=d.charCodeAt(h);var p=.02519603282416938*c;c=p>>>0,p-=c,p*=c,c=p>>>0,p-=c,c+=p*4294967296}return(c>>>0)*23283064365386963e-26};return l}r&&r.exports?r.exports=o:s&&s.amd?s(function(){return o}):this.alea=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),oX=Mr((e,t)=>{(function(n,r,s){function a(u){var c=this,l="";c.x=0,c.y=0,c.z=0,c.w=0,c.next=function(){var h=c.x^c.x<<11;return c.x=c.y,c.y=c.z,c.z=c.w,c.w^=c.w>>>19^h^h>>>8},u===(u|0)?c.x=u:l+=u;for(var d=0;d<l.length+64;d++)c.x^=l.charCodeAt(d)|0,c.next()}function i(u,c){return c.x=u.x,c.y=u.y,c.z=u.z,c.w=u.w,c}function o(u,c){var l=new a(u),d=c&&c.state,h=function(){return(l.next()>>>0)/4294967296};return h.double=function(){do var p=l.next()>>>11,f=(l.next()>>>0)/4294967296,m=(p+f)/(1<<21);while(m===0);return m},h.int32=l.next,h.quick=h,d&&(typeof d=="object"&&i(d,l),h.state=function(){return i(l,{})}),h}r&&r.exports?r.exports=o:s&&s.amd?s(function(){return o}):this.xor128=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),lX=Mr((e,t)=>{(function(n,r,s){function a(u){var c=this,l="";c.next=function(){var h=c.x^c.x>>>2;return c.x=c.y,c.y=c.z,c.z=c.w,c.w=c.v,(c.d=c.d+362437|0)+(c.v=c.v^c.v<<4^(h^h<<1))|0},c.x=0,c.y=0,c.z=0,c.w=0,c.v=0,u===(u|0)?c.x=u:l+=u;for(var d=0;d<l.length+64;d++)c.x^=l.charCodeAt(d)|0,d==l.length&&(c.d=c.x<<10^c.x>>>4),c.next()}function i(u,c){return c.x=u.x,c.y=u.y,c.z=u.z,c.w=u.w,c.v=u.v,c.d=u.d,c}function o(u,c){var l=new a(u),d=c&&c.state,h=function(){return(l.next()>>>0)/4294967296};return h.double=function(){do var p=l.next()>>>11,f=(l.next()>>>0)/4294967296,m=(p+f)/(1<<21);while(m===0);return m},h.int32=l.next,h.quick=h,d&&(typeof d=="object"&&i(d,l),h.state=function(){return i(l,{})}),h}r&&r.exports?r.exports=o:s&&s.amd?s(function(){return o}):this.xorwow=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),uX=Mr((e,t)=>{(function(n,r,s){function a(u){var c=this;c.next=function(){var d=c.x,h=c.i,p,f;return p=d[h],p^=p>>>7,f=p^p<<24,p=d[h+1&7],f^=p^p>>>10,p=d[h+3&7],f^=p^p>>>3,p=d[h+4&7],f^=p^p<<7,p=d[h+7&7],p=p^p<<13,f^=p^p<<9,d[h]=f,c.i=h+1&7,f};function l(d,h){var p,f=[];if(h===(h|0))f[0]=h;else for(h=""+h,p=0;p<h.length;++p)f[p&7]=f[p&7]<<15^h.charCodeAt(p)+f[p+1&7]<<13;for(;f.length<8;)f.push(0);for(p=0;p<8&&f[p]===0;++p);for(p==8?f[7]=-1:f[p],d.x=f,d.i=0,p=256;p>0;--p)d.next()}l(c,u)}function i(u,c){return c.x=u.x.slice(),c.i=u.i,c}function o(u,c){u==null&&(u=+new Date);var l=new a(u),d=c&&c.state,h=function(){return(l.next()>>>0)/4294967296};return h.double=function(){do var p=l.next()>>>11,f=(l.next()>>>0)/4294967296,m=(p+f)/(1<<21);while(m===0);return m},h.int32=l.next,h.quick=h,d&&(d.x&&i(d,l),h.state=function(){return i(l,{})}),h}r&&r.exports?r.exports=o:s&&s.amd?s(function(){return o}):this.xorshift7=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),cX=Mr((e,t)=>{(function(n,r,s){function a(u){var c=this;c.next=function(){var d=c.w,h=c.X,p=c.i,f,m;return c.w=d=d+1640531527|0,m=h[p+34&127],f=h[p=p+1&127],m^=m<<13,f^=f<<17,m^=m>>>15,f^=f>>>12,m=h[p]=m^f,c.i=p,m+(d^d>>>16)|0};function l(d,h){var p,f,m,g,b,y=[],x=128;for(h===(h|0)?(f=h,h=null):(h=h+"\0",f=0,x=Math.max(x,h.length)),m=0,g=-32;g<x;++g)h&&(f^=h.charCodeAt((g+32)%h.length)),g===0&&(b=f),f^=f<<10,f^=f>>>15,f^=f<<4,f^=f>>>13,g>=0&&(b=b+1640531527|0,p=y[g&127]^=f+b,m=p==0?m+1:0);for(m>=128&&(y[(h&&h.length||0)&127]=-1),m=127,g=512;g>0;--g)f=y[m+34&127],p=y[m=m+1&127],f^=f<<13,p^=p<<17,f^=f>>>15,p^=p>>>12,y[m]=f^p;d.w=b,d.X=y,d.i=m}l(c,u)}function i(u,c){return c.i=u.i,c.w=u.w,c.X=u.X.slice(),c}function o(u,c){u==null&&(u=+new Date);var l=new a(u),d=c&&c.state,h=function(){return(l.next()>>>0)/4294967296};return h.double=function(){do var p=l.next()>>>11,f=(l.next()>>>0)/4294967296,m=(p+f)/(1<<21);while(m===0);return m},h.int32=l.next,h.quick=h,d&&(d.X&&i(d,l),h.state=function(){return i(l,{})}),h}r&&r.exports?r.exports=o:s&&s.amd?s(function(){return o}):this.xor4096=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),dX=Mr((e,t)=>{(function(n,r,s){function a(u){var c=this,l="";c.next=function(){var h=c.b,p=c.c,f=c.d,m=c.a;return h=h<<25^h>>>7^p,p=p-f|0,f=f<<24^f>>>8^m,m=m-h|0,c.b=h=h<<20^h>>>12^p,c.c=p=p-f|0,c.d=f<<16^p>>>16^m,c.a=m-h|0},c.a=0,c.b=0,c.c=-1640531527,c.d=1367130551,u===Math.floor(u)?(c.a=u/4294967296|0,c.b=u|0):l+=u;for(var d=0;d<l.length+20;d++)c.b^=l.charCodeAt(d)|0,c.next()}function i(u,c){return c.a=u.a,c.b=u.b,c.c=u.c,c.d=u.d,c}function o(u,c){var l=new a(u),d=c&&c.state,h=function(){return(l.next()>>>0)/4294967296};return h.double=function(){do var p=l.next()>>>11,f=(l.next()>>>0)/4294967296,m=(p+f)/(1<<21);while(m===0);return m},h.int32=l.next,h.quick=h,d&&(typeof d=="object"&&i(d,l),h.state=function(){return i(l,{})}),h}r&&r.exports?r.exports=o:s&&s.amd?s(function(){return o}):this.tychei=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),hX=Mr(()=>{}),pX=Mr((e,t)=>{(function(n,r,s){var a=256,i=6,o=52,u="random",c=s.pow(a,i),l=s.pow(2,o),d=l*2,h=a-1,p;function f(v,I,N){var T=[];I=I==!0?{entropy:!0}:I||{};var E=y(b(I.entropy?[v,w(r)]:v??x(),3),T),A=new m(T),k=function(){for(var C=A.g(i),M=c,L=0;C<l;)C=(C+L)*a,M*=a,L=A.g(1);for(;C>=d;)C/=2,M/=2,L>>>=1;return(C+L)/M};return k.int32=function(){return A.g(4)|0},k.quick=function(){return A.g(4)/4294967296},k.double=k,y(w(A.S),r),(I.pass||N||function(C,M,L,O){return O&&(O.S&&g(O,A),C.state=function(){return g(A,{})}),L?(s[u]=C,M):C})(k,E,"global"in I?I.global:this==s,I.state)}function m(v){var I,N=v.length,T=this,E=0,A=T.i=T.j=0,k=T.S=[];for(N||(v=[N++]);E<a;)k[E]=E++;for(E=0;E<a;E++)k[E]=k[A=h&A+v[E%N]+(I=k[E])],k[A]=I;(T.g=function(C){for(var M,L=0,O=T.i,B=T.j,G=T.S;C--;)M=G[O=h&O+1],L=L*a+G[h&(G[O]=G[B=h&B+M])+(G[B]=M)];return T.i=O,T.j=B,L})(a)}function g(v,I){return I.i=v.i,I.j=v.j,I.S=v.S.slice(),I}function b(v,I){var N=[],T=typeof v,E;if(I&&T=="object")for(E in v)try{N.push(b(v[E],I-1))}catch{}return N.length?N:T=="string"?v:v+"\0"}function y(v,I){for(var N=v+"",T,E=0;E<N.length;)I[h&E]=h&(T^=I[h&E]*19)+N.charCodeAt(E++);return w(I)}function x(){try{var v;return p&&(v=p.randomBytes)?v=v(a):(v=new Uint8Array(a),(n.crypto||n.msCrypto).getRandomValues(v)),w(v)}catch{var I=n.navigator,N=I&&I.plugins;return[+new Date,n,N,n.screen,w(r)]}}function w(v){return String.fromCharCode.apply(0,v)}if(y(s.random(),r),typeof t=="object"&&t.exports){t.exports=f;try{p=hX()}catch{}}else typeof define=="function"&&define.amd?define(function(){return f}):s["seed"+u]=f})(typeof self<"u"?self:e,[],Math)}),lw=Mr((e,t)=>{var n=iX(),r=oX(),s=lX(),a=uX(),i=cX(),o=dX(),u=pX();u.alea=n,u.xor128=r,u.xorwow=s,u.xorshift7=a,u.xor4096=i,u.tychei=o,t.exports=u}),AF=Mr(()=>{}),BS=Mr(()=>{}),$F=Mr(()=>{}),fX=Mr(()=>{}),mX=Mr(()=>{}),gX=Mr(()=>{}),bX=Mr((e,t)=>{var n=(()=>{var r=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(r=r||__filename),function(s){s=s||{};function a(){return z.buffer!=ve&&nt(z.buffer),Ae}function i(){return z.buffer!=ve&&nt(z.buffer),Be}function o(){return z.buffer!=ve&&nt(z.buffer),Ue}function u(){return z.buffer!=ve&&nt(z.buffer),qe}function c(){return z.buffer!=ve&&nt(z.buffer),ut}var l=typeof s<"u"?s:{},d,h;l.ready=new Promise(function(_,V){d=_,h=V});var p;typeof process<"u"&&process.listeners&&(p={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var f=Object.assign({},l),m=(_,V)=>{throw V},g=typeof window=="object",b=typeof importScripts=="function",y=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",x=l.ENVIRONMENT_IS_PTHREAD||!1,w="";function v(_){return l.locateFile?l.locateFile(_,w):w+_}var I,N,T;function E(_){_ instanceof kt||O("exiting due to exception: "+_)}if(y){var A=BS(),k=$F();b?w=k.dirname(w)+"/":w=__dirname+"/",I=(V,me)=>(V=tt(V)?new URL(V):k.normalize(V),A.readFileSync(V,me?void 0:"utf8")),T=V=>{var me=I(V,!0);return me.buffer||(me=new Uint8Array(me)),me},N=(V,me,Pe)=>{V=tt(V)?new URL(V):k.normalize(V),A.readFile(V,function(He,je){He?Pe(He):me(je.buffer)})},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",function(V){if(!(V instanceof kt))throw V}),process.on("unhandledRejection",function(V){throw V}),m=(V,me)=>{if(St())throw process.exitCode=V,me;E(me),process.exit(V)},l.inspect=function(){return"[Emscripten Module object]"};let _;try{_=fX()}catch(V){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),V}globalThis.Worker=_.Worker}else(g||b)&&(b?w=self.location.href:typeof document<"u"&&document.currentScript&&(w=document.currentScript.src),typeof r<"u"&&r&&(w=r),w.indexOf("blob:")!==0?w=w.substr(0,w.replace(/[?#].*/,"").lastIndexOf("/")+1):w="",y||(I=_=>{var V=new XMLHttpRequest;return V.open("GET",_,!1),V.send(null),V.responseText},b&&(T=_=>{var V=new XMLHttpRequest;return V.open("GET",_,!1),V.responseType="arraybuffer",V.send(null),new Uint8Array(V.response)}),N=(_,V,me)=>{var Pe=new XMLHttpRequest;Pe.open("GET",_,!0),Pe.responseType="arraybuffer",Pe.onload=()=>{if(Pe.status==200||Pe.status==0&&Pe.response){V(Pe.response);return}me()},Pe.onerror=me,Pe.send(null)}));y&&typeof performance>"u"&&(globalThis.performance=mX().performance);var C=console.log.bind(console),M=console.warn.bind(console);y&&(C=_=>A.writeSync(1,_+`
`),M=_=>A.writeSync(2,_+`
`));var L=l.print||C,O=l.printErr||M;Object.assign(l,f),f=null,l.arguments&&l.arguments,l.thisProgram&&l.thisProgram,l.quit&&(m=l.quit);var B;l.wasmBinary&&(B=l.wasmBinary);var G=l.noExitRuntime||!0;typeof WebAssembly!="object"&&re("no native wasm support detected");var z,q,Q=!1,K;function ee(_,V){_||re(V)}var Y=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function de(_,V,me){V>>>=0;for(var Pe=V+me,He=V;_[He]&&!(He>=Pe);)++He;if(He-V>16&&_.buffer&&Y)return Y.decode(_.buffer instanceof SharedArrayBuffer?_.slice(V,He):_.subarray(V,He));for(var je="";V<He;){var Ce=_[V++];if(!(Ce&128)){je+=String.fromCharCode(Ce);continue}var Fe=_[V++]&63;if((Ce&224)==192){je+=String.fromCharCode((Ce&31)<<6|Fe);continue}var Rt=_[V++]&63;if((Ce&240)==224?Ce=(Ce&15)<<12|Fe<<6|Rt:Ce=(Ce&7)<<18|Fe<<12|Rt<<6|_[V++]&63,Ce<65536)je+=String.fromCharCode(Ce);else{var En=Ce-65536;je+=String.fromCharCode(55296|En>>10,56320|En&1023)}}return je}function ue(_,V){return _>>>=0,_?de(i(),_,V):""}function Ie(_,V,me,Pe){if(me>>>=0,!(Pe>0))return 0;for(var He=me,je=me+Pe-1,Ce=0;Ce<_.length;++Ce){var Fe=_.charCodeAt(Ce);if(Fe>=55296&&Fe<=57343){var Rt=_.charCodeAt(++Ce);Fe=65536+((Fe&1023)<<10)|Rt&1023}if(Fe<=127){if(me>=je)break;V[me++>>>0]=Fe}else if(Fe<=2047){if(me+1>=je)break;V[me++>>>0]=192|Fe>>6,V[me++>>>0]=128|Fe&63}else if(Fe<=65535){if(me+2>=je)break;V[me++>>>0]=224|Fe>>12,V[me++>>>0]=128|Fe>>6&63,V[me++>>>0]=128|Fe&63}else{if(me+3>=je)break;V[me++>>>0]=240|Fe>>18,V[me++>>>0]=128|Fe>>12&63,V[me++>>>0]=128|Fe>>6&63,V[me++>>>0]=128|Fe&63}}return V[me>>>0]=0,me-He}function Ee(_,V,me){return Ie(_,i(),V,me)}var ve,Ae,Be,Ue,qe,ut;x&&(ve=l.buffer);function nt(_){ve=_,l.HEAP8=Ae=new Int8Array(_),l.HEAP16=new Int16Array(_),l.HEAP32=Ue=new Int32Array(_),l.HEAPU8=Be=new Uint8Array(_),l.HEAPU16=new Uint16Array(_),l.HEAPU32=qe=new Uint32Array(_),l.HEAPF32=new Float32Array(_),l.HEAPF64=ut=new Float64Array(_)}var rt=l.INITIAL_MEMORY||16777216;if(x)z=l.wasmMemory,ve=l.buffer;else if(l.wasmMemory)z=l.wasmMemory;else if(z=new WebAssembly.Memory({initial:rt/65536,maximum:65536,shared:!0}),!(z.buffer instanceof SharedArrayBuffer))throw O("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),y&&O("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");z&&(ve=z.buffer),rt=ve.byteLength,nt(ve);var ze,ct=[],ht=[],yn=[];function St(){return G}function pn(){if(l.preRun)for(typeof l.preRun=="function"&&(l.preRun=[l.preRun]);l.preRun.length;)wn(l.preRun.shift());wt(ct)}function jt(){!x&&wt(ht)}function nn(){if(!x){if(l.postRun)for(typeof l.postRun=="function"&&(l.postRun=[l.postRun]);l.postRun.length;)vn(l.postRun.shift());wt(yn)}}function wn(_){ct.unshift(_)}function Tt(_){ht.unshift(_)}function vn(_){yn.unshift(_)}var Kt=0,an=null;function xr(_){Kt++,l.monitorRunDependencies&&l.monitorRunDependencies(Kt)}function Re(_){if(Kt--,l.monitorRunDependencies&&l.monitorRunDependencies(Kt),Kt==0&&an){var V=an;an=null,V()}}function re(_){l.onAbort&&l.onAbort(_),_="Aborted("+_+")",O(_),Q=!0,K=1,_+=". Build with -sASSERTIONS for more info.";var V=new WebAssembly.RuntimeError(_);throw h(V),V}var $e="data:application/octet-stream;base64,";function Oe(_){return _.startsWith($e)}function tt(_){return _.startsWith("file://")}var Ke;Ke="tfjs-backend-wasm-threaded-simd.wasm",Oe(Ke)||(Ke=v(Ke));function pt(_){try{if(_==Ke&&B)return new Uint8Array(B);if(T)return T(_);throw"both async and sync fetching of the wasm failed"}catch(V){re(V)}}function lt(){if(!B&&(g||b)){if(typeof fetch=="function"&&!tt(Ke))return fetch(Ke,{credentials:"same-origin"}).then(function(_){if(!_.ok)throw"failed to load wasm binary file at '"+Ke+"'";return _.arrayBuffer()}).catch(function(){return pt(Ke)});if(N)return new Promise(function(_,V){N(Ke,function(me){_(new Uint8Array(me))},V)})}return Promise.resolve().then(function(){return pt(Ke)})}function Et(){var _={env:Ju,wasi_snapshot_preview1:Ju};function V(Ce,Fe){var Rt=Ce.exports;if(l.asm=Rt,Tr(l.asm._emscripten_tls_init),ze=l.asm.__indirect_function_table,Tt(l.asm.__wasm_call_ctors),q=Fe,!x){var En=xe.unusedWorkers.length;xe.unusedWorkers.forEach(function(Er){xe.loadWasmModuleToWorker(Er,function(){--En||Re()})})}}x||xr();function me(Ce){V(Ce.instance,Ce.module)}function Pe(Ce){return lt().then(function(Fe){return WebAssembly.instantiate(Fe,_)}).then(function(Fe){return Fe}).then(Ce,function(Fe){O("failed to asynchronously prepare wasm: "+Fe),re(Fe)})}function He(){return!B&&typeof WebAssembly.instantiateStreaming=="function"&&!Oe(Ke)&&!tt(Ke)&&!y&&typeof fetch=="function"?fetch(Ke,{credentials:"same-origin"}).then(function(Ce){var Fe=WebAssembly.instantiateStreaming(Ce,_);return Fe.then(me,function(Rt){return O("wasm streaming compile failed: "+Rt),O("falling back to ArrayBuffer instantiation"),Pe(me)})}):Pe(me)}if(l.instantiateWasm)try{var je=l.instantiateWasm(_,V);return je}catch(Ce){O("Module.instantiateWasm callback failed with error: "+Ce),h(Ce)}return He().catch(h),{}}var Bt={};function kt(_){this.name="ExitStatus",this.message="Program terminated with exit("+_+")",this.status=_}function Zt(_){var V=xe.pthreads[_];delete xe.pthreads[_],V.terminate(),qo(_),xe.runningWorkers.splice(xe.runningWorkers.indexOf(V),1),V.pthread_ptr=0}function At(_){var V=xe.pthreads[_];V.postMessage({cmd:"cancel"})}function In(_){var V=xe.pthreads[_];ee(V),xe.returnWorkerToPool(V)}function Un(_){var V=xe.getNewWorker();if(!V)return 6;xe.runningWorkers.push(V),xe.pthreads[_.pthread_ptr]=V,V.pthread_ptr=_.pthread_ptr;var me={cmd:"run",start_routine:_.startRoutine,arg:_.arg,pthread_ptr:_.pthread_ptr};return V.runPthread=()=>{y&&V.ref(),V.postMessage(me,_.transferList),delete V.runPthread},V.loaded&&V.runPthread(),0}function Kn(_){if(x)return mr(1,1,_);K=_,St()||(xe.terminateAllThreads(),l.onExit&&l.onExit(_),Q=!0),m(_,new kt(_))}function X(_,V){if(K=_,!V&&x)throw Xe(_),"unwind";Kn(_)}var he=X;function _e(_){if(_ instanceof kt||_=="unwind")return K;m(1,_)}var xe={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],pthreads:{},init:function(){x?xe.initWorker():xe.initMainThread()},initMainThread:function(){for(var _=8;_--;)xe.allocateUnusedWorker()},initWorker:function(){G=!1},setExitStatus:function(_){K=_},terminateAllThreads:function(){for(var _ of Object.values(xe.pthreads))xe.returnWorkerToPool(_);for(var _ of xe.unusedWorkers)_.terminate();xe.unusedWorkers=[]},returnWorkerToPool:function(_){var V=_.pthread_ptr;delete xe.pthreads[V],xe.unusedWorkers.push(_),xe.runningWorkers.splice(xe.runningWorkers.indexOf(_),1),_.pthread_ptr=0,y&&_.unref(),qo(V)},receiveObjectTransfer:function(_){},threadInitTLS:function(){xe.tlsInitFunctions.forEach(_=>_())},loadWasmModuleToWorker:function(_,V){_.onmessage=je=>{var Ce=je.data,Fe=Ce.cmd;if(_.pthread_ptr&&(xe.currentProxiedOperationCallerThread=_.pthread_ptr),Ce.targetThread&&Ce.targetThread!=Ci()){var Rt=xe.pthreads[Ce.targetThread];Rt?Rt.postMessage(Ce,Ce.transferList):O('Internal error! Worker sent a message "'+Fe+'" to target pthread '+Ce.targetThread+", but that thread no longer exists!"),xe.currentProxiedOperationCallerThread=void 0;return}Fe==="processProxyingQueue"?Vo(Ce.queue):Fe==="spawnThread"?Un(Ce):Fe==="cleanupThread"?In(Ce.thread):Fe==="killThread"?Zt(Ce.thread):Fe==="cancelThread"?At(Ce.thread):Fe==="loaded"?(_.loaded=!0,y&&_.unref(),V&&V(_),_.runPthread&&_.runPthread()):Fe==="print"?L("Thread "+Ce.threadId+": "+Ce.text):Fe==="printErr"?O("Thread "+Ce.threadId+": "+Ce.text):Fe==="alert"?alert("Thread "+Ce.threadId+": "+Ce.text):Ce.target==="setimmediate"?_.postMessage(Ce):Fe==="callHandler"?l[Ce.handler](...Ce.args):Fe&&O("worker sent an unknown command "+Fe),xe.currentProxiedOperationCallerThread=void 0},_.onerror=je=>{var Ce="worker sent an error!";throw O(Ce+" "+je.filename+":"+je.lineno+": "+je.message),je},y&&(_.on("message",function(je){_.onmessage({data:je})}),_.on("error",function(je){_.onerror(je)}),_.on("detachedExit",function(){}));var me=[],Pe=["onExit","onAbort","print","printErr"];for(var He of Pe)l.hasOwnProperty(He)&&me.push(He);_.postMessage({cmd:"load",handlers:me,urlOrBlob:l.mainScriptUrlOrBlob||r,wasmMemory:z,wasmModule:q})},allocateUnusedWorker:function(){var _,V=v("tfjs-backend-wasm-threaded-simd.worker.js");_=new Worker(V),xe.unusedWorkers.push(_)},getNewWorker:function(){return xe.unusedWorkers.length==0&&(xe.allocateUnusedWorker(),xe.loadWasmModuleToWorker(xe.unusedWorkers[0])),xe.unusedWorkers.pop()}};l.PThread=xe;function wt(_){for(;_.length>0;)_.shift()(l)}function bt(){var _=Ci(),V=o()[_+52>>>2],me=o()[_+56>>>2],Pe=V-me;Ko(V,Pe),Si(V)}l.establishStackSpace=bt;function Xe(_){if(x)return mr(2,0,_);try{he(_)}catch(V){_e(V)}}var Ge=[];function $t(_){var V=Ge[_];return V||(_>=Ge.length&&(Ge.length=_+1),Ge[_]=V=ze.get(_)),V}function Mn(_,V){var me=$t(_)(V);St()?xe.setExitStatus(me):nc(me)}l.invokeEntryPoint=Mn;function Tr(_){xe.tlsInitFunctions.push(_)}function wi(_){Zu(_,!b,1,!g),xe.threadInitTLS()}function Fa(_){x?postMessage({cmd:"cleanupThread",thread:_}):In(_)}function vi(_,V,me,Pe){return x?mr(3,1,_,V,me,Pe):rn(_,V,me,Pe)}function rn(_,V,me,Pe){if(typeof SharedArrayBuffer>"u")return O("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var He=[],je=0;if(x&&(He.length===0||je))return vi(_,V,me,Pe);var Ce={startRoutine:me,pthread_ptr:_,arg:Pe,transferList:He};return x?(Ce.cmd="spawnThread",postMessage(Ce,He),0):Un(Ce)}function ar(){return 65536}var Ii=!0;function fb(){return Ii}function Vo(_){Atomics.store(o(),_>>2,1),Ci()&&tc(_),Atomics.compareExchange(o(),_>>2,1,0)}l.executeNotifiedProxyingQueue=Vo;function Hu(_,V,me,Pe){if(_==V)setTimeout(()=>Vo(Pe));else if(x)postMessage({targetThread:_,cmd:"processProxyingQueue",queue:Pe});else{var He=xe.pthreads[_];if(!He)return;He.postMessage({cmd:"processProxyingQueue",queue:Pe})}return 1}function ju(_,V,me){return-1}function mb(){re("")}function Ma(_){Ma.shown||(Ma.shown={}),Ma.shown[_]||(Ma.shown[_]=1,y&&(_="warning: "+_),O(_))}function gb(){y||b||Ma("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")}function bb(){return Date.now()}function Uo(){return 4294901760}function yb(){return Uo()}var Go;y?Go=()=>{var _=process.hrtime();return _[0]*1e3+_[1]/1e6}:Go=()=>performance.timeOrigin+performance.now();function xb(_,V,me){i().copyWithin(_>>>0,V>>>0,V+me>>>0)}function wb(){return y?gX().cpus().length:navigator.hardwareConcurrency}function vb(_){var V=Js(),me=_();return Si(V),me}function mr(_,V){var me=arguments.length-2,Pe=arguments;return vb(()=>{for(var He=me,je=Ni(He*8),Ce=je>>3,Fe=0;Fe<me;Fe++){var Rt=Pe[2+Fe];c()[Ce+Fe>>>0]=Rt}return ec(_,He,je,V)})}var ro=[];function ki(_,V,me){ro.length=V;for(var Pe=me>>3,He=0;He<V;He++)ro[He]=c()[Pe+He>>>0];var je=_<0,Ce=je?Bt[-_-1]:jo[_];return Ce.apply(null,ro)}function qu(_){try{return z.grow(_-ve.byteLength+65535>>>16),nt(z.buffer),1}catch{}}function Ib(_){var V=i().length;if(_=_>>>0,_<=V)return!1;var me=Uo();if(_>me)return!1;let Pe=(Rt,En)=>Rt+(En-Rt%En)%En;for(var He=1;He<=4;He*=2){var je=V*(1+.2/He);je=Math.min(je,_+100663296);var Ce=Math.min(me,Pe(Math.max(_,je),65536)),Fe=qu(Ce);if(Fe)return!0}return!1}function kb(){throw"unwind"}function Ku(_){return x?mr(4,1,_):52}function Xu(_,V,me,Pe,He){return x?mr(5,1,_,V,me,Pe,He):70}var Qu=[null,[],[]];function Cb(_,V){var me=Qu[_];V===0||V===10?((_===1?L:O)(de(me,0)),me.length=0):me.push(V)}function Yu(_,V,me,Pe){if(x)return mr(6,1,_,V,me,Pe);for(var He=0,je=0;je<me;je++){var Ce=u()[V>>>2],Fe=u()[V+4>>>2];V+=8;for(var Rt=0;Rt<Fe;Rt++)Cb(_,i()[Ce+Rt>>>0]);He+=Fe}return u()[Pe>>>2]=He,0}function Il(_){var V=l["_"+_];return V}function kl(_,V){a().set(_,V>>>0)}function Ho(_,V,me,Pe,He){var je={string:xn=>{var Zs=0;if(xn!=null&&xn!==0){var ic=(xn.length<<2)+1;Zs=Ni(ic),Ee(xn,Zs,ic)}return Zs},array:xn=>{var Zs=Ni(xn.length);return kl(xn,Zs),Zs}};function Ce(xn){return V==="string"?ue(xn):V==="boolean"?!!xn:xn}var Fe=Il(_),Rt=[],En=0;if(Pe)for(var Er=0;Er<Pe.length;Er++){var sc=je[me[Er]];sc?(En===0&&(En=Js()),Rt[Er]=sc(Pe[Er])):Rt[Er]=Pe[Er]}var Dt=Fe.apply(null,Rt);function ac(xn){return En!==0&&Si(En),Ce(xn)}return Dt=ac(Dt),Dt}function Sb(_,V,me,Pe){me=me||[];var He=me.every(Ce=>Ce==="number"||Ce==="boolean"),je=V!=="string";return je&&He&&!Pe?Il(_):function(){return Ho(_,V,me,arguments)}}xe.init();var jo=[null,Kn,Xe,vi,Ku,Xu,Yu],Ju={__emscripten_init_main_thread_js:wi,__emscripten_thread_cleanup:Fa,__pthread_create_js:rn,_emscripten_default_pthread_stack_size:ar,_emscripten_get_now_is_monotonic:fb,_emscripten_notify_task_queue:Hu,_emscripten_set_offscreencanvas_size:ju,abort:mb,emscripten_check_blocking_allowed:gb,emscripten_date_now:bb,emscripten_get_heap_max:yb,emscripten_get_now:Go,emscripten_memcpy_big:xb,emscripten_num_logical_cores:wb,emscripten_receive_on_main_thread_js:ki,emscripten_resize_heap:Ib,emscripten_unwind_to_js_event_loop:kb,exit:he,fd_close:Ku,fd_seek:Xu,fd_write:Yu,memory:z||l.wasmMemory};Et(),l.___wasm_call_ctors=function(){return(l.___wasm_call_ctors=l.asm.__wasm_call_ctors).apply(null,arguments)},l._init=function(){return(l._init=l.asm.init).apply(null,arguments)},l._init_with_threads_count=function(){return(l._init_with_threads_count=l.asm.init_with_threads_count).apply(null,arguments)},l._get_threads_count=function(){return(l._get_threads_count=l.asm.get_threads_count).apply(null,arguments)},l._register_tensor=function(){return(l._register_tensor=l.asm.register_tensor).apply(null,arguments)},l._dispose_data=function(){return(l._dispose_data=l.asm.dispose_data).apply(null,arguments)},l._dispose=function(){return(l._dispose=l.asm.dispose).apply(null,arguments)},l._Abs=function(){return(l._Abs=l.asm.Abs).apply(null,arguments)},l._Acos=function(){return(l._Acos=l.asm.Acos).apply(null,arguments)},l._Acosh=function(){return(l._Acosh=l.asm.Acosh).apply(null,arguments)},l._Add=function(){return(l._Add=l.asm.Add).apply(null,arguments)},l._AddN=function(){return(l._AddN=l.asm.AddN).apply(null,arguments)},l._All=function(){return(l._All=l.asm.All).apply(null,arguments)},l._Any=function(){return(l._Any=l.asm.Any).apply(null,arguments)},l._ArgMax=function(){return(l._ArgMax=l.asm.ArgMax).apply(null,arguments)},l._ArgMin=function(){return(l._ArgMin=l.asm.ArgMin).apply(null,arguments)},l._Asin=function(){return(l._Asin=l.asm.Asin).apply(null,arguments)},l._Asinh=function(){return(l._Asinh=l.asm.Asinh).apply(null,arguments)},l._Atan=function(){return(l._Atan=l.asm.Atan).apply(null,arguments)},l._Atan2=function(){return(l._Atan2=l.asm.Atan2).apply(null,arguments)},l._Atanh=function(){return(l._Atanh=l.asm.Atanh).apply(null,arguments)},l._AvgPool=function(){return(l._AvgPool=l.asm.AvgPool).apply(null,arguments)},l._AvgPool3D=function(){return(l._AvgPool3D=l.asm.AvgPool3D).apply(null,arguments)},l._AvgPool3DGrad=function(){return(l._AvgPool3DGrad=l.asm.AvgPool3DGrad).apply(null,arguments)},l._AvgPoolGrad=function(){return(l._AvgPoolGrad=l.asm.AvgPoolGrad).apply(null,arguments)},l._BatchMatMul=function(){return(l._BatchMatMul=l.asm.BatchMatMul).apply(null,arguments)},l._Bincount=function(){return(l._Bincount=l.asm.Bincount).apply(null,arguments)},l._BitwiseAnd=function(){return(l._BitwiseAnd=l.asm.BitwiseAnd).apply(null,arguments)},l._Ceil=function(){return(l._Ceil=l.asm.Ceil).apply(null,arguments)},l._ClipByValue=function(){return(l._ClipByValue=l.asm.ClipByValue).apply(null,arguments)},l._Conv2D=function(){return(l._Conv2D=l.asm.Conv2D).apply(null,arguments)},l._Conv2DBackpropInput=function(){return(l._Conv2DBackpropInput=l.asm.Conv2DBackpropInput).apply(null,arguments)},l._Conv3D=function(){return(l._Conv3D=l.asm.Conv3D).apply(null,arguments)},l._Conv3DBackpropFilterV2=function(){return(l._Conv3DBackpropFilterV2=l.asm.Conv3DBackpropFilterV2).apply(null,arguments)},l._Conv3DBackpropInputV2=function(){return(l._Conv3DBackpropInputV2=l.asm.Conv3DBackpropInputV2).apply(null,arguments)},l._Cos=function(){return(l._Cos=l.asm.Cos).apply(null,arguments)},l._Cosh=function(){return(l._Cosh=l.asm.Cosh).apply(null,arguments)},l._CropAndResize=function(){return(l._CropAndResize=l.asm.CropAndResize).apply(null,arguments)},l._Cumprod=function(){return(l._Cumprod=l.asm.Cumprod).apply(null,arguments)},l._Cumsum=function(){return(l._Cumsum=l.asm.Cumsum).apply(null,arguments)},l._DenseBincount=function(){return(l._DenseBincount=l.asm.DenseBincount).apply(null,arguments)},l._DepthToSpace=function(){return(l._DepthToSpace=l.asm.DepthToSpace).apply(null,arguments)},l._DepthwiseConv2dNative=function(){return(l._DepthwiseConv2dNative=l.asm.DepthwiseConv2dNative).apply(null,arguments)},l._Diag=function(){return(l._Diag=l.asm.Diag).apply(null,arguments)},l._Dilation2D=function(){return(l._Dilation2D=l.asm.Dilation2D).apply(null,arguments)},l._Dilation2DBackpropFilter=function(){return(l._Dilation2DBackpropFilter=l.asm.Dilation2DBackpropFilter).apply(null,arguments)},l._Dilation2DBackpropInput=function(){return(l._Dilation2DBackpropInput=l.asm.Dilation2DBackpropInput).apply(null,arguments)},l._Elu=function(){return(l._Elu=l.asm.Elu).apply(null,arguments)},l._EluGrad=function(){return(l._EluGrad=l.asm.EluGrad).apply(null,arguments)},l._Equal=function(){return(l._Equal=l.asm.Equal).apply(null,arguments)},l._Erf=function(){return(l._Erf=l.asm.Erf).apply(null,arguments)},l._Exp=function(){return(l._Exp=l.asm.Exp).apply(null,arguments)},l._Expm1=function(){return(l._Expm1=l.asm.Expm1).apply(null,arguments)},l._FlipLeftRight=function(){return(l._FlipLeftRight=l.asm.FlipLeftRight).apply(null,arguments)},l._Floor=function(){return(l._Floor=l.asm.Floor).apply(null,arguments)},l._FloorDiv=function(){return(l._FloorDiv=l.asm.FloorDiv).apply(null,arguments)},l._FusedBatchNorm=function(){return(l._FusedBatchNorm=l.asm.FusedBatchNorm).apply(null,arguments)},l._FusedConv2D=function(){return(l._FusedConv2D=l.asm.FusedConv2D).apply(null,arguments)},l._FusedDepthwiseConv2D=function(){return(l._FusedDepthwiseConv2D=l.asm.FusedDepthwiseConv2D).apply(null,arguments)},l._Gather=function(){return(l._Gather=l.asm.Gather).apply(null,arguments)},l._GatherNd=function(){return(l._GatherNd=l.asm.GatherNd).apply(null,arguments)},l._Greater=function(){return(l._Greater=l.asm.Greater).apply(null,arguments)},l._GreaterEqual=function(){return(l._GreaterEqual=l.asm.GreaterEqual).apply(null,arguments)},l._IsFinite=function(){return(l._IsFinite=l.asm.IsFinite).apply(null,arguments)},l._IsInf=function(){return(l._IsInf=l.asm.IsInf).apply(null,arguments)},l._IsNan=function(){return(l._IsNan=l.asm.IsNan).apply(null,arguments)},l._LRN=function(){return(l._LRN=l.asm.LRN).apply(null,arguments)},l._LRNGrad=function(){return(l._LRNGrad=l.asm.LRNGrad).apply(null,arguments)},l._LeakyRelu=function(){return(l._LeakyRelu=l.asm.LeakyRelu).apply(null,arguments)},l._Less=function(){return(l._Less=l.asm.Less).apply(null,arguments)},l._LessEqual=function(){return(l._LessEqual=l.asm.LessEqual).apply(null,arguments)},l._LinSpace=function(){return(l._LinSpace=l.asm.LinSpace).apply(null,arguments)},l._Log=function(){return(l._Log=l.asm.Log).apply(null,arguments)},l._Log1p=function(){return(l._Log1p=l.asm.Log1p).apply(null,arguments)},l._LogicalAnd=function(){return(l._LogicalAnd=l.asm.LogicalAnd).apply(null,arguments)},l._LogicalNot=function(){return(l._LogicalNot=l.asm.LogicalNot).apply(null,arguments)},l._LogicalOr=function(){return(l._LogicalOr=l.asm.LogicalOr).apply(null,arguments)},l._LogicalXor=function(){return(l._LogicalXor=l.asm.LogicalXor).apply(null,arguments)},l._Max=function(){return(l._Max=l.asm.Max).apply(null,arguments)},l._MaxPool=function(){return(l._MaxPool=l.asm.MaxPool).apply(null,arguments)},l._MaxPool3D=function(){return(l._MaxPool3D=l.asm.MaxPool3D).apply(null,arguments)},l._MaxPool3DGrad=function(){return(l._MaxPool3DGrad=l.asm.MaxPool3DGrad).apply(null,arguments)},l._MaxPoolGrad=function(){return(l._MaxPoolGrad=l.asm.MaxPoolGrad).apply(null,arguments)},l._MaxPoolWithArgmax=function(){return(l._MaxPoolWithArgmax=l.asm.MaxPoolWithArgmax).apply(null,arguments)},l._Maximum=function(){return(l._Maximum=l.asm.Maximum).apply(null,arguments)},l._Mean=function(){return(l._Mean=l.asm.Mean).apply(null,arguments)},l._Min=function(){return(l._Min=l.asm.Min).apply(null,arguments)},l._Minimum=function(){return(l._Minimum=l.asm.Minimum).apply(null,arguments)},l._MirrorPad=function(){return(l._MirrorPad=l.asm.MirrorPad).apply(null,arguments)},l._Mod=function(){return(l._Mod=l.asm.Mod).apply(null,arguments)},l._Multinomial=function(){return(l._Multinomial=l.asm.Multinomial).apply(null,arguments)},l._Multiply=function(){return(l._Multiply=l.asm.Multiply).apply(null,arguments)},l._Neg=function(){return(l._Neg=l.asm.Neg).apply(null,arguments)},l._NonMaxSuppressionV3=function(){return(l._NonMaxSuppressionV3=l.asm.NonMaxSuppressionV3).apply(null,arguments)},l._NonMaxSuppressionV4=function(){return(l._NonMaxSuppressionV4=l.asm.NonMaxSuppressionV4).apply(null,arguments)},l._NonMaxSuppressionV5=function(){return(l._NonMaxSuppressionV5=l.asm.NonMaxSuppressionV5).apply(null,arguments)},l._NotEqual=function(){return(l._NotEqual=l.asm.NotEqual).apply(null,arguments)},l._OneHot=function(){return(l._OneHot=l.asm.OneHot).apply(null,arguments)},l._PadV2=function(){return(l._PadV2=l.asm.PadV2).apply(null,arguments)},l._Pow=function(){return(l._Pow=l.asm.Pow).apply(null,arguments)},l._Prelu=function(){return(l._Prelu=l.asm.Prelu).apply(null,arguments)},l._Prod=function(){return(l._Prod=l.asm.Prod).apply(null,arguments)},l._RealDiv=function(){return(l._RealDiv=l.asm.RealDiv).apply(null,arguments)},l._Reciprocal=function(){return(l._Reciprocal=l.asm.Reciprocal).apply(null,arguments)},l._Relu=function(){return(l._Relu=l.asm.Relu).apply(null,arguments)},l._Relu6=function(){return(l._Relu6=l.asm.Relu6).apply(null,arguments)},l._ResizeBilinear=function(){return(l._ResizeBilinear=l.asm.ResizeBilinear).apply(null,arguments)},l._ResizeBilinearGrad=function(){return(l._ResizeBilinearGrad=l.asm.ResizeBilinearGrad).apply(null,arguments)},l._ResizeNearestNeighbor=function(){return(l._ResizeNearestNeighbor=l.asm.ResizeNearestNeighbor).apply(null,arguments)},l._ResizeNearestNeighborGrad=function(){return(l._ResizeNearestNeighborGrad=l.asm.ResizeNearestNeighborGrad).apply(null,arguments)},l._Reverse=function(){return(l._Reverse=l.asm.Reverse).apply(null,arguments)},l._RotateWithOffset=function(){return(l._RotateWithOffset=l.asm.RotateWithOffset).apply(null,arguments)},l._Round=function(){return(l._Round=l.asm.Round).apply(null,arguments)},l._Rsqrt=function(){return(l._Rsqrt=l.asm.Rsqrt).apply(null,arguments)},l._ScatterNd=function(){return(l._ScatterNd=l.asm.ScatterNd).apply(null,arguments)},l._SearchSorted=function(){return(l._SearchSorted=l.asm.SearchSorted).apply(null,arguments)},l._SelectV2=function(){return(l._SelectV2=l.asm.SelectV2).apply(null,arguments)},l._Selu=function(){return(l._Selu=l.asm.Selu).apply(null,arguments)},l._Sigmoid=function(){return(l._Sigmoid=l.asm.Sigmoid).apply(null,arguments)},l._Sign=function(){return(l._Sign=l.asm.Sign).apply(null,arguments)},l._Sin=function(){return(l._Sin=l.asm.Sin).apply(null,arguments)},l._Sinh=function(){return(l._Sinh=l.asm.Sinh).apply(null,arguments)},l._Softmax=function(){return(l._Softmax=l.asm.Softmax).apply(null,arguments)},l._Softplus=function(){return(l._Softplus=l.asm.Softplus).apply(null,arguments)},l._SparseFillEmptyRows=function(){return(l._SparseFillEmptyRows=l.asm.SparseFillEmptyRows).apply(null,arguments)},l._SparseReshape=function(){return(l._SparseReshape=l.asm.SparseReshape).apply(null,arguments)},l._SparseSegmentReduction=function(){return(l._SparseSegmentReduction=l.asm.SparseSegmentReduction).apply(null,arguments)},l._SparseToDense=function(){return(l._SparseToDense=l.asm.SparseToDense).apply(null,arguments)},l._Sqrt=function(){return(l._Sqrt=l.asm.Sqrt).apply(null,arguments)},l._Square=function(){return(l._Square=l.asm.Square).apply(null,arguments)},l._SquaredDifference=function(){return(l._SquaredDifference=l.asm.SquaredDifference).apply(null,arguments)},l._Step=function(){return(l._Step=l.asm.Step).apply(null,arguments)},l._StridedSlice=function(){return(l._StridedSlice=l.asm.StridedSlice).apply(null,arguments)},l._Sub=function(){return(l._Sub=l.asm.Sub).apply(null,arguments)},l._Sum=function(){return(l._Sum=l.asm.Sum).apply(null,arguments)},l._Tan=function(){return(l._Tan=l.asm.Tan).apply(null,arguments)},l._Tanh=function(){return(l._Tanh=l.asm.Tanh).apply(null,arguments)},l._TensorScatterUpdate=function(){return(l._TensorScatterUpdate=l.asm.TensorScatterUpdate).apply(null,arguments)},l._Tile=function(){return(l._Tile=l.asm.Tile).apply(null,arguments)},l._TopK=function(){return(l._TopK=l.asm.TopK).apply(null,arguments)},l._Transform=function(){return(l._Transform=l.asm.Transform).apply(null,arguments)},l._Transpose=function(){return(l._Transpose=l.asm.Transpose).apply(null,arguments)},l.__FusedMatMul=function(){return(l.__FusedMatMul=l.asm._FusedMatMul).apply(null,arguments)},l._malloc=function(){return(l._malloc=l.asm.malloc).apply(null,arguments)},l._free=function(){return(l._free=l.asm.free).apply(null,arguments)},l.__emscripten_tls_init=function(){return(l.__emscripten_tls_init=l.asm._emscripten_tls_init).apply(null,arguments)};var Ci=l._pthread_self=function(){return(Ci=l._pthread_self=l.asm.pthread_self).apply(null,arguments)};l.___errno_location=function(){return(l.___errno_location=l.asm.__errno_location).apply(null,arguments)};var Zu=l.__emscripten_thread_init=function(){return(Zu=l.__emscripten_thread_init=l.asm._emscripten_thread_init).apply(null,arguments)};l.__emscripten_thread_crashed=function(){return(l.__emscripten_thread_crashed=l.asm._emscripten_thread_crashed).apply(null,arguments)},l._emscripten_main_thread_process_queued_calls=function(){return(l._emscripten_main_thread_process_queued_calls=l.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},l._emscripten_main_browser_thread_id=function(){return(l._emscripten_main_browser_thread_id=l.asm.emscripten_main_browser_thread_id).apply(null,arguments)};var ec=l._emscripten_run_in_main_runtime_thread_js=function(){return(ec=l._emscripten_run_in_main_runtime_thread_js=l.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)};l._emscripten_dispatch_to_thread_=function(){return(l._emscripten_dispatch_to_thread_=l.asm.emscripten_dispatch_to_thread_).apply(null,arguments)};var tc=l.__emscripten_proxy_execute_task_queue=function(){return(tc=l.__emscripten_proxy_execute_task_queue=l.asm._emscripten_proxy_execute_task_queue).apply(null,arguments)},qo=l.__emscripten_thread_free_data=function(){return(qo=l.__emscripten_thread_free_data=l.asm._emscripten_thread_free_data).apply(null,arguments)},nc=l.__emscripten_thread_exit=function(){return(nc=l.__emscripten_thread_exit=l.asm._emscripten_thread_exit).apply(null,arguments)},Ko=l._emscripten_stack_set_limits=function(){return(Ko=l._emscripten_stack_set_limits=l.asm.emscripten_stack_set_limits).apply(null,arguments)},Js=l.stackSave=function(){return(Js=l.stackSave=l.asm.stackSave).apply(null,arguments)},Si=l.stackRestore=function(){return(Si=l.stackRestore=l.asm.stackRestore).apply(null,arguments)},Ni=l.stackAlloc=function(){return(Ni=l.stackAlloc=l.asm.stackAlloc).apply(null,arguments)};l.dynCall_iijjiiii=function(){return(l.dynCall_iijjiiii=l.asm.dynCall_iijjiiii).apply(null,arguments)},l.dynCall_jiji=function(){return(l.dynCall_jiji=l.asm.dynCall_jiji).apply(null,arguments)},l.keepRuntimeAlive=St,l.wasmMemory=z,l.cwrap=Sb,l.ExitStatus=kt,l.PThread=xe;var Ti;an=function _(){Ti||rc(),Ti||(an=_)};function rc(_){if(Kt>0)return;if(x){d(l),jt(),startWorker(l);return}if(pn(),Kt>0)return;function V(){Ti||(Ti=!0,l.calledRun=!0,!Q&&(jt(),d(l),l.onRuntimeInitialized&&l.onRuntimeInitialized(),nn()))}l.setStatus?(l.setStatus("Running..."),setTimeout(function(){setTimeout(function(){l.setStatus("")},1),V()},1)):V()}if(l.preInit)for(typeof l.preInit=="function"&&(l.preInit=[l.preInit]);l.preInit.length>0;)l.preInit.pop()();rc();var Za;p&&(Za={uncaughtException:process.listeners("uncaughtException").filter(function(_){return!p.uncaughtException.indexOf(_)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(_){return!p.unhandledRejection.indexOf(_)>-1})});var Ei;if(typeof WasmBackendModule<"u")Ei=WasmBackendModule;else if(typeof s<"u")Ei=s;else throw new Error("Could not find wasm module in post.js");if(Za){var dp=Ei._dispose;Ei._dispose=function(){dp(),Za.uncaughtException.forEach(function(_){process.removeListener("uncaughtException",_)}),Za.unhandledRejection.forEach(function(_){process.removeListener("unhandledRejection",_)})}}return s.ready}})();typeof e=="object"&&typeof t=="object"?t.exports=n:typeof define=="function"&&define.amd?define([],function(){return n}):typeof e=="object"&&(e.WasmBackendModuleThreadedSimd=n)}),yX=Mr((e,t)=>{t.exports.wasmWorkerContents=`"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",data=>onmessage({data:data}));var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8")+"//# sourceURL="+f)},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}var initializedJS=false;var pendingNotifiedProxyingQueues=[];function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"
");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=(info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports};self.onunhandledrejection=e=>{throw e.reason??e};self.startWorker=instance=>{Module=instance;postMessage({"cmd":"loaded"})};self.onmessage=e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=function(){postMessage({cmd:"callHandler",handler:handler,args:[...arguments]})}}Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob=="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module)}else if(e.data.cmd==="run"){Module["__emscripten_thread_init"](e.data.pthread_ptr,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInitTLS();if(!initializedJS){pendingNotifiedProxyingQueues.forEach(queue=>{Module["executeNotifiedProxyingQueue"](queue)});pendingNotifiedProxyingQueues=[];initializedJS=true}try{Module["invokeEntryPoint"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processProxyingQueue"){if(initializedJS){Module["executeNotifiedProxyingQueue"](e.data.queue)}else{pendingNotifiedProxyingQueues.push(e.data.queue)}}else if(e.data.cmd){err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}};`}),xX=Mr((e,t)=>{var n=(()=>{var r=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(r=r||__filename),function(s){s=s||{};var a=typeof s<"u"?s:{},i,o;a.ready=new Promise(function(X,he){i=X,o=he});var u;typeof process<"u"&&process.listeners&&(u={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var c=Object.assign({},a),l=typeof window=="object",d=typeof importScripts=="function",h=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",p="";function f(X){return a.locateFile?a.locateFile(X,p):p+X}var m,g,b;if(h){var y=BS(),x=$F();d?p=x.dirname(p)+"/":p=__dirname+"/",m=(X,he)=>(X=rt(X)?new URL(X):x.normalize(X),y.readFileSync(X,he?void 0:"utf8")),b=X=>{var he=m(X,!0);return he.buffer||(he=new Uint8Array(he)),he},g=(X,he,_e)=>{X=rt(X)?new URL(X):x.normalize(X),y.readFile(X,function(xe,wt){xe?_e(xe):he(wt.buffer)})},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",function(X){if(!(X instanceof St))throw X}),process.on("unhandledRejection",function(X){throw X}),a.inspect=function(){return"[Emscripten Module object]"}}else(l||d)&&(d?p=self.location.href:typeof document<"u"&&document.currentScript&&(p=document.currentScript.src),r&&(p=r),p.indexOf("blob:")!==0?p=p.substr(0,p.replace(/[?#].*/,"").lastIndexOf("/")+1):p="",m=X=>{var he=new XMLHttpRequest;return he.open("GET",X,!1),he.send(null),he.responseText},d&&(b=X=>{var he=new XMLHttpRequest;return he.open("GET",X,!1),he.responseType="arraybuffer",he.send(null),new Uint8Array(he.response)}),g=(X,he,_e)=>{var xe=new XMLHttpRequest;xe.open("GET",X,!0),xe.responseType="arraybuffer",xe.onload=()=>{if(xe.status==200||xe.status==0&&xe.response){he(xe.response);return}_e()},xe.onerror=_e,xe.send(null)});var w=a.print||console.log.bind(console),v=a.printErr||console.warn.bind(console);Object.assign(a,c),c=null,a.arguments&&a.arguments,a.thisProgram&&a.thisProgram,a.quit&&a.quit;var I;a.wasmBinary&&(I=a.wasmBinary),a.noExitRuntime,typeof WebAssembly!="object"&&qe("no native wasm support detected");var N,T=!1,E=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function A(X,he,_e){he>>>=0;for(var xe=he+_e,wt=he;X[wt]&&!(wt>=xe);)++wt;if(wt-he>16&&X.buffer&&E)return E.decode(X.subarray(he,wt));for(var bt="";he<wt;){var Xe=X[he++];if(!(Xe&128)){bt+=String.fromCharCode(Xe);continue}var Ge=X[he++]&63;if((Xe&224)==192){bt+=String.fromCharCode((Xe&31)<<6|Ge);continue}var $t=X[he++]&63;if((Xe&240)==224?Xe=(Xe&15)<<12|Ge<<6|$t:Xe=(Xe&7)<<18|Ge<<12|$t<<6|X[he++]&63,Xe<65536)bt+=String.fromCharCode(Xe);else{var Mn=Xe-65536;bt+=String.fromCharCode(55296|Mn>>10,56320|Mn&1023)}}return bt}function k(X,he){return X>>>=0,X?A(B,X,he):""}function C(X,he,_e,xe){if(_e>>>=0,!(xe>0))return 0;for(var wt=_e,bt=_e+xe-1,Xe=0;Xe<X.length;++Xe){var Ge=X.charCodeAt(Xe);if(Ge>=55296&&Ge<=57343){var $t=X.charCodeAt(++Xe);Ge=65536+((Ge&1023)<<10)|$t&1023}if(Ge<=127){if(_e>=bt)break;he[_e++>>>0]=Ge}else if(Ge<=2047){if(_e+1>=bt)break;he[_e++>>>0]=192|Ge>>6,he[_e++>>>0]=128|Ge&63}else if(Ge<=65535){if(_e+2>=bt)break;he[_e++>>>0]=224|Ge>>12,he[_e++>>>0]=128|Ge>>6&63,he[_e++>>>0]=128|Ge&63}else{if(_e+3>=bt)break;he[_e++>>>0]=240|Ge>>18,he[_e++>>>0]=128|Ge>>12&63,he[_e++>>>0]=128|Ge>>6&63,he[_e++>>>0]=128|Ge&63}}return he[_e>>>0]=0,_e-wt}function M(X,he,_e){return C(X,B,he,_e)}var L,O,B,G;function z(X){L=X,a.HEAP8=O=new Int8Array(X),a.HEAP16=new Int16Array(X),a.HEAP32=new Int32Array(X),a.HEAPU8=B=new Uint8Array(X),a.HEAPU16=new Uint16Array(X),a.HEAPU32=G=new Uint32Array(X),a.HEAPF32=new Float32Array(X),a.HEAPF64=new Float64Array(X)}a.INITIAL_MEMORY;var q=[],Q=[],K=[];function ee(){if(a.preRun)for(typeof a.preRun=="function"&&(a.preRun=[a.preRun]);a.preRun.length;)ue(a.preRun.shift());pn(q)}function Y(){pn(Q)}function de(){if(a.postRun)for(typeof a.postRun=="function"&&(a.postRun=[a.postRun]);a.postRun.length;)Ee(a.postRun.shift());pn(K)}function ue(X){q.unshift(X)}function Ie(X){Q.unshift(X)}function Ee(X){K.unshift(X)}var ve=0,Ae=null;function Be(X){ve++,a.monitorRunDependencies&&a.monitorRunDependencies(ve)}function Ue(X){if(ve--,a.monitorRunDependencies&&a.monitorRunDependencies(ve),ve==0&&Ae){var he=Ae;Ae=null,he()}}function qe(X){a.onAbort&&a.onAbort(X),X="Aborted("+X+")",v(X),T=!0,X+=". Build with -sASSERTIONS for more info.";var he=new WebAssembly.RuntimeError(X);throw o(he),he}var ut="data:application/octet-stream;base64,";function nt(X){return X.startsWith(ut)}function rt(X){return X.startsWith("file://")}var ze;ze="tfjs-backend-wasm.wasm",nt(ze)||(ze=f(ze));function ct(X){try{if(X==ze&&I)return new Uint8Array(I);if(b)return b(X);throw"both async and sync fetching of the wasm failed"}catch(he){qe(he)}}function ht(){if(!I&&(l||d)){if(typeof fetch=="function"&&!rt(ze))return fetch(ze,{credentials:"same-origin"}).then(function(X){if(!X.ok)throw"failed to load wasm binary file at '"+ze+"'";return X.arrayBuffer()}).catch(function(){return ct(ze)});if(g)return new Promise(function(X,he){g(ze,function(_e){X(new Uint8Array(_e))},he)})}return Promise.resolve().then(function(){return ct(ze)})}function yn(){var X={env:lt,wasi_snapshot_preview1:lt};function he(Xe,Ge){var $t=Xe.exports;a.asm=$t,N=a.asm.memory,z(N.buffer),a.asm.__indirect_function_table,Ie(a.asm.__wasm_call_ctors),Ue()}Be();function _e(Xe){he(Xe.instance)}function xe(Xe){return ht().then(function(Ge){return WebAssembly.instantiate(Ge,X)}).then(function(Ge){return Ge}).then(Xe,function(Ge){v("failed to asynchronously prepare wasm: "+Ge),qe(Ge)})}function wt(){return!I&&typeof WebAssembly.instantiateStreaming=="function"&&!nt(ze)&&!rt(ze)&&!h&&typeof fetch=="function"?fetch(ze,{credentials:"same-origin"}).then(function(Xe){var Ge=WebAssembly.instantiateStreaming(Xe,X);return Ge.then(_e,function($t){return v("wasm streaming compile failed: "+$t),v("falling back to ArrayBuffer instantiation"),xe(_e)})}):xe(_e)}if(a.instantiateWasm)try{var bt=a.instantiateWasm(X,he);return bt}catch(Xe){v("Module.instantiateWasm callback failed with error: "+Xe),o(Xe)}return wt().catch(o),{}}function St(X){this.name="ExitStatus",this.message="Program terminated with exit("+X+")",this.status=X}function pn(X){for(;X.length>0;)X.shift()(a)}function jt(){qe("")}function nn(){return 4294901760}function wn(){return nn()}function Tt(X,he,_e){B.copyWithin(X>>>0,he>>>0,he+_e>>>0)}function vn(X){try{return N.grow(X-L.byteLength+65535>>>16),z(N.buffer),1}catch{}}function Kt(X){var he=B.length;X=X>>>0;var _e=nn();if(X>_e)return!1;let xe=($t,Mn)=>$t+(Mn-$t%Mn)%Mn;for(var wt=1;wt<=4;wt*=2){var bt=he*(1+.2/wt);bt=Math.min(bt,X+100663296);var Xe=Math.min(_e,xe(Math.max(X,bt),65536)),Ge=vn(Xe);if(Ge)return!0}return!1}function an(X){return 52}function xr(X,he,_e,xe,wt){return 70}var Re=[null,[],[]];function re(X,he){var _e=Re[X];he===0||he===10?((X===1?w:v)(A(_e,0)),_e.length=0):_e.push(he)}function $e(X,he,_e,xe){for(var wt=0,bt=0;bt<_e;bt++){var Xe=G[he>>>2],Ge=G[he+4>>>2];he+=8;for(var $t=0;$t<Ge;$t++)re(X,B[Xe+$t>>>0]);wt+=Ge}return G[xe>>>2]=wt,0}function Oe(X){var he=a["_"+X];return he}function tt(X,he){O.set(X,he>>>0)}function Ke(X,he,_e,xe,wt){var bt={string:rn=>{var ar=0;if(rn!=null&&rn!==0){var Ii=(rn.length<<2)+1;ar=kt(Ii),M(rn,ar,Ii)}return ar},array:rn=>{var ar=kt(rn.length);return tt(rn,ar),ar}};function Xe(rn){return he==="string"?k(rn):he==="boolean"?!!rn:rn}var Ge=Oe(X),$t=[],Mn=0;if(xe)for(var Tr=0;Tr<xe.length;Tr++){var wi=bt[_e[Tr]];wi?(Mn===0&&(Mn=Et()),$t[Tr]=wi(xe[Tr])):$t[Tr]=xe[Tr]}var Fa=Ge.apply(null,$t);function vi(rn){return Mn!==0&&Bt(Mn),Xe(rn)}return Fa=vi(Fa),Fa}function pt(X,he,_e,xe){_e=_e||[];var wt=_e.every(Xe=>Xe==="number"||Xe==="boolean"),bt=he!=="string";return bt&&wt&&!xe?Oe(X):function(){return Ke(X,he,_e,arguments)}}var lt={abort:jt,emscripten_get_heap_max:wn,emscripten_memcpy_big:Tt,emscripten_resize_heap:Kt,fd_close:an,fd_seek:xr,fd_write:$e};yn(),a.___wasm_call_ctors=function(){return(a.___wasm_call_ctors=a.asm.__wasm_call_ctors).apply(null,arguments)},a._init=function(){return(a._init=a.asm.init).apply(null,arguments)},a._init_with_threads_count=function(){return(a._init_with_threads_count=a.asm.init_with_threads_count).apply(null,arguments)},a._get_threads_count=function(){return(a._get_threads_count=a.asm.get_threads_count).apply(null,arguments)},a._register_tensor=function(){return(a._register_tensor=a.asm.register_tensor).apply(null,arguments)},a._dispose_data=function(){return(a._dispose_data=a.asm.dispose_data).apply(null,arguments)},a._dispose=function(){return(a._dispose=a.asm.dispose).apply(null,arguments)},a._Abs=function(){return(a._Abs=a.asm.Abs).apply(null,arguments)},a._Acos=function(){return(a._Acos=a.asm.Acos).apply(null,arguments)},a._Acosh=function(){return(a._Acosh=a.asm.Acosh).apply(null,arguments)},a._Add=function(){return(a._Add=a.asm.Add).apply(null,arguments)},a._AddN=function(){return(a._AddN=a.asm.AddN).apply(null,arguments)},a._All=function(){return(a._All=a.asm.All).apply(null,arguments)},a._Any=function(){return(a._Any=a.asm.Any).apply(null,arguments)},a._ArgMax=function(){return(a._ArgMax=a.asm.ArgMax).apply(null,arguments)},a._ArgMin=function(){return(a._ArgMin=a.asm.ArgMin).apply(null,arguments)},a._Asin=function(){return(a._Asin=a.asm.Asin).apply(null,arguments)},a._Asinh=function(){return(a._Asinh=a.asm.Asinh).apply(null,arguments)},a._Atan=function(){return(a._Atan=a.asm.Atan).apply(null,arguments)},a._Atan2=function(){return(a._Atan2=a.asm.Atan2).apply(null,arguments)},a._Atanh=function(){return(a._Atanh=a.asm.Atanh).apply(null,arguments)},a._AvgPool=function(){return(a._AvgPool=a.asm.AvgPool).apply(null,arguments)},a._AvgPool3D=function(){return(a._AvgPool3D=a.asm.AvgPool3D).apply(null,arguments)},a._AvgPool3DGrad=function(){return(a._AvgPool3DGrad=a.asm.AvgPool3DGrad).apply(null,arguments)},a._AvgPoolGrad=function(){return(a._AvgPoolGrad=a.asm.AvgPoolGrad).apply(null,arguments)},a._BatchMatMul=function(){return(a._BatchMatMul=a.asm.BatchMatMul).apply(null,arguments)},a._Bincount=function(){return(a._Bincount=a.asm.Bincount).apply(null,arguments)},a._BitwiseAnd=function(){return(a._BitwiseAnd=a.asm.BitwiseAnd).apply(null,arguments)},a._Ceil=function(){return(a._Ceil=a.asm.Ceil).apply(null,arguments)},a._ClipByValue=function(){return(a._ClipByValue=a.asm.ClipByValue).apply(null,arguments)},a._Conv2D=function(){return(a._Conv2D=a.asm.Conv2D).apply(null,arguments)},a._Conv2DBackpropInput=function(){return(a._Conv2DBackpropInput=a.asm.Conv2DBackpropInput).apply(null,arguments)},a._Conv3D=function(){return(a._Conv3D=a.asm.Conv3D).apply(null,arguments)},a._Conv3DBackpropFilterV2=function(){return(a._Conv3DBackpropFilterV2=a.asm.Conv3DBackpropFilterV2).apply(null,arguments)},a._Conv3DBackpropInputV2=function(){return(a._Conv3DBackpropInputV2=a.asm.Conv3DBackpropInputV2).apply(null,arguments)},a._Cos=function(){return(a._Cos=a.asm.Cos).apply(null,arguments)},a._Cosh=function(){return(a._Cosh=a.asm.Cosh).apply(null,arguments)},a._CropAndResize=function(){return(a._CropAndResize=a.asm.CropAndResize).apply(null,arguments)},a._Cumprod=function(){return(a._Cumprod=a.asm.Cumprod).apply(null,arguments)},a._Cumsum=function(){return(a._Cumsum=a.asm.Cumsum).apply(null,arguments)},a._DenseBincount=function(){return(a._DenseBincount=a.asm.DenseBincount).apply(null,arguments)},a._DepthToSpace=function(){return(a._DepthToSpace=a.asm.DepthToSpace).apply(null,arguments)},a._DepthwiseConv2dNative=function(){return(a._DepthwiseConv2dNative=a.asm.DepthwiseConv2dNative).apply(null,arguments)},a._Diag=function(){return(a._Diag=a.asm.Diag).apply(null,arguments)},a._Dilation2D=function(){return(a._Dilation2D=a.asm.Dilation2D).apply(null,arguments)},a._Dilation2DBackpropFilter=function(){return(a._Dilation2DBackpropFilter=a.asm.Dilation2DBackpropFilter).apply(null,arguments)},a._Dilation2DBackpropInput=function(){return(a._Dilation2DBackpropInput=a.asm.Dilation2DBackpropInput).apply(null,arguments)},a._Elu=function(){return(a._Elu=a.asm.Elu).apply(null,arguments)},a._EluGrad=function(){return(a._EluGrad=a.asm.EluGrad).apply(null,arguments)},a._Equal=function(){return(a._Equal=a.asm.Equal).apply(null,arguments)},a._Erf=function(){return(a._Erf=a.asm.Erf).apply(null,arguments)},a._Exp=function(){return(a._Exp=a.asm.Exp).apply(null,arguments)},a._Expm1=function(){return(a._Expm1=a.asm.Expm1).apply(null,arguments)},a._FlipLeftRight=function(){return(a._FlipLeftRight=a.asm.FlipLeftRight).apply(null,arguments)},a._Floor=function(){return(a._Floor=a.asm.Floor).apply(null,arguments)},a._FloorDiv=function(){return(a._FloorDiv=a.asm.FloorDiv).apply(null,arguments)},a._FusedBatchNorm=function(){return(a._FusedBatchNorm=a.asm.FusedBatchNorm).apply(null,arguments)},a._FusedConv2D=function(){return(a._FusedConv2D=a.asm.FusedConv2D).apply(null,arguments)},a._FusedDepthwiseConv2D=function(){return(a._FusedDepthwiseConv2D=a.asm.FusedDepthwiseConv2D).apply(null,arguments)},a._Gather=function(){return(a._Gather=a.asm.Gather).apply(null,arguments)},a._GatherNd=function(){return(a._GatherNd=a.asm.GatherNd).apply(null,arguments)},a._Greater=function(){return(a._Greater=a.asm.Greater).apply(null,arguments)},a._GreaterEqual=function(){return(a._GreaterEqual=a.asm.GreaterEqual).apply(null,arguments)},a._IsFinite=function(){return(a._IsFinite=a.asm.IsFinite).apply(null,arguments)},a._IsInf=function(){return(a._IsInf=a.asm.IsInf).apply(null,arguments)},a._IsNan=function(){return(a._IsNan=a.asm.IsNan).apply(null,arguments)},a._LRN=function(){return(a._LRN=a.asm.LRN).apply(null,arguments)},a._LRNGrad=function(){return(a._LRNGrad=a.asm.LRNGrad).apply(null,arguments)},a._LeakyRelu=function(){return(a._LeakyRelu=a.asm.LeakyRelu).apply(null,arguments)},a._Less=function(){return(a._Less=a.asm.Less).apply(null,arguments)},a._LessEqual=function(){return(a._LessEqual=a.asm.LessEqual).apply(null,arguments)},a._LinSpace=function(){return(a._LinSpace=a.asm.LinSpace).apply(null,arguments)},a._Log=function(){return(a._Log=a.asm.Log).apply(null,arguments)},a._Log1p=function(){return(a._Log1p=a.asm.Log1p).apply(null,arguments)},a._LogicalAnd=function(){return(a._LogicalAnd=a.asm.LogicalAnd).apply(null,arguments)},a._LogicalNot=function(){return(a._LogicalNot=a.asm.LogicalNot).apply(null,arguments)},a._LogicalOr=function(){return(a._LogicalOr=a.asm.LogicalOr).apply(null,arguments)},a._LogicalXor=function(){return(a._LogicalXor=a.asm.LogicalXor).apply(null,arguments)},a._Max=function(){return(a._Max=a.asm.Max).apply(null,arguments)},a._MaxPool=function(){return(a._MaxPool=a.asm.MaxPool).apply(null,arguments)},a._MaxPool3D=function(){return(a._MaxPool3D=a.asm.MaxPool3D).apply(null,arguments)},a._MaxPool3DGrad=function(){return(a._MaxPool3DGrad=a.asm.MaxPool3DGrad).apply(null,arguments)},a._MaxPoolGrad=function(){return(a._MaxPoolGrad=a.asm.MaxPoolGrad).apply(null,arguments)},a._MaxPoolWithArgmax=function(){return(a._MaxPoolWithArgmax=a.asm.MaxPoolWithArgmax).apply(null,arguments)},a._Maximum=function(){return(a._Maximum=a.asm.Maximum).apply(null,arguments)},a._Mean=function(){return(a._Mean=a.asm.Mean).apply(null,arguments)},a._Min=function(){return(a._Min=a.asm.Min).apply(null,arguments)},a._Minimum=function(){return(a._Minimum=a.asm.Minimum).apply(null,arguments)},a._MirrorPad=function(){return(a._MirrorPad=a.asm.MirrorPad).apply(null,arguments)},a._Mod=function(){return(a._Mod=a.asm.Mod).apply(null,arguments)},a._Multinomial=function(){return(a._Multinomial=a.asm.Multinomial).apply(null,arguments)},a._Multiply=function(){return(a._Multiply=a.asm.Multiply).apply(null,arguments)},a._Neg=function(){return(a._Neg=a.asm.Neg).apply(null,arguments)},a._NonMaxSuppressionV3=function(){return(a._NonMaxSuppressionV3=a.asm.NonMaxSuppressionV3).apply(null,arguments)},a._NonMaxSuppressionV4=function(){return(a._NonMaxSuppressionV4=a.asm.NonMaxSuppressionV4).apply(null,arguments)},a._NonMaxSuppressionV5=function(){return(a._NonMaxSuppressionV5=a.asm.NonMaxSuppressionV5).apply(null,arguments)},a._NotEqual=function(){return(a._NotEqual=a.asm.NotEqual).apply(null,arguments)},a._OneHot=function(){return(a._OneHot=a.asm.OneHot).apply(null,arguments)},a._PadV2=function(){return(a._PadV2=a.asm.PadV2).apply(null,arguments)},a._Pow=function(){return(a._Pow=a.asm.Pow).apply(null,arguments)},a._Prelu=function(){return(a._Prelu=a.asm.Prelu).apply(null,arguments)},a._Prod=function(){return(a._Prod=a.asm.Prod).apply(null,arguments)},a._RealDiv=function(){return(a._RealDiv=a.asm.RealDiv).apply(null,arguments)},a._Reciprocal=function(){return(a._Reciprocal=a.asm.Reciprocal).apply(null,arguments)},a._Relu=function(){return(a._Relu=a.asm.Relu).apply(null,arguments)},a._Relu6=function(){return(a._Relu6=a.asm.Relu6).apply(null,arguments)},a._ResizeBilinear=function(){return(a._ResizeBilinear=a.asm.ResizeBilinear).apply(null,arguments)},a._ResizeBilinearGrad=function(){return(a._ResizeBilinearGrad=a.asm.ResizeBilinearGrad).apply(null,arguments)},a._ResizeNearestNeighbor=function(){return(a._ResizeNearestNeighbor=a.asm.ResizeNearestNeighbor).apply(null,arguments)},a._ResizeNearestNeighborGrad=function(){return(a._ResizeNearestNeighborGrad=a.asm.ResizeNearestNeighborGrad).apply(null,arguments)},a._Reverse=function(){return(a._Reverse=a.asm.Reverse).apply(null,arguments)},a._RotateWithOffset=function(){return(a._RotateWithOffset=a.asm.RotateWithOffset).apply(null,arguments)},a._Round=function(){return(a._Round=a.asm.Round).apply(null,arguments)},a._Rsqrt=function(){return(a._Rsqrt=a.asm.Rsqrt).apply(null,arguments)},a._ScatterNd=function(){return(a._ScatterNd=a.asm.ScatterNd).apply(null,arguments)},a._SearchSorted=function(){return(a._SearchSorted=a.asm.SearchSorted).apply(null,arguments)},a._SelectV2=function(){return(a._SelectV2=a.asm.SelectV2).apply(null,arguments)},a._Selu=function(){return(a._Selu=a.asm.Selu).apply(null,arguments)},a._Sigmoid=function(){return(a._Sigmoid=a.asm.Sigmoid).apply(null,arguments)},a._Sign=function(){return(a._Sign=a.asm.Sign).apply(null,arguments)},a._Sin=function(){return(a._Sin=a.asm.Sin).apply(null,arguments)},a._Sinh=function(){return(a._Sinh=a.asm.Sinh).apply(null,arguments)},a._Softmax=function(){return(a._Softmax=a.asm.Softmax).apply(null,arguments)},a._Softplus=function(){return(a._Softplus=a.asm.Softplus).apply(null,arguments)},a._SparseFillEmptyRows=function(){return(a._SparseFillEmptyRows=a.asm.SparseFillEmptyRows).apply(null,arguments)},a._SparseReshape=function(){return(a._SparseReshape=a.asm.SparseReshape).apply(null,arguments)},a._SparseSegmentReduction=function(){return(a._SparseSegmentReduction=a.asm.SparseSegmentReduction).apply(null,arguments)},a._SparseToDense=function(){return(a._SparseToDense=a.asm.SparseToDense).apply(null,arguments)},a._Sqrt=function(){return(a._Sqrt=a.asm.Sqrt).apply(null,arguments)},a._Square=function(){return(a._Square=a.asm.Square).apply(null,arguments)},a._SquaredDifference=function(){return(a._SquaredDifference=a.asm.SquaredDifference).apply(null,arguments)},a._Step=function(){return(a._Step=a.asm.Step).apply(null,arguments)},a._StridedSlice=function(){return(a._StridedSlice=a.asm.StridedSlice).apply(null,arguments)},a._Sub=function(){return(a._Sub=a.asm.Sub).apply(null,arguments)},a._Sum=function(){return(a._Sum=a.asm.Sum).apply(null,arguments)},a._Tan=function(){return(a._Tan=a.asm.Tan).apply(null,arguments)},a._Tanh=function(){return(a._Tanh=a.asm.Tanh).apply(null,arguments)},a._TensorScatterUpdate=function(){return(a._TensorScatterUpdate=a.asm.TensorScatterUpdate).apply(null,arguments)},a._Tile=function(){return(a._Tile=a.asm.Tile).apply(null,arguments)},a._TopK=function(){return(a._TopK=a.asm.TopK).apply(null,arguments)},a._Transform=function(){return(a._Transform=a.asm.Transform).apply(null,arguments)},a._Transpose=function(){return(a._Transpose=a.asm.Transpose).apply(null,arguments)},a.__FusedMatMul=function(){return(a.__FusedMatMul=a.asm._FusedMatMul).apply(null,arguments)},a._malloc=function(){return(a._malloc=a.asm.malloc).apply(null,arguments)},a._free=function(){return(a._free=a.asm.free).apply(null,arguments)},a.___errno_location=function(){return(a.___errno_location=a.asm.__errno_location).apply(null,arguments)};var Et=a.stackSave=function(){return(Et=a.stackSave=a.asm.stackSave).apply(null,arguments)},Bt=a.stackRestore=function(){return(Bt=a.stackRestore=a.asm.stackRestore).apply(null,arguments)},kt=a.stackAlloc=function(){return(kt=a.stackAlloc=a.asm.stackAlloc).apply(null,arguments)};a.dynCall_iijjiiii=function(){return(a.dynCall_iijjiiii=a.asm.dynCall_iijjiiii).apply(null,arguments)},a.dynCall_jiji=function(){return(a.dynCall_jiji=a.asm.dynCall_jiji).apply(null,arguments)},a.cwrap=pt;var Zt;Ae=function X(){Zt||At(),Zt||(Ae=X)};function At(X){if(ve>0||(ee(),ve>0))return;function he(){Zt||(Zt=!0,a.calledRun=!0,!T&&(Y(),i(a),a.onRuntimeInitialized&&a.onRuntimeInitialized(),de()))}a.setStatus?(a.setStatus("Running..."),setTimeout(function(){setTimeout(function(){a.setStatus("")},1),he()},1)):he()}if(a.preInit)for(typeof a.preInit=="function"&&(a.preInit=[a.preInit]);a.preInit.length>0;)a.preInit.pop()();At();var In;u&&(In={uncaughtException:process.listeners("uncaughtException").filter(function(X){return!u.uncaughtException.indexOf(X)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(X){return!u.unhandledRejection.indexOf(X)>-1})});var Un;if(typeof s<"u")Un=s;else if(typeof WasmBackendModuleThreadedSimd<"u")Un=WasmBackendModuleThreadedSimd;else throw new Error("Could not find wasm module in post.js");if(In){var Kn=Un._dispose;Un._dispose=function(){Kn(),In.uncaughtException.forEach(function(X){process.removeListener("uncaughtException",X)}),In.unhandledRejection.forEach(function(X){process.removeListener("unhandledRejection",X)})}}return s.ready}})();typeof e=="object"&&typeof t=="object"?t.exports=n:typeof define=="function"&&define.amd?define([],function(){return n}):typeof e=="object"&&(e.WasmBackendModule=n)}),uw=class{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}},Vy=class{refCount(e){return ma("refCount")}incRef(e){return ma("incRef")}timerAvailable(){return!0}time(e){return ma("time")}read(e){return ma("read")}readSync(e){return ma("readSync")}readToGPU(e,t){return ma("readToGPU")}numDataIds(){return ma("numDataIds")}disposeData(e,t){return ma("disposeData")}write(e,t,n){return ma("write")}move(e,t,n,r,s){return ma("move")}createTensorFromGPUData(e,t,n){return ma("createTensorFromGPUData")}memory(){return ma("memory")}floatPrecision(){return ma("floatPrecision")}epsilon(){return this.floatPrecision()===32?1e-7:1e-4}dispose(){return ma("dispose")}};function ma(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function RF(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,sx(e,t,n)}function wX(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,r=0;for(;n>0;)r=Math.random()*n|0,n--,sx(e,n,r),sx(t,n,r)}function ay(e,t,n){return Math.max(e,Math.min(t,n))}function vX(e){return e%2===0?e:e+1}function sx(e,t,n){let r=e[t];e[t]=e[n],e[n]=r}function IX(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function kX(e,t){let n=Math.random();return t*n+(1-n)*e}function CX(e,t){let n=0;for(let r=0;r<e.length;r++){let s=Number(e[r])-Number(t[r]);n+=s*s}return n}function H(e,t){if(!e)throw new Error(typeof t=="string"?t:t())}function qs(e,t,n=""){H(hl(e,t),()=>n+` Shapes ${e} and ${t} must match`)}function bd(e){H(e!=null,()=>"The input to the tensor constructor must be a non-null value.")}function _n(e){if(e.length===0)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function SX(e){return e.length===0}function _F(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==null&&t[n]!==null&&e[n]!==t[n])return!1;return!0}function hl(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function Dp(e){return e%1===0}function NX(e){if(Math.tanh!=null)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{let t=Math.exp(2*e);return(t-1)/(t+1)}}function TX(e){let t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function EX(e){let t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return RF(t),t}function Jb(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function AX(e,t=s=>0,n,r){return new Promise((s,a)=>{let i=0,o=()=>{if(e()){s();return}i++;let u=t(i);if(n!=null&&i>=n){a();return}r!=null?r(o,u):setTimeout(o,u)};o()})}function $X(e,t){let n=1,r=-1;for(let a=0;a<e.length;++a)if(e[a]>=0)n*=e[a];else if(e[a]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${a}`);r=a}else if(e[a]<0)throw Error(`Shapes can not be < 0. Found ${e[a]} at dim ${a}`);if(r===-1){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(n===0)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);let s=e.slice();return s[r]=t/n,s}function mi(e,t){let n=t.length;return e=e==null?t.map((r,s)=>s):[].concat(e),H(e.every(r=>r>=-n&&r<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`),H(e.every(r=>Dp(r)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(r=>r<0?n+r:r)}function DF(e,t){let n=[],r=[],s=t!=null&&Array.isArray(t)&&t.length===0,a=t==null||s?null:mi(t,e).sort(),i=0;for(let o=0;o<e.length;++o){if(a!=null){if(a[i]===o&&e[o]!==1)throw new Error(`Can't squeeze axis ${o} since its dim '${e[o]}' is not 1`);(a[i]==null||a[i]>o)&&e[o]===1&&(n.push(e[o]),r.push(o)),a[i]<=o&&i++}e[o]!==1&&(n.push(e[o]),r.push(o))}return{newShape:n,keptDims:r}}function FF(e,t){return zS(e,t)}function zS(e,t){let n=null;if(e==null||e==="float32")n=new Float32Array(t);else if(e==="int32")n=new Int32Array(t);else if(e==="bool")n=new Uint8Array(t);else if(e==="string")n=new Array(t);else throw new Error(`Unknown data type ${e}`);return n}function MF(e,t){for(let n=0;n<e.length;n++){let r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function OF(e){return e==="bool"||e==="complex64"||e==="float32"||e==="int32"||e==="string"}function RX(e,t){return!(t==="complex64"||t==="float32"&&e!=="complex64"||t==="int32"&&e!=="float32"&&e!=="complex64"||t==="bool"&&e==="bool")}function ax(e){if(e==="float32"||e==="int32")return 4;if(e==="complex64")return 8;if(e==="bool")return 1;throw new Error(`Unknown dtype ${e}`)}function LF(e){if(e==null)return 0;let t=0;return e.forEach(n=>t+=n.length),t}function Fl(e){return typeof e=="string"||e instanceof String}function PF(e){return typeof e=="boolean"}function BF(e){return typeof e=="number"}function Uy(e){return Array.isArray(e)?Uy(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":BF(e)?"float32":Fl(e)?"string":PF(e)?"bool":"float32"}function Xl(e){return!!(e&&e.constructor&&e.call&&e.apply)}function ix(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function hf(e){let t=e.length;if(t<2)return[];let n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function zF(e,t,n,r=!1){let s=new Array;if(t.length===1){let a=t[0]*(r?2:1);for(let i=0;i<a;i++)s[i]=n[e+i]}else{let a=t[0],i=t.slice(1),o=i.reduce((u,c)=>u*c)*(r?2:1);for(let u=0;u<a;u++)s[u]=zF(e+u*o,i,n,r)}return s}function Sp(e,t,n=!1){if(e.length===0)return t[0];let r=e.reduce((s,a)=>s*a)*(n?2:1);if(r===0)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return zF(0,e,t,n)}function _X(e,t){if(Array.isArray(e))return e;if(t==="float32")return e instanceof Float32Array?e:new Float32Array(e);if(t==="int32")return e instanceof Int32Array?e:new Int32Array(e);if(t==="bool"||t==="string")return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function WS(e,t){let n=cw(e,t);for(let r=0;r<n.length;r++)n[r]=1;return n}function cw(e,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool")return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function DX(e,t){let n=e.reduce((r,s)=>r*s,1);if(t==null||t==="float32")return Sp(e,new Float32Array(n));if(t==="int32")return Sp(e,new Int32Array(n));if(t==="bool")return Sp(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function Da(e){e.forEach(t=>{H(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function FX(e,t,n){if(t===0)return 0;if(t===1)return e[0];let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=n[s]*e[s];return r}function MX(e,t,n){if(t===0)return[];if(t===1)return[e];let r=new Array(t);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(e/n[s]),e-=r[s]*n[s];return r[r.length-1]=e,r}function dw(e){return e&&e.then&&typeof e.then=="function"}var j$="tfjsflags",WF=class{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=OX,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(ge().getBool("IS_TEST")||ge().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},this.urlFlags[e]!=null){let r=this.urlFlags[e];ge().getBool("IS_TEST")||ge().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${r}.`),this.set(e,r)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];let t=this.evaluateFlag(e);if(dw(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;let e=this.getQueryParams(this.global.location.search);j$ in e&&e[j$].split(",").forEach(t=>{let[n,r]=t.split(":");this.urlFlags[n]=PX(n,r)})}};function OX(e){let t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...r)=>(LX(t,r[0],r[1]),r.join("="))),t}function LX(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}function PX(e,t){let n=t.toLowerCase();return n==="true"||n==="false"?n==="true":`${+n}`===n?+n:t}function ge(){return VS}var VS=null;function BX(e){VS=e}var JI;function VF(){if(JI==null){let e;if(typeof window<"u")e=window;else if(typeof globalThis<"u")e=globalThis;else if(typeof process<"u")e=process;else if(typeof self<"u")e=self;else throw new Error("Could not find a global object");JI=e}return JI}function zX(){let e=VF();return e._tfGlobals==null&&(e._tfGlobals=new Map),e._tfGlobals}function US(e,t){let n=zX();if(n.has(e))return n.get(e);{let r=t();return n.set(e,r),n.get(e)}}var pf="Abs",yd="Acos",xd="Acosh",yu="Add",wd="AddN",ff="All",mf="Any",gf="ArgMax",bf="ArgMin",vd="Asin",Id="Asinh",kd="Atan",Cd="Atanh",Sd="Atan2",Nd="AvgPool",Gy="AvgPoolGrad",yf="AvgPool3D",Hy="AvgPool3DGrad",Td="BatchMatMul",xf="BatchToSpaceND",wf="Bincount",vf="BitwiseAnd",UF="BroadcastTo",jy="BroadcastArgs",Ed="Cast",Ad="Ceil",xu="ClipByValue",hw="Complex",qy="ComplexAbs",If="Concat",$d="Conv2D",pw="Conv2DBackpropFilter",Rd="Conv2DBackpropInput",_d="Conv3D",kf="Conv3DBackpropFilterV2",Cf="Conv3DBackpropInputV2",Dd="Cos",Fd="Cosh",Sf="Cumprod",Md="Cumsum",Nf="CropAndResize",Ky="DenseBincount",Tf="DepthToSpace",Od="DepthwiseConv2dNative",fw="DepthwiseConv2dNativeBackpropFilter",mw="DepthwiseConv2dNativeBackpropInput",Xy="Diag",Ld="Dilation2D",Fp="Dilation2DBackpropInput",Mp="Dilation2DBackpropFilter",gw="Draw",Pd="RealDiv",bw="Einsum",Bd="Elu",Ef="EluGrad",zd="Erf",Af="Equal",Wd="Exp",$f="ExpandDims",Vd="Expm1",yw="FFT",Qy="Fill",Rf="FlipLeftRight",Ud="Floor",Gd="FloorDiv",Hd="FusedBatchNorm",_f="GatherV2",Df="GatherNd",Ff="Greater",jd="GreaterEqual",qd="Identity",xw="IFFT",ww="Imag",Kd="IsFinite",Xd="IsInf",Qd="IsNan",Yd="LeakyRelu",Mf="Less",Of="LessEqual",Lf="LinSpace",Jd="Log",Zd="Log1p",Pf="LogicalAnd",Bf="LogicalNot",zf="LogicalOr",GF="LogicalXor",HF="LogSoftmax",WX="LowerBound",eh="LRN",Wf="LRNGrad",VX="MatrixBandPart",th="Max",nh="Maximum",rh="MaxPool",Yy="MaxPoolGrad",Vf="MaxPool3D",Jy="MaxPool3DGrad",Zy="MaxPoolWithArgmax",sh="Mean",ah="Min",ih="Minimum",oh="MirrorPad",lh="Mod",Uf="Multinomial",uh="Multiply",Gf="Neg",Hf="NotEqual",jf="NonMaxSuppressionV3",qf="NonMaxSuppressionV4",Kf="NonMaxSuppressionV5",Xf="OnesLike",ch="OneHot",Qf="Pack",dh="PadV2",UX="Pool",hh="Pow",ph="Prelu",fh="Prod",vw="RaggedGather",Iw="RaggedRange",kw="RaggedTensorToTensor",e0="Range",Cw="Real",mh="Reciprocal",gh="Relu",Yf="Reshape",bh="ResizeNearestNeighbor",Jf="ResizeNearestNeighborGrad",yh="ResizeBilinear",Zf="ResizeBilinearGrad",xh="Relu6",wh="Reverse",vh="Round",Ih="Rsqrt",em="ScatterNd",tm="TensorScatterUpdate",nm="SearchSorted",rm="Select",kh="Selu",sm="Slice",Ch="Sin",Sh="Sinh",Nh="Sign",Th="Sigmoid",Eh="Softplus",Ah="Sqrt",$h="Sum",am="SpaceToBatchND",im="SplitV",Rh="Softmax",t0="SparseFillEmptyRows",om="SparseReshape",n0="SparseSegmentMean",r0="SparseSegmentSum",lm="SparseToDense",_h="SquaredDifference",s0="Square",a0="StaticRegexReplace",um="StridedSlice",i0="StringNGrams",o0="StringSplit",l0="StringToHashBucketFast",Dh="Sub",Fh="Tan",Mh="Tanh",wu="Tile",cm="TopK",dm="Transform",nl="Transpose",u0="Unique",hm="Unpack",c0="UnsortedSegmentSum",GX="UpperBound",pm="ZerosLike",vu="Step",ox="FromPixels",fm="RotateWithOffset",Oc="_FusedMatMul",Lc="FusedConv2D",Pc="FusedDepthwiseConv2D";function Dl(...e){ge().getBool("IS_TEST")||ge().getBool("PROD")||console.warn(...e)}function HX(...e){ge().getBool("IS_TEST")||ge().getBool("PROD")||console.log(...e)}var Op=US("kernelRegistry",()=>new Map),iy=US("gradRegistry",()=>new Map);function oy(e,t){let n=GS(e,t);return Op.get(n)}function Gk(e){return iy.get(e)}function lx(e){let t=Op.entries(),n=[];for(;;){let{done:r,value:s}=t.next();if(r)break;let[a,i]=s,[o]=a.split("_");o===e&&n.push(i)}return n}function d0(e){let{kernelName:t,backendName:n}=e,r=GS(t,n);Op.has(r)&&Dl(`The kernel '${t}' for backend '${n}' is already registered`),Op.set(r,e)}function jF(e){let{kernelName:t}=e;iy.has(t)&&ge().getBool("DEBUG")&&Dl(`Overriding the gradient for '${t}'`),iy.set(t,e)}function jX(e,t){let n=GS(e,t);if(!Op.has(n))throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);Op.delete(n)}function qX(e){if(!iy.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);iy.delete(e)}function KX(e,t){lx(e).forEach(n=>{let r=Object.assign({},n,{backendName:t});d0(r)})}function GS(e,t){return`${t}_${e}`}var $={};Pt($,{arraysEqual:()=>hl,arraysEqualWithNull:()=>_F,assert:()=>H,assertNonNegativeIntegerDimensions:()=>Da,assertNonNull:()=>bd,assertShapesMatch:()=>qs,bytesFromStringArray:()=>LF,bytesPerElement:()=>ax,checkConversionForErrors:()=>MF,clamp:()=>ay,computeStrides:()=>hf,convertBackendValuesAndArrayBuffer:()=>_X,createScalarValue:()=>eQ,createShuffledIndices:()=>EX,decodeString:()=>ux,distSquared:()=>CX,encodeString:()=>p0,fetch:()=>nQ,fingerPrint64:()=>ZX,flatten:()=>Ql,getArrayFromDType:()=>zS,getTypedArrayFromDType:()=>FF,hasEncodingLoss:()=>RX,hexToLong:()=>h0,indexToLoc:()=>MX,inferDtype:()=>Uy,inferFromImplicitShape:()=>$X,isBoolean:()=>PF,isFunction:()=>Xl,isInt:()=>Dp,isNumber:()=>BF,isPromise:()=>dw,isScalarShape:()=>SX,isString:()=>Fl,isTypedArray:()=>ts,isValidDtype:()=>OF,locToIndex:()=>FX,makeOnesTypedArray:()=>WS,makeZerosNestedTypedArray:()=>DX,makeZerosTypedArray:()=>cw,nearestDivisor:()=>ix,nearestLargerEven:()=>vX,now:()=>ly,parseAxisParam:()=>mi,randUniform:()=>kX,repeatedTry:()=>AX,rightPad:()=>Jb,shuffle:()=>RF,shuffleCombo:()=>wX,sizeFromShape:()=>_n,sizeToSquarishShape:()=>TX,squeezeShape:()=>DF,sum:()=>IX,swap:()=>sx,tanh:()=>NX,toNestedArray:()=>Sp,toTypedArray:()=>Sw});function qF(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var q$=bu(rX()),gc=q$.default||q$;function h0(e){return gc.fromString(e,!0,16)}var KF=h0("c3a5c85c97cb3127"),hc=h0("b492b66fbe98f273"),Ms=h0("9ae16a3b2f90404f");function Hk(e){return e.xor(e.shru(47))}function XF(e,t,n){let r=e.slice(t,t+n);return gc.fromBytes(Array.from(r),!0,!0)}function Xn(e,t){return XF(e,t,8)}function K$(e,t){return XF(e,t,4)}function es(e,t){return t===0?e:e.shru(t).or(e.shl(64-t))}function Wl(e,t,n=h0("9ddfea08eb382d69")){let r=e.xor(t).mul(n);r=r.xor(r.shru(47));let s=t.xor(r).mul(n);return s=s.xor(s.shru(47)),s=s.mul(n),s}function XX(e,t,n,r,s,a){s=s.add(e),a=es(a.add(s).add(r),21);let i=s;return s=s.add(t),s=s.add(n),a=a.add(es(s,44)),[s.add(r),a.add(i)]}function c2(e,t,n,r){return XX(Xn(e,t),Xn(e,t+8),Xn(e,t+16),Xn(e,t+24),n,r)}function QX(e,t=e.length){if(t>=8){let n=Ms.add(t*2),r=Xn(e,0).add(Ms),s=Xn(e,t-8),a=es(s,37).mul(n).add(r),i=es(r,25).add(s).mul(n);return Wl(a,i,n)}if(t>=4){let n=Ms.add(t*2),r=K$(e,0);return Wl(r.shl(3).add(t),K$(e,t-4),n)}if(t>0){let n=e[0],r=e[t>>1],s=e[t-1],a=n+(r<<8),i=t+(s<<2);return Hk(Ms.mul(a).xor(KF.mul(i))).mul(Ms)}return Ms}function YX(e,t=e.length){let n=Ms.add(t*2),r=Xn(e,0).mul(hc),s=Xn(e,8),a=Xn(e,t-8).mul(n),i=Xn(e,t-16).mul(Ms);return Wl(es(r.add(s),43).add(es(a,30)).add(i),r.add(es(s.add(Ms),18)).add(a),n)}function JX(e,t=e.length){let n=Ms.add(t*2),r=Xn(e,0).mul(Ms),s=Xn(e,8),a=Xn(e,t-8).mul(n),i=Xn(e,t-16).mul(Ms),o=es(r.add(s),43).add(es(a,30)).add(i),u=Wl(o,r.add(es(s.add(Ms),18)).add(a),n),c=Xn(e,16).mul(n),l=Xn(e,24),d=o.add(Xn(e,t-32)).mul(n),h=u.add(Xn(e,t-24)).mul(n);return Wl(es(c.add(l),43).add(es(d,30)).add(h),c.add(es(l.add(r),18)).add(d),n)}function ZX(e,t=e.length){let n=gc.fromNumber(81,!0);if(t<=32)return t<=16?QX(e,t):YX(e,t);if(t<=64)return JX(e,t);let r=n,s=n.mul(hc).add(113),a=Hk(s.mul(Ms).add(113)).mul(Ms),i=[gc.UZERO,gc.UZERO],o=[gc.UZERO,gc.UZERO];r=r.mul(Ms).add(Xn(e,0));let u=0,c=(t-1>>6)*64,l=c+(t-1&63)-63;do r=es(r.add(s).add(i[0]).add(Xn(e,u+8)),37).mul(hc),s=es(s.add(i[1]).add(Xn(e,u+48)),42).mul(hc),r=r.xor(o[1]),s=s.add(i[0]).add(Xn(e,u+40)),a=es(a.add(o[0]),33).mul(hc),i=c2(e,u,i[1].mul(hc),r.add(o[0])),o=c2(e,u+32,a.add(o[1]),s.add(Xn(e,u+16))),[a,r]=[r,a],u+=64;while(u!==c);let d=hc.add(a.and(255).shl(1));return u=l,o[0]=o[0].add(t-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),r=es(r.add(s).add(i[0]).add(Xn(e,u+8)),37).mul(d),s=es(s.add(i[1]).add(Xn(e,u+48)),42).mul(d),r=r.xor(o[1].mul(9)),s=s.add(i[0].mul(9).add(Xn(e,u+40))),a=es(a.add(o[0]),33).mul(d),i=c2(e,u,i[1].mul(d),r.add(o[0])),o=c2(e,u+32,a.add(o[1]),s.add(Xn(e,u+16))),[a,r]=[r,a],Wl(Wl(i[0],o[0],d).add(Hk(s).mul(KF)).add(a),Wl(i[1],o[1],d).add(r),d)}function eQ(e,t){return t==="string"?p0(e):Sw([e],t)}function tQ(e,t){return e instanceof Float32Array&&t==="float32"||e instanceof Int32Array&&t==="int32"||e instanceof Uint8Array&&t==="bool"}function Sw(e,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=Ql(e)),ge().getBool("DEBUG")&&MF(e,t),tQ(e,t))return e;if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool"){let n=new Uint8Array(e.length);for(let r=0;r<n.length;++r)Math.round(e[r])!==0&&(n[r]=1);return n}else throw new Error(`Unknown data type ${t}`)}function ly(){return ge().platform.now()}function nQ(e,t){return ge().platform.fetch(e,t)}function p0(e,t="utf-8"){return t=t||"utf-8",ge().platform.encode(e,t)}function ux(e,t="utf-8"){return t=t||"utf-8",ge().platform.decode(e,t)}function ts(e){return ge().platform.isTypedArray!=null?ge().platform.isTypedArray(e):qF(e)}function Ql(e,t=[],n=!1){if(t==null&&(t=[]),typeof e=="boolean"||typeof e=="number"||typeof e=="string"||dw(e)||e==null||ts(e)&&n)t.push(e);else if(Array.isArray(e)||ts(e))for(let r=0;r<e.length;++r)Ql(e[r],t,n);else{let r=-1;for(let s of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(s)&&(r=Math.max(r,Number(s)));for(let s=0;s<=r;s++)Ql(e[s],t,n)}return t}var rQ=class{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new aQ)}profileKernel(e,t,n){let r,s=()=>{r=n()},a,i=ly();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(s);else{s();for(let o of r)o.dataSync();a=Promise.resolve({kernelMs:ly()-i})}if(ge().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let o=0;o<r.length;o++){let u=r[o];u.data().then(c=>{sQ(c,u.dtype,e)})}return{kernelName:e,outputs:r,inputs:t,timeMs:a.then(o=>o.kernelMs),extraInfo:a.then(o=>o.getExtraProfileInfo!=null?o.getExtraProfileInfo():"")}}logKernelProfile(e){let{kernelName:t,outputs:n,timeMs:r,inputs:s,extraInfo:a}=e;n.forEach(i=>{Promise.all([i.data(),r,a]).then(o=>{this.logger.logKernelProfile(t,i,o[0],o[1],s,o[2])})})}};function sQ(e,t,n){if(t!=="float32")return!1;for(let r=0;r<e.length;r++){let s=e[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${n}'`),!0}return!1}var aQ=class{logKernelProfile(e,t,n,r,s,a){let i=typeof r=="number"?Jb(`${r}ms`,9):r.error,o=Jb(e,25),u=t.rank,c=t.size,l=Jb(t.shape.toString(),14),d="";for(let h in s){let p=s[h];if(p!=null){let f=p.shape||t.shape,m=f.length;d+=`${h}: ${m}D ${m>0?f:""} `}}console.log(`%c${o}	%c${i}	%c${u}D ${l}	%c${c}	%c${d}	%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function iQ(e,t,n){let r={},s={};for(let u=0;u<t.length;u++)r[t[u].id]=!0;for(let u=0;u<e.length;u++){let c=e[u],l=c.inputs;for(let d in l){let h=l[d],p=!1;for(let f=0;f<t.length;f++)if(r[h.id]){c.outputs.forEach(m=>r[m.id]=!0),p=!0,s[c.id]=!0;break}if(p)break}}let a={};a[n.id]=!0;let i={};for(let u=e.length-1;u>=0;u--){let c=e[u],l=c.inputs;for(let d=0;d<c.outputs.length;d++)if(a[c.outputs[d].id]){for(let h in l)a[l[h].id]=!0,i[c.id]=!0;break}}let o=[];for(let u=0;u<e.length;u++){let c=e[u];if(s[c.id]&&i[c.id]){let l={};for(let h in c.inputs){let p=c.inputs[h];r[p.id]&&(l[h]=p)}let d=Object.assign({},c);d.inputs=l,d.outputs=c.outputs,o.push(d)}}return o}function oQ(e,t,n,r){for(let s=t.length-1;s>=0;s--){let a=t[s],i=[];if(a.outputs.forEach(u=>{let c=e[u.id];c!=null?i.push(c):i.push(null)}),a.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);let o=a.gradient(i);for(let u in a.inputs){if(!(u in o))throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(o)}.`);let c=n(()=>o[u]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${c.dtype}'`);let l=a.inputs[u];if(!hl(c.shape,l.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${u}' has shape '${c.shape}', which does not match the shape of the input '${l.shape}'`);if(e[l.id]==null)e[l.id]=c;else{let d=e[l.id];e[l.id]=r(d,c),d.dispose()}}}}var X$=20,Nb=3,ZI=7;function lQ(e,t,n,r){let s=hf(t),a=uQ(e,t,n,s),i=t.length,o=z2(e,t,n,s,a),u=["Tensor"];return r&&(u.push(`  dtype: ${n}`),u.push(`  rank: ${i}`),u.push(`  shape: [${t}]`),u.push("  values:")),u.push(o.map(c=>"    "+c).join(`
`)),u.join(`
`)}function uQ(e,t,n,r){let s=_n(t),a=r[r.length-1],i=new Array(a).fill(0),o=t.length,u=n==="complex64"?Ob(e):e;if(o>1)for(let c=0;c<s/a;c++){let l=c*a;for(let d=0;d<a;d++)i[d]=Math.max(i[d],Mb(u[l+d],0,n).length)}return i}function Mb(e,t,n){let r;return Array.isArray(e)?r=`${parseFloat(e[0].toFixed(ZI))} + ${parseFloat(e[1].toFixed(ZI))}j`:Fl(e)?r=`'${e}'`:n==="bool"?r=QF(e):r=parseFloat(e.toFixed(ZI)).toString(),Jb(r,t)}function QF(e){return e===0?"false":"true"}function z2(e,t,n,r,s,a=!0){let i=n==="complex64"?2:1,o=t[0],u=t.length;if(u===0){if(n==="complex64"){let m=Ob(e);return[Mb(m[0],0,n)]}return n==="bool"?[QF(e[0])]:[e[0].toString()]}if(u===1){if(o>X$){let m=Nb*i,g=Array.from(e.slice(0,m)),b=Array.from(e.slice((o-Nb)*i,o*i));return n==="complex64"&&(g=Ob(g),b=Ob(b)),["["+g.map((y,x)=>Mb(y,s[x],n)).join(", ")+", ..., "+b.map((y,x)=>Mb(y,s[o-Nb+x],n)).join(", ")+"]"]}return["["+(n==="complex64"?Ob(e):Array.from(e)).map((m,g)=>Mb(m,s[g],n)).join(", ")+"]"]}let c=t.slice(1),l=r.slice(1),d=r[0]*i,h=[];if(o>X$){for(let m=0;m<Nb;m++){let g=m*d,b=g+d;h.push(...z2(e.slice(g,b),c,n,l,s,!1))}h.push("...");for(let m=o-Nb;m<o;m++){let g=m*d,b=g+d;h.push(...z2(e.slice(g,b),c,n,l,s,m===o-1))}}else for(let m=0;m<o;m++){let g=m*d,b=g+d;h.push(...z2(e.slice(g,b),c,n,l,s,m===o-1))}let p=u===2?",":"";h[0]="["+(o>0?h[0]+p:"");for(let m=1;m<h.length-1;m++)h[m]=" "+h[m]+p;let f=`,
`;for(let m=2;m<u;m++)f+=`
`;return h[h.length-1]=" "+h[h.length-1]+"]"+(a?"":f),h}function Ob(e){let t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}var _r=class{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=_n(e),n!=null){let r=n.length;H(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||zS(t,this.size),this.strides=hf(e)}set(e,...t){t.length===0&&(t=[0]),H(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);let n=this.locToIndex(t);this.values[n]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(let r of e){if(r<0||r>=this.shape[t]){let s=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(s)}t++}let n=e[e.length-1];for(let r=0;r<e.length-1;++r)n+=this.strides[r]*e[r];return this.values[n]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];let t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Mi().makeTensor(this.values,this.shape,this.dtype)}},Mi=null,yp=null;function cQ(e){Mi=e}function dQ(e){yp=e}var Wt=class{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=_n(e),this.strides=hf(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let e=await this.data();return yp.buffer(this.shape,this.dtype,e)}bufferSync(){return yp.buffer(this.shape,this.dtype,this.dataSync())}async array(){let e=await this.data();return Sp(this.shape,e,this.dtype==="complex64")}arraySync(){return Sp(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();let e=Mi().read(this.dataId);if(this.dtype==="string"){let t=await e;try{return t.map(n=>ux(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Mi().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();let e=Mi().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>ux(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();let e=await Mi().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Mi().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return yp.print(this,e)}clone(){return this.throwIfDisposed(),yp.clone(this)}toString(e=!1){let t=this.dataSync();return lQ(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),yp.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),Mi().makeVariable(this,e,t,n)}};Object.defineProperty(Wt,Symbol.hasInstance,{value:e=>!!e&&e.data!=null&&e.dataSync!=null&&e.throwIfDisposed!=null});function Ne(){return US("Tensor",()=>Wt)}Ne();var Bc=class extends Wt{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!hl(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Mi().disposeTensor(this),this.dataId=e.dataId,Mi().incRef(this,null)}dispose(){Mi().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(Bc,Symbol.hasInstance,{value:e=>e instanceof Wt&&e.assign!=null&&e.assign instanceof Function});var Bi={};Pt(Bi,{assertTypesMatch:()=>ZF,getTensorsInContainer:()=>HS,isTensorInList:()=>pQ,makeTypesMatch:()=>fr});var jk;(function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"})(jk||(jk={}));var qk;(function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"})(qk||(qk={}));var Kk;(function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"})(Kk||(Kk={}));var Xk;(function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"})(Xk||(Xk={}));var Qk;(function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"})(Qk||(Qk={}));var hQ={float32:Xk,int32:qk,bool:Kk,complex64:Qk};function Ha(e,t){if(e==="string"||t==="string"){if(e==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return hQ[e][t]}function Nw(e){return Ha(e,"int32")}function YF(e){return e!=null&&typeof e=="object"&&"texture"in e&&e.texture instanceof WebGLTexture}function JF(e){return typeof GPUBuffer<"u"&&e!=null&&typeof e=="object"&&"buffer"in e&&e.buffer instanceof GPUBuffer}function fr(e,t){if(e.dtype===t.dtype)return[e,t];let n=Ha(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function ZF(e,t){H(e.dtype===t.dtype,()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`)}function pQ(e,t){return t.some(n=>n.id===e.id)}function HS(e){let t=[];return e6(e,t,new Set),t}function e6(e,t,n){if(e==null)return;if(e instanceof Wt){t.push(e);return}if(!fQ(e))return;let r=e;for(let s in r){let a=r[s];n.has(a)||(n.add(a),e6(a,t,n))}}function fQ(e){return Array.isArray(e)||typeof e=="object"}function ek(e){return e.kernelName!=null}var Q$=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(let e in this.registeredVariables)this.registeredVariables[e].dispose()}},jS=class Yk{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Q$}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let t=this.getSortedBackends();for(let n=0;n<t.length;n++){let r=t[n];if(await this.initializeBackend(r).success){await this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:t,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){let{asyncInit:n}=this.initializeBackend(t);if(n)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,n,r=1){return t in this.registryFactory?(Dl(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:n,priority:r},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;let{success:n,asyncInit:r}=this.initializeBackend(t);if(!(r?await n:n))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new rQ(this.backendInstance),!0}setupRegisteredKernels(){lx(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){lx(t).forEach(n=>{n.disposeFunc!=null&&n.disposeFunc(this.registry[t])})}initializeBackend(t){let n=this.registryFactory[t];if(n==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{let r=n.factory();if(r&&!(r instanceof Vy)&&typeof r.then=="function"){let s=++this.pendingBackendInitId,a=r.then(i=>s<this.pendingBackendInitId?!1:(this.registry[t]=i,this.pendingBackendInit=null,!0)).catch(i=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,Dl(`Initialization of backend ${t} failed`),Dl(i.stack||i.message)),!1));return this.pendingBackendInit=a,{success:a,asyncInit:!0}}else return this.registry[t]=r,{success:!0,asyncInit:!1}}catch(r){return Dl(`Initialization of backend ${t} failed`),Dl(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,n)=>this.registryFactory[n].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){let t=this.getSortedBackends();for(let n=0;n<t.length;n++){let r=t[n],{success:s,asyncInit:a}=this.initializeBackend(r);if(a||s)return{name:r,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,n){let r=this.state.tensorInfo.get(n),s=r.backend,a=this.readSync(n),i=s.refCount(n);s.disposeData(n,!0),r.backend=t,t.move(n,a,r.shape,r.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,n){let r=null;if(n==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");n=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof n!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=t}let s;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(s),()=>(s=n(),s instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(t,n,r){t();try{let s=r();return n(),s}catch(s){throw n(),s}}nextTensorId(){return Yk.nextTensorId++}nextVariableId(){return Yk.nextVariableId++}clone(t){let n=J.runKernel(qd,{x:t}),r={x:t},s=i=>({x:()=>{let o="float32",u={x:i},c={dtype:o};return J.runKernel(Ed,u,c)}}),a=[];return this.addTapeNode(this.state.activeScope.name,r,[n],s,a,{}),n}runKernel(t,n,r){if(this.backendName==null&&this.backend,oy(t,this.backendName)==null)throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:n,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,n,r){let s=this.backend.numDataIds(),a=0;r.forEach(u=>{a+=u.dtype==="complex64"?3:1});let i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=s-n-a-i;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${t}'`)}runKernelFunc(t){let n,r=[],s=this.isTapeOn(),a=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let o;this.backendName==null&&this.backend;let u,c=ek(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(ek(t)){let{kernelName:f,inputs:m,attrs:g}=t;this.backendName==null&&this.backend;let b=oy(f,this.backendName);H(b!=null,()=>`Cannot find registered kernel '${f}' for backend '${this.backendName}'`),o=()=>{let y=this.backend.numDataIds();u=b.kernelFunc({inputs:m,attrs:g,backend:this.backend});let x=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(f,y,x);let w=x.map(v=>v.rank!=null?v:this.makeTensorFromTensorInfo(v));if(s){let v=this.getTensorsForGradient(f,m,w);r=this.saveTensorsForBackwardMode(v)}return w}}else{let{forwardFunc:f}=t,m=g=>{s&&(r=g.map(b=>this.keep(this.clone(b))))};o=()=>{let g=this.backend.numDataIds();u=this.tidy(()=>f(this.backend,m));let b=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,g,b),b}}let{inputs:l,attrs:d}=t,h=ek(t)?null:t.backwardsFunc,p;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?n=o():(p=this.profiler.profileKernel(c,l,()=>o()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),n=p.outputs)}),s&&this.addTapeNode(c,l,n,h,r,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(l).map(f=>l[f]!=null?l[f].shape:null),outputShapes:n.map(f=>f.shape),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(u)?n:n[0]}saveTensorsForBackwardMode(t){return t.map(n=>this.keep(this.clone(n)))}getTensorsForGradient(t,n,r){let s=Gk(t);if(s!=null){let a=s.inputsToSave||[],i=s.outputsToSave||[],o;s.saveAllInputs?(H(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),o=Object.keys(n).map(c=>n[c])):o=a.map(c=>n[c]);let u=r.filter((c,l)=>i[l]);return o.concat(u)}return[]}makeTensor(t,n,r,s){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",s=s||this.backend;let a=t;r==="string"&&Fl(t[0])&&(a=t.map(u=>p0(u)));let i=s.write(a,n,r),o=new Wt(n,r,i,this.nextTensorId());if(this.trackTensor(o,s),r==="string"){let u=this.state.tensorInfo.get(i),c=LF(a);this.state.numBytes+=c-u.bytes,u.bytes=c}return o}makeTensorFromDataId(t,n,r,s){r=r||"float32";let a={dataId:t,shape:n,dtype:r};return this.makeTensorFromTensorInfo(a,s)}makeTensorFromTensorInfo(t,n){let{dataId:r,shape:s,dtype:a}=t,i=new Wt(s,a,r,this.nextTensorId());return this.trackTensor(i,n),i}makeVariable(t,n=!0,r,s){r=r||this.nextVariableId().toString(),s!=null&&s!==t.dtype&&(t=t.cast(s));let a=new Bc(t,n,r,this.nextTensorId());if(this.state.registeredVariables[a.name]!=null)throw new Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(t,n){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let r=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(r=t.size*ax(t.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:n||this.backend,dtype:t.dtype,shape:t.shape,bytes:r})),t instanceof Bc||this.track(t)}incRef(t,n){this.trackTensor(t,n),this.backend.incRef(t.dataId)}removeDataId(t,n){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===n&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;let n=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){let r=t.size*ax(t.dtype);this.state.numBytes-=r}n.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,n.backend)}disposeVariables(){for(let t in this.state.registeredVariables){let n=this.state.registeredVariables[t];this.disposeVariable(n)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){let t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;let n=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-r;for(let s of this.state.activeProfile.kernels)s.kernelTimeMs=await s.kernelTimeMs,s.extraInfo=await s.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,n,r,s,a,i){let o={id:this.state.nextTapeNodeId++,kernelName:t,inputs:n,outputs:r,saved:a},u=Gk(t);u!=null&&(s=u.gradFunc),s!=null&&(o.gradient=c=>(c=c.map((l,d)=>{if(l==null){let h=r[d],p=cw(h.size,h.dtype);return this.makeTensor(p,h.shape,h.dtype)}return l}),s(c.length>1?c:c[0],a,i))),this.state.activeTape.push(o)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){let n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(n.name=t),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(t){let n=HS(t),r=new Set(n.map(a=>a.id));for(let a=0;a<this.state.activeScope.track.length;a++){let i=this.state.activeScope.track[a];!i.kept&&!r.has(i.id)&&i.dispose()}let s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(a=>{!a.kept&&a.scopeId===s.id&&this.track(a)})}gradients(t,n,r,s=!1){if(H(n.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);let a=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));H(a instanceof Wt,()=>"The result y returned by f() must be a tensor.");let i=iQ(this.state.activeTape,n,a);if(!s&&i.length===0&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let o={};o[a.id]=r??mQ(a.shape),oQ(o,i,c=>this.tidy(c),gQ);let u=n.map(c=>o[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(let l of c.saved)l.dispose()}),this.state.activeTape=null),{value:a,grads:u}})}customGrad(t){return H(Xl(t),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{H(n.every(o=>o instanceof Wt),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r,s={};n.forEach((o,u)=>{s[u]=o});let a=(o,u)=>(r=t(...n,u),H(r.value instanceof Wt,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),H(Xl(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),i=(o,u)=>{let c=r.gradFunc(o,u),l=Array.isArray(c)?c:[c];H(l.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),H(l.every(h=>h instanceof Wt),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let d={};return l.forEach((h,p)=>{d[p]=()=>h}),d};return this.runKernelFunc({forwardFunc:a,backwardsFunc:i,inputs:s})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,n){return this.state.tensorInfo.get(t).backend.readToGPU(t,n)}async time(t){let n=ly(),r=await this.backend.time(t);return r.wallMs=ly()-n,r}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Q$;for(let t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};jS.nextTensorId=0;jS.nextVariableId=0;function mQ(e){let t=WS(_n(e),"float32");return J.makeTensor(t,e,"float32")}function t6(){let e=VF();if(e._tfengine==null){let t=new WF(e);e._tfengine=new jS(t)}return BX(e._tfengine.ENV),cQ(()=>e._tfengine),e._tfengine}var J=t6();function gQ(e,t){let n={a:e,b:t};return J.runKernel(yu,n)}var f0={};Pt(f0,{isBrowser:()=>n6,isMobile:()=>xQ,mockIsMobile:()=>yQ});function bQ(){return typeof navigator<"u"&&navigator!=null}var Jk;function yQ(e){Jk=e}function xQ(e){if(Jk!==void 0)return Jk;if(e||bQ()){if(e||(e=navigator),e.product==="ReactNative")return!0;let t=e.userAgent||e.vendor||(typeof window<"u"?window.opera:"");if(!t){let n=e;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function n6(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}var la=ge();la.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});la.registerFlag("IS_BROWSER",()=>n6());la.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");la.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));la.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));la.registerFlag("PROD",()=>!1);la.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>la.getBool("DEBUG"));la.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);la.registerFlag("IS_TEST",()=>!1);la.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>la.getBool("DEBUG"));la.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);la.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);la.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function No(e,t){let n=e;if(ts(e))return t==="string"?[]:[e.length];if(YF(e)){let s=e.channels||"RGBA";return[e.height,e.width*s.length]}else if(JF(e))return[e.buffer.size/(t==null?4:ax(t))];if(!Array.isArray(e))return[];let r=[];for(;Array.isArray(n)||ts(n)&&t!=="string";)r.push(n.length),n=n[0];return Array.isArray(e)&&ge().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&r6(e,r,[]),r}function r6(e,t,n){if(n=n||[],!Array.isArray(e)&&!ts(e)){H(t.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}H(t.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`),H(e.length===t[0],()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`);let r=t.slice(1);for(let s=0;s<e.length;++s)r6(e[s],r,n.concat(s))}function Y$(e,t,n,r){if(e!=="string_or_numeric"){if(e==null)throw new Error("Expected dtype cannot be null.");if(e!=="numeric"&&e!==t||e==="numeric"&&t==="string")throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function W(e,t,n,r="numeric"){if(e instanceof Ne())return Y$(r,e.dtype,t,n),e;let s=Uy(e);if(s!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),Y$(r,s,t,n),e==null||!ts(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string"){let o=e==null?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${o}'`)}let a=No(e,s);!ts(e)&&!Array.isArray(e)&&(e=[e]);let i=s!=="string"?Sw(e,s):Ql(e,[],!0);return J.makeTensor(i,a,s)}function uy(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((s,a)=>W(s,`${t}[${a}]`,n,r))}var qS="__op";function ne(e){let t=Object.keys(e);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0],r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+qS;let s=(...a)=>{J.startScope(n);try{let i=r(...a);return dw(i)&&console.error("Cannot return a Promise inside of tidy."),J.endScope(i),i}catch(i){throw J.endScope(null),i}};return Object.defineProperty(s,"name",{value:n,configurable:!0}),s}function wQ(e,t){let n=W(e,"real","complex"),r=W(t,"imag","complex");qs(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);let s={real:n,imag:r};return J.runKernel(hw,s)}var il=ne({complex_:wQ});function Iu(e,t,n,r){if(r==null)r=Uy(e);else if(r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(JF(e)||YF(e)){if(r!=="float32"&&r!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return J.backend.createTensorFromGPUData(e,t||n,r)}if(!ts(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){Da(t);let s=_n(t),a=_n(n);H(s===a,()=>`Based on the provided shape, [${t}], the tensor should have ${s} values but has ${a}`);for(let i=0;i<n.length;++i){let o=n[i],u=i===n.length-1?o!==_n(t.slice(i)):!0;H(n[i]===t[i]||!u,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return!ts(e)&&!Array.isArray(e)&&(e=[e]),t=t||n,e=r!=="string"?Sw(e,r):Ql(e,[],!0),J.makeTensor(e,t,r)}function zs(e,t,n){let r=No(e,n);return Iu(e,t,r,n)}var zc={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},pl=class s6{static join(t){return new s6(t).slice()}constructor(t){if(this.shards=[],this.previousShardIndex=0,t==null||(t instanceof Array||(t=[t]),t=t.map(r=>ts(r)?r.buffer:r),t.length===0))return;this.bufferUniformSize=t[0].byteLength;let n=0;for(let r=0;r<t.length;r++){let s=t[r];r!==t.length-1&&s.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);let a=n+s.byteLength;this.shards.push({buffer:s,start:n,end:a}),n=a}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,n=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,n=isNaN(Number(n))?0:n,t=Math.max(0,t),n=Math.min(this.byteLength,n),n<=t)return new ArrayBuffer(0);let r=this.findShardForByte(t);if(r===-1)throw new Error(`Could not find start shard for byte ${t}`);let s=n-t,a=new ArrayBuffer(s),i=new Uint8Array(a),o=0;for(let u=r;u<this.shards.length;u++){let c=this.shards[u],l=t+o-c.start,d=o,h=Math.min(n,c.end)-c.start,p=new Uint8Array(c.buffer,l,h-l);if(i.set(p,d),o+=p.length,n<c.end)break}return a}findShardForByte(t){if(this.shards.length===0||t<0||t>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function n(s){return t<s.start?-1:t>=s.end?1:0}if(n(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;let r=vQ(this.shards,n);return r===-1?-1:(this.previousShardIndex=r,this.previousShardIndex)}};function vQ(e,t){let n=0,r=e.length;for(;n<=r;){let s=Math.floor((r-n)/2)+n,a=t(e[s]);if(a===0)return s;a<0?r=s:n=s+1}return-1}function IQ(){ge().set("PROD",!0)}function kQ(){ge().set("DEBUG",!0)}function CQ(){ge().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function a6(e){ge().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function SQ(){J.disposeVariables()}function ai(){return J}function Zk(){return J.memory()}function NQ(e){return J.profile(e)}function ie(e,t){return J.tidy(e,t)}function Lt(e){HS(e).forEach(t=>t.dispose())}function zr(e){return J.keep(e)}function TQ(e){return J.time(e)}function EQ(e){return J.setBackend(e)}function AQ(){return J.ready()}function i6(){return J.backendName}function $Q(e){J.removeBackend(e)}function RQ(e){return J.findBackend(e)}function _Q(e){return J.findBackendFactory(e)}function Tw(e,t,n=1){return J.registerBackend(e,t,n)}function KS(){return J.backend}function DQ(e,t){ge().setPlatform(e,t)}var Yl=4;async function FQ(e,t){let n=[],r=[],s=Array.isArray(e)?e.map(i=>i.name):Object.keys(e);for(let i=0;i<s.length;++i){let o=s[i],u=Array.isArray(e)?e[i].tensor:e[o];if(u.dtype!=="float32"&&u.dtype!=="int32"&&u.dtype!=="bool"&&u.dtype!=="string"&&u.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${o}': ${u.dtype}`);let c={name:o,shape:u.shape,dtype:u.dtype};if(u.dtype==="string"){let l=new Promise(async d=>{let h=await u.bytes(),p=h.reduce((g,b)=>g+b.length,0)+Yl*h.length,f=new Uint8Array(p),m=0;for(let g=0;g<h.length;g++){let b=h[g],y=new Uint8Array(new Uint32Array([b.length]).buffer);f.set(y,m),m+=Yl,f.set(b,m),m+=b.length}d(f)});r.push(l)}else r.push(u.data());t!=null&&(c.group=t),n.push(c)}let a=await Promise.all(r);return{data:LQ(a),specs:n}}function o6(e,t){let n=new pl(e),r={},s=0;for(let a of t){let i=MQ(a,(o,u)=>n.slice(s+o,s+u));r[a.name]=l6(a,n.slice(s,s+i)),s+=i}return r}function MQ(e,t){let n=_n(e.shape),r;if("quantization"in e){let s=e.quantization;r=zc[s.dtype]}else if(e.dtype==="string"){let s=0;for(let a=0;a<n;a++)s+=Yl+new Uint32Array(t(s,s+Yl))[0];return s}else r=zc[e.dtype];return n*r}async function OQ(e,t){let n=_n(e.shape),r;if("quantization"in e){let s=e.quantization;r=zc[s.dtype]}else if(e.dtype==="string"){let s=0;for(let a=0;a<n;a++)s+=Yl+new Uint32Array(await t(s,s+Yl))[0];return s}else r=zc[e.dtype];return n*r}function l6(e,t){let n=e.name,r=e.dtype,s=e.shape,a=_n(s),i,o=0;if("quantization"in e){let u=e.quantization;if(u.dtype==="uint8"||u.dtype==="uint16"){if(!("min"in u&&"scale"in u))throw new Error(`Weight ${e.name} with quantization ${u.dtype} doesn't have corresponding metadata min and scale.`)}else if(u.dtype==="float16"){if(r!=="float32")throw new Error(`Weight ${e.name} is quantized with ${u.dtype} which only supports weights of type float32 not ${r}.`)}else throw new Error(`Weight ${e.name} has unknown quantization dtype ${u.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let c=zc[u.dtype],l=u.dtype==="uint8"?new Uint8Array(t):new Uint16Array(t);if(r==="float32")if(u.dtype==="uint8"||u.dtype==="uint16"){i=new Float32Array(l.length);for(let d=0;d<l.length;d++){let h=l[d];i[d]=h*u.scale+u.min}}else if(u.dtype==="float16")i=GQ()(l);else throw new Error(`Unsupported quantization type ${u.dtype} for weight type float32.`);else if(r==="int32"){if(u.dtype!=="uint8"&&u.dtype!=="uint16")throw new Error(`Unsupported quantization type ${u.dtype} for weight type int32.`);i=new Int32Array(l.length);for(let d=0;d<l.length;d++){let h=l[d];i[d]=Math.round(h*u.scale+u.min)}}else throw new Error(`Unsupported dtype in weight '${n}': ${r}`);o+=a*c}else if(r==="string"){let u=_n(e.shape);i=[];for(let c=0;c<u;c++){let l=new Uint32Array(t.slice(o,o+Yl))[0];o+=Yl;let d=new Uint8Array(t.slice(o,o+l));i.push(d),o+=l}}else{let u=zc[r];if(r==="float32")i=new Float32Array(t);else if(r==="int32")i=new Int32Array(t);else if(r==="bool")i=new Uint8Array(t);else if(r==="complex64"){i=new Float32Array(t);let c=new Float32Array(i.length/2),l=new Float32Array(i.length/2);for(let f=0;f<c.length;f++)c[f]=i[f*2],l[f]=i[f*2+1];let d=zs(c,s,"float32"),h=zs(l,s,"float32"),p=il(d,h);return d.dispose(),h.dispose(),p}else throw new Error(`Unsupported dtype in weight '${n}': ${r}`);o+=a*u}return zs(i,s,r)}async function J$(e,t,n){let r=new Uint8Array(t);for(;r.byteLength<n;){let{done:s,value:a}=await e.read();if(s&&a==null){let o=n-r.byteLength;throw new Error(`Reader is done but ${o} bytes are still expected`)}let i=new Uint8Array(r.length+a.byteLength);i.set(r,0),i.set(new Uint8Array(a),r.length),r=i}return r.buffer}async function u6(e,t){let n={},r=e.getReader(),s=new ArrayBuffer(0);for(let a of t){let i=await OQ(a,async(c,l)=>(s=await J$(r,s,l),s.slice(c,l)));s=await J$(r,s,i);let o=s.slice(0,i);s=s.slice(i);let u=l6(a,o);if(n[a.name]=u,i6()==="webgpu"){let c=KS();"uploadToGPU"in c&&_n(u.shape)>=ge().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&c.uploadToGPU(u.dataId)}}return n}function LQ(e){if(e===null)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0,n=[];e.forEach(a=>{if(t+=a.byteLength,n.push(a.byteLength===a.buffer.byteLength?a:new a.constructor(a)),!(a instanceof Float32Array||a instanceof Int32Array||a instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${a.constructor.name}`)});let r=new Uint8Array(t),s=0;return n.forEach(a=>{r.set(new Uint8Array(a.buffer),s),s+=a.byteLength}),r.buffer}var XS=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function Z$(e){return XS?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function PQ(e){if(XS)return Buffer.from(e).toString("base64");let t=new Uint8Array(e),n="";for(let r=0,s=t.length;r<s;r++)n+=String.fromCharCode(t[r]);return btoa(n)}function BQ(e){if(XS){let r=Buffer.from(e,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}let t=atob(e),n=new Uint8Array(t.length);for(let r=0;r<t.length;++r)n.set([t.charCodeAt(r)],r);return n.buffer}function zQ(e){return pl.join(e)}function eR(e){let t="/";for(e=e.trim();e.endsWith(t);)e=e.slice(0,e.length-1);let n=e.split(t);return n[n.length-1]}function c6(e,t){let n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return e.signature!=null&&(n.signature=e.signature),e.userDefinedMetadata!=null&&(n.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(n.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(n.initializerSignature=e.initializerSignature),e.trainingConfig!=null&&(n.trainingConfig=e.trainingConfig),n}function d6(e,t,n){let r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(e.trainingConfig!=null&&(r.trainingConfig=e.trainingConfig),e.weightsManifest!=null){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=n}return e.signature!=null&&(r.signature=e.signature),e.userDefinedMetadata!=null&&(r.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(r.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(r.initializerSignature=e.initializerSignature),r}async function QS(e,t){let n,r;return e.weightsManifest!=null&&([n,r]=await t(e.weightsManifest)),d6(e,n,r)}function m0(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:e.modelTopology==null?0:Z$(JSON.stringify(e.modelTopology)),weightSpecsBytes:e.weightSpecs==null?0:Z$(JSON.stringify(e.weightSpecs)),weightDataBytes:e.weightData==null?0:new pl(e.weightData).byteLength}}function eC(e){let t=[];for(let n of e)t.push(...n.weights);return t}function WQ(){let e=n=>{let r=n<<13,s=0;for(;!(r&8388608);)s-=8388608,r<<=1;return r&=-8388609,s+=947912704,r|s},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}function VQ(){let e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}function UQ(){let e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}function GQ(){let e=WQ(),t=VQ(),n=UQ();return r=>{let s=new ArrayBuffer(4*r.length),a=new Uint32Array(s);for(let i=0;i<r.length;i++){let o=r[i],u=e[n[o>>10]+(o&1023)]+t[o>>10];a[i]=u}return new Float32Array(s)}}var ja=class Ri{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Ri.instance==null&&(Ri.instance=new Ri),Ri.instance}static registerSaveRouter(t){Ri.getInstance().saveRouters.push(t)}static registerLoadRouter(t){Ri.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return Ri.getHandlers(t,"save")}static getLoadHandlers(t,n){return Ri.getHandlers(t,"load",n)}static getHandlers(t,n,r){let s=[];return(n==="load"?Ri.getInstance().loadRouters:Ri.getInstance().saveRouters).forEach(a=>{let i=a(t,r);i!==null&&s.push(i)}),s}},HQ=e=>ja.registerSaveRouter(e),jQ=e=>ja.registerLoadRouter(e),qQ=e=>ja.getSaveHandlers(e),KQ=(e,t)=>ja.getLoadHandlers(e,t),tC="tensorflowjs",nC=1,Cc="models_store",Ml="model_info_store";function h6(){if(!ge().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let e=typeof window>"u"?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function rC(e){let t=e.result;t.createObjectStore(Cc,{keyPath:"modelPath"}),t.createObjectStore(Ml,{keyPath:"modelPath"})}var Wc=class{constructor(e){if(this.indexedDB=h6(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((n,r)=>{let s=this.indexedDB.open(tC,nC);s.onupgradeneeded=()=>rC(s),s.onsuccess=()=>{let a=s.result;if(t==null){let i=a.transaction(Cc,"readonly"),o=i.objectStore(Cc).get(this.modelPath);o.onsuccess=()=>{if(o.result==null)return a.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));n(o.result.modelArtifacts)},o.onerror=u=>(a.close(),r(o.error)),i.oncomplete=()=>a.close()}else{t.weightData=pl.join(t.weightData);let i=m0(t),o=a.transaction(Ml,"readwrite"),u=o.objectStore(Ml),c;try{c=u.put({modelPath:this.modelPath,modelArtifactsInfo:i})}catch(d){return r(d)}let l;c.onsuccess=()=>{l=a.transaction(Cc,"readwrite");let d=l.objectStore(Cc),h;try{h=d.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:i})}catch(p){return r(p)}h.onsuccess=()=>n({modelArtifactsInfo:i}),h.onerror=p=>{u=o.objectStore(Ml);let f=u.delete(this.modelPath);f.onsuccess=()=>(a.close(),r(h.error)),f.onerror=m=>(a.close(),r(h.error))}},c.onerror=d=>(a.close(),r(c.error)),o.oncomplete=()=>{l==null?a.close():l.oncomplete=()=>a.close()}}},s.onerror=a=>r(s.error)})}};Wc.URL_SCHEME="indexeddb://";var p6=e=>ge().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Wc.URL_SCHEME)?XQ(e.slice(Wc.URL_SCHEME.length)):null;ja.registerSaveRouter(p6);ja.registerLoadRouter(p6);function XQ(e){return new Wc(e)}function QQ(e){return e.startsWith(Wc.URL_SCHEME)?e.slice(Wc.URL_SCHEME.length):e}var YQ=class{constructor(){this.indexedDB=h6()}async listModels(){return new Promise((e,t)=>{let n=this.indexedDB.open(tC,nC);n.onupgradeneeded=()=>rC(n),n.onsuccess=()=>{let r=n.result,s=r.transaction(Ml,"readonly"),a=s.objectStore(Ml).getAll();a.onsuccess=()=>{let i={};for(let o of a.result)i[o.modelPath]=o.modelArtifactsInfo;e(i)},a.onerror=i=>(r.close(),t(a.error)),s.oncomplete=()=>r.close()},n.onerror=r=>t(n.error)})}async removeModel(e){return e=QQ(e),new Promise((t,n)=>{let r=this.indexedDB.open(tC,nC);r.onupgradeneeded=()=>rC(r),r.onsuccess=()=>{let s=r.result,a=s.transaction(Ml,"readwrite"),i=a.objectStore(Ml),o=i.get(e),u;o.onsuccess=()=>{if(o.result==null)return s.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{let c=i.delete(e),l=()=>{u=s.transaction(Cc,"readwrite");let d=u.objectStore(Cc).delete(e);d.onsuccess=()=>t(o.result.modelArtifactsInfo),d.onerror=h=>n(o.error)};c.onsuccess=l,c.onerror=d=>(l(),s.close(),n(o.error))}},o.onerror=c=>(s.close(),n(o.error)),a.oncomplete=()=>{u==null?s.close():u.oncomplete=()=>s.close()}},r.onerror=s=>n(r.error)})}},Zo="/",xp="tensorflowjs_models",f6="info",JQ="model_topology",ZQ="weight_specs",eY="weight_data",tY="model_metadata";function m6(e){return{info:[xp,e,f6].join(Zo),topology:[xp,e,JQ].join(Zo),weightSpecs:[xp,e,ZQ].join(Zo),weightData:[xp,e,eY].join(Zo),modelMetadata:[xp,e,tY].join(Zo)}}function g6(e){for(let t of Object.values(e))window.localStorage.removeItem(t)}function nY(e){let t=e.split(Zo);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(Zo)}function rY(e){return e.startsWith(Vc.URL_SCHEME)?e.slice(Vc.URL_SCHEME.length):e}var Vc=class{constructor(e){if(!ge().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=m6(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),r=m0(e),s=pl.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,PQ(s));let a={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:r}}catch{throw g6(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(n==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;let r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;let s=this.LS.getItem(this.keys.modelMetadata);if(s!=null){let i=JSON.parse(s);t.format=i.format,t.generatedBy=i.generatedBy,t.convertedBy=i.convertedBy,i.signature!=null&&(t.signature=i.signature),i.userDefinedMetadata!=null&&(t.userDefinedMetadata=i.userDefinedMetadata),i.modelInitializer!=null&&(t.modelInitializer=i.modelInitializer),i.initializerSignature!=null&&(t.initializerSignature=i.initializerSignature),i.trainingConfig!=null&&(t.trainingConfig=i.trainingConfig)}let a=this.LS.getItem(this.keys.weightData);if(a==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=BQ(a),t}};Vc.URL_SCHEME="localstorage://";var b6=e=>ge().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Vc.URL_SCHEME)?sY(e.slice(Vc.URL_SCHEME.length)):null;ja.registerSaveRouter(b6);ja.registerLoadRouter(b6);function sY(e){return new Vc(e)}var aY=class{constructor(){H(ge().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),H(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let e={},t=xp+Zo,n=Zo+f6;for(let r=0;r<this.LS.length;++r){let s=this.LS.key(r);if(s.startsWith(t)&&s.endsWith(n)){let a=nY(s);e[a]=JSON.parse(this.LS.getItem(s))}}return e}async removeModel(e){e=rY(e);let t=m6(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);let n=JSON.parse(this.LS.getItem(t.info));return g6(t),n}},Np="://",Jl=class Nl{constructor(){this.managers={}}static getInstance(){return Nl.instance==null&&(Nl.instance=new Nl),Nl.instance}static registerManager(t,n){H(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(Np)&&(t=t.slice(0,t.indexOf(Np))),H(t.length>0,()=>"scheme must not be an empty string.");let r=Nl.getInstance();H(r.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),r.managers[t]=n}static getManager(t){let n=Nl.getInstance().managers[t];if(n==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return n}static getSchemes(){return Object.keys(Nl.getInstance().managers)}};function W2(e){if(e.indexOf(Np)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Jl.getSchemes().join(",")}`);return{scheme:e.split(Np)[0],path:e.split(Np)[1]}}async function y6(e,t,n=!1){H(e!==t,()=>`Old path and new path are the same: '${e}'`);let r=ja.getLoadHandlers(e);H(r.length>0,()=>`Copying failed because no load handler is found for source URL ${e}.`),H(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`);let s=r[0],a=ja.getSaveHandlers(t);H(a.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),H(a.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`);let i=a[0],o=W2(e).scheme,u=W2(e).path,c=o===W2(e).scheme,l=await s.load();n&&c&&await Jl.getManager(o).removeModel(u);let d=await i.save(l);return n&&!c&&await Jl.getManager(o).removeModel(u),d.modelArtifactsInfo}async function iY(){let e=Jl.getSchemes(),t={};for(let n of e){let r=await Jl.getManager(n).listModels();for(let s in r){let a=n+Np+s;t[a]=r[s]}}return t}async function oY(e){let t=W2(e);return Jl.getManager(t.scheme).removeModel(t.path)}async function lY(e,t){return y6(e,t,!1)}async function uY(e,t){return y6(e,t,!0)}var cY=class{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!ge().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",n=>{if(n.source===window&&n.data.name===this.messageName){n.stopPropagation();let r=this.functionRefs[n.data.index];r(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return qF(e)}};if(ge().get("IS_BROWSER")){ge().setPlatform("browser",new cY);try{Jl.registerManager(Vc.URL_SCHEME,new aY)}catch{}try{Jl.registerManager(Wc.URL_SCHEME,new YQ)}catch{}}var dY={importFetch:()=>sX()},tk,hY=class{constructor(){this.util=aX(),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return ge().global.fetch!=null?ge().global.fetch(e,t):(tk==null&&(tk=dY.importFetch()),tk(e,t))}now(){let e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}};ge().get("IS_NODE")&&!ge().get("IS_BROWSER")&&ge().setPlatform("node",new hY);function Ht(e,t="float32",n){return t=t||"float32",Da(e),new _r(e,t,n)}function pY(e,t){let n=W(e,"x","cast");if(!OF(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&n.dtype!=="string"||t!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");let r={x:n},s={dtype:t};return J.runKernel(Ed,r,s)}var Ve=ne({cast_:pY});function fY(e){let t={x:W(e,"x","clone","string_or_numeric")};return J.runKernel(qd,t)}var xo=ne({clone_:fY});function YS(e,t=!1){console.log(e.toString(t))}t6();var mY={buffer:Ht,cast:Ve,clone:xo,print:YS};dQ(mY);function gY(e,t){let n=W(e,"a","add"),r=W(t,"b","add");[n,r]=fr(n,r);let s={a:n,b:r};return J.runKernel(yu,s)}var Se=ne({add_:gY});function bY(e,t){let n=W(e,"a","floorDiv"),r=W(t,"b","floorDiv");[n,r]=fr(n,r);let s={a:n,b:r};return J.runKernel(Gd,s)}var Ew=ne({floorDiv_:bY});function yY(e,t){let n=W(e,"a","div"),r=W(t,"b","div");if([n,r]=fr(n,r),n.dtype==="int32"&&r.dtype==="int32")return Ew(n,r);let s={a:n,b:r},a={};return J.runKernel(Pd,s,a)}var it=ne({div_:yY});function xY(e,t){let n=W(e,"a","mul"),r=W(t,"b","mul");[n,r]=fr(n,r);let s={a:n,b:r};return J.runKernel(uh,s)}var se=ne({mul_:xY});function wY(e){let t=W(e,"x","abs");if(t.dtype==="complex64"){let n={x:t};return J.runKernel(qy,n)}else{let n={x:t};return J.runKernel(pf,n)}}var Ar=ne({abs_:wY});function vY(e){let t={x:W(e,"x","acos")};return J.runKernel(yd,t)}var JS=ne({acos_:vY});function IY(e){let t={x:W(e,"x","acosh")};return J.runKernel(xd,t)}var ZS=ne({acosh_:IY});function kY(e){H(Array.isArray(e),()=>"The argument passed to tf.addN() must be a list of tensors"),H(e.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`);let t=e.map((s,a)=>W(s,`tensors${a}`,"addN")),n=t[0];t.forEach(s=>{if(s.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(s=>{if(!hl(s.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});let r=t;return J.runKernel(wd,r)}var x6=ne({addN_:kY});function CY(e,t=null,n=!1){let r={x:W(e,"x","all","bool")},s={axis:t,keepDims:n};return J.runKernel(ff,r,s)}var Aw=ne({all_:CY});function SY(e,t=null,n=!1){let r={x:W(e,"x","any","bool")},s={axis:t,keepDims:n};return J.runKernel(mf,r,s)}var cy=ne({any_:SY});function NY(e,t=0){let n={x:W(e,"x","argMax")},r={axis:t};return J.runKernel(gf,n,r)}var Uc=ne({argMax_:NY});function TY(e,t=0){let n={x:W(e,"x","argMin")},r={axis:t};return J.runKernel(bf,n,r)}var e3=ne({argMin_:TY});function EY(e){let t={x:W(e,"x","asin")};return J.runKernel(vd,t)}var t3=ne({asin_:EY});function AY(e){let t={x:W(e,"x","asinh")};return J.runKernel(Id,t)}var n3=ne({asinh_:AY});function $Y(e){let t={x:W(e,"x","atan")};return J.runKernel(kd,t)}var r3=ne({atan_:$Y});function RY(e,t){let n=W(e,"a","atan2"),r=W(t,"b","atan2");[n,r]=fr(n,r);let s={a:n,b:r};return J.runKernel(Sd,s)}var s3=ne({atan2_:RY});function _Y(e){let t={x:W(e,"x","atanh")};return J.runKernel(Cd,t)}var a3=ne({atanh_:_Y});function DY(e,t,n,r,s="NHWC",a){let i=e[3],o=[...t,i],u=I6(s);return g0(e,o,n,a,r,null,null,u)}function w6(e,t,n,r,s,a,i="channelsLast"){let[o,u]=dy(t),c;if(i==="channelsLast")c=[o,u,e[3],e[3]];else if(i==="channelsFirst")c=[o,u,e[1],e[1]];else throw new Error(`Unknown dataFormat ${i}`);return g0(e,c,n,r,s,a,!1,i)}function FY(e,t,n,r,s,a,i="NDHWC"){let[o,u,c]=sC(t),l,d;if(i==="NDHWC")d="channelsLast",l=[o,u,c,e[4],e[4]];else if(i==="NCDHW")d="channelsFirst",l=[o,u,c,e[1],e[1]];else throw new Error(`Unknown dataFormat ${i}`);return v6(e,l,n,r,s,!1,d,a)}function g0(e,t,n,r,s,a,i=!1,o="channelsLast"){let[u,c,l,d]=[-1,-1,-1,-1];if(o==="channelsLast")[u,c,l,d]=e;else if(o==="channelsFirst")[u,d,c,l]=e;else throw new Error(`Unknown dataFormat ${o}`);let[h,p,,f]=t,[m,g]=dy(n),[b,y]=dy(r),x=Tp(h,b),w=Tp(p,y),{padInfo:v,outHeight:I,outWidth:N}=LY(s,c,l,m,g,x,w,a,o),T=i?f*d:f,E;return o==="channelsFirst"?E=[u,T,I,N]:o==="channelsLast"&&(E=[u,I,N,T]),{batchSize:u,dataFormat:o,inHeight:c,inWidth:l,inChannels:d,outHeight:I,outWidth:N,outChannels:T,padInfo:v,strideHeight:m,strideWidth:g,filterHeight:h,filterWidth:p,effectiveFilterHeight:x,effectiveFilterWidth:w,dilationHeight:b,dilationWidth:y,inShape:e,outShape:E,filterShape:t}}function v6(e,t,n,r,s,a=!1,i="channelsLast",o){let[u,c,l,d,h]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[u,c,l,d,h]=e;else if(i==="channelsFirst")[u,h,c,l,d]=e;else throw new Error(`Unknown dataFormat ${i}`);let[p,f,m,,g]=t,[b,y,x]=sC(n),[w,v,I]=sC(r),N=Tp(p,w),T=Tp(f,v),E=Tp(m,I),{padInfo:A,outDepth:k,outHeight:C,outWidth:M}=PY(s,c,l,d,b,y,x,N,T,E,o),L=a?g*h:g,O;return i==="channelsFirst"?O=[u,L,k,C,M]:i==="channelsLast"&&(O=[u,k,C,M,L]),{batchSize:u,dataFormat:i,inDepth:c,inHeight:l,inWidth:d,inChannels:h,outDepth:k,outHeight:C,outWidth:M,outChannels:L,padInfo:A,strideDepth:b,strideHeight:y,strideWidth:x,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:N,effectiveFilterHeight:T,effectiveFilterWidth:E,dilationDepth:w,dilationHeight:v,dilationWidth:I,inShape:e,outShape:O,filterShape:t}}function MY(e,t,n,r,s){r==null&&(r=i3(e,t,n));let a=e[0],i=e[1],o=hy((a-t+2*r)/n+1,s),u=hy((i-t+2*r)/n+1,s);return[o,u]}function OY(e,t,n,r,s,a){s==null&&(s=i3(e,t[0],r[0]));let i=[0,0,0,n];for(let o=0;o<3;o++)e[o]+2*s>=t[o]&&(i[o]=hy((e[o]-t[o]+2*s)/r[o]+1,a));return i}function i3(e,t,n,r=1){let s=Tp(t,r);return Math.floor((e[0]*(n-1)-n+s)/2)}function dy(e){return typeof e=="number"?[e,e,e]:e.length===2?[e[0],e[1],1]:e}function sC(e){return typeof e=="number"?[e,e,e]:e}function Tp(e,t){return t<=1?e:e+(e-1)*(t-1)}function LY(e,t,n,r,s,a,i,o,u){let c,l,d;if(typeof e=="number"){c={top:e,bottom:e,left:e,right:e,type:e===0?"VALID":"NUMBER"};let h=MY([t,n],a,r,e,o);l=h[0],d=h[1]}else if(e==="same"){l=Math.ceil(t/r),d=Math.ceil(n/s);let h=Math.max(0,(l-1)*r+a-t),p=Math.max(0,(d-1)*s+i-n),f=Math.floor(h/2),m=h-f,g=Math.floor(p/2),b=p-g;c={top:f,bottom:m,left:g,right:b,type:"SAME"}}else if(e==="valid")c={top:0,bottom:0,left:0,right:0,type:"VALID"},l=Math.ceil((t-a+1)/r),d=Math.ceil((n-i+1)/s);else if(typeof e=="object"){let h=u==="channelsLast"?e[1][0]:e[2][0],p=u==="channelsLast"?e[1][1]:e[2][1],f=u==="channelsLast"?e[2][0]:e[3][0],m=u==="channelsLast"?e[2][1]:e[3][1];c={top:h,bottom:p,left:f,right:m,type:h===0&&p===0&&f===0&&m===0?"VALID":"EXPLICIT"},l=hy((t-a+h+p)/r+1,o),d=hy((n-i+f+m)/s+1,o)}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:c,outHeight:l,outWidth:d}}function PY(e,t,n,r,s,a,i,o,u,c,l){let d,h,p,f;if(e==="valid"&&(e=0),typeof e=="number"){d={top:e,bottom:e,left:e,right:e,front:e,back:e,type:e===0?"VALID":"NUMBER"};let m=OY([t,n,r,1],[o,u,c],1,[s,a,i],e,l);h=m[0],p=m[1],f=m[2]}else if(e==="same"){h=Math.ceil(t/s),p=Math.ceil(n/a),f=Math.ceil(r/i);let m=(h-1)*s+o-t,g=(p-1)*a+u-n,b=(f-1)*i+c-r,y=Math.floor(m/2),x=m-y,w=Math.floor(g/2),v=g-w,I=Math.floor(b/2),N=b-I;d={top:w,bottom:v,left:I,right:N,front:y,back:x,type:"SAME"}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:d,outDepth:h,outHeight:p,outWidth:f}}function hy(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function Zl(e){let[t,n,r]=dy(e);return t===1&&n===1&&r===1}function Mo(e,t){return Zl(e)||Zl(t)}function Gc(e){return dy(e).every(t=>t>0)}function I6(e){if(e==="NHWC")return"channelsLast";if(e==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function Ks(e,t,n){if(n!=null){if(typeof t=="string")throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if(typeof t=="number")H(Dp(t),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);else if(typeof t=="object")t.forEach(r=>{r.forEach(s=>{H(Dp(s),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${s}.`)})});else throw Error(`Error in ${e}: Unknown padding parameter: ${t}`)}}function BY(e,t){let n={x:W(e,"x","reshape","string_or_numeric")},r={shape:t};return J.runKernel(Yf,n,r)}var ae=ne({reshape_:BY});function zY(e,t,n,r,s){let a=W(e,"x","avgPool","float32"),i=1;H(Mo(n,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`);let o=a,u=!1;a.rank===3&&(u=!0,o=ae(a,[1,a.shape[0],a.shape[1],a.shape[2]])),H(o.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),Ks("avgPool",r,s);let c={x:o},l={filterSize:t,strides:n,pad:r,dimRoundingMode:s},d=J.runKernel(Nd,c,l);return d=Ve(d,a.dtype),u?ae(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var fl=ne({avgPool_:zY});function WY(e,t,n,r,s,a="NDHWC"){let i=W(e,"x","avgPool3d","float32"),o=i,u=!1;i.rank===4&&(u=!0,o=ae(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),H(o.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),H(a==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),H(typeof n=="number"&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`),Ks("avgPool3d",r,s);let c={x:o},l={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a},d=J.runKernel(yf,c,l);return d=Ve(d,o.dtype),u?ae(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var o3=ne({avgPool3d_:WY});function VY(e,t=0){H(e.length>=1,()=>"Pass at least one tensor to concat");let n=uy(e,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(a=>{if(a.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${a.dtype}. `)}),n.length===1)return xo(n[0]);let r=n,s={axis:t};return J.runKernel(If,r,s)}var Bn=ne({concat_:VY});function UY(e,t,n=!1,r=!1){let s=W(e,"a","matMul"),a=W(t,"b","matMul");[s,a]=fr(s,a);let i={a:s,b:a},o={transposeA:n,transposeB:r};return J.runKernel(Td,i,o)}var Ut=ne({matMul_:UY});function GY(e){let t={x:W(e,"x","sigmoid","float32")};return J.runKernel(Th,t)}var ci=ne({sigmoid_:GY});function HY(e,t,n){let r=W(e,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");let s={x:r},a={begin:t,size:n};return J.runKernel(sm,s,a)}var en=ne({slice_:HY});function jY(e){let t={x:W(e,"x","tanh","float32")};return J.runKernel(Mh,t)}var eu=ne({tanh_:jY});function qY(e,t,n,r,s,a){let i=W(e,"forgetBias","basicLSTMCell"),o=W(t,"lstmKernel","basicLSTMCell"),u=W(n,"lstmBias","basicLSTMCell"),c=W(r,"data","basicLSTMCell"),l=W(s,"c","basicLSTMCell"),d=W(a,"h","basicLSTMCell"),h=Bn([c,d],1),p=Ut(h,o),f=Se(p,u),m=f.shape[0],g=f.shape[1]/4,b=[m,g],y=en(f,[0,0],b),x=en(f,[0,g],b),w=en(f,[0,g*2],b),v=en(f,[0,g*3],b),I=Se(se(ci(y),eu(x)),se(l,ci(Se(i,w)))),N=se(eu(I),ci(v));return[I,N]}var k6=ne({basicLSTMCell_:qY});function KY(e,t,n){let r=W(e,"x","batchToSpaceND"),s=t.reduce((o,u)=>o*u);H(r.rank>=1+t.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`),H(n.length===t.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`),H(r.shape[0]%s===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${s}`);let a={x:r},i={blockShape:t,crops:n};return J.runKernel(xf,a,i)}var b0=ne({batchToSpaceND_:KY});function XY(e){let t;return e.rank===0||e.rank===1?t=ae(e,[1,1,1,e.size]):e.rank===2?t=ae(e,[1,1,e.shape[0],e.shape[1]]):e.rank===3?t=ae(e,[1,e.shape[0],e.shape[1],e.shape[2]]):t=e,t}function QY(e,t,n,r,s,a){a==null&&(a=.001);let i=W(e,"x","batchNorm"),o=W(t,"mean","batchNorm"),u=W(n,"variance","batchNorm"),c;s!=null&&(c=W(s,"scale","batchNorm"));let l;r!=null&&(l=W(r,"offset","batchNorm")),H(o.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),H(l==null||o.rank===l.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),H(c==null||o.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let d={x:XY(i),scale:c,offset:l,mean:o,variance:u},h={varianceEpsilon:a},p=J.runKernel(Hd,d,h);return ae(p,i.shape)}var Oh=ne({batchNorm_:QY});function YY(e,t,n,r,s,a){let i=W(e,"x","batchNorm"),o=W(t,"mean","batchNorm"),u=W(n,"variance","batchNorm"),c;s!=null&&(c=W(s,"scale","batchNorm"));let l;return r!=null&&(l=W(r,"offset","batchNorm")),H(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),H(o.rank===2||o.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),H(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`),c!=null&&H(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),l!=null&&H(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${l.rank}.`),Oh(i,o,u,l,c,a)}var l3=ne({batchNorm2d_:YY});function JY(e,t,n,r,s,a){let i=W(e,"x","batchNorm"),o=W(t,"mean","batchNorm"),u=W(n,"variance","batchNorm"),c;s!=null&&(c=W(s,"scale","batchNorm"));let l;return r!=null&&(l=W(r,"offset","batchNorm")),H(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),H(o.rank===3||o.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),H(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`),c!=null&&H(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),l!=null&&H(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${l.rank}.`),Oh(i,o,u,l,c,a)}var u3=ne({batchNorm3d_:JY});function ZY(e,t,n,r,s,a){let i=W(e,"x","batchNorm"),o=W(t,"mean","batchNorm"),u=W(n,"variance","batchNorm"),c;s!=null&&(c=W(s,"scale","batchNorm"));let l;return r!=null&&(l=W(r,"offset","batchNorm")),H(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),H(o.rank===4||o.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),H(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`),c!=null&&H(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),l!=null&&H(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${l.rank}.`),Oh(i,o,u,l,c,a)}var c3=ne({batchNorm4d_:ZY});function eJ(e,t,n){let r=W(e,"x","bincount"),s=W(t,"weights","bincount");H(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),H(n>=0,()=>`size must be non-negative, but got ${n}.`),H(s.size===r.size||s.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`);let a={x:r,weights:s},i={size:n};return J.runKernel(wf,a,i)}var d3=ne({bincount_:eJ});function tJ(e,t){let n=W(e,"x","bitwiseAnd"),r=W(t,"y","bitwiseAnd");if(!hl(n.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${r.shape}`);if(n.dtype!=="int32"||r.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${r.dtype}`);let s={a:n,b:r};return J.runKernel(vf,s)}var C6=ne({bitwiseAnd_:tJ});function nJ(e,t){let n=W(e,"s0","broadcastArgs","int32"),r=W(t,"s1","broadcastArgs","int32");if(n.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);let s={s0:n,s1:r};return J.runKernel(jy,s)}var S6=ne({broadcastArgs_:nJ});function rJ(e,t){let n=W(e,"broadcastTo","x"),r=n.shape;if(Da(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){let u=n.shape.slice();for(;u.length<t.length;)u.unshift(1);n=ae(n,u)}let s=n.shape,a=Array.from(t);for(let u=t.length-1;u>=0;u--)if(s[u]===t[u])a[u]=1;else if(n.shape[u]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);if(a.map((u,c)=>u>1?c:-1).filter(u=>u>=0).length===0)return xo(n);let i={x:n},o={reps:a};return J.runKernel(wu,i,o)}var Ec=ne({broadcastTo_:rJ});function sJ(e){let t={x:W(e,"x","ceil","float32")};return J.runKernel(Ad,t)}var h3=ne({ceil_:sJ});function Ca(e,t,n){Da(e),n=n||Uy(t);let r={shape:e,value:t,dtype:n};return J.runKernel(Qy,{},r)}function aJ(e,t,n){let r=W(e,"x","clipByValue");if(H(t<=n,()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`),t===n)return Ca(r.shape,t,r.dtype);let s={x:r},a={clipValueMin:t,clipValueMax:n};return J.runKernel(xu,s,a)}var vs=ne({clipByValue_:aJ});function iJ(e){return Bn(e,0)}var p3=ne({concat1d_:iJ});function oJ(e,t){return Bn(e,t)}var f3=ne({concat2d_:oJ});function lJ(e,t){return Bn(e,t)}var m3=ne({concat3d_:lJ});function uJ(e,t){return Bn(e,t)}var g3=ne({concat4d_:uJ});function cJ(e,t,n,r,s="NHWC",a=[1,1],i){let o=W(e,"x","conv2d","float32"),u=W(t,"filter","conv2d","float32"),c=o,l=!1;o.rank===3&&(l=!0,c=ae(o,[1,o.shape[0],o.shape[1],o.shape[2]])),H(c.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),H(u.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),Ks("conv2d",r,i);let d=s==="NHWC"?c.shape[3]:c.shape[1];H(d===u.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${u.shape[2]}.`),H(Mo(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),H(Gc(a),()=>"Error in conv2D: Dilated rates should be larger than 0."),H(Gc(n),()=>"Error in conv2D: Strides should be larger than 0.");let h={x:c,filter:u},p={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i},f=J.runKernel($d,h,p);return l?ae(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var Vs=ne({conv2d_:cJ});function dJ(e,t,n,r,s="NWC",a=1,i){let o=W(e,"x","conv1d"),u=W(t,"filter","conv1d"),c=o,l=!1;o.rank===2&&(l=!0,c=ae(o,[1,o.shape[0],o.shape[1]])),H(c.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),H(u.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),Ks("conv1d",r,i),H(c.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${u.shape[1]}.`),H(Mo(n,a),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${a}'`),H(Gc(a),()=>"Error in conv1D: Dilated rates should be larger than 0."),H(Gc(n),()=>"Error in conv1D: Stride should be larger than 0."),H(s==="NWC",()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);let d=ae(u,[1,u.shape[0],u.shape[1],u.shape[2]]),h=ae(c,[c.shape[0],1,c.shape[1],c.shape[2]]),p=Vs(h,d,[1,n],r,"NHWC",[1,a],i);return l?ae(p,[p.shape[2],p.shape[3]]):ae(p,[p.shape[0],p.shape[2],p.shape[3]])}var $w=ne({conv1d_:dJ});function hJ(e,t,n,r,s,a="NHWC",i){H(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let o=e,u=t,c=!1;t.rank===3&&(c=!0,u=ae(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),H(o.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),H(u.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),H(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);let l=a==="NHWC"?o[3]:o[1],d=a==="NHWC"?u.shape[3]:u.shape[1];H(l===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[2]}.`),H(d===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${n.shape[3]}.`),Ks("conv2dDerInput",s,i);let h={dy:u,filter:n},p={strides:r,pad:s,dataFormat:a,dimRoundingMode:i,inputShape:o},f=J.runKernel(Rd,h,p);return c?ae(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var b3=ne({conv2DBackpropInput_:hJ});function pJ(e,t,n,r,s,a){let i=W(e,"x","conv2dTranspose"),o=W(t,"filter","conv2dTranspose");return b3(n,i,o,r,s,"NHWC",a)}var Rw=ne({conv2dTranspose_:pJ});function fJ(e,t,n,r,s="NDHWC",a=[1,1,1]){let i=W(e,"x","conv3d"),o=W(t,"filter","conv3d"),u=i,c=!1;i.rank===4&&(c=!0,u=ae(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),H(u.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),H(o.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),H(u.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${o.shape[3]}.`),H(Mo(n,a),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),H(s==="NDHWC",()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`),H(Gc(a),()=>"Error in conv3D: Dilated rates should be larger than 0."),H(Gc(n),()=>"Error in conv3D: Strides should be larger than 0.");let l={x:u,filter:o},d={strides:n,pad:r,dataFormat:s,dilations:a},h=J.runKernel(_d,l,d);return c?ae(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}var y3=ne({conv3d_:fJ});function mJ(e,t,n,r,s){H(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let a=e,i=t,o=!1;t.rank===4&&(o=!0,i=ae(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),a=[1,e[0],e[1],e[2],e[3]]);let u=a[4],c=i.shape[4];H(a.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`),H(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),H(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),H(u===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${n.shape[3]}.`),H(c===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${n.shape[4]}.`);let l={dy:i,filter:n},d={pad:s,strides:r,inputShape:a},h=J.runKernel(Cf,l,d);return o?ae(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}var N6=ne({conv3DBackpropInput_:mJ});function gJ(e,t,n,r,s){let a=W(e,"x","conv3dTranspose"),i=W(t,"filter","conv3dTranspose");return N6(n,a,i,r,s)}var x3=ne({conv3dTranspose_:gJ});function bJ(e){let t={x:W(e,"x","cos","float32")};return J.runKernel(Dd,t)}var y0=ne({cos_:bJ});function yJ(e){let t={x:W(e,"x","cosh","float32")};return J.runKernel(Fd,t)}var _w=ne({cosh_:yJ});function xJ(e,t=0,n=!1,r=!1){let s={x:W(e,"x","cumprod")},a={axis:t,exclusive:n,reverse:r};return J.runKernel(Sf,s,a)}var py=ne({cumprod_:xJ});function wJ(e,t=0,n=!1,r=!1){let s={x:W(e,"x","cumsum")},a={axis:t,exclusive:n,reverse:r};return J.runKernel(Md,s,a)}var Dw=ne({cumsum_:wJ});function vJ(e,t,n,r=!1){let s=W(e,"x","denseBincount"),a=W(t,"weights","denseBincount");H(s.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),H(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),H(n>=0,()=>`size must be non-negative, but got ${n}.`),H(a.size===s.size||a.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${a.shape}.`);let i={x:s,weights:a},o={size:n,binaryOutput:r};return J.runKernel(Ky,i,o)}var cx=ne({denseBincount_:vJ});function IJ(e,t,n="NHWC"){let r=W(e,"x","depthToSpace","float32"),s=n==="NHWC"?r.shape[1]:r.shape[2],a=n==="NHWC"?r.shape[2]:r.shape[3],i=n==="NHWC"?r.shape[3]:r.shape[1];H(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),H(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${t}  for depthToSpace with input shape
    ${r.shape}`),H(a*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${a} and ${t} for depthToSpace with input shape
        ${r.shape}`),H(i%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${r.shape}`);let o={x:r},u={blockSize:t,dataFormat:n};return J.runKernel(Tf,o,u)}var w3=ne({depthToSpace_:IJ});function kJ(e,t,n,r,s="NHWC",a=[1,1],i){let o=W(e,"x","depthwiseConv2d","float32"),u=W(t,"filter","depthwiseConv2d","float32"),c=o,l=!1;o.rank===3&&(l=!0,c=ae(o,[1,o.shape[0],o.shape[1],o.shape[2]])),H(c.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),H(u.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`);let d=s==="NHWC"?c.shape[3]:c.shape[1];H(d===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${u.shape[2]}.`),Ks("depthwiseConv2d",r,i);let h={x:c,filter:u},p={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i},f=J.runKernel(Od,h,p);return l?ae(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var Lh=ne({depthwiseConv2d_:kJ});function CJ(e){let t={x:W(e,"x","diag")};return J.runKernel(Xy,t)}var T6=ne({diag_:CJ});function SJ(e,t,n,r,s=[1,1],a="NHWC"){let i=W(e,"x","dilation2d"),o=W(t,"filter","dilation2d");H(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),H(o.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),H(a==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`);let u=i,c=!1;i.rank===3&&(u=ae(i,[1,i.shape[0],i.shape[1],i.shape[2]]),c=!0),H(u.shape[3]===o.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${u.shape[3]} vs ${o.shape[2]}`);let l={x:u,filter:o},d={strides:n,pad:r,dilations:s},h=J.runKernel(Ld,l,d);return c?ae(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var v3=ne({dilation2d_:SJ}),mm={};Pt(mm,{assertAndGetBroadcastShape:()=>zn,getBroadcastDims:()=>E6,getReductionAxes:()=>Fr});function E6(e,t){let n=e.length,r=[];for(let s=0;s<n;s++){let a=n-1-s,i=e[a]||1;(t[t.length-1-s]||1)>1&&i===1&&r.unshift(a)}return r}function Fr(e,t){let n=[];for(let r=0;r<t.length;r++){let s=e[e.length-r-1],a=t.length-r-1,i=t[a];(s==null||s===1&&i>1)&&n.unshift(a)}return n}function zn(e,t){let n=Math.max(e.length,t.length),r=new Array(n);for(let s=0;s<n;s++){let a=e[e.length-s-1];a==null&&(a=1);let i=t[t.length-s-1];if(i==null&&(i=1),a===1)r[n-s-1]=i;else if(i===1)r[n-s-1]=a;else if(a!==i){let o=`Operands could not be broadcast together with shapes ${e} and ${t}.`;throw Error(o)}else r[n-s-1]=a}return r}function NJ(e,t){let n=W(e,"a","equal","string_or_numeric"),r=W(t,"b","equal","string_or_numeric");[n,r]=fr(n,r),zn(n.shape,r.shape);let s={a:n,b:r};return J.runKernel(Af,s)}var Na=ne({equal_:NJ});function TJ(e,t,n){let r=W(t,"a","where"),s=W(n,"b","where"),a=W(e,"condition","where","bool"),i=zn(zn(a.shape,r.shape),s.shape),o=Ec(a,i),u=Ec(r,i),c=Ec(s,i),l={condition:o,t:u,e:c};return J.runKernel(rm,l)}var os=ne({where_:TJ});function EJ(e){let t={x:W(e,"x","zerosLike")};return J.runKernel(pm,t)}var sn=ne({zerosLike_:EJ});function AJ(e,t){let n=W(e,"a","div"),r=W(t,"b","div");[n,r]=fr(n,r);let s=it(n,r),a=sn(s),i=Na(r,a);return os(i,a,s)}var I3=ne({divNoNan_:AJ});function $J(e,t){let n=W(e,"t1","dot"),r=W(t,"t2","dot");H((n.rank===1||n.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`);let s=n.rank===1?n.size:n.shape[1],a=r.rank===1?r.size:r.shape[0];if(H(s===a,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${a}.`),n.rank===1&&r.rank===1){let i=ae(n,[1,-1]),o=ae(r,[-1,1]),u=Ut(i,o);return ae(u,[])}else if(n.rank===1&&r.rank===2){let i=ae(n,[1,-1]),o=ae(r,[r.shape[0],r.shape[1]]),u=Ut(i,o);return ae(u,[u.size])}else if(n.rank===2&&r.rank===1){let i=ae(r,[-1,1]),o=Ut(n,i);return ae(o,[o.size])}else{let i=ae(r,[r.shape[0],r.shape[1]]);return Ut(n,i)}}var k3=ne({dot_:$J});function RJ(e,...t){let n=t.map((s,a)=>W(s,`tensors${a}`,"einsum")),r={equation:e};return J.runKernel(bw,n,r)}var bc=ne({einsum_:RJ});function _J(e){let t={x:W(e,"x","elu","float32")};return J.runKernel(Bd,t)}var gm=ne({elu_:_J});function DJ(e,t){let n=W(e,"x","ensureShape","string_or_numeric");if(!_F(n.shape,t))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${t}`);return e}var A6=ne({ensureShape_:DJ});function FJ(e){let t=W(e,"x","erf");H(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=Ve(t,"float32"));let n={x:t};return J.runKernel(zd,n)}var Fw=ne({erf_:FJ});function C3(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function $6(e,t,n){let r=e.length+t.length,s=[],a=0,i=0;for(let o=0;o<r;o++)n.indexOf(o)===-1?s.push(e[a++]):s.push(t[i++]);return s}function R6(e,t){let n=[],r=e.length;for(let a=0;a<r;a++)t.indexOf(a)===-1&&n.push(e[a]);let s=t.map(a=>e[a]);return[n,s]}function Hc(e,t){let n=t.map(r=>1);return $6(e,n,t)}function MJ(e,t,n){H(C3(t,n),()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`)}function _6(e,t){if(C3(e,t))return null;let n=[];for(let r=0;r<t;++r)e.indexOf(r)===-1&&n.push(r);return e.forEach(r=>n.push(r)),n}function S3(e){return e.map((t,n)=>[n,t]).sort((t,n)=>t[1]-n[1]).map(t=>t[0])}function OJ(e,t){let n=[];for(let r=t-e;r<t;++r)n.push(r);return n}function LJ(e,t=null,n=!1){let r={x:W(e,"x","max")},s={reductionIndices:t,keepDims:n};return J.runKernel(th,r,s)}var Va=ne({max_:LJ});function PJ(e,t=null,n=!1){let r={x:W(e,"x","min")},s={axis:t,keepDims:n};return J.runKernel(ah,r,s)}var Lp=ne({min_:PJ});function BJ(e,t){let n=W(e,"base","pow"),r=W(t,"exp","pow");[n,r]=fr(n,r);let s={a:n,b:r};return J.runKernel(hh,s)}var To=ne({pow_:BJ});function vt(e,t){if((ts(e)&&t!=="string"||Array.isArray(e))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&ts(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Iu(e,[],[],t)}function zJ(e){let t={x:W(e,"x","sqrt","float32")};return J.runKernel(Ah,t)}var ls=ne({sqrt_:zJ});function WJ(e){let t=W(e,"x","square"),n={};return J.runKernel("Square",{x:t},n)}var Pn=ne({square_:WJ});function VJ(e,t=null,n=!1){let r=W(e,"x","sum");r.dtype==="bool"&&(r=Ve(r,"int32"));let s={x:r},a={axis:t,keepDims:n};return J.runKernel($h,s,a)}var dt=ne({sum_:VJ});function UJ(e,t="euclidean",n=null,r=!1){e=W(e,"x","norm");let s=D6(e,t,n),a=s.shape;if(r){let i=mi(n,e.shape);a=Hc(s.shape,i)}return ae(s,a)}function D6(e,t,n=null){if(e.rank===0)return Ar(e);if(e.rank!==1&&n===null)return D6(ae(e,[-1]),t,n);if(e.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(t===1)return dt(Ar(e),n);if(t===1/0)return Va(Ar(e),n);if(t===-1/0)return Lp(Ar(e),n);if(t==="euclidean"||t===2)return ls(dt(To(Ar(e),vt(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&n.length===2){if(t===1)return Va(dt(Ar(e),n[0]),n[1]-1);if(t===1/0)return Va(dt(Ar(e),n[1]),n[0]);if(t===-1/0)return Lp(dt(Ar(e),n[1]),n[0]);if(t==="fro"||t==="euclidean")return ls(dt(Pn(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}var bm=ne({norm_:UJ});function GJ(e,t=null,n=!1){return bm(e,"euclidean",t,n)}var N3=ne({euclideanNorm_:GJ});function HJ(e){let t={x:W(e,"x","exp")};return J.runKernel(Wd,t)}var Is=ne({exp_:HJ});function jJ(e,t=0){let n=W(e,"x","expandDims","string_or_numeric");H(t<=n.rank,()=>"Axis must be <= rank of the tensor");let r={input:n},s={dim:t};return J.runKernel($f,r,s)}var ns=ne({expandDims_:jJ});function qJ(e){let t={x:W(e,"x","expm1")};return J.runKernel(Vd,t)}var T3=ne({expm1_:qJ});function KJ(e,t){let n=W(e,"x","tile","string_or_numeric");H(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`);let r={x:n},s={reps:t};return J.runKernel(wu,r,s)}var Ia=ne({tile_:KJ});function XJ(e,t,n,r="float32"){t==null&&(t=e);let s=Ht([e,t],r),a=e<=t?e:t;for(let o=0;o<a;++o)s.set(1,o,o);let i=ae(s.toTensor(),[e,t]);if(n==null)return i;if(n.length===1)return Ia(ns(i,0),[n[0],1,1]);if(n.length===2)return Ia(ns(ns(i,0),0),[n[0],n[1],1,1]);if(n.length===3)return Ia(ns(ns(ns(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}var Mw=ne({eye_:XJ});function QJ(e){let t={x:W(e,"x","floor","float32")};return J.runKernel(Ud,t)}var ym=ne({floor_:QJ});function YJ(e,t,n=0,r=0){let s=W(e,"x","gather"),a=W(t,"indices","gather","int32"),i={x:s,indices:a},o={axis:n,batchDims:r};return J.runKernel(_f,i,o)}var xm=ne({gather_:YJ});function JJ(e,t){let n=W(e,"a","greater","string_or_numeric"),r=W(t,"b","greater","string_or_numeric");[n,r]=fr(n,r),zn(n.shape,r.shape);let s={a:n,b:r};return J.runKernel(Ff,s)}var Xs=ne({greater_:JJ});function ZJ(e,t){let n=W(e,"a","greaterEqual","string_or_numeric"),r=W(t,"b","greaterEqual","string_or_numeric");[n,r]=fr(n,r),zn(n.shape,r.shape);let s={a:n,b:r};return J.runKernel(jd,s)}var ml=ne({greaterEqual_:ZJ});function eZ(e){let t={input:W(e,"input","imag")};return J.runKernel(ww,t)}var x0=ne({imag_:eZ});function tZ(e){let t={x:W(e,"x","isFinite")};return J.runKernel(Kd,t)}var E3=ne({isFinite_:tZ});function nZ(e){let t={x:W(e,"x","isInf")};return J.runKernel(Xd,t)}var A3=ne({isInf_:nZ});function rZ(e){let t={x:W(e,"x","isNaN")};return J.runKernel(Qd,t)}var $3=ne({isNaN_:rZ});function sZ(e,t=.2){let n={x:W(e,"x","leakyRelu")},r={alpha:t};return J.runKernel(Yd,n,r)}var w0=ne({leakyRelu_:sZ});function aZ(e,t){let n=W(e,"a","less","string_or_numeric"),r=W(t,"b","less","string_or_numeric");[n,r]=fr(n,r),zn(n.shape,r.shape);let s={a:n,b:r};return J.runKernel(Mf,s)}var Pp=ne({less_:aZ});function iZ(e,t){let n=W(e,"a","lessEqual","string_or_numeric"),r=W(t,"b","lessEqual","string_or_numeric");[n,r]=fr(n,r),zn(n.shape,r.shape);let s={a:n,b:r};return J.runKernel(Of,s)}var ku=ne({lessEqual_:iZ});function F6(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");let r={start:e,stop:t,num:n};return J.runKernel(Lf,{},r)}function oZ(e,t=5,n=1,r=1,s=.5){let a=W(e,"x","localResponseNormalization");H(a.rank===4||a.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${a.rank}.`),H(Dp(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let i=a,o=!1;a.rank===3&&(o=!0,i=ae(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let u={x:i},c={depthRadius:t,bias:n,alpha:r,beta:s},l=J.runKernel(eh,u,c);return o?ae(l,[l.shape[1],l.shape[2],l.shape[3]]):l}var R3=ne({localResponseNormalization_:oZ});function lZ(e){let t={x:W(e,"x","log","float32")};return J.runKernel(Jd,t)}var Ta=ne({log_:lZ});function uZ(e){let t={x:W(e,"x","log1p")};return J.runKernel(Zd,t)}var v0=ne({log1p_:uZ});function cZ(e){return H(Xl(e),()=>"The f passed in grad(f) must be a function"),(t,n)=>{let r=W(t,"x","tf.grad","string_or_numeric"),s=n!=null?W(n,"dy","tf.grad"):null;return J.tidy(()=>{let{value:a,grads:i}=J.gradients(()=>e(r),[r],s);return s!=null&&qs(a.shape,s.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),Ow(i),i[0]})}}function dZ(e){return H(Xl(e),()=>"The f passed in grads(f) must be a function"),(t,n)=>{H(Array.isArray(t),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");let r=uy(t,"args","tf.grads","string_or_numeric"),s=n!=null?W(n,"dy","tf.grads"):null;return J.tidy(()=>{let{value:a,grads:i}=J.gradients(()=>e(...r),r,s);return s!=null&&qs(a.shape,s.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Ow(i),i})}}function hZ(e){return H(Xl(e),()=>"The f passed in valueAndGrad(f) must be a function"),(t,n)=>{H(t instanceof Wt,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),H(n==null||n instanceof Wt,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");let{grads:r,value:s}=J.gradients(()=>e(t),[t],n);return Ow(r),{grad:r[0],value:s}}}function pZ(e){return H(Xl(e),()=>"The f passed in valueAndGrads(f) must be a function"),(t,n)=>{H(Array.isArray(t)&&t.every(s=>s instanceof Wt),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),H(n==null||n instanceof Wt,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");let r=J.gradients(()=>e(...t),t,n);return n!=null&&qs(r.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Ow(r.grads),r}}function M6(e,t){H(Xl(e),()=>"The f passed in variableGrads(f) must be a function"),H(t==null||Array.isArray(t)&&t.every(c=>c instanceof Bc),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let n=t!=null;if(!n){t=[];for(let c in J.registeredVariables)t.push(J.registeredVariables[c])}let r=n?t.filter(c=>!c.trainable):null,s=t.length;t=t.filter(c=>c.trainable),H(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);let a=!0,{value:i,grads:o}=J.gradients(e,t,null,a);H(o.some(c=>c!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),H(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);let u={};return t.forEach((c,l)=>{o[l]!=null&&(u[c.name]=o[l])}),r?.forEach(c=>u[c.name]=null),{value:i,grads:u}}function Eo(e){return J.customGrad(e)}function Ow(e){if(e.filter(t=>t==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function fZ(e){let t={x:W(e,"x","neg")};return J.runKernel(Gf,t)}var Jn=ne({neg_:fZ});function mZ(e){let t={x:W(e,"x","softplus")};return J.runKernel(Eh,t)}var Ph=ne({softplus_:mZ});function gZ(e){let t=W(e,"x","logSigmoid");return Eo(n=>({value:Jn(Ph(Jn(n))),gradFunc:r=>se(r,ci(Jn(n)))}))(t)}var _3=ne({logSigmoid_:gZ});function bZ(e,t){let n=W(e,"a","sub"),r=W(t,"b","sub");[n,r]=fr(n,r);let s={a:n,b:r};return J.runKernel(Dh,s)}var et=ne({sub_:bZ});function yZ(e,t=-1){let n=W(e,"logits","logSoftmax");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return Eo((r,s)=>{let a=Va(r,t,!0),i=et(r,a),o=et(Ve(i,"float32"),Ta(dt(Is(i),t,!0)));return s([o]),{value:o,gradFunc:(u,c)=>{let[l]=c,d=!0,h=Is(l);return et(u,se(dt(u,t,d),h))}}})(n)}var Lw=ne({logSoftmax_:yZ});function xZ(e,t=null,n=!1){let r=W(e,"x","logSumExp"),s=mi(t,r.shape),a=Va(r,s,!0),i=et(r,a),o=Is(i),u=dt(o,s),c=Ta(u),l=Se(ae(a,c.shape),c);if(n){let d=Hc(l.shape,s);return ae(l,d)}return l}var I0=ne({logSumExp_:xZ});function wZ(e,t){let n=W(e,"a","logicalAnd","bool"),r=W(t,"b","logicalAnd","bool");zn(n.shape,r.shape);let s={a:n,b:r};return J.runKernel(Pf,s)}var di=ne({logicalAnd_:wZ});function vZ(e){let t={x:W(e,"x","logicalNot","bool")};return J.runKernel(Bf,t)}var k0=ne({logicalNot_:vZ});function IZ(e,t){let n=W(e,"a","logicalOr","bool"),r=W(t,"b","logicalOr","bool");zn(n.shape,r.shape);let s={a:n,b:r};return J.runKernel(zf,s)}var Pw=ne({logicalOr_:IZ});function kZ(e,t){let n=W(e,"a","logicalXor","bool"),r=W(t,"b","logicalXor","bool");return zn(n.shape,r.shape),di(Pw(e,t),k0(di(e,t)))}var D3=ne({logicalXor_:kZ}),d2=2147483648;function CZ(e,t,n="left"){let r=W(e,"sortedSequence","searchSorted"),s=W(t,"values","searchSorted"),a=r.shape[r.shape.length-1],i=s.shape[s.shape.length-1],o=ae(r,[-1,a]),u=ae(s,[-1,i]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==u.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(_n(u.shape)>=d2)throw new Error(`values tensor size must less than ${d2}`);if(o.shape[1]>=d2)throw new Error(`trailing dim_size must less than ${d2} for int32 output type, was ${o.shape[1]}`);let c={sortedSequence:o,values:u},l={side:n};return J.runKernel(nm,c,l)}var Bw=ne({searchSorted_:CZ});function O6(e,t){return Bw(e,t,"left")}function SZ(e,t,n,r,s){let a=W(e,"x","maxPool"),i=1,o=a,u=!1;a.rank===3&&(u=!0,o=ae(a,[1,a.shape[0],a.shape[1],a.shape[2]])),H(o.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),H(Mo(n,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),Ks("maxPool",r,s);let c={x:o},l={filterSize:t,strides:n,pad:r,dimRoundingMode:s},d=J.runKernel(rh,c,l);return u?ae(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var Zr=ne({maxPool_:SZ});function NZ(e,t=[1,1,1],n,r,s,a="NDHWC"){let i=W(e,"x","maxPool3d"),o=i,u=!1;i.rank===4&&(u=!0,o=ae(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),H(o.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),H(a==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),Ks("maxPool3d",r,s);let c={x:o},l={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a},d=J.runKernel(Vf,c,l);return u?ae(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var F3=ne({maxPool3d_:NZ});function TZ(e,t,n,r,s=!1){let a={x:W(e,"x","maxPoolWithArgmax")},i={filterSize:t,strides:n,pad:r,includeBatchInIndex:s},o=J.runKernel(Zy,a,i);return{result:o[0],indexes:o[1]}}var L6=ne({maxPoolWithArgmax_:TZ});function EZ(e,t){let n=W(e,"a","maximum"),r=W(t,"b","maximum");[n,r]=fr(n,r),n.dtype==="bool"&&(n=Ve(n,"int32"),r=Ve(r,"int32")),zn(n.shape,r.shape);let s={a:n,b:r};return J.runKernel(nh,s)}var Oo=ne({maximum_:EZ});function AZ(e,t=null,n=!1){let r={x:W(e,"x","mean")},s={axis:t,keepDims:n};return J.runKernel(sh,r,s)}var cr=ne({mean_:AZ});function dr(e,t="float32"){if(Da(e),t==="complex64"){let r=dr(e,"float32"),s=dr(e,"float32");return il(r,s)}let n=cw(_n(e),t);return J.makeTensor(n,e,t)}function ra(e,t="float32"){if(Da(e),t==="complex64"){let r=ra(e,"float32"),s=dr(e,"float32");return il(r,s)}let n=WS(_n(e),t);return J.makeTensor(n,e,t)}function P6(e,t,{indexing:n="xy"}={}){if(n!=="xy"&&n!=="ij")throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(e===void 0)return[];let r=W(e,"x","meshgrid",e instanceof Wt?e.dtype:"float32");if(t===void 0)return[r];let s=W(t,"y","meshgrid",t instanceof Wt?t.dtype:"float32"),a=_n(r.shape),i=_n(s.shape);return n==="xy"?(r=ae(r,[1,-1]),s=ae(s,[-1,1]),[Ut(ra([i,1],r.dtype),r),Ut(s,ra([1,a],s.dtype))]):(r=ae(r,[-1,1]),s=ae(s,[1,-1]),[Ut(r,ra([1,i],r.dtype)),Ut(ra([a,1],s.dtype),s)])}function $Z(e,t){let n=W(e,"a","minimum"),r=W(t,"b","minimum");[n,r]=fr(n,r),n.dtype==="bool"&&(n=Ve(n,"int32"),r=Ve(r,"int32")),zn(n.shape,r.shape);let s={a:n,b:r};return J.runKernel(ih,s)}var tu=ne({minimum_:$Z});function RZ(e,t,n){H(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);let r=W(e,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");H(t.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`);let s=n==="reflect"?1:0;for(let o=0;o<r.rank;o++)H(t[o].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),H(t[o][0]>=0&&t[o][0]<=r.shape[o]-s&&t[o][1]>=0&&t[o][1]<=r.shape[o]-s,()=>`Padding in dimension ${o} cannot be greater than or equal to ${r.shape[o]-s} or less than 0 for input of shape ${r.shape}`);let a={paddings:t,mode:n},i={x:r};return J.runKernel(oh,i,a)}var M3=ne({mirrorPad_:RZ});function _Z(e,t){let n=W(e,"a","mod"),r=W(t,"b","mod");[n,r]=fr(n,r);let s={a:n,b:r};return J.runKernel(lh,s)}var O3=ne({mod_:_Z});function DZ(e,t=null,n=!1){e=W(e,"x","moments");let r=mi(t,e.shape),s=cr(e,r,n),a=s.shape;n||(a=Hc(s.shape,r));let i=Pn(et(Ve(e,"float32"),ae(s,a))),o=cr(i,r,n);return{mean:s,variance:o}}var C0=ne({moments_:DZ});function FZ(e,t,n,r){let s=W(t,"data","multiRNNCell"),a=uy(n,"c","multiRNNCell"),i=uy(r,"h","multiRNNCell"),o=s,u=[];for(let d=0;d<e.length;d++){let h=e[d](o,a[d],i[d]);u.push(h[0]),u.push(h[1]),o=h[1]}let c=[],l=[];for(let d=0;d<u.length;d+=2)c.push(u[d]),l.push(u[d+1]);return[c,l]}var B6=ne({multiRNNCell_:FZ});function MZ(e,t,n,r=!1){let s=W(e,"logits","multinomial"),a=s.size,i=s.rank;if(a<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${a}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();let o={logits:i===1?ae(s,[1,-1]):s},u={numSamples:t,seed:n,normalized:r},c=J.runKernel(Uf,o,u);return i===1?ae(c,[c.size]):c}var z6=ne({multinomial_:MZ});function OZ(e,t){let n=W(e,"a","notEqual","string_or_numeric"),r=W(t,"b","notEqual","string_or_numeric");[n,r]=fr(n,r),zn(n.shape,r.shape);let s={a:n,b:r};return J.runKernel(Hf,s)}var jc=ne({notEqual_:OZ});function LZ(e,t,n=1,r=0,s="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let a={indices:W(e,"indices","oneHot","int32")},i={dtype:s,depth:t,onValue:n,offValue:r};return J.runKernel(ch,a,i)}var Bp=ne({oneHot_:LZ});function PZ(e){let t={x:W(e,"x","onesLike")};return J.runKernel(Xf,t)}var Ea=ne({onesLike_:PZ});function BZ(e,t){let n=W(e,"v1","outerProduct"),r=W(t,"v2","outerProduct");H(n.rank===1&&r.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`);let s=ae(n,[-1,1]),a=ae(r,[1,-1]);return Ut(s,a)}var W6=ne({outerProduct_:BZ});function zZ(e,t,n=0){let r=W(e,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let s={paddings:t,constantValue:n},a={x:r};return J.runKernel(dh,a,s)}var Ji=ne({pad_:zZ});function WZ(e,t,n=0){return H(t.length===2,()=>"Invalid number of paddings. Must be length of 2."),Ji(e,[t],n)}var V6=ne({pad1d_:WZ});function VZ(e,t,n=0){return H(t.length===2&&t[0].length===2&&t[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Ji(e,t,n)}var U6=ne({pad2d_:VZ});function UZ(e,t,n=0){return H(t.length===3&&t[0].length===2&&t[1].length===2&&t[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Ji(e,t,n)}var G6=ne({pad3d_:UZ});function GZ(e,t,n=0){return H(t.length===4&&t[0].length===2&&t[1].length===2&&t[2].length===2&&t[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Ji(e,t,n)}var H6=ne({pad4d_:GZ});function HZ(e,t,n){let r=W(e,"x","spaceToBatchND");H(r.rank>=1+t.length,()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`),H(n.length===t.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`),H(r.shape.reduce((i,o,u)=>u>0&&u<=t.length?i&&(o+n[u-1][0]+n[u-1][1])%t[u-1]===0:i,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`);let s={x:r},a={blockShape:t,paddings:n};return J.runKernel(am,s,a)}var S0=ne({spaceToBatchND_:HZ});function jZ(e,t,n,r,s,a,i){s==null&&(s=[1,1]),a==null&&(a=1),r===0&&(r="valid");let o=W(e,"x","maxPool"),u=o,c=!1;o.rank===3&&(c=!0,u=ae(o,[1,o.shape[0],o.shape[1],o.shape[2]])),H(Mo(a,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${s}'`);let l=w6(u.shape,t,a,s,r),d=[l.dilationHeight,l.dilationWidth],h;r==="same"?h=KZ([l.filterHeight,l.filterWidth],d):h=[[0,0],[0,0]];let p=d[0]===1&&d[1]===1,[f,m]=qZ([l.inHeight,l.inWidth],d,h),g=p?r:"valid",b=p?u:S0(u,d,f),y=(n==="avg"?()=>fl(b,t,a,g,i):()=>Zr(b,t,a,g,i))(),x=p?y:b0(y,d,m);return c?ae(x,[x.shape[1],x.shape[2],x.shape[3]]):x}function qZ(e,t,n){let r=n.map(l=>l[0]),s=n.map(l=>l[1]),a=e.concat(r,s),i=t.map((l,d)=>(l-a[d]%l)%l),o=s.map((l,d)=>l+i[d]),u=t.map((l,d)=>[r[d],o[d]]),c=t.map((l,d)=>[0,i[d]]);return[u,c]}function KZ(e,t){let n=e.map((a,i)=>a+(a-1)*(t[i]-1)).map(a=>a-1),r=n.map(a=>Math.floor(a/2)),s=n.map((a,i)=>a-r[i]);return n.map((a,i)=>[r[i],s[i]])}var L3=ne({pool_:jZ});function XZ(e,t){let n=W(e,"x","prelu"),r=W(t,"alpha","prelu"),s={x:n,alpha:r};return J.runKernel(ph,s)}var N0=ne({prelu_:XZ});function QZ(e,t=null,n=!1){let r=W(e,"x","prod");r.dtype==="bool"&&(r=Ve(r,"int32"));let s={x:r},a={axis:t,keepDims:n};return J.runKernel(fh,s,a)}var P3=ne({prod_:QZ});function YZ(e,t,n,r){let s=e.map((l,d)=>W(l,`tensors${d}`,"raggedGather","int32")),a=W(t,"paramsDenseValues","raggedGather"),i=W(n,"indices","raggedGather","int32"),o={paramsNestedSplits:s,paramsDenseValues:a,indices:i},u={outputRaggedRank:r},c=J.runKernel(vw,o,u);return{outputNestedSplits:c.slice(0,c.length-1),outputDenseValues:c[c.length-1]}}var j6=ne({raggedGather_:YZ});function JZ(e,t,n){let r=W(e,"starts","raggedRange"),s=W(t,"limits","raggedRange",r.dtype),a=W(n,"deltas","raggedRange",r.dtype),i={starts:r,limits:s,deltas:a},o=J.runKernel(Iw,i);return{rtNestedSplits:o[0],rtDenseValues:o[1]}}var q6=ne({raggedRange_:JZ});function ZZ(e,t,n,r,s){let a=W(e,"shape","raggedTensorToTensor","int32"),i=W(t,"values","raggedTensorToTensor"),o=W(n,"defaultValue","raggedTensorToTensor",i.dtype),u=r.map((d,h)=>W(d,`tensors${h}`,"raggedTensorToTensor","int32")),c={shape:a,values:i,defaultValue:o,rowPartitionTensors:u},l={rowPartitionTypes:s};return J.runKernel(kw,c,l)}var K6=ne({raggedTensorToTensor_:ZZ});function e7(e,t,n){Da(e);let r=_n(e),s=null;if(n==null||n==="float32")s=new Float32Array(r);else if(n==="int32")s=new Int32Array(r);else if(n==="bool")s=new Uint8Array(r);else throw new Error(`Unknown data type ${n}`);for(let a=0;a<r;a++)s[a]=t();return J.makeTensor(s,e,n)}var X6=ne({rand_:e7}),B3=bu(lw()),Q6={};Pt(Q6,{TEST_EPSILON_FLOAT16:()=>Y6,createVideoElement:()=>l7,encodeStrings:()=>J6,expectArrayBuffersEqual:()=>o7,expectArraysClose:()=>n7,expectArraysEqual:()=>s7,expectNumbersClose:()=>a7,expectPromiseToFail:()=>r7,expectValuesInRange:()=>i7,play:()=>u7,testEpsilon:()=>z3});var t7=.001,Y6=.1;function n7(e,t,n){return n==null&&(n=z3()),aC(e,t,(r,s)=>W3(r,s,n))}function z3(){return J.backend.floatPrecision()===32?t7:Y6}function aC(e,t,n){let r=!0;if((ts(e)||ts(t))&&(r=!1),ts(e)&&ts(t)&&(r=!0),r){let i=e.constructor.name,o=t.constructor.name;if(i!==o)throw new Error(`Arrays are of different type. Actual: ${i}. Expected: ${o}`)}if(Array.isArray(e)&&Array.isArray(t)){let i=No(e),o=No(t);if(!hl(i,o))throw new Error(`Arrays have different shapes. Actual: [${i}]. Expected: [${o}]`)}let s=ts(e)?e:Ql(e),a=ts(t)?t:Ql(t);if(s.length!==a.length)throw new Error(`Arrays have different lengths actual: ${s.length} vs expected: ${a.length}.
Actual:   ${s}.
Expected: ${a}.`);for(let i=0;i<a.length;++i){let o=s[i],u=a[i];if(!n(o,u))throw new Error(`Arrays differ: actual[${i}] = ${o}, expected[${i}] = ${u}.
Actual:   ${s}.
Expected: ${a}.`)}typeof expect<"u"&&expect().nothing()}function r7(e,t){e().then(()=>t.fail(),()=>t()),typeof expect<"u"&&expect().nothing()}function s7(e,t){let n=typeof t=="string"||typeof t=="number"||typeof t=="boolean"?[t]:t;return Fl(e)||Fl(e[0])||Fl(t)||Fl(t[0])?aC(e,n,(r,s)=>r==s):aC(e,t,(r,s)=>W3(r,s,0))}function a7(e,t,n){if(n==null&&(n=z3()),!W3(e,t,n))throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`);typeof expect<"u"&&expect().nothing()}function W3(e,t,n){return!isFinite(e)&&!isFinite(t)?!0:!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function i7(e,t,n){for(let r=0;r<e.length;r++)if(e[r]<t||e[r]>n)throw new Error(`Value out of range:${e[r]} low: ${t}, high: ${n}`)}function o7(e,t){let n=new Float32Array(e),r=new Float32Array(t);if(n.length!==r.length)throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${n.length}`);for(let s=0;s<r.length;s++)if(n[s]!==r[s])throw new Error(`Expected ArrayBuffer value at ${s} to be ${r[s]} but got ${n[s]} instead`)}function J6(e){for(let t=0;t<e.length;t++){let n=e[t];Array.isArray(n)?J6(n):e[t]=p0(n)}return e}function l7(e){let t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(e),new Promise(n=>{t.addEventListener("loadeddata",r=>n(t)),t.load()})}async function u7(e){await e.play(),"requestVideoFrameCallback"in e&&await new Promise(t=>{e.requestVideoFrameCallback(t)})}var V3=class{constructor(e,t,n,r,s){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let a=s||Math.random();this.random=B3.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){let r=this.nextVal;return this.nextVal=NaN,r}let e,t,n=!1;for(;!n;){let r,s,a;do r=2*this.random()-1,s=2*this.random()-1,a=r*r+s*s;while(a>=1||a===0);let i=Math.sqrt(-2*Math.log(a)/a);e=this.mean+this.stdDev*r*i,t=this.mean+this.stdDev*s*i,(!this.truncated||this.isValidTruncated(e))&&(n=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}},c7=class{constructor(e,t,n,r){this.alpha=e,this.beta=1/t,this.dtype=n;let s=r||Math.random();this.randu=B3.alea(s.toString()),this.randn=new V3(0,1,n,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,r,s,a;for(;;){do r=this.randn.nextValue(),a=1+this.c*r;while(a<=0);if(a*=a*a,e=r*r,t=1-.331*e*e,n=.5*e+this.d*(1-a+Math.log(a)),s=this.randu(),s<t||Math.log(s)<n)break}return a=1/this.beta*this.d*a,this.alpha<1&&(a*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(a)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}},d7=class{constructor(e=0,t=1,n,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=n,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=B3.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function h7(e,t,n=1,r="float32",s){if(Da(e),n==null&&(n=1),r==null&&(r="float32"),r!=="float32"&&r!=="int32")throw new Error(`Unsupported data type ${r}`);let a=new c7(t,n,r,s),i=Ht(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}var Z6=ne({randomGamma_:h7});function p7(e,t=0,n=1,r,s){if(Da(e),r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);let a=new V3(t,n,r,!1,s),i=Ht(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}var zw=ne({randomNormal_:p7});function f7(e,t,n){if(t!=null&&t==="bool")throw new Error(`Unsupported data type ${t}`);return zw(e,0,1,t,n)}var e5=ne({randomStandardNormal_:f7});function m7(e,t=0,n=1,r="float32",s){Da(e);let a=Ht(e,r),i=new d7(t,n,null,s);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}var Cu=ne({randomUniform_:m7});function g7(e,t,n,r){return Cu(e,t,n,"int32",r)}var t5=ne({randomUniformInt_:g7});function qc(e,t,n=1,r="float32"){if(n===0)throw new Error("Cannot have a step of zero");let s={start:e,stop:t,step:n,dtype:r};return J.runKernel(e0,{},s)}function b7(e){let t={input:W(e,"input","real")};return J.runKernel(Cw,t)}var zp=ne({real_:b7});function y7(e){let t={x:W(e,"x","reciprocal")};return J.runKernel(mh,t)}var U3=ne({reciprocal_:y7});function x7(e){let t={x:W(e,"x","relu")};return J.runKernel(gh,t)}var Rn=ne({relu_:x7});function w7(e){let t={x:W(e,"x","relu6")};return J.runKernel(xh,t)}var Ww=ne({relu6_:w7});function v7(e,t){let n={x:W(e,"x","reverse")},r={dims:t};return J.runKernel(wh,n,r)}var qa=ne({reverse_:v7});function I7(e){let t=W(e,"x","reverse");return H(t.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),qa(t,0)}var n5=ne({reverse1d_:I7});function k7(e,t){let n=W(e,"x","reverse");return H(n.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),qa(n,t)}var r5=ne({reverse2d_:k7});function C7(e,t){let n=W(e,"x","reverse");return H(n.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),qa(n,t)}var s5=ne({reverse3d_:C7});function S7(e,t){let n=W(e,"x","reverse");return H(n.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),qa(n,t)}var a5=ne({reverse4d_:S7});function N7(e){let t={x:W(e,"x","round")};return J.runKernel(vh,t)}var Vw=ne({round_:N7});function T7(e){let t={x:W(e,"x","rsqrt","float32")};return J.runKernel(Ih,t)}var Uw=ne({rsqrt_:T7});function E7(e){let t={x:W(e,"x","selu")};return J.runKernel(kh,t)}var Gw=ne({selu_:E7});function A7(e,t,n,r,s,a=[1,1],i="NHWC"){let o=W(e,"x","separableConv2d"),u=W(t,"depthwiseFilter","separableConv2d"),c=W(n,"pointwiseFilter","separableConv2d"),l=o,d=!1;if(o.rank===3&&(d=!0,l=ae(o,[1,o.shape[0],o.shape[1],o.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");H(l.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${l.rank}.`),H(u.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`),H(c.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`),H(c.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),H(c.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);let h=u.shape[2],p=u.shape[3];H(c.shape[2]===h*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${h*p}, but got ${c.shape[2]}.`);let f=Lh(l,u,r,s,i,a),m=Vs(f,c,1,"valid",i);return d?ae(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var wm=ne({separableConv2d_:A7});async function $7(e,t){let n=W(e,"x","setdiff1d"),r=W(t,"y","setdiff1d");H(n.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`),H(n.rank===1,()=>`x should be 1D tensor, but got x (${n.shape}).`),H(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);let s=await n.data(),a=await r.data(),i=new Set(a),o=0;for(let l=0;l<s.length;l++)i.has(s[l])||o++;let u=new _r([o],n.dtype),c=new _r([o],"int32");for(let l=0,d=0;l<s.length;l++)i.has(s[l])||(u.values[d]=s[l],c.values[d]=l,d++);return[u.toTensor(),c.toTensor()]}var i5=$7;function R7(e){let t={x:W(e,"x","sign")};return J.runKernel(Nh,t)}var G3=ne({sign_:R7});function _7(e){let t={x:W(e,"x","sin","float32")};return J.runKernel(Ch,t)}var Hw=ne({sin_:_7});function D7(e){let t={x:W(e,"x","sinh")};return J.runKernel(Sh,t)}var jw=ne({sinh_:D7});function F7(e,t,n){let r=W(e,"x","slice1d");return H(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),en(r,[t],[n])}var T0=ne({slice1d_:F7});function M7(e,t,n){let r=W(e,"x","slice2d");return H(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),en(r,t,n)}var qw=ne({slice2d_:M7});function O7(e,t,n){let r=W(e,"x","slice3d");return H(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),en(r,t,n)}var vm=ne({slice3d_:O7});function L7(e,t,n){let r=W(e,"x","slice4d");return H(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),en(r,t,n)}var Wp=ne({slice4d_:L7});function P7(e,t=-1){let n=W(e,"logits","softmax","float32");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);let r={logits:n},s={dim:t};return J.runKernel(Rh,r,s)}var Su=ne({softmax_:P7});function B7(e){H(e.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`);let t={input:e};return J.runKernel(yw,t)}var E0=ne({fft_:B7});function z7(e){H(e.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`);let t={input:e};return J.runKernel(xw,t)}var Vp=ne({ifft_:z7});function W7(e){let t=e.shape[e.shape.length-1],n=e.size/t,r;if(t<=2){let s=ae(e,[n,t]);r=Vp(s)}else{let s=[n,2*(t-1)],a=ae(zp(e),[n,t]),i=ae(x0(e),[n,t]),o=qa(en(a,[0,1],[n,t-2]),1),u=se(qa(en(i,[0,1],[n,t-2]),1),vt(-1)),c=Bn([a,o],1),l=Bn([i,u],1),d=ae(il(c,l),[s[0],s[1]]);r=Vp(d)}if(r=zp(r),e.rank===3&&e.shape[0]!==0){let s=r,a=e.shape[0];r=ae(r,[a,r.shape[0]/a,r.shape[1]]),s.dispose()}return r}var Kw=ne({irfft_:W7});function V7(e,t,n=0){let r={x:W(e,"x","split")},s={numOrSizeSplits:t,axis:n};return J.runKernel(im,r,s)}var sa=ne({split_:V7});function U7(e,t){H(e.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let n=e.shape[e.shape.length-1],r=e.size/n,s;if(t!=null&&t<n){let f=e.shape.map(g=>0),m=e.shape.map(g=>g);m[e.shape.length-1]=t,s=en(e,f,m),n=t}else if(t!=null&&t>n){let f=e.shape.map(m=>m);f[e.shape.length-1]=t-n,s=Bn([e,dr(f)],e.shape.length-1),n=t}else s=e;let a=sn(s),i=ae(il(s,a),[r,n]),o=E0(i),u=Math.floor(n/2)+1,c=zp(o),l=x0(o),d=sa(c,[u,n-u],c.shape.length-1),h=sa(l,[u,n-u],l.shape.length-1),p=s.shape.slice();return p[s.shape.length-1]=u,ae(il(d[0],h[0]),p)}var A0=ne({rfft_:U7});function G7(e,t){let n=W(e,"a","squaredDifference"),r=W(t,"b","squaredDifference");[n,r]=fr(n,r),zn(n.shape,r.shape);let s={a:n,b:r},a={};return J.runKernel(_h,s,a)}var Xw=ne({squaredDifference_:G7});function H7(e,t){let n=W(e,"x","squeeze","string_or_numeric");return ae(n,DF(n.shape,t).newShape)}var Nu=ne({squeeze_:H7});function j7(e,t=0){let n=uy(e,"tensors","stack","string_or_numeric");H(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&H(t<=n[0].rank,()=>"Axis must be <= rank of the tensor");let r=n,s={axis:t};return J.runKernel(Qf,r,s)}var Dr=ne({stack_:j7});function q7(e,t=0){let n={x:W(e,"x","step")},r={alpha:t};return J.runKernel(vu,n,r)}var Bh=ne({step_:q7});function K7(e,t,n,r,s=0,a=0,i=0,o=0,u=0){let c={x:W(e,"x","stridedSlice","string_or_numeric")},l={begin:t,end:n,strides:r,beginMask:s,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:u};return J.runKernel(um,c,l)}var H3=ne({stridedSlice_:K7});function X7(e){let t={x:W(e,"x","tan","float32")};return J.runKernel(Fh,t)}var j3=ne({tan_:X7});function Tn(e,t){bd(e);let n=No(e,t);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Iu(e,null,n,t)}function wo(e,t,n){if(bd(e),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");let r=No(e,n);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Iu(e,t,r,n)}function Qw(e,t,n){if(bd(e),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");let r=No(e,n);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Iu(e,t,r,n)}function nu(e,t,n){if(bd(e),t!=null&&t.length!==4)throw new Error("tensor4d() requires shape to have four numbers");let r=No(e,n);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Iu(e,t,r,n)}function o5(e,t,n){if(bd(e),t!=null&&t.length!==5)throw new Error("tensor5d() requires shape to have five numbers");let r=No(e,n);if(r.length!==5&&r.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Iu(e,t,r,n)}function l5(e,t,n){if(bd(e),t!=null&&t.length!==6)throw new Error("tensor6d() requires shape to have six numbers");let r=No(e,n);if(r.length!==6&&r.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||r,Iu(e,t,r,n)}var Yw={};Pt(Yw,{calculateShapes:()=>u5,validateInput:()=>Jw,validateUpdateShape:()=>q3});function q3(e,t,n){let r=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(a+` update.rank < ${s}. `);if(e.length<r+(n.rank-s))throw new Error(a+` Output shape length < ${r+(n.rank-s)}`);if(n.rank!==s+e.length-r)throw new Error(a+` update.rank != ${s+e.length-r}`);for(let i=0;i<s;++i)if(n.shape[i]!==t.shape[i])throw new Error(a+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<n.rank-s;++i)if(n.shape[i+s]!==e[i+r])throw new Error(a+` updates.shape[${i+s}] (${n.shape[i+s]}) != shape[${i+s}] (${e[i+s]})`)}function Jw(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(e.size===0)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}q3(n,t,e)}function u5(e,t,n){let r=t.shape.length,s=r>1?t.shape[r-1]:1,a=n.length,i=1;for(let d=s;d<a;++d)i*=n[d];let o=s<1?1:s,u=_n(t.shape)/o,c=[...hf(n.slice(0,s)),1],l=_n(n);return{sliceRank:s,numUpdates:u,sliceSize:i,strides:c,outputSize:l}}function Q7(e,t,n){let r=W(e,"tensor","tensorScatterupdate"),s=W(t,"indices","tensorScatterupdate","int32"),a=W(n,"updates","tensorScatterupdate");if(Jw(a,s,r.shape),r.dtype!==a.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${a.dtype}.`);let i={tensor:r,indices:s,updates:a},o={};return J.runKernel(tm,i,o)}var c5=ne({tensorScatterUpdate_:Q7});function Y7(e,t=1,n=!0){let r=W(e,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");let s=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${t}`);let a={x:r},i={k:t,sorted:n},[o,u]=J.runKernel(cm,a,i);return{values:o,indices:u}}var K3=ne({topk_:Y7});function J7(e,t=0,n=1,r,s){if(Da(e),r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");let a=new V3(t,n,r,!0,s),i=Ht(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}var Zw=ne({truncatedNormal_:J7});function Z7(e,t=0){let n=W(e,"x","unique","string_or_numeric");H(n.rank>0,()=>"The input tensor must be at least 1D");let r={x:n},s={axis:t},[a,i]=J.runKernel(u0,r,s);return{values:a,indices:i}}var X3=ne({unique_:Z7});function eee(e,t,n){let r=W(e,"x","unsortedSegmentSum"),s=W(t,"segmentIds","unsortedSegmentSum","int32");H(Dp(n),()=>"numSegments must be of dtype int");let a={x:r,segmentIds:s},i={numSegments:n};return J.runKernel(c0,a,i)}var ev=ne({unsortedSegmentSum_:eee});function tee(e,t=0){let n=W(e,"x","unstack","string_or_numeric");H(t>=-n.shape.length&&t<n.shape.length,()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`);let r={value:n},s={axis:t};return J.runKernel(hm,r,s)}var br=ne({unstack_:tee});function d5(e,t){return Bw(e,t,"right")}function Q3(e,t=!0,n,r){return J.makeVariable(e,t,n,r)}function h5(e,t){let n=[];for(let a=0;a<t.length;a++)t[a]&&n.push(a);let r=Ht(e,"int32"),s=Ht([n.length,e.length],"int32");for(let a=0;a<n.length;a++){let i=r.indexToLoc(n[a]),o=a*e.length;s.values.set(i,o)}return s.toTensor()}async function nee(e){let t=W(e,"condition","whereAsync","bool"),n=await t.data(),r=h5(t.shape,n);return e!==t&&t.dispose(),r}var Y3=nee;async function ree(e,t,n){let r=W(e,"tensor","boolMask"),s=W(t,"mask","boolMask","bool"),a=n??0,i=s.rank,o=r.shape;H(i>0,()=>"mask cannot be scalar"),qs(o.slice(a,a+i),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let u=1;for(let m=a;m<a+i;m++)u*=o[m];let c=o.slice(0,a).concat([u],o.slice(a+i)),l=ae(r,c),d=ae(s,[-1]),h=await Y3(d),p=Nu(h,[1]),f=xm(l,p,a);return e!==r&&r.dispose(),t!==s&&s.dispose(),p.dispose(),l.dispose(),d.dispose(),h.dispose(),f}var p5=ree;function see(e,t,n){let r=W(e,"x","transpose");if(t==null&&(t=r.shape.map((i,o)=>o).reverse()),H(r.rank===t.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`),t.forEach(i=>{H(i>=0&&i<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${t}`)}),r.rank<=1)return r.clone();let s={x:r},a={perm:t};return r.dtype==="complex64"?ie(()=>{let i=zp(r),o=x0(r);return i=J.runKernel(nl,{x:i},a),o=J.runKernel(nl,{x:o},a),n&&(o=Jn(o)),il(i,o)}):J.runKernel(nl,s,a)}var Gt=ne({transpose_:see});function aee(e,t,n,r,s=!0){let a=W(e,"v","movingAverage"),i=W(t,"x","movingAverage"),o=W(n,"decay","movingAverage");ZF(a,i),H(hl(a.shape,i.shape),()=>"Shape mismatch in v and x");let u=vt(1),c=et(u,o),l=se(et(i,a),c);if(s){H(r!=null,()=>"When using zeroDebias: true, step is required.");let d=W(r,"step","movingAverage");l=it(l,et(u,To(o,d)))}return Se(a,l)}var f5=ne({movingAverage_:aee});function iee(e,t,n){Da(n);let r=W(e,"indices","scatterND","int32"),s=W(t,"updates","scatterND");Jw(s,r,n);let a={indices:r,updates:s},i={shape:n};return J.runKernel(em,a,i)}var m5=ne({scatterND_:iee});function oee(e,t,n,r){if(e.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);let s=e.rank>0?e.shape[0]:1,a=e.rank>1?e.shape[1]:1;if(n.length!==a)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${a}.`);let i=t.size;if(!(t.rank===0||t.rank===1&&i===s))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${s}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function lee(e,t,n,r=0){Da(n);let s=W(e,"sparseIndices","sparseToDense","int32"),a=W(t,"sparseValues","sparseToDense","string_or_numeric"),i=W(r,"defaultValue","sparseToDense",a.dtype);oee(s,a,n,i);let o={sparseIndices:s,sparseValues:a,defaultValue:i},u={outputShape:n};return J.runKernel(lm,o,u)}var g5=ne({sparseToDense_:lee});function uee(e,t){let n=W(t,"indices","gatherND","int32"),r={params:W(e,"x","gatherND","string_or_numeric"),indices:n};return J.runKernel(Df,r)}var b5=ne({gatherND_:uee});function cee(e,t){if(t==null)return e.shape.slice();if(hl(e.shape,t))return t;if(e.shape.length===t.length){let n=[];for(let r=0;r<e.shape.length;r++)t[r]==null&&e.shape[r]!=null?n.push(e.shape[r]):n.push(t[r]);return n}return t}function dee(e,t,n,r){let s=W(e,"x","dropout");if(H(s.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),H(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return e instanceof Wt?s.clone():s;let a=cee(s,n),i=1-t,o=it(ym(Se(Cu(a,0,1,"float32",r),i)),i);return se(s,o)}var J3=ne({dropout_:dee});function Z3(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function tv(e,t,n){let r=1-e%2,s=new Float32Array(e);for(let a=0;a<e;++a){let i=2*Math.PI*a/(e+r-1);s[a]=t-n*Math.cos(i)}return Tn(s,"float32")}async function hee(e,t,n=1){let r=W(e,"predictions","inTopK"),s=W(t,"targets","inTopK");H(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),H(r.rank-1===s.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`),qs(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let a=r.shape[r.shape.length-1];H(n>0&&n<=a,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${a}), but got ${n}`);let i=await r.data(),o=await s.data(),[u,c]=[i.length/a,a],l=FF("bool",u);for(let d=0;d<u;d++){let h=d*c,p=i.subarray(h,h+c),f=[];for(let m=0;m<p.length;m++)f.push({value:p[m],index:m});f.sort((m,g)=>g.value-m.value),l[d]=0;for(let m=0;m<n;m++)if(f[m].index===o[d]){l[d]=1;break}}return e!==r&&r.dispose(),t!==s&&s.dispose(),zs(l,s.shape,"bool")}var y5=hee,Up={};Pt(Up,{conv2d:()=>mee,depthwiseConv2d:()=>xee,matMul:()=>vee});function pee(e,t,n,r,s,a="NHWC",i){let o=e;e.rank===3&&(o=ae(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u=t;u.rank===3&&(u=ae(t,[1,t.shape[0],t.shape[1],t.shape[2]])),H(o.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),H(u.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),H(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);let c=a==="NHWC"?o.shape[3]:o.shape[1],l=a==="NHWC"?u.shape[3]:u.shape[1];H(c===n[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${n[2]}.`),H(l===n[3],()=>`Error in conv2dDerFilter: depth of dy (${l}) must match output depth for filter (${n[3]}).`),Ks("conv2dDerFilter",s,i);let d={x:o,dy:u},h={strides:r,pad:s,dataFormat:a,dimRoundingMode:i,filterShape:n};return J.runKernel(pw,d,h)}var eN=ne({conv2DBackpropFilter_:pee});function nv(e,t,n){if(n==null||n==="linear")return e;if(n==="relu")return se(e,Bh(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function rv(e,t){let n=t,r=Fr(e.shape,t.shape);return r.length>0&&(n=dt(n,r)),ae(n,e.shape)}function sv(e,t,n,r){if(t==="linear")return e;if(t==="relu")return Rn(e);if(t==="elu")return gm(e);if(t==="relu6")return Ww(e);if(t==="prelu")return N0(e,n);if(t==="leakyrelu")return w0(e,r);if(t==="sigmoid")return ci(e);throw new Error(`Unknown fused activation ${t}.`)}var av=(e,t)=>!(e>0)||t==="linear";function fee({x:e,filter:t,strides:n,pad:r,dataFormat:s="NHWC",dilations:a=[1,1],dimRoundingMode:i,bias:o,activation:u="linear",preluActivationWeights:c,leakyreluAlpha:l}){if(u=u||"linear",av(J.state.gradientDepth,u)===!1){H(s==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let I=Vs(e,t,n,r,s,a,i);return o!=null&&(I=Se(I,o)),sv(I,u,c,l)}let d=W(e,"x","conv2d","float32"),h=W(t,"filter","conv2d","float32"),p=d,f=!1;d.rank===3&&(f=!0,p=ae(d,[1,d.shape[0],d.shape[1],d.shape[2]])),H(p.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),H(h.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${h.rank}.`),Ks("fused conv2d",r,i);let m=s==="NHWC"?p.shape[3]:p.shape[1];H(h.shape[2]===m,()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${h.shape[2]}.`),H(Mo(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`);let g=g0(p.shape,h.shape,n,a,r,i),b;o!=null&&(b=W(o,"bias","fused conv2d"),[b]=fr(b,d),s==="NHWC"?zn(g.outShape,b.shape):(H(b.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${b.shape.length}.`),H(b.shape.length===0||b.shape[0]===g.outChannels||b.shape[0]===1,()=>`Error in fused conv2d: bias shape (${b.shape}) is not compatible with the number of output channels (${g.outChannels})`)));let y;if(c!=null){let I=c.shape;if(H(I.length<=1||I.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${I.length}.`),I.length===1)H(I[0]===1||I[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${I}) is not compatible with the number of output channels (${g.outChannels}).`);else if(I.length===3)try{zn(I,g.outShape)}catch{let T=`Error in fused conv2d: PReLU activation weights (${I}) is not compatible with the output shape of the conv2d (${g.outShape}).`;throw Error(T)}y=W(c,"prelu weights","fused conv2d")}let x=(I,N)=>{H(s==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`);let[T,E,A,k]=N,C=nv(I,A,u);H(Zl(a),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`);let M=b3(E.shape,C,T,n,r),L=eN(E,C,T.shape,n,r),O=[M,L];if(k!=null){let B=rv(k,C);O.push(B)}return O},w={x:p,filter:h,bias:b,preluActivationWeights:y},v={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i,activation:u,leakyreluAlpha:l};return o==null?Eo((I,N,T)=>{let E=J.runKernel(Lc,w,v);return T([N,I,E]),f&&(E=ae(E,[E.shape[1],E.shape[2],E.shape[3]])),{value:E,gradFunc:x}})(p,h):Eo((I,N,T,E)=>{let A=J.runKernel(Lc,w,v);return E([N,I,A,T]),f&&(A=ae(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:x}})(p,h,b)}var mee=ne({fusedConv2d_:fee});function gee(e,t,n,r,s,a=[1,1],i){let o=e;e.rank===3&&(o=ae(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u=t;u.rank===3&&(u=ae(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let c={x:o,dy:u},l={strides:r,pad:s,dimRoundingMode:i,dilations:a,filterShape:n};return J.runKernel(fw,c,l)}var x5=ne({depthwiseConv2dNativeBackpropFilter_:gee});function bee(e,t,n,r,s,a=[1,1],i){let o=t,u=!1;t.rank===3&&(u=!0,o=ae(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let c={dy:o,filter:n},l={strides:r,pad:s,dimRoundingMode:i,dilations:a,inputShape:e},d=J.runKernel(mw,c,l);return u?ae(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var w5=ne({depthwiseConv2dNativeBackpropInput_:bee});function yee({x:e,filter:t,strides:n,pad:r,dataFormat:s="NHWC",dilations:a=[1,1],dimRoundingMode:i,bias:o,activation:u="linear",preluActivationWeights:c,leakyreluAlpha:l}){if(av(J.state.gradientDepth,u)===!1){let v=Lh(e,t,n,r,s,a,i);return o!=null&&(v=Se(v,o)),sv(v,u,c,l)}let d=W(e,"x","depthwiseConv2d","float32"),h=W(t,"filter","depthwiseConv2d","float32"),p=d,f=!1;d.rank===3&&(f=!0,p=ae(d,[1,d.shape[0],d.shape[1],d.shape[2]])),H(p.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),H(h.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${h.rank}.`),H(p.shape[3]===h.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${h.shape[2]}.`),a==null&&(a=[1,1]),H(Mo(n,a),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),Ks("fused depthwiseConv2d",r,i);let m=g0(p.shape,h.shape,n,a,r,i,!0),g;o!=null&&(g=W(o,"bias","fused conv2d"),[g]=fr(g,d),zn(m.outShape,g.shape));let b;c!=null&&(b=W(c,"prelu weights","fused depthwiseConv2d"));let y=(v,I)=>{H(Zl(a),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);let[N,T,E,A]=I,k=nv(v,E,u),C=w5(T.shape,k,N,n,r,a,i),M=x5(T,k,N.shape,n,r,a,i);if(A!=null){let L=rv(g,k);return[C,M,L]}return[C,M]},x={x:p,filter:h,bias:g,preluActivationWeights:b},w={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i,activation:u,leakyreluAlpha:l};return o==null?Eo((v,I,N)=>{let T=J.runKernel(Pc,x,w);return N([I,v,T]),f&&(T=ae(T,[T.shape[1],T.shape[2],T.shape[3]])),{value:T,gradFunc:y}})(p,h):Eo((v,I,N,T)=>{let E=J.runKernel(Pc,x,w);return T([I,v,E,N]),f&&(E=ae(E,[E.shape[1],E.shape[2],E.shape[3]])),{value:E,gradFunc:y}})(p,h,g)}var xee=ne({fusedDepthwiseConv2d_:yee});function wee({a:e,b:t,transposeA:n=!1,transposeB:r=!1,bias:s,activation:a="linear",preluActivationWeights:i,leakyreluAlpha:o=.2}){if(av(J.state.gradientDepth,a)===!1){let A=Ut(e,t,n,r);return s!=null&&(A=Se(A,s)),sv(A,a,i,o)}let u=W(e,"a","fused matMul"),c=W(t,"b","fused matMul");[u,c]=fr(u,c);let l=n?u.shape[u.rank-2]:u.shape[u.rank-1],d=r?c.shape[c.rank-1]:c.shape[c.rank-2],h=n?u.shape[u.rank-1]:u.shape[u.rank-2],p=r?c.shape[c.rank-2]:c.shape[c.rank-1],f=u.shape.slice(0,-2),m=c.shape.slice(0,-2),g=_n(f),b=_n(m);H(l===d,()=>`Error in fused matMul: inner shapes (${l}) and (${d}) of Tensors with shapes ${u.shape} and ${c.shape} and transposeA=${n} and transposeB=${r} must match.`);let y=zn(u.shape.slice(0,-2),c.shape.slice(0,-2)).concat([h,p]),x=n?ae(u,[g,l,h]):ae(u,[g,h,l]),w=r?ae(c,[b,p,d]):ae(c,[b,d,p]),v;s!=null&&(v=W(s,"bias","fused matMul"),[v]=fr(v,u),zn(y,v.shape));let I;i!=null&&(I=W(i,"prelu weights","fused matMul"));let N=(A,k)=>{let[C,M,L,O]=k,B=nv(ae(A,L.shape),L,a),G,z;if(!n&&!r?(G=Ut(B,M,!1,!0),z=Ut(C,B,!0,!1)):!n&&r?(G=Ut(B,M,!1,!1),z=Ut(B,C,!0,!1)):n&&!r?(G=Ut(M,B,!1,!0),z=Ut(C,B,!1,!1)):(G=Ut(M,B,!0,!0),z=Ut(B,C,!0,!0)),s!=null){let q=rv(O,B);return[G,z,q]}else return[G,z]},T={a:x,b:w,bias:v,preluActivationWeights:I},E={transposeA:n,transposeB:r,activation:a,leakyreluAlpha:o};return s==null?Eo((A,k,C)=>{let M=J.runKernel(Oc,T,E);return C([A,k,M]),{value:ae(M,y),gradFunc:N}})(x,w):Eo((A,k,C,M)=>{let L=J.runKernel(Oc,T,E);return M([A,k,L,C]),{value:ae(L,y),gradFunc:N}})(x,w,v)}var vee=ne({fusedMatMul_:wee});function Iee(e){return tv(e,.54,.46)}var kee=ne({hammingWindow_:Iee});function Cee(e){return tv(e,.5,.5)}var v5=ne({hannWindow_:Cee});function See(e,t,n,r=!1,s=0){let a=0,i=[];for(;a+t<=e.size;)i.push(en(e,a,t)),a+=n;if(r)for(;a<e.size;){let o=a+t-e.size,u=Bn([en(e,a,t-o),Ca([o],s)]);i.push(u),a+=n}return i.length===0?wo([],[0,t]):ae(Bn(i),[i.length,t])}var I5=ne({frame_:See});function Nee(e,t,n,r,s=v5){r==null&&(r=Z3(t));let a=I5(e,t,n),i=se(a,s(t));return A0(i,r)}var Tee=ne({stft_:Nee});function Eee(e,t,n,r,s="bilinear",a=0){let i=W(e,"image","cropAndResize"),o=W(t,"boxes","cropAndResize","float32"),u=W(n,"boxInd","cropAndResize","int32"),c=o.shape[0];H(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),H(o.rank===2&&o.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${o.shape}.`),H(u.rank===1&&u.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${o.shape}.`),H(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),H(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),H(s==="bilinear"||s==="nearest",()=>`method must be bilinear or nearest, but was ${s}`);let l={image:i,boxes:o,boxInd:u},d={method:s,extrapolationValue:a,cropSize:r};return J.runKernel(Nf,l,d)}var Aee=ne({cropAndResize_:Eee});function $ee(e){let t=W(e,"image","flipLeftRight","float32");H(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);let n={image:t};return J.runKernel(Rf,n,{})}var Ree=ne({flipLeftRight_:$ee});function _ee(e){let t=W(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];H(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),H(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);let s=new Array(t.rank);return s.fill(1,0,n),s[n]=3,Ia(t,s)}var Dee=ne({grayscaleToRGB_:_ee});function Fee(e){let t=W(e,"image","RGBToGrayscale"),n=t.rank-1,r=t.shape[n];H(t.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`),H(r===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`);let s=t.dtype,a=Ve(t,"float32"),i=Tn([.2989,.587,.114]),o;switch(t.rank){case 2:o=bc("ij,j->i",a,i);break;case 3:o=bc("ijk,k->ij",a,i);break;case 4:o=bc("ijkl,l->ijk",a,i);break;case 5:o=bc("ijklm,m->ijkl",a,i);break;case 6:o=bc("ijklmn,n->ijklm",a,i);break;default:throw new Error("Not a valid tensor rank.")}return o=ns(o,-1),Ve(o,s)}var Mee=ne({rgbToGrayscale_:Fee});function Oee(e,t,n=0,r=.5){let s=W(e,"image","rotateWithOffset","float32");H(s.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`);let a={image:s},i={radians:t,fillValue:n,center:r};return J.runKernel(fm,a,i)}var Lee=ne({rotateWithOffset_:Oee});function Im(e,t,n,r,s,a){r==null&&(r=.5),s==null&&(s=Number.NEGATIVE_INFINITY),a==null&&(a=0);let i=e.shape[0];return n=Math.min(n,i),H(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),H(e.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),H(e.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),H(t.rank===1,()=>"scores must be a 1D tensor"),H(t.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`),H(0<=a&&a<=1,()=>`softNmsSigma must be in [0, 1], but was '${a}'`),{maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a}}function Pee(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){let a=W(e,"boxes","nonMaxSuppression","float32"),i=W(t,"scores","nonMaxSuppression","float32"),o=Im(a,i,n,r,s);n=o.maxOutputSize,r=o.iouThreshold,s=o.scoreThreshold;let u={maxOutputSize:n,iouThreshold:r,scoreThreshold:s};return J.runKernel(jf,{boxes:a,scores:i},u)}var Bee=ne({nonMaxSuppression_:Pee});function zee(e,t,n){let r=Wee(e,t,n),s=r<0?-(r+1):r;e.splice(s,0,t)}function Wee(e,t,n){return Uee(e,t,n||Vee)}function Vee(e,t){return e>t?1:e<t?-1:0}function Uee(e,t,n){let r=0,s=e.length,a=0,i=!1;for(;r<s;){a=r+(s-r>>>1);let o=n(t,e[a]);o>0?r=a+1:(s=a,i=!o)}return i?r:-r-1}function k5(e,t,n,r,s){return tN(e,t,n,r,s,0)}function C5(e,t,n,r,s,a){return tN(e,t,n,r,s,0,!1,a,!0)}function S5(e,t,n,r,s,a){return tN(e,t,n,r,s,a,!0)}function tN(e,t,n,r,s,a,i=!1,o=!1,u=!1){let c=[];for(let g=0;g<t.length;g++)t[g]>s&&c.push({score:t[g],boxIndex:g,suppressBeginIndex:0});c.sort(tR);let l=a>0?-.5/a:0,d=[],h=[];for(;d.length<n&&c.length>0;){let g=c.pop(),{score:b,boxIndex:y,suppressBeginIndex:x}=g;if(b<s)break;let w=!1;for(let v=d.length-1;v>=x;--v){let I=Gee(e,y,d[v]);if(I>=r){w=!0;break}if(g.score=g.score*Hee(r,l,I),g.score<=s)break}g.suppressBeginIndex=d.length,w||(g.score===b?(d.push(y),h.push(g.score)):g.score>s&&zee(c,g,tR))}let p=d.length,f=n-p;o&&f>0&&(d.push(...new Array(f).fill(0)),h.push(...new Array(f).fill(0)));let m={selectedIndices:d};return i&&(m.selectedScores=h),u&&(m.validOutputs=p),m}function Gee(e,t,n){let r=e.subarray(t*4,t*4+4),s=e.subarray(n*4,n*4+4),a=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),u=Math.max(r[1],r[3]),c=Math.min(s[0],s[2]),l=Math.min(s[1],s[3]),d=Math.max(s[0],s[2]),h=Math.max(s[1],s[3]),p=(o-a)*(u-i),f=(d-c)*(h-l);if(p<=0||f<=0)return 0;let m=Math.max(a,c),g=Math.max(i,l),b=Math.min(o,d),y=Math.min(u,h),x=Math.max(b-m,0)*Math.max(y-g,0);return x/(p+f-x)}function Hee(e,t,n){let r=Math.exp(t*n*n);return n<=e?r:0}function tR(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}async function jee(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){let a=W(e,"boxes","nonMaxSuppressionAsync"),i=W(t,"scores","nonMaxSuppressionAsync"),o=Im(a,i,n,r,s);n=o.maxOutputSize,r=o.iouThreshold,s=o.scoreThreshold;let u=await Promise.all([a.data(),i.data()]),c=u[0],l=u[1],{selectedIndices:d}=k5(c,l,n,r,s);return a!==e&&a.dispose(),i!==t&&i.dispose(),Tn(d,"int32")}var qee=jee;function Kee(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){let i=W(e,"boxes","nonMaxSuppression"),o=W(t,"scores","nonMaxSuppression"),u=Im(i,o,n,r,s,a);n=u.maxOutputSize,r=u.iouThreshold,s=u.scoreThreshold,a=u.softNmsSigma;let c={boxes:i,scores:o},l={maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a},d=J.runKernel(Kf,c,l);return{selectedIndices:d[0],selectedScores:d[1]}}var Xee=ne({nonMaxSuppressionWithScore_:Kee});async function Qee(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){let i=W(e,"boxes","nonMaxSuppressionAsync"),o=W(t,"scores","nonMaxSuppressionAsync"),u=Im(i,o,n,r,s,a);n=u.maxOutputSize,r=u.iouThreshold,s=u.scoreThreshold,a=u.softNmsSigma;let c=await Promise.all([i.data(),o.data()]),l=c[0],d=c[1],{selectedIndices:h,selectedScores:p}=S5(l,d,n,r,s,a);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:Tn(h,"int32"),selectedScores:Tn(p)}}var Yee=Qee;function Jee(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){let i=W(e,"boxes","nonMaxSuppression"),o=W(t,"scores","nonMaxSuppression"),u=Im(i,o,n,r,s,null),c=u.maxOutputSize,l=u.iouThreshold,d=u.scoreThreshold,h={boxes:i,scores:o},p={maxOutputSize:c,iouThreshold:l,scoreThreshold:d,padToMaxOutputSize:a},f=J.runKernel(qf,h,p);return{selectedIndices:f[0],validOutputs:f[1]}}var Zee=ne({nonMaxSuppressionPadded_:Jee});async function ete(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){let i=W(e,"boxes","nonMaxSuppressionAsync"),o=W(t,"scores","nonMaxSuppressionAsync"),u=Im(i,o,n,r,s,null),c=u.maxOutputSize,l=u.iouThreshold,d=u.scoreThreshold,[h,p]=await Promise.all([i.data(),o.data()]),{selectedIndices:f,validOutputs:m}=C5(h,p,c,l,d,a);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:Tn(f,"int32"),validOutputs:vt(m,"int32")}}var tte=ete;function nte(e,t,n=!1,r=!1){let s=W(e,"images","resizeBilinear");H(s.rank===3||s.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),H(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),H(r===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let a=s,i=!1;s.rank===3&&(i=!0,a=ae(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let o={images:a},u={alignCorners:n,halfPixelCenters:r,size:t},c=J.runKernel(yh,o,u);return i?ae(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var N5=ne({resizeBilinear_:nte});function rte(e,t,n=!1,r=!1){let s=W(e,"images","resizeNearestNeighbor");H(s.rank===3||s.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),H(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),H(s.dtype==="float32"||s.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),H(r===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let a=s,i=!1;s.rank===3&&(i=!0,a=ae(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let o={images:a},u={alignCorners:n,halfPixelCenters:r,size:t},c=J.runKernel(bh,o,u);return i?ae(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var T5=ne({resizeNearestNeighbor_:rte});function ste(e,t="binary",n=!1,r=.5){let s=W(e,"image","threshold"),a=.2989,i=.587,o=.114,u=s.shape[0]*s.shape[1],c=se(Tn([r]),255),l,d,h,p;if(H(s.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),H(s.shape[2]===3||s.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),H(s.dtype==="int32"||s.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),H(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),s.shape[2]===3){[l,d,h]=sa(s,[1,1,1],-1);let m=se(l,a),g=se(d,i),b=se(h,o);p=Se(Se(m,g),b)}else p=e;if(t==="otsu"){let m=d3(Ve(Vw(p),"int32"),zs([]),256);c=ate(m,u)}let f=n?ku(p,c):Xs(p,c);return Ve(se(f,255),"int32")}function ate(e,t){let n=Tn([-1]),r=Tn([0]),s=Tn([0]),a,i,o,u,c,l;for(let d=0;d<e.size-1;d++){a=en(e,0,d+1),i=en(e,d+1),c=it(dt(a),t),l=it(dt(i),t);let h=dt(se(a,qc(0,a.size)));o=it(h,dt(a));let p=Ca(i.shape,a.size),f=Se(qc(0,i.size),p),m=se(i,f);u=it(dt(m),dt(i));let g=et(o,u),b=et(o,u),y=se(c,l);s=se(se(y,g),b);let x=Xs(s,r);r=os(x,s,r),n=os(x,Tn([d]),n)}return n}var ite=ne({threshold_:ste});function ote(e,t,n="nearest",r="constant",s=0,a){let i=W(e,"image","transform","float32"),o=W(t,"transforms","transform","float32");H(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),H(o.rank===2&&(o.shape[0]===i.shape[0]||o.shape[0]===1)&&o.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),H(a==null||a.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${a}.`);let u={image:i,transforms:o},c={interpolation:n,fillMode:r,fillValue:s,outputShape:a};return J.runKernel(dm,u,c)}var lte=ne({transform_:ote});function ute(e,t,n){let r=W(e,"a","bandPart");H(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);let s=r.shape,[a,i]=r.shape.slice(-2),o,u;typeof t=="number"?(H(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),H(t<=a,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${a}).`),o=W(t<0?a:t,"numLower","bandPart")):(H(t.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),o=os(Pp(t,0),a,tu(t,a))),typeof n=="number"?(H(n%1===0,()=>`bandPart(): numUpper must be an integer, got ${n}.`),H(n<=i,()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`),u=W(n<0?i:n,"numUpper","bandPart")):(H(n.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),u=os(Pp(n,0),i,tu(n,i)));let c=ae(qc(0,a,1,"int32"),[-1,1]),l=qc(0,i,1,"int32"),d=et(c,l),h=di(ku(d,o),ml(d,Jn(u))),p=dr([a,i],r.dtype);return ae(Dr(br(ae(r,[-1,a,i])).map(f=>os(h,f,p))),s)}var cte=ne({bandPart_:ute});function dte(e){let t;if(Array.isArray(e)){t=!1,H(e!=null&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let s=e[0].shape[0];for(let a=1;a<e.length;++a)H(e[a].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[a].shape[0]} vs. ${s})`)}else t=!0,e=sa(e,e.shape[0],0).map(s=>Nu(s,[0]));H(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);let n=[],r=e;for(let s=0;s<e.length;++s)n.push(J.tidy(()=>{let a=r[s];if(s>0)for(let i=0;i<s;++i){let o=se(dt(se(n[i],a)),n[i]);a=et(a,o)}return it(a,bm(a,"euclidean"))}));return t?Dr(n,0):n}var hte=ne({gramSchmidt_:dte});function pte(e,t=!1){if(H(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),e.rank===2)return nR(e,t);{let n=e.shape.slice(0,e.shape.length-2).reduce((u,c)=>u*c),r=br(ae(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),s=[],a=[];r.forEach(u=>{let[c,l]=nR(u,t);s.push(c),a.push(l)});let i=ae(Dr(s,0),e.shape),o=ae(Dr(a,0),e.shape);return[i,o]}}function nR(e,t=!1){return J.tidy(()=>{H(e.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);let n=e.shape[0],r=e.shape[1],s=Mw(n),a=xo(e),i=wo([[1]],[1,1]),o=xo(i),u=n>=r?r:n;for(let c=0;c<u;++c){let l=a,d=o,h=s;[o,a,s]=J.tidy(()=>{let p=en(a,[c,c],[n-c,1]),f=bm(p),m=en(a,[c,c],[1,1]),g=os(Xs(m,0),wo([[-1]]),wo([[1]])),b=et(m,se(g,f)),y=it(p,b);y.shape[0]===1?o=xo(i):o=Bn([i,en(y,[1,0],[y.shape[0]-1,y.shape[1]])],0);let x=Jn(it(Ut(g,b),f)),w=en(a,[c,0],[n-c,r]),v=se(x,o),I=Gt(o);if(c===0)a=et(w,Ut(v,Ut(I,w)));else{let E=et(w,Ut(v,Ut(I,w)));a=Bn([en(a,[0,0],[c,r]),E],0)}let N=Gt(v),T=en(s,[0,c],[n,s.shape[1]-c]);if(c===0)s=et(T,Ut(Ut(T,o),N));else{let E=et(T,Ut(Ut(T,o),N));s=Bn([en(s,[0,0],[n,c]),E],1)}return[o,a,s]}),Lt([l,d,h])}return!t&&n>r&&(s=en(s,[0,0],[n,r]),a=en(a,[0,0],[r,r])),[s,a]})}var fte=ne({qr_:pte}),Ls;(function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Ls||(Ls={}));function mte(e,t,n=Ls.SUM_BY_NONZERO_WEIGHTS){let r=W(e,"losses","computeWeightedLoss"),s=null;t!=null&&(s=W(t,"weights","computeWeightedLoss"));let a=s==null?r:se(r,s);if(n===Ls.NONE)return a;if(n===Ls.SUM)return dt(a);if(n===Ls.MEAN){if(s==null)return cr(a);{let i=r.size/s.size,o=it(dt(a),dt(s));return i>1?it(o,vt(i)):o}}if(n===Ls.SUM_BY_NONZERO_WEIGHTS){if(s==null)return it(dt(a),vt(r.size));{let i=se(s,ra(r.shape)),o=Ve(dt(jc(i,vt(0))),"float32");return it(dt(a),o)}}throw Error(`Unknown reduction: ${n}`)}var gl=ne({computeWeightedLoss_:mte});function gte(e,t,n,r=Ls.SUM_BY_NONZERO_WEIGHTS){let s=W(e,"labels","absoluteDifference"),a=W(t,"predictions","absoluteDifference"),i=null;n!=null&&(i=W(n,"weights","absoluteDifference")),qs(s.shape,a.shape,"Error in absoluteDifference: ");let o=Ar(et(s,a));return gl(o,i,r)}var bte=ne({absoluteDifference_:gte});function yte(e,t,n,r,s=Ls.SUM_BY_NONZERO_WEIGHTS){let a=W(e,"labels","cosineDistance"),i=W(t,"predictions","cosineDistance"),o=null;r!=null&&(o=W(r,"weights","cosineDistance")),qs(a.shape,i.shape,"Error in cosineDistance: ");let u=vt(1),c=et(u,dt(se(a,i),n,!0));return gl(c,o,s)}var xte=ne({cosineDistance_:yte});function wte(e,t,n,r=Ls.SUM_BY_NONZERO_WEIGHTS){let s=W(e,"labels","hingeLoss"),a=W(t,"predictions","hingeLoss"),i=null;n!=null&&(i=W(n,"weights","hingeLoss")),qs(s.shape,a.shape,"Error in hingeLoss: ");let o=vt(1);s=et(se(vt(2),s),o);let u=Rn(et(o,se(s,a)));return gl(u,i,r)}var vte=ne({hingeLoss_:wte});function Ite(e,t,n,r=1,s=Ls.SUM_BY_NONZERO_WEIGHTS){let a=W(e,"labels","huberLoss"),i=W(t,"predictions","huberLoss"),o=null;n!=null&&(o=W(n,"weights","huberLoss")),qs(a.shape,i.shape,"Error in huberLoss: ");let u=vt(r),c=Ar(et(i,a)),l=tu(c,u),d=et(c,l),h=Se(se(vt(.5),Pn(l)),se(u,d));return gl(h,o,s)}var kte=ne({huberLoss_:Ite});function Cte(e,t,n,r=1e-7,s=Ls.SUM_BY_NONZERO_WEIGHTS){let a=W(e,"labels","logLoss"),i=W(t,"predictions","logLoss"),o=null;n!=null&&(o=W(n,"weights","logLoss")),qs(a.shape,i.shape,"Error in logLoss: ");let u=vt(1),c=vt(r),l=Jn(se(a,Ta(Se(i,c)))),d=se(et(u,a),Ta(Se(et(u,i),c))),h=et(l,d);return gl(h,o,s)}var Ste=ne({logLoss_:Cte});function Nte(e,t,n,r=Ls.SUM_BY_NONZERO_WEIGHTS){let s=W(e,"labels","meanSquaredError"),a=W(t,"predictions","meanSquaredError"),i=null;n!=null&&(i=W(n,"weights","meanSquaredError")),qs(s.shape,a.shape,"Error in meanSquaredError: ");let o=Xw(s,a);return gl(o,i,r)}var Tte=ne({meanSquaredError_:Nte});function Ete(e,t){let n=W(e,"labels","sigmoidCrossEntropyWithLogits"),r=W(t,"logits","sigmoidCrossEntropyWithLogits");qs(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");let s=Rn(r),a=se(r,n),i=v0(Is(Jn(Ar(r))));return Se(et(s,a),i)}function Ate(e,t,n,r=0,s=Ls.SUM_BY_NONZERO_WEIGHTS){let a=W(e,"multiClassLabels","sigmoidCrossEntropy"),i=W(t,"logits","sigmoidCrossEntropy"),o=null;if(n!=null&&(o=W(n,"weights","sigmoidCrossEntropy")),qs(a.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){let c=vt(r),l=vt(1),d=vt(.5);a=Se(se(a,et(l,c)),se(d,c))}let u=Ete(a,i);return gl(u,o,s)}var $te=ne({sigmoidCrossEntropy_:Ate});function Rte(e,t,n=-1){if(n===-1&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return Eo((r,s,a)=>{let i=I0(s,[n],!0),o=et(Ve(s,"float32"),i);a([r,o]);let u=Jn(se(o,r));return{value:dt(u,[n]),gradFunc:(c,l)=>{let[d,h]=l,p=Hc(c.shape,[n]);return[se(ae(c,p),et(Ve(d,"float32"),Is(h))),se(ae(c,p),et(Is(h),Ve(d,"float32")))]}}})(e,t)}function _te(e,t,n,r=0,s=Ls.SUM_BY_NONZERO_WEIGHTS){let a=W(e,"onehotLabels","softmaxCrossEntropy"),i=W(t,"logits","softmaxCrossEntropy"),o=null;if(n!=null&&(o=W(n,"weights","softmaxCrossEntropy")),qs(a.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){let c=vt(r),l=vt(1),d=vt(a.shape[1]);a=Se(se(a,et(l,c)),it(c,d))}let u=Rte(a,i);return gl(u,o,s)}var Dte=ne({softmaxCrossEntropy_:_te});function Fte(e,t,n,r){let s=W(e,"indices","sparseFillEmptyRows","int32"),a=W(t,"values","sparseFillEmptyRows"),i=W(n,"denseShape","sparseFillEmptyRows","int32"),o=W(r,"defaultValue","sparseFillEmptyRows",a.dtype);if(s.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${s.shape}`);if(a.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${a.shape}`);if(i.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(o.rank!==0)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);let u={indices:s,values:a,denseShape:i,defaultValue:o},c=J.runKernel(t0,u);return{outputIndices:c[0],outputValues:c[1],emptyRowIndicator:c[2],reverseIndexMap:c[3]}}var Mte=ne({sparseFillEmptyRows_:Fte});function Ote(e,t,n){let r=W(e,"inputIndices","sparseReshape","int32"),s=W(t,"inputShape","sparseReshape","int32"),a=W(n,"newShape","sparseReshape","int32");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(s.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(a.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${a.shape}`);let i={inputIndices:r,inputShape:s,newShape:a},o=J.runKernel(om,i);return{outputIndices:o[0],outputShape:o[1]}}var Lte=ne({sparseReshape_:Ote});function Pte(e,t,n){let r=W(e,"data","sparseSegmentMean"),s=W(t,"indices","sparseSegmentMean","int32"),a=W(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${s.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${a.shape}`);let i={data:r,indices:s,segmentIds:a};return J.runKernel(n0,i)}var Bte=ne({sparseSegmentMean_:Pte});function zte(e,t,n){let r=W(e,"data","sparseSegmentSum"),s=W(t,"indices","sparseSegmentSum","int32"),a=W(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${s.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${a.shape}`);let i={data:r,indices:s,segmentIds:a};return J.runKernel(r0,i)}var Wte=ne({sparseSegmentSum_:zte});function Vte(e,t,n,r,s,a,i,o){let u=W(e,"data","stringNGrams","string");if(u.dtype!=="string")throw new Error("Data must be of datatype string");if(u.shape.length!==1)throw new Error(`Data must be a vector, saw: ${u.shape}`);let c=W(t,"dataSplits","stringNGrams");if(c.dtype!=="int32")throw new Error("Data splits must be of datatype int32");let l={separator:n,nGramWidths:r,leftPad:s,rightPad:a,padWidth:i,preserveShortSequences:o},d={data:u,dataSplits:c},h=J.runKernel(i0,d,l);return{nGrams:h[0],nGramsSplits:h[1]}}var Ute=ne({stringNGrams_:Vte});function Gte(e,t,n=!0){let r=W(e,"input","stringSplit","string"),s=W(t,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(s.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);let a={skipEmpty:n},i={input:r,delimiter:s},o=J.runKernel(o0,i,a);return{indices:o[0],values:o[1],shape:o[2]}}var Hte=ne({stringSplit_:Gte});function jte(e,t){let n=W(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");let s={input:n};return J.runKernel(l0,s,r)}var qte=ne({stringToHashBucketFast_:jte});function Kte(e,t,n,r=!0){let s=W(e,"input","staticRegexReplace","string"),a={pattern:t,rewrite:n,replaceGlobal:r};return J.runKernel(a0,{x:s},a)}var Xte=ne({staticRegexReplace_:Kte}),E5={fft:E0,ifft:Vp,rfft:A0,irfft:Kw},A5={hammingWindow:kee,hannWindow:v5,frame:I5,stft:Tee},La={flipLeftRight:Ree,grayscaleToRGB:Dee,resizeNearestNeighbor:T5,resizeBilinear:N5,rgbToGrayscale:Mee,rotateWithOffset:Lee,cropAndResize:Aee,nonMaxSuppression:Bee,nonMaxSuppressionAsync:qee,nonMaxSuppressionWithScore:Xee,nonMaxSuppressionWithScoreAsync:Yee,nonMaxSuppressionPadded:Zee,nonMaxSuppressionPaddedAsync:tte,threshold:ite,transform:lte},nN={bandPart:cte,gramSchmidt:hte,qr:fte},$5={absoluteDifference:bte,computeWeightedLoss:gl,cosineDistance:xte,hingeLoss:vte,huberLoss:kte,logLoss:Ste,meanSquaredError:Tte,sigmoidCrossEntropy:$te,softmaxCrossEntropy:Dte},R5={sparseFillEmptyRows:Mte,sparseReshape:Lte,sparseSegmentMean:Bte,sparseSegmentSum:Wte},_5={stringNGrams:Ute,stringSplit:Hte,stringToHashBucketFast:qte,staticRegexReplace:Xte},Me={};Pt(Me,{Serializable:()=>D5,SerializationMap:()=>F5,getRegisteredName:()=>Yte,registerClass:()=>M5});var Qte=new Map,iC=new Map,D5=class{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}},F5=class wp{constructor(){this.classNameMap={}}static getMap(){return wp.instance==null&&(wp.instance=new wp),wp.instance}static register(t){wp.getMap().classNameMap[t.className]=[t,t.fromConfig]}};function M5(e,t,n){H(e.className!=null,()=>"Class being registered does not have the static className property defined."),H(typeof e.className=="string",()=>"className is required to be a string, but got type "+typeof e.className),H(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof t>"u"&&(t="Custom"),typeof n>"u"&&(n=e.className);let r=n,s=t+">"+r;return F5.register(e),Qte.set(s,e),iC.set(e,s),e}function Yte(e){return iC.has(e)?iC.get(e):e.className}var bl=class extends D5{minimize(e,t=!1,n){let{value:r,grads:s}=this.computeGradients(e,n);if(n!=null){let a=n.map(i=>({name:i.name,tensor:s[i.name]}));this.applyGradients(a)}else this.applyGradients(s);return Lt(s),t?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return M6(e,t)}dispose(){this.iterations_!=null&&Lt(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:vt(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}};Object.defineProperty(bl,Symbol.hasInstance,{value:e=>e.minimize!=null&&e.computeGradients!=null&&e.applyGradients!=null});var rN=class extends bl{static get className(){return"Adadelta"}constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],n==null&&(this.epsilon=J.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=J.registeredVariables[t],s=!1;this.accumulatedGrads[n]==null&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:ie(()=>sn(r).variable(s))}),this.accumulatedUpdates[n]==null&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:ie(()=>sn(r).variable(s))});let a=Array.isArray(e)?e[n].tensor:e[t];if(a==null)return;let i=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;ie(()=>{let u=Se(se(i,this.rho),se(Pn(a),1-this.rho)),c=se(it(ls(Se(o,this.epsilon)),ls(Se(i,this.epsilon))),a),l=Se(se(o,this.rho),se(Pn(c),1-this.rho));i.assign(u),o.assign(l);let d=Se(se(c,-this.learningRate),r);r.assign(d)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Lt(this.accumulatedGrads.map(e=>e.variable)),Lt(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){let e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=e.length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.accumulatedUpdates=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}},sN=class extends bl{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=J.registeredVariables[t];this.accumulatedGrads[n]==null&&(this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:ie(()=>Ca(r.shape,this.initialAccumulatorValue).variable(!1))});let s=Array.isArray(e)?e[n].tensor:e[t];if(s==null)return;let a=this.accumulatedGrads[n].variable;ie(()=>{let i=Se(a,Pn(s));a.assign(i);let o=Se(se(it(s,ls(Se(i,J.backend.epsilon()))),-this.learningRate),r);r.assign(o)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Lt(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulatedGrads=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}},aN=class extends bl{static get className(){return"Adam"}constructor(e,t,n,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],ie(()=>{this.accBeta1=vt(t).variable(),this.accBeta2=vt(n).variable()}),r==null&&(this.epsilon=J.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);ie(()=>{let n=et(1,this.accBeta1),r=et(1,this.accBeta2);t.forEach((s,a)=>{let i=J.registeredVariables[s],o=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${s}/m`,variable:ie(()=>sn(i).variable(o))}),this.accumulatedSecondMoment[a]==null&&(this.accumulatedSecondMoment[a]={originalName:`${s}/v`,variable:ie(()=>sn(i).variable(o))});let u=Array.isArray(e)?e[a].tensor:e[s];if(u==null)return;let c=this.accumulatedFirstMoment[a].variable,l=this.accumulatedSecondMoment[a].variable,d=Se(se(c,this.beta1),se(u,1-this.beta1)),h=Se(se(l,this.beta2),se(Pn(u),1-this.beta2)),p=it(d,n),f=it(h,r);c.assign(d),l.assign(h);let m=Se(se(it(p,Se(ls(f),this.epsilon)),-this.learningRate),i);i.assign(m)}),this.accBeta1.assign(se(this.accBeta1,this.beta1)),this.accBeta2.assign(se(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Lt(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&Lt(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),ie(()=>{this.accBeta1.assign(To(this.beta1,this.iterations_+1)),this.accBeta2.assign(To(this.beta2,this.iterations_+1))});let t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}},iN=class extends bl{static get className(){return"Adamax"}constructor(e,t,n,r=null,s=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],ie(()=>{this.iteration=vt(0).variable(),this.accBeta1=vt(t).variable()}),r==null&&(this.epsilon=J.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);ie(()=>{let n=et(1,this.accBeta1),r=it(-this.learningRate,Se(se(this.iteration,this.decay),1));t.forEach((s,a)=>{let i=J.registeredVariables[s],o=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${s}/m`,variable:sn(i).variable(o)}),this.accumulatedWeightedInfNorm[a]==null&&(this.accumulatedWeightedInfNorm[a]={originalName:`${s}/v`,variable:sn(i).variable(o)});let u=Array.isArray(e)?e[a].tensor:e[s];if(u==null)return;let c=this.accumulatedFirstMoment[a].variable,l=this.accumulatedWeightedInfNorm[a].variable,d=Se(se(c,this.beta1),se(u,1-this.beta1)),h=se(l,this.beta2),p=Ar(u),f=Oo(h,p);c.assign(d),l.assign(f);let m=Se(se(it(r,n),it(d,Se(f,this.epsilon))),i);i.assign(m)}),this.iteration.assign(Se(this.iteration,1)),this.accBeta1.assign(se(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Lt(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&Lt(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}},iv=class extends bl{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=Array.isArray(e)?e[n].tensor:e[t];if(r==null)return;let s=J.registeredVariables[t];ie(()=>{let a=Se(se(this.c,r),s);s.assign(a)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=zr(vt(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}},oN=class extends iv{static get className(){return"Momentum"}constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=vt(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=J.registeredVariables[t];this.accumulations[n]==null&&(this.accumulations[n]={originalName:`${t}/momentum`,variable:ie(()=>sn(r).variable(!1))});let s=this.accumulations[n].variable,a=Array.isArray(e)?e[n].tensor:e[t];a!=null&&ie(()=>{let i,o=Se(se(this.m,s),a);this.useNesterov?i=Se(se(this.c,Se(a,se(o,this.m))),r):i=Se(se(this.c,o),r),s.assign(o),r.assign(i)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Lt(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulations=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}},lN=class extends bl{static get className(){return"RMSProp"}constructor(e,t=.9,n=0,r=null,s=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,r==null&&(this.epsilon=J.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=J.registeredVariables[t],s=!1;this.accumulatedMeanSquares[n]==null&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:ie(()=>sn(r).variable(s))}),this.accumulatedMoments[n]==null&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:ie(()=>sn(r).variable(s))}),this.accumulatedMeanGrads[n]==null&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:ie(()=>sn(r).variable(s))});let a=Array.isArray(e)?e[n].tensor:e[t];if(a==null)return;let i=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;ie(()=>{let u=Se(se(i,this.decay),se(Pn(a),1-this.decay));if(this.centered){let c=this.accumulatedMeanGrads[n].variable,l=Se(se(c,this.decay),se(a,1-this.decay)),d=it(se(a,this.learningRate),ls(et(u,Se(Pn(l),this.epsilon)))),h=Se(se(o,this.momentum),d);i.assign(u),c.assign(l),o.assign(h);let p=et(r,h);r.assign(p)}else{let c=Se(se(i,this.decay),se(Pn(a),1-this.decay)),l=Se(se(o,this.momentum),it(se(a,this.learningRate),ls(Se(c,this.epsilon))));i.assign(c),o.assign(l);let d=et(r,l);r.assign(d)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Lt(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Lt(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&Lt(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.accumulatedMoments=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}},Jte=[rN,sN,aN,iN,oN,lN,iv];function Zte(){for(let e of Jte)M5(e)}var fs={};Pt(fs,{CompositeArrayBuffer:()=>pl,browserFiles:()=>ine,browserHTTPRequest:()=>hne,concatenateArrayBuffers:()=>zQ,copyModel:()=>lY,decodeWeights:()=>o6,decodeWeightsStream:()=>u6,encodeWeights:()=>FQ,fromMemory:()=>fne,fromMemorySync:()=>z5,getLoadHandlers:()=>KQ,getModelArtifactsForJSON:()=>QS,getModelArtifactsForJSONSync:()=>d6,getModelArtifactsInfoForJSON:()=>m0,getSaveHandlers:()=>qQ,getWeightSpecs:()=>eC,http:()=>cN,isHTTPScheme:()=>lC,listModels:()=>iY,loadWeights:()=>lne,moveModel:()=>uY,registerLoadRouter:()=>jQ,registerSaveRouter:()=>HQ,removeModel:()=>oY,weightsLoaderFactory:()=>L5,withSaveHandler:()=>mne,withSaveHandlerSync:()=>gne});var ene="model",tne=".json",nne=".weights.bin";function rR(e){return new Promise(t=>setTimeout(t)).then(e)}var dx=class oC{constructor(t){if(!ge().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(oC.URL_SCHEME)&&(t=t.slice(oC.URL_SCHEME.length)),(t==null||t.length===0)&&(t=ene),this.modelJsonFileName=t+tne,this.weightDataFileName=t+nne}async save(t){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let n=pl.join(t.weightData),r=window.URL.createObjectURL(new Blob([n],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let s=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],a=c6(t,s),i=window.URL.createObjectURL(new Blob([JSON.stringify(a)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=i,await rR(()=>o.dispatchEvent(new MouseEvent("click"))),t.weightData!=null){let u=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;u.download=this.weightDataFileName,u.href=r,await rR(()=>u.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:m0(t)}}}};dx.URL_SCHEME="downloads://";var rne=class{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{let n=new FileReader;n.onload=r=>{let s=JSON.parse(r.target.result),a=s.modelTopology;if(a==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(s.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:a});return}let i=QS(s,o=>this.loadWeights(o));e(i)},n.onerror=r=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)})}loadWeights(e){let t=[],n=[];for(let a of e)t.push(...a.weights),n.push(...a.paths);let r=this.checkManifestAndWeightFiles(e),s=n.map(a=>this.loadWeightsFile(a,r[a]));return Promise.all(s).then(a=>[t,a])}loadWeightsFile(e,t){return new Promise((n,r)=>{let s=new FileReader;s.onload=a=>{let i=a.target.result;n(i)},s.onerror=a=>r(`Failed to weights data from file of path '${e}'.`),s.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){let t=[],n=this.weightsFiles.map(s=>eR(s.name)),r={};for(let s of e)s.paths.forEach(a=>{let i=eR(a);if(t.indexOf(i)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${i}'`);if(t.push(i),n.indexOf(i)===-1)throw new Error(`Weight file with basename '${i}' is not provided.`);r[a]=this.weightsFiles[n.indexOf(i)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}},sne=e=>ge().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(dx.URL_SCHEME)?ane(e.slice(dx.URL_SCHEME.length)):null;ja.registerSaveRouter(sne);function ane(e="model"){return new dx(e)}function ine(e){return new rne(e)}function sR(e,t,n,r){i(e),n=n??0,r=r??1,o(n,r);let s=0,a=u=>(u.then(c=>{let l=n+ ++s/e.length*(r-n);return t(l),c}),u);function i(u){H(u!=null&&Array.isArray(u)&&u.length>0,()=>"promises must be a none empty array")}function o(u,c){H(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${u}`),H(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${c}`),H(c>=u,()=>`startFraction must be no more than endFraction, but got startFraction ${u} and endFraction ${c}`)}return Promise.all(e.map(a))}async function O5(e,t){t==null&&(t={});let n=t.fetchFunc==null?ge().platform.fetch:t.fetchFunc,r=e.map(a=>n(a,t.requestInit,{isBinary:!0})),s=(t.onProgress==null?await Promise.all(r):await sR(r,t.onProgress,0,.5)).map(a=>a.arrayBuffer());return t.onProgress==null?await Promise.all(s):await sR(s,t.onProgress,.5,1)}function one(e,t){var n;let r=t.fetchFunc==null?ge().platform.fetch:t.fetchFunc,s=0,a;return(n=t.onProgress)===null||n===void 0||n.call(t,0),new ReadableStream({pull:async i=>{for(var o;s<e.length;){a||(a=(await r(e[s],t.requestInit,{isBinary:!0})).body.getReader());let{done:u,value:c}=await a.read();if(u){s++,a=void 0,(o=t.onProgress)===null||o===void 0||o.call(t,s/e.length);continue}i.enqueue(c);return}i.close()}})}async function lne(e,t="",n,r){return L5(s=>O5(s,{requestInit:r}))(e,t,n)}function L5(e){return async(t,n="",r)=>{let s=t.map(()=>!1),a={},i=r!=null?r.map(()=>!1):[],o=[];if(t.forEach((p,f)=>{let m=0;p.weights.forEach(g=>{let b="quantization"in g?g.quantization.dtype:g.dtype,y=zc[b]*_n(g.shape),x=()=>{s[f]=!0,a[f]==null&&(a[f]=[]),a[f].push({manifestEntry:g,groupOffset:m,sizeBytes:y})};r!=null?r.forEach((w,v)=>{w===g.name&&(x(),i[v]=!0)}):x(),o.push(g.name),m+=y})}),!i.every(p=>p)){let p=r.filter((f,m)=>!i[m]);throw new Error(`Could not find weights in manifest with names: ${p.join(", ")}. 
Manifest JSON has weights with names: ${o.join(", ")}.`)}let u=s.reduce((p,f,m)=>(f&&p.push(m),p),[]),c=[];u.forEach(p=>{t[p].paths.forEach(f=>{let m=n+(n.endsWith("/")?"":"/")+f;c.push(m)})});let l=await e(c),d={},h=0;return u.forEach(p=>{let f=t[p].paths.length,m=new pl(l.slice(h,h+f));a[p].forEach(g=>{let b=m.slice(g.groupOffset,g.groupOffset+g.sizeBytes),y=o6(b,[g.manifestEntry]);for(let x in y)d[x]=y[x]}),h+=f}),d}}var une="application/octet-stream",cne="application/json",uN=class{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(H(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=ge().platform.fetch,H(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&H(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;let n=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=c6(e,n);if(t.body.append("model.json",new Blob([JSON.stringify(r)],{type:cne}),"model.json"),e.weightData!=null){let a=pl.join(e.weightData);t.body.append("model.weights.bin",new Blob([a],{type:une}),"model.weights.bin")}let s=await this.fetch(this.path,t);if(s.ok)return{modelArtifactsInfo:m0(e),responses:[s]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`)}async loadModelJSON(){let e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let a=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?a+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":a+=" Please make sure the server is serving valid JSON for this request.",new Error(a)}let n=t.modelTopology,r=t.weightsManifest;if(n==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();let e=await this.loadModelJSON();return QS(e,t=>this.loadWeights(t))}async loadStream(){let e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=eC(e.weightsManifest),r=()=>one(t,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:r})}async getWeightUrls(e){let t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=dne(t),s=this.weightPathPrefix||n,a=[],i=[];for(let o of e)for(let u of o.paths)this.weightUrlConverter!=null?i.push(this.weightUrlConverter(u)):a.push(s+u+r);return this.weightUrlConverter&&a.push(...await Promise.all(i)),a}async loadWeights(e){let t=await this.getWeightUrls(e),n=eC(e),r=await O5(t,this.loadOptions);return[n,r]}};uN.URL_SCHEME_REGEX=/^https?:\/\//;function dne(e){let t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),r=e.substring(0,t),s=n>t?e.substring(n):"";return[r+"/",s]}function lC(e){return e.match(uN.URL_SCHEME_REGEX)!=null}var P5=(e,t)=>{if(typeof fetch>"u"&&(t==null||t.fetchFunc==null))return null;{let n=!0;if(Array.isArray(e)?n=e.every(r=>lC(r)):n=lC(e),n)return cN(e,t)}return null};ja.registerSaveRouter(P5);ja.registerLoadRouter(P5);function cN(e,t){return new uN(e,t)}function hne(e,t){return cN(e,t)}var nk=class{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}},B5=class{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}},pne=class{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}};function fne(e,t,n,r){let s=arguments;return new pne(z5(...s))}function z5(e,t,n,r){return arguments.length===1?e.modelTopology!=null||e.weightSpecs!=null?new nk(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new nk({modelTopology:e})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new nk({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:r}))}function mne(e){return new B5(e)}function gne(e){return new B5(e)}var W5={};Pt(W5,{confusionMatrix:()=>yne});function bne(e,t,n){let r=W(e,"labels","confusionMatrix"),s=W(t,"predictions","confusionMatrix");H(n==null||n>0&&Number.isInteger(n),()=>`If provided, numClasses must be a positive integer, but got ${n}`),H(r.rank===1,()=>`Expected the rank of labels to be 1, but got ${r.rank}`),H(s.rank===1,()=>`Expected the rank of predictions to be 1, but got ${s.rank}`),H(r.shape[0]===s.shape[0],()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${s.shape[0]}. Labels and predictions should have the same number of elements.`),H(n>0&&Number.isInteger(n),()=>`numClasses is required to be a positive integer, but got ${n}`);let a=Bp(Ve(r,"int32"),n),i=Bp(Ve(s,"int32"),n),o=Gt(a),u=Ut(o,i);return Ve(u,"int32")}var yne=ne({confusionMatrix_:bne}),$0={};Pt($0,{draw:()=>Nne,fromPixels:()=>Tne,fromPixelsAsync:()=>kne,toPixels:()=>Sne});var lc,aR=!1;function V5(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(e==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,s=!1,a=!1,i=!1,o=!1;if(e.data instanceof Uint8Array)n=!0;else if(typeof ImageData<"u"&&e instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&e instanceof HTMLVideoElement)s=!0;else if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement)a=!0;else if(e.getContext!=null)i=!0;else if(typeof ImageBitmap<"u"&&e instanceof ImageBitmap)o=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);if(oy(ox,J.backendName)!=null){let h={pixels:e},p={numChannels:t};return J.runKernel(ox,h,p)}let[u,c]=s?[e.videoWidth,e.videoHeight]:[e.width,e.height],l;if(i)l=e.getContext("2d").getImageData(0,0,u,c).data;else if(r||n)l=e.data;else if(a||s||o){if(lc==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")lc=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else lc=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});lc.canvas.width=u,lc.canvas.height=c,lc.drawImage(e,0,0,u,c),l=lc.getImageData(0,0,u,c).data}let d;if(t===4)d=new Int32Array(l);else{let h=u*c;d=new Int32Array(h*t);for(let p=0;p<h;p++)for(let f=0;f<t;++f)d[p*t+f]=l[p*4+f]}return Qw(d,[c,u,t],"int32")}function xne(e){return e!=null&&e.data instanceof Uint8Array}function wne(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function vne(e){return e!=null&&e.width!==0&&e.height!==0}function Ine(e){return wne()&&!(e instanceof ImageBitmap)&&vne(e)&&!xne(e)}async function kne(e,t=3){let n=null;if(ge().getBool("WRAP_TO_IMAGEBITMAP")&&Ine(e)){let r;try{r=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch{r=null}r!=null&&r.width===e.width&&r.height===e.height?n=r:n=e}else n=e;return V5(n,t)}function U5(e){if(e.rank!==2&&e.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);let t=e.rank===2?1:e.shape[2];if(t>4||t===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);if(e.dtype!=="float32"&&e.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`)}function Cne(e){let t=e?.alpha||1;if(t>1||t<0)throw new Error(`Alpha value ${t} is suppoed to be in range [0 - 1].`)}async function Sne(e,t){let n=W(e,"img","toPixels");if(!(e instanceof Wt)){let c=n;n=Ve(c,"int32"),c.dispose()}U5(n);let[r,s]=n.shape.slice(0,2),a=n.rank===2?1:n.shape[2],i=await n.data(),o=n.dtype==="float32"?255:1,u=new Uint8ClampedArray(s*r*4);for(let c=0;c<r*s;++c){let l=[0,0,0,255];for(let h=0;h<a;h++){let p=i[c*a+h];if(n.dtype==="float32"){if(p<0||p>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${p}.`)}else if(n.dtype==="int32"&&(p<0||p>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${p}.`);a===1?(l[0]=p*o,l[1]=p*o,l[2]=p*o):l[h]=p*o}let d=c*4;u[d+0]=Math.round(l[0]),u[d+1]=Math.round(l[1]),u[d+2]=Math.round(l[2]),u[d+3]=Math.round(l[3])}if(t!=null){aR||oy(gw,J.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),aR=!0),t.width=s,t.height=r;let c=t.getContext("2d"),l=new ImageData(u,s,r);c.putImageData(l,0,0)}return n!==e&&n.dispose(),u}function Nne(e,t,n){let r=W(e,"img","draw");if(!(e instanceof Wt)){let i=r;r=Ve(i,"int32"),i.dispose()}U5(r),Cne(n?.imageOptions);let s={image:r},a={canvas:t,options:n};J.runKernel(gw,s,a)}var Tne=ne({fromPixels_:V5}),dN={};Pt(dN,{prepareAndValidate:()=>G5});function G5(e,t){let n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(_n(e.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);let s=t.shape,a=s[s.length-1],i=1;for(let d=0;d<s.length-1;++d)i*=s[d];let o=e.shape,u=s.slice();u.pop();let c=1;for(let d=a;d<n;++d)c*=o[d],u.push(o[d]);let l=[...hf(e.shape).map(d=>d/c),1].slice(0,a);return[u,i,c,l]}var Gr={};Pt(Gr,{assertParamsValid:()=>Ane,computeFlatOffset:()=>Fne,computeOutShape:()=>Rne,getNormalizedAxes:()=>_ne,isSliceContinous:()=>Dne,maskToAxes:()=>$ne,parseSliceParams:()=>Z5,sliceInfo:()=>Mne,startForAxis:()=>Y5,startIndicesWithElidedDims:()=>K5,stopForAxis:()=>J5,stopIndicesWithElidedDims:()=>X5,stridesForAxis:()=>Q5,stridesWithElidedDims:()=>H5});var uC=-2,Ene=-1;function Ane(e,t,n){let r=e.shape.length;H(r===t.length,()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`),H(r===n.length,()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)H(t[s]+n[s]<=e.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${t[s]+n[s]}) would overflow input.shape[${s}] (${e.shape[s]})`)}function $ne(e){let t=[],n=0;for(;e>0;)e&1&&t.push(n),e/=2,n++;return t}function Rne(e,t,n){let r=[];for(let s=0;s<e.length;s++)r[s]=Math.ceil((t[s]-e[s])/n[s]);return r}function H5(e,t,n,r){let s=[...e];for(let a=s.length;a<r.length;a++)s.push(1);for(let a=0;a<n;a++)a===0?s[t]=1:(s.splice(t,0,1),s.pop());return s}function j5(e,t,n){return n<=e?n:n-(t-1)}function q5(e,t){let n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function _ne(e,t,n,r,s,a,i,o,u){let c=e.length,l=new Array(c),d=new Array(c),h=new Array(c);if(t.length&&n>0){let p=t[0],f=n+1;l=K5(i,p,f,r,e),d=X5(o,p,f,s,e),h=H5(a,p,f,e)}else for(let p=0;p<c;p++)l[p]=Y5(i,r,a,e,p,u),d[p]=J5(o,s,a,e,p,u),h[p]=Q5(a,p,u);return{begin:l,end:d,strides:h}}function K5(e,t,n,r,s){let a=[...s],i=q5(n,t);for(let o=0;o<a.length;o++)if(i.indexOf(o)>-1)a[o]=0;else{let u=j5(t,n,o),c=r[u];e&1<<u&&(c=0),a[o]=c}return a}function X5(e,t,n,r,s){let a=[...s],i=q5(n,t);for(let o=0;o<a.length;o++)if(i.indexOf(o)>-1)a[o]=Number.MAX_SAFE_INTEGER;else{let u=j5(t,n,o),c=r[u];e&1<<u&&(c=Number.MAX_SAFE_INTEGER),a[o]=c}for(let o=0;o<a.length;o++){let u=s[o];a[o]<0&&(a[o]+=u),a[o]=ay(0,a[o],s[o])}return a}function Q5(e,t,n){let r=e[t];return(n&1<<t||r==null)&&(r=1),r}function Y5(e,t,n,r,s,a){let i=t[s],o=n[s]||1;(e&1<<s||a&1<<s||i==null)&&(o>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);let u=r[s];return i<0&&(i+=u),i=ay(0,i,u-1),i}function J5(e,t,n,r,s,a){let i=t[s],o=n[s]||1;(e&1<<s||a&1<<s||i==null)&&(o>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);let u=r[s];return i<0&&(i+=u),o>0?i=ay(0,i,u):i=ay(-1,i,u-1),i}function Dne(e,t,n){let r=n.length;for(let s=0;s<n.length;s++)if(n[s]>1){r=s;break}for(let s=r+1;s<n.length;s++)if(t[s]>0||n[s]!==e[s])return!1;return!0}function Fne(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function Z5(e,t,n){let r,s=e.shape.length;typeof t=="number"?r=[t,...new Array(s-1).fill(0)]:t.length<s?r=t.concat(new Array(s-t.length).fill(0)):r=t.slice(),r.forEach(i=>{H(i!==-1,()=>"slice() does not support negative begin indexing.")});let a;return n==null?a=new Array(s).fill(-1):typeof n=="number"?a=[n,...new Array(s-1).fill(-1)]:n.length<s?a=n.concat(new Array(s-n.length).fill(-1)):a=n,a=a.map((i,o)=>i>=0?i:(H(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${o}.`),e.shape[o]-r[o])),[r,a]}function Mne(e,t,n,r,s,a,i,o,u){let c;if(r==null?(c=new Array(t.length),c.fill(1)):c=r,i!=null&&i&i-1)throw new Error("Multiple ellipses in slice is not allowed.");let l=!1,d={dims:c.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:c.slice(),beginMask:s,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:u};for(let y=0;y<d.dims;y++)l&&1<<y&o&&d.numAddAxisAfterEllipsis++,1<<y&i&&(l=!0);l||(d.ellipsisMask|=1<<d.dims,d.dims++);let h={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};One(d,h);let p=!0,f=!0,m=!0,g=[],b=[];for(let y=0;y<e.length;++y){if(h.strides[y]===0)throw Error(`strides[${y}] must be non-zero`);let x=!!(h.shrinkAxisMask&1<<y),w=e[y];if(w===-1){g.push(x?1:-1);continue}let v=[h.beginMask&1<<y,h.endMask&1<<y],I=[h.strides[y]>0?0:-1,h.strides[y]>0?w:w-1];if(x&&h.strides[y]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&h.strides[y]===1;let N=!!(h.beginMask&1<<y&&h.endMask&1<<y);if(h.beginValid&&h.endValid){if(x){let k=h.begin[y]<0?w+h.begin[y]:h.begin[y];if(h.begin[y]=k,h.end[y]=h.begin[y]+1,k<0||k>=w)throw Error(`slice index ${h.begin[y]} of dimension ${y} out of bounds.`)}else h.begin[y]=iR(h.begin[y],0,h.strides[y],w,v,I),h.end[y]=iR(h.end[y],1,h.strides[y],w,v,I);let A=h.strides[y]===1&&h.begin[y]===0&&h.end[y]===w;p=p&&A,f=f&&(y===0&&h.strides[y]===1||A)}else p=p&&h.strides[y]===1&&N,f=f&&(y===0&&h.strides[y]===1||N);let T,E=!1;if(h.beginValid&&h.endValid?(T=h.end[y]-h.begin[y],E=!0):x?(T=1,E=!0):N&&w>=0&&(h.strides[y]<0?T=-w:T=w,E=!0),E){let A;T===0||T<0!=h.strides[y]<0?A=0:A=Math.trunc(T/h.strides[y])+(T%h.strides[y]!==0?1:0),g.push(A)}else g.push(-1)}for(let y=0;y<h.finalShapeGatherIndices.length;++y){let x=h.finalShapeGatherIndices[y];x>=0?b.push(g[x]):x===uC&&b.push(1)}return{finalShapeSparse:b.filter((y,x)=>h.finalShapeGatherIndices[x]!==uC),finalShape:b,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:h.begin,end:h.end,strides:h.strides}}function One(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=e.begin!=null,t.endValid=e.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){let s=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<s;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(uC),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);e.begin!=null&&(t.begin[n]=e.begin[r]),e.end!=null&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(Ene),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}function iR(e,t,n,r,s,a){if(s[t])return n>0?a[t]:a[t+1&1];{let i=e<0?r+e:e;return i<a[0]?a[0]:i>a[1]?a[1]:i}}var Lne="4.22.0",eM=class{static sgd(e){return new iv(e)}static momentum(e,t,n=!1){return new oN(e,t,n)}static rmsprop(e,t=.9,n=0,r=null,s=!1){return new lN(e,t,n,r,s)}static adam(e=.001,t=.9,n=.999,r=null){return new aN(e,t,n,r)}static adadelta(e=.001,t=.95,n=null){return new rN(e,t,n)}static adamax(e=.002,t=.9,n=.999,r=null,s=0){return new iN(e,t,n,r,s)}static adagrad(e,t=.1){return new sN(e,t)}},pc=eM,Pne=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:e=>e();function hN(){return new Promise(e=>Pne(()=>e()))}var P={};Pt(P,{ERF_A1:()=>Zne,ERF_A2:()=>ere,ERF_A3:()=>tre,ERF_A4:()=>nre,ERF_A5:()=>rre,ERF_P:()=>Jne,PARALLELIZE_THRESHOLD:()=>pN,RowPartitionType:()=>uo,SELU_SCALE:()=>nM,SELU_SCALEALPHA:()=>tM,applyActivation:()=>sv,assertAndGetBroadcastShape:()=>zn,assertAxesAreInnerMostDims:()=>MJ,assertParamsConsistent:()=>Bne,assignToTypedArray:()=>ure,axesAreInnerMostDims:()=>C3,calculateShapes:()=>u5,checkEinsumDimSizes:()=>mre,checkPadOnDimRoundingMode:()=>Ks,combineLocations:()=>$6,combineRaggedTensorToTensorShapes:()=>Wne,complexWithEvenIndex:()=>ire,complexWithOddIndex:()=>ore,computeConv2DInfo:()=>g0,computeConv3DInfo:()=>v6,computeDefaultPad:()=>i3,computeDilation2DInfo:()=>DY,computeOptimalWindowSize:()=>Hne,computeOutAndReduceShapes:()=>R6,computeOutShape:()=>zne,computePool2DInfo:()=>w6,computePool3DInfo:()=>FY,convertConv2DDataFormat:()=>I6,decodeEinsumEquation:()=>pre,eitherStridesOrDilationsAreOne:()=>Mo,expandShapeToKeepDim:()=>Hc,exponent:()=>dre,exponents:()=>cre,fromStringArrayToUint8:()=>Ore,fromUint8ToStringArray:()=>Mre,getAxesPermutation:()=>_6,getBroadcastDims:()=>E6,getComplexWithIndex:()=>lre,getEinsumComputePath:()=>gre,getEinsumPermutation:()=>fre,getFusedBiasGradient:()=>rv,getFusedDyActivation:()=>nv,getImageCenter:()=>jne,getInnerMostAxes:()=>OJ,getPermuted:()=>Kne,getRaggedRank:()=>Une,getReductionAxes:()=>Fr,getReshaped:()=>qne,getReshapedPermuted:()=>Xne,getRowPartitionTypesHelper:()=>Vne,getSliceBeginCoords:()=>Qne,getSliceSize:()=>Yne,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>wre,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>vre,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>Ire,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>Sre,getSparseReshapeInputOutputMismatchErrorMessage:()=>Tre,getSparseReshapeInputOutputMultipleErrorMessage:()=>Nre,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>kre,getSparseReshapeNegativeOutputDimErrorMessage:()=>Cre,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>Rre,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>Ere,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>Are,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>$re,getUndoAxesPermutation:()=>S3,isIdentityPermutation:()=>bre,log:()=>HX,mergeRealAndImagArrays:()=>sre,prepareAndValidate:()=>G5,prepareSplitSize:()=>xre,segment_util:()=>rM,shouldFuse:()=>av,slice_util:()=>Gr,splitRealAndImagArrays:()=>are,stridesOrDilationsArePositive:()=>Gc,tupleValuesAreOne:()=>Zl,upcastType:()=>Ha,validateDefaultValueShape:()=>Gne,validateInput:()=>Jw,validateUpdateShape:()=>q3,warn:()=>Dl});function Bne(e,t){let n=e[0].length;e.forEach((s,a)=>{H(s.length===n,()=>`Error in concat${n}D: rank of tensors[${a}] must be the same as the rank of the rest (${n})`)}),H(t>=0&&t<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);let r=e[0];e.forEach((s,a)=>{for(let i=0;i<n;i++)H(i===t||s[i]===r[i],()=>`Error in concat${n}D: Shape of tensors[${a}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${a}.`)})}function zne(e,t){let n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}var uo;(function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"})(uo||(uo={}));function Wne(e,t,n){let r=new Array;if(n==null&&t==null)return r;if(t==null)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(n==null)return r;if(e+n.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let s=1;s<n.length;++s){let a=n[s],i=r[r.length-n.length+s],o=r[i];if(a>=0)if(o>=0){if(o!==a)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${s+e}] = ${a} but shape[${s+e}] = ${o}`)}else r[i]=a}return r}function Vne(e){let t={FIRST_DIM_SIZE:uo.FIRST_DIM_SIZE,VALUE_ROWIDS:uo.VALUE_ROWIDS,ROW_LENGTHS:uo.ROW_LENGTHS,ROW_SPLITS:uo.ROW_SPLITS,ROW_LIMITS:uo.ROW_LIMITS,ROW_STARTS:uo.ROW_STARTS},n=[];for(let r of e)if(r in t)n.push(t[r]);else break;return n}function Une(e){return e.length===0?0:e[0]===uo.FIRST_DIM_SIZE?e.length-1:e.length}function Gne(e,t){if(e==null||t==null)return;let n=e.length,r=t.length;if(n>=r)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let s=0;s<Math.min(n,r-1);++s){let a=e[s],i=t[s+1];if(a>=0&&i>=0&&a!==1&&a!==i)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${s-e.length}] = ${a} but ragged tensor input.flatValues.shape[${s-e.length}] = ${i}`)}}var pN=30;function Hne(e){return e<=pN?e:ix(e,Math.floor(Math.sqrt(e)))}function jne(e,t,n){let r=n*(typeof e=="number"?e:e[0]),s=t*(typeof e=="number"?e:e[1]);return[r,s]}function qne(e,t,n,r=!0){let s=[];if(r)s=s.concat(t.slice(0)),s.push(e[0]/n),s=s.concat(e.slice(1));else{s=s.concat(e[0]);let a=t.length;for(let i=0;i<a;++i)s=s.concat([e[i+1]/t[i],t[i]]);s=s.concat(e.slice(a+1))}return s}function Kne(e,t,n=!0){let r=[];if(n){r.push(t);for(let s=t+1;s<e;++s)s<=2*t?(r.push(s),r.push(s-(t+1))):r.push(s)}else{let s=[],a=[];for(let i=1;i<e;++i)i>=t*2+1||i%2===1?a.push(i):s.push(i);r.push(...s),r.push(0),r.push(...a)}return r}function Xne(e,t,n,r=!0){let s=[];r?s.push(e[0]/n):s.push(e[0]*n);for(let a=1;a<e.length;++a)a<=t.length?r?s.push(t[a-1]*e[a]):s.push(e[a]/t[a-1]):s.push(e[a]);return s}function Qne(e,t){let n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function Yne(e,t,n){let r=e.slice(0,1);for(let s=0;s<n;++s)r.push(e[s+1]-t[s][0]-t[s][1]);return r}var tM=1.7580993408473768,nM=1.0507009873554805,Jne=.3275911,Zne=.254829592,ere=-.284496736,tre=1.421413741,nre=-1.453152027,rre=1.061405429;function sre(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);let n=new Float32Array(e.length*2);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function are(e){let t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function ire(e){let t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let s=0;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],r[Math.floor(s/4)]=e[s+1];return{real:n,imag:r}}function ore(e){let t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let s=2;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],r[Math.floor(s/4)]=e[s+1];return{real:n,imag:r}}function lre(e,t){let n=e[t*2],r=e[t*2+1];return{real:n,imag:r}}function ure(e,t,n,r){e[r*2]=t,e[r*2+1]=n}function cre(e,t){let n=new Float32Array(e/2),r=new Float32Array(e/2);for(let s=0;s<Math.ceil(e/2);s++){let a=(t?2:-2)*Math.PI*(s/e);n[s]=Math.cos(a),r[s]=Math.sin(a)}return{real:n,imag:r}}function dre(e,t,n){let r=(n?2:-2)*Math.PI*(e/t),s=Math.cos(r),a=Math.sin(r);return{real:s,imag:a}}var rk="->",hre=/->/g,oR=",",lR="...";function pre(e,t){e=e.replace(/\s/g,"");let n=(e.length-e.replace(hre,"").length)/rk.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${rk}").`);let[r,s]=e.split(rk);H(r.indexOf(lR)===-1,()=>`The ellipsis notation ("${lR}") is not supported yet.`);let a=r.split(oR),i=a.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let o=[];for(let h=0;h<s.length;++h){let p=s[h];if(!a.some(f=>f.indexOf(p)!==-1))throw new Error(`Output subscripts contain the label ${p} not present in the input subscripts.`);o.indexOf(p)===-1&&o.push(p)}for(let h=0;h<r.length;++h){let p=r[h];o.indexOf(p)===-1&&p!==oR&&o.push(p)}let u=new Array(a.length);for(let h=0;h<i;++h){if(new Set(a[h].split("")).size!==a[h].length)throw new Error(`Found duplicate axes in input component ${a[h]}. Support for duplicate axes in input is not implemented yet.`);u[h]=[];for(let p=0;p<a[h].length;++p)u[h].push(o.indexOf(a[h][p]))}let c=o.length,l=s.length,d=[];for(let h=l;h<c;++h)d.push(h);return{allDims:o,summedDims:d,idDims:u}}function fre(e,t){let n=new Array(e);n.fill(-1);for(let s=0;s<t.length;++s)n[t[s]]=s;let r=[];for(let s=0;s<e;++s)n[s]===-1&&r.push(s);return n=n.filter(s=>s!==-1),{permutationIndices:n,expandDims:r}}function mre(e,t,n){let r=new Array(e);for(let s=0;s<n.length;++s){let a=n[s].shape;for(let i=0;i<t[s].length;++i)r[t[s][i]]===void 0?r[t[s][i]]=a[i]:H(r[t[s][i]]===a[i],()=>`Expected dimension ${r[t[s][i]]} at axis ${i} of input shaped ${JSON.stringify(a)}, but got dimension ${a[i]}`)}}function gre(e,t){let n=e,r=[],s=0;e.length===0&&n.push(-1),s=e.length+1;for(let i=0;i<s;++i)r.push([]);let a=[];for(let i=0;i<n.length;++i){let o=n[i],u=yre(t,o);for(let c of u)a.indexOf(c)===-1&&(r[i].push(c),a.push(c))}return{path:n,steps:r}}function bre(e){return e.every((t,n)=>t===n)}function yre(e,t){let n=[];for(let r=0;r<e.length;++r)(e[r].length===0||e[r].indexOf(t)!==-1||t===-1)&&n.push(r);return n}function xre(e,t,n=0){let r=[];if(typeof t=="number")H(e.shape[n]%t===0,()=>"Number of splits must evenly divide the axis."),r=new Array(t).fill(e.shape[n]/t);else{let s=t.reduce((i,o)=>(o===-1&&(i+=1),i),0);H(s<=1,()=>"There should be only one negative value in split array.");let a=t.indexOf(-1);if(a!==-1){let i=t.reduce((o,u)=>u>0?o+u:o);t[a]=e.shape[n]-i}H(e.shape[n]===t.reduce((i,o)=>i+o),()=>"The sum of sizes must match the size of the axis dimension."),r=t}return r}function wre(e){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${e}`}function vre(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function Ire(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function kre(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function Cre(e,t){return`size ${e} must be non-negative, not ${t}`}function Sre(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Nre(e,t){let n=_n(e),r=_n(t);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${e} outputShape= ${t}`}function Tre(e,t){let n=_n(e),r=_n(t);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${r}. inputShape=${e} outputShape=${t}`}function Ere(){return"segment ids must be >= 0"}function Are(){return"segment ids are not increasing"}function $re(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function Rre(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}var rM={};Pt(rM,{collectGatherOpShapeInfo:()=>Fre,computeOutShape:()=>Dre,segOpComputeOptimalWindowSize:()=>_re});function _re(e,t){let n=!1,r;for(e<=pN?(r=e,n=!0):r=ix(e,Math.floor(Math.sqrt(e)));!n;)r>t||r===e?n=!0:r=ix(e,r+1);return r}function Dre(e,t,n){let r=[],s=e.length;for(let a=0;a<s;a++)a!==t?r.push(e[a]):r.push(n);return r}function Fre(e,t,n,r){let s=t.shape.length,a=e.shape.length;if(r!==0&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>a)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${a}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let d=0;d<r;++d)if(e.shape[d]!==t.shape[d])throw new Error(`x.shape[${d}]: ${e.shape[d]} should be equal to indices.shape[${d}]: ${t.shape[d]}.`);let i=e.shape[n],o=[],u=1,c=1,l=1;for(let d=0;d<r;++d)o.push(e.shape[d]),u*=e.shape[d];for(let d=r;d<n;d++)o.push(e.shape[d]),c*=e.shape[d];for(let d=r;d<s;d++)o.push(t.shape[d]);for(let d=n+1;d<a;d++)o.push(e.shape[d]),l*=e.shape[d];return{batchSize:u,sliceSize:l,outerSize:c,dimSize:i,outputShape:o}}function Mre(e){try{return e.map(t=>ux(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function Ore(e){return e.map(t=>p0(t))}var Lo={};Pt(Lo,{nonMaxSuppressionV3Impl:()=>k5,nonMaxSuppressionV4Impl:()=>C5,nonMaxSuppressionV5Impl:()=>S5,whereImpl:()=>h5});Zte();var sM={kernelName:pf,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>se(e,Bh(Ve(n,"float32"),-1))}}},Lre={kernelName:yd,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=Pn(Ve(n,"float32")),s=ls(et(vt(1),r));return Jn(it(e,s))}}}},Pre={kernelName:xd,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=ls(et(Pn(Ve(n,"float32")),1));return it(e,r)}}}},Bre={kernelName:yu,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=zn(n.shape,r.shape);return{a:()=>{let a=e,i=Fr(n.shape,s);return i.length>0&&(a=dt(a,i)),ae(a,n.shape)},b:()=>{let a=e,i=Fr(r.shape,s);return i.length>0&&(a=dt(a,i)),ae(a,r.shape)}}}},zre={kernelName:wd,saveAllInputs:!0,gradFunc:(e,t)=>{let n={};return t.forEach((r,s)=>{n[s]=()=>e.clone()}),n}},Wre={kernelName:gf,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>sn(n)}}},Vre={kernelName:bf,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>sn(n)}}},Ure={kernelName:vd,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>it(e,ls(et(vt(1),Pn(Ve(n,"float32")))))}}},Gre={kernelName:Id,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=ls(Se(vt(1),Pn(Ve(n,"float32"))));return it(e,r)}}}},Hre={kernelName:Sd,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=zn(n.shape,r.shape);return{a:()=>{let a=Se(Pn(n),Pn(r)),i=se(e,it(r,a)),o=Fr(n.shape,s);return o.length>0&&(i=dt(i,o)),ae(i,n.shape)},b:()=>{let a=Se(Pn(n),Pn(r)),i=Jn(se(e,it(n,a))),o=Fr(r.shape,s);return o.length>0&&(i=dt(i,o)),ae(i,r.shape)}}}},jre={kernelName:kd,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>it(e,Se(Pn(Ve(n,"float32")),1))}}},qre={kernelName:Cd,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>it(e,et(vt(1),Pn(Ve(n,"float32"))))}}};function Kre(e,t,n,r,s,a){let i=W(e,"dy","avgPool3dGrad"),o=W(t,"input","avgPool3dGrad"),u=i,c=o,l=!1;o.rank===4&&(l=!0,u=ae(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),c=ae(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),H(u.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),H(c.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${c.rank}.`),Ks("avgPool3dGrad",s,a);let d={dy:u,input:c},h={filterSize:n,strides:r,pad:s,dimRoundingMode:a},p=J.runKernel(Hy,d,h);return l?ae(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var Xre=ne({avgPool3dGrad_:Kre}),Qre={kernelName:yf,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:s,strides:a,pad:i,dimRoundingMode:o}=n;return{x:()=>Xre(e,r,s,a,i,o)}}};function Yre(e,t,n,r,s){let a=W(e,"dy","avgPoolGrad"),i=W(t,"input","avgPoolGrad");H(i.rank===a.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${a.rank})`);let o=i,u=a,c=!1;i.rank===3&&(c=!0,o=ae(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=ae(a,[1,a.shape[0],a.shape[1],a.shape[2]])),H(u.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${u.rank}.`),H(o.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);let l={dy:u,input:o},d={filterSize:n,strides:r,pad:s},h=J.runKernel(Gy,l,d);return c?ae(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var Jre=ne({avgPoolGrad_:Yre}),Zre={kernelName:Nd,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:s,strides:a,pad:i}=n;return{x:()=>Jre(e,r,s,a,i)}}},ese={kernelName:Td,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{let[r,s]=t,{transposeA:a,transposeB:i}=n;return!a&&!i?{a:()=>Ut(e,s,!1,!0),b:()=>Ut(r,e,!0,!1)}:!a&&i?{a:()=>Ut(e,s,!1,!1),b:()=>Ut(e,r,!0,!1)}:a&&!i?{a:()=>Ut(s,e,!1,!0),b:()=>Ut(r,e,!1,!1)}:{a:()=>Ut(s,e,!0,!0),b:()=>Ut(e,r,!0,!0)}}},tse={kernelName:xf,gradFunc:(e,t,n)=>{let{blockShape:r,crops:s}=n;return{x:()=>S0(e,r,s)}}},nse={kernelName:UF,gradFunc:(e,t,n)=>{let r=n,s=r.inputShape,a=r.shape,i=Array.from(a);for(let u=s.length-1;u>=0;u--)if(s[u]===a[u])i[u]=1;else if(s[u]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${a}].`);let o=[];for(let u=0;u<i.length;u++)i[u]>1&&o.push(u);return{x:()=>dt(e,o,!0)}}},rse={kernelName:Ed,gradFunc:e=>({x:()=>e.clone()})},sse={kernelName:Ad,gradFunc:e=>({x:()=>sn(e)})},ase={kernelName:xu,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{clipValueMin:s,clipValueMax:a}=n;return{x:()=>os(di(ml(r,s),ku(r,a)),e,sn(e))}}},ise={kernelName:qy,inputsToSave:["x"],gradFunc:sM.gradFunc},ose={kernelName:If,saveAllInputs:!0,gradFunc:(e,t,n)=>{let r=t.map(o=>o.shape),{axis:s}=n,a=mi(s,t[0].shape)[0],i=r.map(o=>o[a]);return sa(e,i,a).map(o=>()=>o)}},lse={kernelName:$d,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,s]=t,{dilations:a,strides:i,pad:o,dataFormat:u}=n;return H(Zl(a),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`),{x:()=>b3(r.shape,e,s,i,o,u),filter:()=>eN(r,e,s.shape,i,o,u)}}},use={kernelName:Rd,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{let[r,s]=t,{strides:a,pad:i,dataFormat:o,dimRoundingMode:u}=n;return{dy:()=>Vs(e,s,a,i,o,1,u),filter:()=>eN(e,r,s.shape,a,i,o,u)}}};function cse(e,t,n,r,s){let a=e;e.rank===4&&(a=ae(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;i.rank===4&&(i=ae(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),H(a.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${a.shape}.`),H(i.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),H(n.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),H(a.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${a.shape[4]}) must match input depth in filter (${n[3]}.`),H(i.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`);let o={x:a,dy:i},u={strides:r,pad:s,filterShape:n};return J.runKernel(kf,o,u)}var dse=ne({conv3DBackpropFilter_:cse}),hse={kernelName:_d,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:s,pad:a}=n;H(Zl(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);let[i,o]=t;return{x:()=>N6(i.shape,e,o,s,a),filter:()=>dse(i,e,o.shape,s,a)}}},pse={kernelName:Dd,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>se(Jn(Hw(Ve(n,"float32"))),e)}}},fse={kernelName:Fd,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>se(jw(Ve(n,"float32")),e)}}},mse={kernelName:Md,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:s,exclusive:a,reverse:i}=n;return{x:()=>{let o=_6([s],r.rank),u=Dw(e,s,a,!i);return o!=null&&(u=Gt(u,o)),u}}}},gse={kernelName:Od,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:s,pad:a,dimRoundingMode:i}=n,o=r??[1,1];H(Zl(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);let[u,c]=t;return H(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${u.rank}.`),H(c.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${c.rank}.`),H(u.shape[3]===c.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`),H(Mo(s,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${o}'.`),Ks("depthwiseConv2d",a,i),{x:()=>w5(u.shape,e,c,s,a,o,i),filter:()=>x5(u,e,c.shape,s,a,o,i)}}},bse={kernelName:Ld,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,s]=t,a={x:r,filter:s,dy:e},i={x:r,filter:s,dy:e};return{x:()=>J.runKernel(Fp,a,n),filter:()=>J.runKernel(Mp,i,n)}}},yse={kernelName:Bd,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t,r={dy:e,y:n};return{x:()=>J.runKernel(Ef,r)}}},xse={kernelName:zd,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=se(Is(Jn(Pn(n))),2/Math.sqrt(Math.PI));return{x:()=>se(e,r)}}},wse={kernelName:Wd,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>se(e,n)}}},vse={kernelName:$f,inputsToSave:["input"],gradFunc:(e,t)=>{let[n]=t;return{input:()=>ae(e,n.shape)}}},Ise={kernelName:Vd,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>se(e,Is(n))}}},kse={kernelName:Ud,gradFunc:e=>({x:()=>sn(e)})},Cse={kernelName:Gd,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=zn(n.shape,r.shape);return{a:()=>{let a=it(e,Ve(r,"float32")),i=Fr(n.shape,s);return i.length>0?ae(dt(a,i),n.shape):a},b:()=>{let a=se(e,Ve(n,"float32")),i=Fr(r.shape,s);i.length>0&&(a=ae(dt(a,i),r.shape));let o=Pn(r);return Jn(it(a,Ve(o,"float32")))}}}},Sse={kernelName:Hd,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{let{varianceEpsilon:r}=n,[s,a,i,o]=t,u=o??vt(1),c=Fr(a.shape,s.shape),l=[];if(a.rank===1){for(let m=0;m<s.shape.length-1;++m)l.push(s.shape[m]);l.push(1)}let d=et(s,a),h=se(e,u),p=Uw(Se(i,vt(r))),f=se(se(se(p,p),p),vt(-.5));return{x:()=>a.rank===1?ae(se(se(e,Ia(ae(p,[1,1,1,a.shape[0]]),l)),u),s.shape):ae(se(se(e,p),u),s.shape),mean:()=>{let m=se(se(p,vt(-1)),h);return a.rank===1&&(m=dt(m,c)),ae(m,a.shape)},variance:()=>{let m=se(se(f,d),h);return a.rank===1&&(m=dt(m,c)),ae(m,a.shape)},scale:()=>{let m=se(d,p),g=se(e,m);return a.rank===1&&(g=dt(g,c)),ae(g,a.shape)},offset:()=>{let m=e;return a.rank===1&&(m=dt(m,c)),ae(m,a.shape)}}}},Nse={kernelName:_f,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{let[r,s]=t,{axis:a,batchDims:i}=n,o=mi(a,r.shape)[0],u=(c,l,d)=>()=>{let h=c.shape,p=l.size,f=h.slice(0,o),m=f.length,g=h.slice(a,h.length).slice(1),b=g.length,y=uR(0,m),x=uR(m+1,m+1+b),w=cR([f,[p],g]),v=ae(d,w),I=ae(l,[p]),N=cR([[m],y,x]),T=Gt(v,N),E=ev(T,I,c.shape[o]),A=S3(N);return E=Gt(E,A),E};if(i===1){let c=r.shape[0],l=r.split(c,0);return{x:()=>Dr(l.map((d,h)=>u(d,s.slice(h,1),e.slice(h,1))())).reshape(r.shape),indices:()=>s}}else return{x:u(r,s,e),indices:()=>s}}};function uR(e,t){let n=[];for(let r=e;r<t;++r)n.push(r);return n}function cR(e){let t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}var Tse={kernelName:jd,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>sn(n),b:()=>sn(r)}}},Ese={kernelName:qd,gradFunc:e=>({x:()=>Ve(e,"float32")})},Ase={kernelName:Kd,gradFunc:e=>({x:()=>sn(e)})},$se={kernelName:Xd,gradFunc:e=>({x:()=>sn(e)})},Rse={kernelName:Qd,gradFunc:e=>({x:()=>sn(e)})},_se={kernelName:Yd,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{alpha:s}=n,a=Xs(r,0);return{x:()=>os(a,e,se(e,s))}}},Dse={kernelName:Zd,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>it(e,Se(n,1))}}},Fse={kernelName:Jd,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>it(e,Ve(n,"float32"))}}},Mse={kernelName:HF,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{axis:s}=n;return{logits:()=>{let a=Is(r);return et(e,se(dt(e,s,!0),a))}}}};function Ose(e,t,n,r=5,s=1,a=1,i=.5){let o={x:e,y:t,dy:n},u={depthRadius:r,bias:s,alpha:a,beta:i};return J.runKernel(Wf,o,u)}var Lse=ne({localResponseNormalizationBackprop_:Ose}),Pse={kernelName:eh,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,s]=t,{depthRadius:a,bias:i,alpha:o,beta:u}=n;return{x:()=>Lse(r,s,e,a,i,o,u)}}};function aM(e,t,n,r){return t.rank<n.rank&&(t=ae(t,Hc(t.shape,r))),e.rank<n.rank&&(e=ae(e,Hc(e.shape,r))),{x:()=>se(e,Ve(Na(n,t),e.dtype))}}var dR={kernelName:th,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{reductionIndices:s}=r,a=t[0],i=t[1],o=mi(s,a.shape),u=aM(e,i,a,o);return{x:()=>u.x()}}},Bse={kernelName:nh,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>se(e,Ve(ml(n,r),"float32")),b:()=>se(e,Ve(Pp(n,r),"float32"))}}};function zse(e,t,n,r,s,a,i){let o=W(e,"dy","maxPool3dGrad"),u=W(t,"input","maxPool3dGrad"),c=W(n,"output","maxPool3dGrad"),l=o,d=u,h=c,p=!1;u.rank===4&&(p=!0,l=ae(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),d=ae(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),h=ae(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),H(l.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),H(d.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),H(h.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${h.rank}.`),Ks("maxPool3dGrad",a,i);let f={dy:l,input:d,output:h},m={filterSize:r,strides:s,pad:a,dimRoundingMode:i},g=J.runKernel(Jy,f,m);return p?ae(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}var Wse=ne({maxPool3dGrad_:zse}),Vse={kernelName:Vf,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,s]=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:u}=n;return{x:()=>Wse(e,r,s,a,i,o,u)}}};function Use(e,t,n,r,s,a,i){let o=W(e,"dy","maxPoolGrad"),u=W(t,"input","maxPoolGrad"),c=W(n,"output","maxPoolGrad");H(u.rank===o.rank,()=>`Rank of input (${u.rank}) does not match rank of dy (${o.rank})`),H(o.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),H(u.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${u.rank}.`),Ks("maxPoolGrad",a,i);let l={dy:o,input:u,output:c},d={filterSize:r,strides:s,pad:a,dimRoundingMode:i};return J.runKernel(Yy,l,d)}var Gse=ne({maxPoolGrad_:Use}),Hse={kernelName:rh,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,s]=t,{filterSize:a,strides:i,pad:o}=n;return{x:()=>Gse(e,r,s,a,i,o)}}},jse={kernelName:sh,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:s}=n,a=mi(s,r.shape),i=R6(r.shape,a)[1],o=_n(i);return{x:()=>{let u=r.shape.slice();a.forEach(l=>{u[l]=1});let c=ae(e,u);return it(se(c,ra(r.shape,"float32")),o)}}}},qse={kernelName:ah,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{axis:s}=r,[a,i]=t,o=mi(s,a.shape),u=aM(e,i,a,o);return{x:()=>u.x()}}},Kse={kernelName:ih,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>se(e,Ve(ku(n,r),"float32")),b:()=>se(e,Ve(Xs(n,r),"float32"))}}},Xse={kernelName:oh,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:s}=n,a=s.map(i=>i[0]);return{x:()=>en(e,a,r.shape)}}},Qse={kernelName:lh,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=zn(n.shape,r.shape);return{a:()=>{let a=Fr(n.shape,s);return a.length>0?ae(dt(e,a),n.shape):e},b:()=>{let a=se(e,Jn(ym(it(n,r)))),i=Fr(r.shape,s);return i.length>0?ae(dt(a,i),r.shape):a}}}},Yse={kernelName:uh,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=zn(n.shape,r.shape);return{a:()=>{let a=se(e,Ve(r,"float32")),i=Fr(n.shape,s);return i.length>0?ae(dt(a,i),n.shape):a},b:()=>{let a=se(e,Ve(n,"float32")),i=Fr(r.shape,s);return i.length>0?ae(dt(a,i),r.shape):a}}}},Jse={kernelName:Gf,gradFunc:e=>({x:()=>Jn(e)})},Zse={kernelName:ch,inputsToSave:["indices"],gradFunc:(e,t)=>{let n=t[0];return{indices:()=>dr(n.shape,"float32")}}},eae={kernelName:Xf,gradFunc:e=>({x:()=>sn(e)})},tae={kernelName:Qf,saveAllInputs:!0,gradFunc:(e,t,n)=>{let{axis:r}=n;return br(e,r).map(s=>()=>s)}},hR={kernelName:dh,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:s}=n,a=s.map(i=>i[0]);return{x:()=>en(e,a,r.shape)}}},nae={kernelName:hh,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{let[n,r,s]=t,a=n,i=r,o=zn(a.shape,i.shape);return{a:()=>{let u=Ve(i,"float32"),c=se(e,se(u,To(a,et(u,vt(1))))),l=Fr(a.shape,o);return l.length>0&&(c=dt(c,l)),ae(c,a.shape)},b:()=>{let u=Xs(a,0),c=os(u,Ta(a),sn(a)),l=se(e,se(s,c)),d=Fr(i.shape,o);return d.length>0&&(l=dt(l,d)),ae(l,i.shape)}}}},rae={kernelName:ph,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{let[n,r]=t,s=Xs(n,0);return{x:()=>os(s,e,se(e,r)),alpha:()=>{let a=os(s,sn(e),se(e,n)),i=Fr(r.shape,e.shape);return i.length>0&&(a=dt(a,i)),ae(a,r.shape)}}}};function sae(e,t,n){let r=e.shape.slice();r[n]=1;let s=ae(t,r),a=py(e,n,!0,!1),i=py(e,n,!0,!0),o=se(a,i);return se(s,o)}function aae(e,t,n){let r=e.shape.length,s=r-n.length,a=P.getAxesPermutation(n,r),i=e;a!=null&&(i=Gt(e,a));let o=i.shape.slice(),u=o.splice(r-n.length,n.length).reduce((d,h)=>d*h,1);o.push(u);let c=i.reshape(o),l=sae(c,t,s);if(l=l.reshape(i.shape),a!=null){let d=P.getUndoAxesPermutation(a);l=Gt(l,d)}return l}var iae={kernelName:fh,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:s}=n,a=[];return s==null?a=r.shape.map((i,o)=>o):typeof s=="number"?a=[s]:a=s,{x:()=>aae(r,e,a)}}},oae={kernelName:Pd,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=zn(n.shape,r.shape);return{a:()=>{let a=it(e,Ve(r,"float32")),i=Fr(n.shape,s);return i.length>0?ae(dt(a,i),n.shape):a},b:()=>{let a=se(e,Ve(n,"float32")),i=Fr(r.shape,s);i.length>0&&(a=ae(dt(a,i),r.shape));let o=Pn(r);return Jn(it(a,Ve(o,"float32")))}}}},lae={kernelName:mh,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>it(e,Jn(Pn(n)))}}},uae={kernelName:xh,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=se(ku(n,6),Bh(n));return{x:()=>se(e,Ve(r,"float32"))}}},cae={kernelName:gh,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>se(e,Ve(Bh(n),"float32"))}}},dae={kernelName:Yf,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ae(e,n.shape)}}},hae={kernelName:yh,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,s={dy:e,images:r};return{images:()=>J.runKernel(Zf,s,n)}}},pae={kernelName:bh,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,s={dy:e,images:r};return{images:()=>J.runKernel(Jf,s,n)}}},fae={kernelName:wh,gradFunc:(e,t,n)=>{let{dims:r}=n,s=mi(r,e.shape);return{x:()=>qa(e,s)}}},mae={kernelName:vh,gradFunc:e=>({x:()=>sn(e)})},gae={kernelName:Ih,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Jn(it(e,se(To(n,1.5),2)))}}},bae={kernelName:rm,inputsToSave:["condition"],gradFunc:(e,t)=>{let[n]=t;return{condition:()=>Ve(sn(n),"float32"),t:()=>se(e,Ve(n,e.dtype)),e:()=>se(e,Ve(k0(n),e.dtype))}}},yae={kernelName:kh,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=Xs(n,vt(0)),s=vt(tM),a=vt(nM),i=se(e,a),o=se(se(e,s),Is(Ve(n,"float32")));return os(r,i,o)}}}},xae={kernelName:Th,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>se(e,se(n,et(vt(1),n)))}}},wae={kernelName:Nh,gradFunc:e=>({x:()=>sn(e)})},vae={kernelName:Ch,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>se(y0(Ve(n,"float32")),e)}}},Iae={kernelName:Sh,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>se(_w(Ve(n,"float32")),e)}}},kae={kernelName:sm,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{begin:s,size:a}=n,i=r.shape,[o,u]=Z5(r,s,a),c=[];for(let l=0;l<e.rank;l++)c.push([o[l],i[l]-o[l]-u[l]]);return{x:()=>Ji(e,c)}}},Cae={kernelName:Rh,outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{dim:s}=n,a=!0,i=se(e,r);return{logits:()=>et(i,se(dt(i,[s],a),r))}}},Sae={kernelName:Eh,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>se(e,ci(n))}}},pR={kernelName:am,gradFunc:(e,t,n)=>{let{blockShape:r,paddings:s}=n;return{x:()=>b0(e,r,s)}}},fR={kernelName:im,gradFunc:(e,t,n)=>{let{axis:r}=n;return{x:()=>Bn(e,r)}}},Nae={kernelName:Ah,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>it(e,se(ls(Ve(n,"float32")),2))}}},Tae={kernelName:s0,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>se(e,se(Ve(n,"float32"),2))}}},Eae={kernelName:_h,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=vt(2);return{a:()=>se(e,se(s,et(n,r))),b:()=>se(e,se(s,et(r,n)))}}},Aae={kernelName:vu,gradFunc:e=>({x:()=>sn(e)})},$ae={kernelName:Dh,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=zn(n.shape,r.shape);return{a:()=>{let a=e,i=Fr(n.shape,s);return i.length>0&&(a=dt(a,i)),ae(a,n.shape)},b:()=>{let a=e,i=Fr(r.shape,s);return i.length>0&&(a=dt(a,i)),ae(Jn(a),r.shape)}}}},Rae={kernelName:$h,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,s=r.shape.slice(),{axis:a}=n;mi(a,r.shape).forEach(u=>{s[u]=1});let i=ae(e,s),o=se(i,ra(r.shape,"float32"));return{x:()=>o}}},_ae={kernelName:Fh,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>it(e,Pn(y0(n)))}}},Dae={kernelName:Mh,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>se(et(vt(1),Pn(n)),e)}}},Fae={kernelName:wu,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{reps:s}=n;return{x:()=>{let a=sn(r);if(r.rank===1)for(let i=0;i<s[0];++i)a=Se(a,en(e,[i*r.shape[0]],[r.shape[0]]));else if(r.rank===2)for(let i=0;i<s[0];++i)for(let o=0;o<s[1];++o)a=Se(a,en(e,[i*r.shape[0],o*r.shape[1]],[r.shape[0],r.shape[1]]));else if(r.rank===3)for(let i=0;i<s[0];++i)for(let o=0;o<s[1];++o)for(let u=0;u<s[2];++u)a=Se(a,en(e,[i*r.shape[0],o*r.shape[1],u*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else if(r.rank===4)for(let i=0;i<s[0];++i)for(let o=0;o<s[1];++o)for(let u=0;u<s[2];++u)for(let c=0;c<s[3];++c)a=Se(a,en(e,[i*r.shape[0],o*r.shape[1],u*r.shape[2],c*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);return a}}}},Mae={kernelName:nl,gradFunc:(e,t,n)=>{let r=n,{perm:s}=r,a=S3(s);return{x:()=>Gt(e,a)}}},Oae={kernelName:hm,gradFunc:(e,t,n)=>{let r=n,{axis:s}=r;return{value:()=>Dr(e,s)}}},Lae={kernelName:c0,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Pae(e,n)}}};function Pae(e,t){let n=Oo(t,sn(t)),r=xm(e,n),s=ml(t,vt(0,"int32")),a=r.rank-s.rank;for(let o=0;o<a;++o)s=ns(s,o+1);s=di(s,ra(r.shape,"bool"));let i=sn(r);return os(s,r,i)}var Bae={kernelName:pm,gradFunc:e=>({x:()=>sn(e)})},zae=[sM,Lre,Pre,Bre,zre,Wre,Vre,Ure,Gre,Hre,jre,qre,Qre,Zre,ese,tse,nse,rse,sse,ase,ise,ose,use,lse,hse,pse,fse,mse,gse,bse,oae,yse,xse,wse,vse,Ise,Cse,kse,Sse,Nse,Tse,Ese,Ase,$se,Rse,_se,Dse,Fse,Mse,Pse,dR,dR,Bse,Vse,Hse,jse,qse,Kse,Xse,Qse,Yse,Jse,Zse,eae,tae,hR,hR,nae,rae,iae,lae,uae,cae,dae,hae,pae,fae,mae,gae,bae,yae,xae,wae,vae,Iae,kae,Cae,Sae,pR,pR,fR,fR,Nae,Eae,Tae,Aae,$ae,Rae,_ae,Dae,Fae,Mae,Oae,Lae,Bae];for(let e of zae)jF(e);Ne().prototype.abs=function(){return this.throwIfDisposed(),Ar(this)};Ne().prototype.acos=function(){return this.throwIfDisposed(),JS(this)};Ne().prototype.acosh=function(){return this.throwIfDisposed(),ZS(this)};Ne().prototype.add=function(e){return this.throwIfDisposed(),Se(this,e)};Ne().prototype.all=function(e,t){return this.throwIfDisposed(),Aw(this,e,t)};Ne().prototype.any=function(e,t){return this.throwIfDisposed(),cy(this,e,t)};Ne().prototype.argMax=function(e){return this.throwIfDisposed(),Uc(this,e)};Ne().prototype.argMin=function(e){return this.throwIfDisposed(),e3(this,e)};Ne().prototype.asScalar=function(){return this.throwIfDisposed(),H(this.size===1,()=>"The array must have only 1 element."),ae(this,[])};Ne().prototype.asType=function(e){return this.throwIfDisposed(),Ve(this,e)};Ne().prototype.as1D=function(){return this.throwIfDisposed(),ae(this,[this.size])};Ne().prototype.as2D=function(e,t){return this.throwIfDisposed(),ae(this,[e,t])};Ne().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),ae(this,[e,t,n])};Ne().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),ae(this,[e,t,n,r])};Ne().prototype.as5D=function(e,t,n,r,s){return this.throwIfDisposed(),ae(this,[e,t,n,r,s])};Ne().prototype.asin=function(){return this.throwIfDisposed(),t3(this)};Ne().prototype.asinh=function(){return this.throwIfDisposed(),n3(this)};Ne().prototype.atan=function(){return this.throwIfDisposed(),r3(this)};Ne().prototype.atan2=function(e){return this.throwIfDisposed(),s3(this,e)};Ne().prototype.atanh=function(){return this.throwIfDisposed(),a3(this)};Ne().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),fl(this,e,t,n,r)};Ne().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),b0(this,e,t)};Ne().prototype.batchNorm=function(e,t,n,r,s){return this.throwIfDisposed(),Oh(this,e,t,n,r,s)};Ne().prototype.broadcastTo=function(e){return this.throwIfDisposed(),Ec(this,e)};Ne().prototype.cast=function(e){return this.throwIfDisposed(),Ve(this,e)};Ne().prototype.ceil=function(){return this.throwIfDisposed(),h3(this)};Ne().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),vs(this,e,t)};Ne().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof Wt&&(e=[e]),Bn([this,...e],t)};Ne().prototype.conv1d=function(e,t,n,r,s,a){return this.throwIfDisposed(),$w(this,e,t,n,r,s,a)};Ne().prototype.conv2dTranspose=function(e,t,n,r,s){return this.throwIfDisposed(),Rw(this,e,t,n,r,s)};Ne().prototype.conv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),Vs(this,e,t,n,r,s,a)};Ne().prototype.cos=function(){return this.throwIfDisposed(),y0(this)};Ne().prototype.cosh=function(){return this.throwIfDisposed(),_w(this)};Ne().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),py(this,e,t,n)};Ne().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),Dw(this,e,t,n)};Ne().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),w3(this,e,t)};Ne().prototype.depthwiseConv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),Lh(this,e,t,n,r,s,a)};Ne().prototype.dilation2d=function(e,t,n,r,s){return this.throwIfDisposed(),v3(this,e,t,n,r,s)};Ne().prototype.divNoNan=function(e){return this.throwIfDisposed(),I3(this,e)};Ne().prototype.div=function(e){return this.throwIfDisposed(),it(this,e)};Ne().prototype.dot=function(e){return this.throwIfDisposed(),k3(this,e)};Ne().prototype.elu=function(){return this.throwIfDisposed(),gm(this)};Ne().prototype.equal=function(e){return this.throwIfDisposed(),Na(this,e)};Ne().prototype.erf=function(){return this.throwIfDisposed(),Fw(this)};Ne().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),N3(this,e,t)};Ne().prototype.exp=function(){return this.throwIfDisposed(),Is(this)};Ne().prototype.expandDims=function(e){return this.throwIfDisposed(),ns(this,e)};Ne().prototype.expm1=function(){return this.throwIfDisposed(),T3(this)};Ne().prototype.fft=function(){return this.throwIfDisposed(),E0(this)};Ne().prototype.flatten=function(){return this.throwIfDisposed(),ae(this,[this.size])};Ne().prototype.floor=function(){return this.throwIfDisposed(),ym(this)};Ne().prototype.floorDiv=function(e){return this.throwIfDisposed(),Ew(this,e)};Ne().prototype.gather=function(e,t,n){return this.throwIfDisposed(),xm(this,e,t,n)};Ne().prototype.greaterEqual=function(e){return this.throwIfDisposed(),ml(this,e)};Ne().prototype.greater=function(e){return this.throwIfDisposed(),Xs(this,e)};Ne().prototype.ifft=function(){return this.throwIfDisposed(),Vp(this)};Ne().prototype.irfft=function(){return this.throwIfDisposed(),Kw(this)};Ne().prototype.isFinite=function(){return this.throwIfDisposed(),E3(this)};Ne().prototype.isInf=function(){return this.throwIfDisposed(),A3(this)};Ne().prototype.isNaN=function(){return this.throwIfDisposed(),$3(this)};Ne().prototype.leakyRelu=function(e){return this.throwIfDisposed(),w0(this,e)};Ne().prototype.lessEqual=function(e){return this.throwIfDisposed(),ku(this,e)};Ne().prototype.less=function(e){return this.throwIfDisposed(),Pp(this,e)};Ne().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),R3(this,e,t,n,r)};Ne().prototype.logSigmoid=function(){return this.throwIfDisposed(),_3(this)};Ne().prototype.logSoftmax=function(e){return this.throwIfDisposed(),Lw(this,e)};Ne().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),I0(this,e,t)};Ne().prototype.log=function(){return this.throwIfDisposed(),Ta(this)};Ne().prototype.log1p=function(){return this.throwIfDisposed(),v0(this)};Ne().prototype.logicalAnd=function(e){return this.throwIfDisposed(),di(this,e)};Ne().prototype.logicalNot=function(){return this.throwIfDisposed(),k0(this)};Ne().prototype.logicalOr=function(e){return this.throwIfDisposed(),Pw(this,e)};Ne().prototype.logicalXor=function(e){return this.throwIfDisposed(),D3(this,e)};Ne().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),Ut(this,e,t,n)};Ne().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),Zr(this,e,t,n,r)};Ne().prototype.max=function(e,t){return this.throwIfDisposed(),Va(this,e,t)};Ne().prototype.maximum=function(e){return this.throwIfDisposed(),Oo(this,e)};Ne().prototype.mean=function(e,t){return this.throwIfDisposed(),cr(this,e,t)};Ne().prototype.min=function(e,t){return this.throwIfDisposed(),Lp(this,e,t)};Ne().prototype.minimum=function(e){return this.throwIfDisposed(),tu(this,e)};Ne().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),M3(this,e,t)};Ne().prototype.mod=function(e){return this.throwIfDisposed(),O3(this,e)};Ne().prototype.mul=function(e){return this.throwIfDisposed(),se(this,e)};Ne().prototype.neg=function(){return this.throwIfDisposed(),Jn(this)};Ne().prototype.norm=function(e,t,n){return this.throwIfDisposed(),bm(this,e,t,n)};Ne().prototype.notEqual=function(e){return this.throwIfDisposed(),jc(this,e)};Ne().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),Bp(this,e,t,n)};Ne().prototype.onesLike=function(){return this.throwIfDisposed(),Ea(this)};Ne().prototype.pad=function(e,t){return this.throwIfDisposed(),Ji(this,e,t)};Ne().prototype.pool=function(e,t,n,r,s,a){return this.throwIfDisposed(),L3(this,e,t,n,r,s,a)};Ne().prototype.pow=function(e){return this.throwIfDisposed(),To(this,e)};Ne().prototype.prelu=function(e){return this.throwIfDisposed(),N0(this,e)};Ne().prototype.prod=function(e,t){return this.throwIfDisposed(),P3(this,e,t)};Ne().prototype.reciprocal=function(){return this.throwIfDisposed(),U3(this)};Ne().prototype.relu=function(){return this.throwIfDisposed(),Rn(this)};Ne().prototype.relu6=function(){return this.throwIfDisposed(),Ww(this)};Ne().prototype.reshapeAs=function(e){return this.throwIfDisposed(),ae(this,e.shape)};Ne().prototype.reshape=function(e){return this.throwIfDisposed(),ae(this,e)};Ne().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),N5(this,e,t,n)};Ne().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),T5(this,e,t,n)};Ne().prototype.reverse=function(e){return this.throwIfDisposed(),qa(this,e)};Ne().prototype.rfft=function(){return this.throwIfDisposed(),A0(this)};Ne().prototype.round=function(){return this.throwIfDisposed(),Vw(this)};Ne().prototype.rsqrt=function(){return this.throwIfDisposed(),Uw(this)};Ne().prototype.selu=function(){return this.throwIfDisposed(),Gw(this)};Ne().prototype.separableConv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),wm(this,e,t,n,r,s,a)};Ne().prototype.sigmoid=function(){return this.throwIfDisposed(),ci(this)};Ne().prototype.sign=function(){return this.throwIfDisposed(),G3(this)};Ne().prototype.sin=function(){return this.throwIfDisposed(),Hw(this)};Ne().prototype.sinh=function(){return this.throwIfDisposed(),jw(this)};Ne().prototype.slice=function(e,t){return this.throwIfDisposed(),en(this,e,t)};Ne().prototype.softmax=function(e){return this.throwIfDisposed(),Su(this,e)};Ne().prototype.softplus=function(){return this.throwIfDisposed(),Ph(this)};Ne().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),S0(this,e,t)};Ne().prototype.split=function(e,t){return this.throwIfDisposed(),sa(this,e,t)};Ne().prototype.sqrt=function(){return this.throwIfDisposed(),ls(this)};Ne().prototype.square=function(){return this.throwIfDisposed(),Pn(this)};Ne().prototype.squaredDifference=function(e){return this.throwIfDisposed(),Xw(this,e)};Ne().prototype.squeeze=function(e){return this.throwIfDisposed(),Nu(this,e)};Ne().prototype.stack=function(e,t){this.throwIfDisposed();let n=e instanceof Wt?[this,e]:[this,...e];return Dr(n,t)};Ne().prototype.step=function(e){return this.throwIfDisposed(),Bh(this,e)};Ne().prototype.stridedSlice=function(e,t,n,r,s,a,i,o){return this.throwIfDisposed(),H3(this,e,t,n,r,s,a,i,o)};Ne().prototype.sub=function(e){return this.throwIfDisposed(),et(this,e)};Ne().prototype.sum=function(e,t){return this.throwIfDisposed(),dt(this,e,t)};Ne().prototype.tan=function(){return this.throwIfDisposed(),j3(this)};Ne().prototype.tanh=function(){return this.throwIfDisposed(),eu(this)};Ne().prototype.tile=function(e){return this.throwIfDisposed(),Ia(this,e)};Ne().prototype.toBool=function(){return this.throwIfDisposed(),Ve(this,"bool")};Ne().prototype.toFloat=function(){return this.throwIfDisposed(),Ve(this,"float32")};Ne().prototype.toInt=function(){return this.throwIfDisposed(),Ve(this,"int32")};Ne().prototype.topk=function(e,t){return this.throwIfDisposed(),K3(this,e,t)};Ne().prototype.transpose=function(e){return this.throwIfDisposed(),Gt(this,e)};Ne().prototype.unique=function(e){return this.throwIfDisposed(),X3(this,e)};Ne().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),ev(this,e,t)};Ne().prototype.unstack=function(e){return this.throwIfDisposed(),br(this,e)};Ne().prototype.where=function(e,t){return this.throwIfDisposed(),os(e,this,t)};Ne().prototype.zerosLike=function(){return this.throwIfDisposed(),sn(this)};var Al=class iM extends Error{constructor(t){super(t),Object.setPrototypeOf(this,iM.prototype)}},go=class oM extends Error{constructor(t){super(t),Object.setPrototypeOf(this,oM.prototype)}},oe=class lM extends Error{constructor(t){super(t),Object.setPrototypeOf(this,lM.prototype)}},Xt=class uM extends Error{constructor(t){super(t),Object.setPrototypeOf(this,uM.prototype)}},Wae=class cM extends Error{constructor(t){super(t),Object.setPrototypeOf(this,cM.prototype)}},dM=class{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){let n=this.cache.keys().next().value;this.cache.delete(n)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){let n=this.cache.keys().next().value;this.cache.delete(n)}this.maxEntries=e}};function Kc(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}else{let n=new Array(t);return n.fill(e),n}}function co(e,t){if(!e)throw new Wae(t)}function mR(e,t){let n=0;for(let r of e)r===t&&n++;return n}function ea(e){return e.length===1?e[0]:e}function An(e){return Array.isArray(e)?e:[e]}function Xo(e){let t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function yc(e){return e.length<=1||e.indexOf("_")===-1?e:e.replace(/[_]+(\w|$)/g,(t,n)=>n.toUpperCase())}var ei={};function fN(e){if(e==null)return null;let t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function cC(e){if(!(e==null||typeof e!="object"))if(Array.isArray(e))e.forEach(t=>cC(t));else{let t=Object.keys(e);for(let n of t){let r=e[n];r!=null&&typeof r=="object"&&(!Array.isArray(r)&&r.type==="ndarray"&&typeof r.value=="number"?e[n]=r.value:cC(r))}}}function R0(e,t={},n={},r="object",s=!1){if(typeof e=="string"){let a=e,i;if(a in n)i=n[a];else if(a in ei)i=ei[a];else if(i=t[a],i==null)throw new oe(`Unknown ${r}: ${e}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}else{let a=e;if(a.className==null||a.config==null)throw new oe(`${r}: Improper config format: ${JSON.stringify(a)}.
'className' and 'config' must set.`);let i=a.className,o,u;if(i in n?[o,u]=n[i]:i in ei?[o,u]=ei.className:i in t&&([o,u]=t[i]),o==null)throw new oe(`Unknown ${r}: ${i}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(u!=null){let c={};for(let p of Object.keys(ei))c[p]=ei[p];for(let p of Object.keys(n))c[p]=n[p];let l=a.config;l.customObjects=c;let d=Object.assign({},ei);for(let p of Object.keys(n))ei[p]=n[p];cC(a.config);let h=u(o,a.config,n,s);return ei=Object.assign({},d),h}else{let c=Object.assign({},ei);for(let d of Object.keys(n))ei[d]=n[d];let l=new o(a.config);return ei=Object.assign({},c),l}}}function Vae(e,t){return e<t?-1:e>t?1:0}function h2(e,t){return-1*Vae(e,t)}function Vl(e){if(e==null)return e;let t=[];for(let n of e)t.indexOf(n)===-1&&t.push(n);return t}function Uae(e){if(e==null)throw new oe(`Invalid value in obj: ${JSON.stringify(e)}`);for(let t in e)if(e.hasOwnProperty(t))return!1;return!0}function zh(e,t,n){if(n!=null&&e.indexOf(n)<0)throw new oe(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function mN(e,t,n=0,r=1/0){return co(n>=0),co(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every(s=>typeof s===t)}function as(e,t){Array.isArray(e)?($.assert(e.length>0,()=>`${t} is unexpectedly an empty array.`),e.forEach((n,r)=>as(n,`element ${r+1} of ${t}`))):$.assert(Number.isInteger(e)&&e>0,()=>`Expected ${t} to be a positive integer, but got ${hM(e)}.`)}function hM(e){return e===null?"null":Array.isArray(e)?"["+e.map(t=>hM(t)).join(",")+"]":typeof e=="string"?`"${e}"`:`${e}`}function Gae(e,t,n){let r=n!=null?n():$.now(),s;return(...a)=>{let i=n!=null?n():$.now();return i-r<t||(r=i,s=e(...a)),s}}function pM(e){return e==="relu"?"relu":e==="linear"?"linear":e==="elu"?"elu":null}var Hae=0;function fM(){return Hae++}var p2={};function ov(e=""){return e in p2||(p2[e]=0),p2[e]+=1,e+p2[e].toString()}var jae=["channelsFirst","channelsLast"],qae=["nearest","bilinear"],Kae=["valid","same","causal"],Xae=["max","avg"],Qae=["sum","mul","concat","ave"],hp=new Map;function kr(e){zh(jae,"DataFormat",e)}function Yae(e){zh(qae,"InterpolationFormat",e)}function Xa(e){zh(Kae,"PaddingMode",e)}function mM(e){zh(Xae,"PoolMode",e)}var Zb=[],gR="/";function Ac(e,t){Zb.push(e);try{let n=t();return Zb.pop(),n}catch(n){throw Zb.pop(),n}}function Jae(){return Zb.length===0?"":Zb.join(gR)+gR}function gM(e){if(!yM(e))throw new Error("Not a valid tensor name: '"+e+"'");return Jae()+e}function bM(e){if(!yM(e))throw new Error("Not a valid tensor name: '"+e+"'");hp.has(e)||hp.set(e,0);let t=hp.get(e);if(hp.set(e,hp.get(e)+1),t>0){let n=`${e}_${t}`;return hp.set(n,1),n}else return e}var Zae=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function yM(e){return!!e.match(Zae)}function eie(e){return e===parseInt(e.toString(),10)}function Ul(e,t,n){t==null&&(t=0),n==null&&(n=e.length);let r=1;for(let s=t;s<n;++s)r*=e[s];return r}function Gp(e){if(e.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r<t&&(t=r)}return t}function ru(e){if(e.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r>t&&(t=r)}return t}function Hi(e,t){if(t<e)throw new oe(`end (${t}) < begin (${e}) is forbidden.`);let n=[];for(let r=e;r<t;++r)n.push(r);return n}var sk;function Wr(){return sk==null&&(sk=KS().epsilon()),sk}function ji(){return"channelsLast"}function ol(e,t){return Ve(e,t)}function _0(e,t=-1){let n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),ae(e,n)}function tie(e,t){return ie(()=>{if(e.shape.length!==2)throw new oe(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);let n=_0(e,1);return dC(n,[1,t,1])})}function nie(e){let t=[Ul(e.shape)];return ae(e,t)}function rie(e){if(e.rank<=1)throw new oe(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);let t=[e.shape[0],Ul(e.shape,1)];return ae(e,t)}function $c(e,t,n){return ie(()=>{switch(e.rank){case 1:return T0(e,t,n);case 2:return qw(e,[t,0],[n,e.shape[1]]);case 3:return vm(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return Wp(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return en(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return en(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new oe(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}})}function ak(e,t,n){return ie(()=>{switch(e.rank){case 1:return T0(e,t,n);case 2:return qw(e,[0,t],[e.shape[0],n]);case 3:return vm(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return Wp(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new oe(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function f2(e,t,n,r){return ie(()=>{switch(e.rank){case 1:return T0(e,t,n);case 2:switch(r){case 1:return $c(e,t,n);case 2:return ak(e,t,n);default:throw new oe(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return $c(e,t,n);case 2:return vm(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return ak(e,t,n);default:throw new oe(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return $c(e,t,n);case 2:return Wp(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return Wp(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return ak(e,t,n);default:throw new oe(`The axis is not within the rank of the tensor ${r}`)}default:throw new oe(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function gN(e,t=-1){let n;return t<0&&(n=e[0].rank,n!==0?t=n:t=0),t===e[0].rank&&(t=-1),Bn(e,t)}function bR(e,t){switch(e.rank){case 1:return p3([e,t]);case 2:return f3([e,t],0);case 3:return m3([e,t],0);case 4:return g3([e,t],0);default:throw new oe(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function dC(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new oe(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return Ia(e,t)}function lv(e,t=0,n=1,r,s){return zw(e,t,n,r,s)}function vo(e,t,n,r){if(e.rank<2||t.rank<2)throw new Xt(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){let s=e.shape.slice(-1)[0],a=t.shape.slice(-2)[0];if(s!==a)throw new Xt(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(e.rank===2&&t.rank===2)return Up.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?hC(e.rank,r,ji()):null,activation:n});{let s=e.shape.slice(),a=s.pop();e=ae(e,[-1,a]);let i=t.shape.slice(),o=i.pop(),u=i.pop(),c=[...i,o],l=Array.from({length:t.rank},(h,p)=>p===0?t.rank-2:p<=t.rank-2?p-1:p);t=ae(Gt(t,l),[u,-1]);let d=[...s,...c];return ae(Up.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?hC(e.rank,r,ji()):null,activation:n}),d)}}function xM(e,t,n){return ie(()=>(Array.isArray(t)?t=Tn(t,"int32"):t=Ve(t,"int32"),xm(e,t,n)))}function D0(e){return se(e,e)}function hC(e,t,n){let r=t.shape;if(t.rank!==1&&t.rank!==e)throw new oe(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(e===5){if(n==="channelsFirst")return r.length===1?ae(t,[1,r[0],1,1,1]):ae(t,[1,r[3],r[0],r[1],r[2]]);if(n==="channelsLast")return r.length===1?ae(t,[1,1,1,1,r[0]]):ae(t,[1].concat(r))}else if(e===4){if(n==="channelsFirst")return r.length===1?ae(t,[1,r[0],1,1]):ae(t,[1,r[2],r[0],r[1]]);if(n==="channelsLast")return r.length===1?ae(t,[1,1,1,r[0]]):ae(t,[1].concat(r))}else if(e===3){if(n==="channelsFirst")return r.length===1?ae(t,[1,r[0],1]):ae(t,[1,r[1],r[0]]);if(n==="channelsLast")return r.length===1?ae(t,[1,1,r[0]]):ae(t,[1].concat(r))}else if(e<3)return t;throw new oe(`Unsupported input rank by biasAdd: ${t.rank}`)}function Zi(e,t,n){return ie(()=>(n==null&&(n=ji()),kr(n),Se(e,hC(e.rank,t,n))))}function sie(e,t=1){if(t!==1)throw new Xt(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return gm(e)}function aie(e){return ie(()=>it(e,Se(Ar(e),1)))}function wM(e,t,n,r){return ie(()=>J3(e,t,n,r))}function iie(e){return ie(()=>{let t=Se(.5,se(.2,e));return vs(t,0,1)})}function F0(e,t,n=!1){return n?e():t()}var oie=["fanIn","fanOut","fanAvg"],lie=["normal","uniform","truncatedNormal"];function uie(e){zh(oie,"FanMode",e)}function cie(e){zh(lie,"Distribution",e)}var gi=class extends Me.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},bN=class extends gi{apply(e,t){return dr(e,t)}};bN.className="Zeros";Me.registerClass(bN);var uv=class extends gi{apply(e,t){return ra(e,t)}};uv.className="Ones";Me.registerClass(uv);var yN=class extends gi{constructor(e){if(super(),typeof e!="object")throw new oe(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new oe(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return ie(()=>se(vt(this.value),ra(e,t)))}getConfig(){return{value:this.value}}};yN.className="Constant";Me.registerClass(yN);var xN=class extends gi{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return Cu(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};xN.className="RandomUniform";Me.registerClass(xN);var wN=class extends gi{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Xt(`randomNormal does not support dType ${t}.`);return lv(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};wN.className="RandomNormal";Me.registerClass(wN);var vN=class extends gi{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Xt(`truncatedNormal does not support dType ${t}.`);return Zw(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};vN.className="TruncatedNormal";Me.registerClass(vN);var IN=class extends gi{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return ie(()=>{if(e.length!==2||e[0]!==e[1])throw new oe("Identity matrix initializer can only be used for 2D square matrices.");return se(this.gain,Mw(e[0]))})}getConfig(){return{gain:this.gain}}};IN.className="Identity";Me.registerClass(IN);function die(e,t="channelsLast"){let n,r;if(kr(t),e.length===2)n=e[0],r=e[1];else if([3,4,5].indexOf(e.length)!==-1){if(t==="channelsFirst"){let s=Ul(e,2);n=e[1]*s,r=e[0]*s}else if(t==="channelsLast"){let s=Ul(e,0,e.length-2);n=e[e.length-2]*s,r=e[e.length-1]*s}}else{let s=Ul(e);n=Math.sqrt(s),r=Math.sqrt(s)}return[n,r]}var ua=class extends gi{constructor(e){if(super(),e.scale<0)throw new oe(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,uie(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,cie(this.distribution),this.seed=e.seed}apply(e,t){let n=die(e),r=n[0],s=n[1],a=this.scale;if(this.mode==="fanIn"?a/=Math.max(1,r):this.mode==="fanOut"?a/=Math.max(1,s):a/=Math.max(1,(r+s)/2),this.distribution==="normal"){let i=Math.sqrt(a);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Xt(`${this.getClassName()} does not support dType ${t}.`);return Zw(e,0,i,t,this.seed)}else{let i=Math.sqrt(3*a);return Cu(e,-i,i,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};ua.className="VarianceScaling";Me.registerClass(ua);var cv=class extends ua{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return ua.className}};cv.className="GlorotUniform";Me.registerClass(cv);var dv=class extends ua{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return ua.className}};dv.className="GlorotNormal";Me.registerClass(dv);var hv=class extends ua{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return ua.className}};hv.className="HeNormal";Me.registerClass(hv);var pv=class extends ua{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return ua.className}};pv.className="HeUniform";Me.registerClass(pv);var fv=class extends ua{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return ua.className}};fv.className="LeCunNormal";Me.registerClass(fv);var mv=class extends ua{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return ua.className}};mv.className="LeCunUniform";Me.registerClass(mv);var kN=class extends gi{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return ie(()=>{if(e.length<2)throw new Xt("Shape must be at least 2D.");if(t!=="int32"&&t!=="float32"&&t!==void 0)throw new TypeError(`Unsupported data type ${t}.`);t=t;let n=$.sizeFromShape(e.slice(0,-1)),r=e[e.length-1],s=n*r;s>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${s}) elements: Slowness may result.`);let a=[Math.max(r,n),Math.min(r,n)],i=lv(a,0,1,t,this.seed),o=nN.qr(i,!1),u=o[0],c=o[1].flatten().stridedSlice([0],[Math.min(r,n)*Math.min(r,n)],[Math.min(r,n)+1]);return u=se(u,c.sign()),n<r&&(u=u.transpose()),se(vt(this.gain),u.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}};kN.className="Orthogonal";Me.registerClass(kN);var yR={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function xR(e,t={}){return R0(e,Me.SerializationMap.getMap().classNameMap,t,"initializer")}function hr(e){return fN(e)}function ir(e){if(typeof e=="string"){let t=e in yR?yR[e]:e;if(t==="GlorotNormal")return new dv;if(t==="GlorotUniform")return new cv;if(t==="HeNormal")return new hv;if(t==="HeUniform")return new pv;if(t==="LeCunNormal")return new fv;if(t==="LeCunUniform")return new mv;{let n={};return n.className=t,n.config={},xR(n)}}else return e instanceof gi?e:xR(e)}function pC(e){return Array.isArray(e)&&Array.isArray(e[0])}function hx(e){return e.length===0?[]:Array.isArray(e[0])?e:[e]}function Ft(e){let t;if(Array.isArray(e)){if(e.length!==1)throw new oe(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function fn(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(e.length===1)return e=e,e[0];throw new oe(`Expected exactly 1 Shape; got ${e.length}`)}else return e}function px(e){let t=0;for(let n of e)n.shape.length===0?t+=1:t+=n.shape.reduce((r,s)=>r*s);return t}var wR="Variable",vM=class{constructor(t,n="float32",r=wR,s=!0,a=null){this.dtype=n??"float32",this.shape=t.shape,this.id=fM(),r=r??wR,this.originalName=gM(r),this.name=bM(this.originalName),this.trainable_=s,this.constraint=a,this.val=Q3(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),hie(this.val,t),this.val.id!==t.id&&(this.val.assign(t),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}};function hie(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}function fC(e){return e.map(t=>t.read())}function CN(e){e.forEach(t=>{t[0].write(t[1])})}var Rr=class{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}},qi=class{constructor(e,t,n,r,s,a,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=s,this.outputTensorIndex=i,this.id=fM(),a!=null&&(this.originalName=gM(a),this.name=bM(this.originalName)),this.rank=t.length}},pie=0,gv=class{constructor(e,t){this.callArgs=t,this.id=pie++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(let n of e.inboundLayers)n?.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){let e=[];for(let t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},fie=0,Qt=class extends Me.Serializable{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=fie++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){let n=this.getClassName();t=Xo(n)+"_"+ov(n)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let n;if(e.batchInputShape!=null)n=e.batchInputShape;else if(e.inputShape!=null){let s=null;e.batchSize!=null&&(s=e.batchSize),n=[s].concat(e.inputShape)}this.batchInputShape=n;let r=e.dtype;r==null&&(r=e.inputDType),r==null&&(r="float32"),this.dtype=r}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new go(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new oe(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return ea(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return ea(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Al(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new Al(`Layer ${this.name} is not connected, no input to return.`);return ea(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new Al(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Al(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return ea(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){let t=An(e);if(this.inputSpec==null||this.inputSpec.length===0)return;let n=An(this.inputSpec);if(t.length!==n.length)throw new oe(`Layer ${this.name} expects ${n.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let r=0;r<t.length;r++){let s=t[r],a=n[r];if(a==null)continue;let i=s.rank;if(a.ndim!=null&&i!==a.ndim)throw new oe(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${a.ndim}, found ndim=${i}`);if(a.maxNDim!=null&&i>a.maxNDim)throw new oe(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${a.maxNDim}, found ndim=${i}`);if(a.minNDim!=null&&i<a.minNDim)throw new oe(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${a.minNDim}, found ndim=${i}.`);if(a.dtype!=null&&s.dtype!==a.dtype)throw new oe(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${a.dtype}, found dtype=${s.dtype}.`);if(a.axes){let o=s.shape;for(let u in a.axes){let c=Number(u),l=a.axes[u],d=c>=0?o[c]:o[o.length+c];if(l!=null&&[l,null].indexOf(d)===-1)throw new oe(`Input ${r} is incompatible with layer ${this.name}: expected axis ${c} of input shape to have value ${l} but got shape ${o}.`)}}if(a.shape!=null)for(let o=0;o<a.shape.length;++o){let u=a.shape[o],c=s.shape[o];if(u!=null&&c!=null&&u!==c)throw new oe(`Input ${r} is incompatible with layer ${this.name}: expected shape=${a.shape}, found shape=${s.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();let n=An(e),r=bie(e),s=yie(e);if(r===s)throw new oe("Arguments to apply() must be all SymbolicTensors or all Tensors");return Ac(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);let a=[];for(let i of An(e))a.push(i.shape);this.build(ea(a)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&s&&(this._refCount=1)}if(this.assertInputCompatibility(e),s){let a=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,a);let i=An(a),o=[];for(let u of i)n.indexOf(u)!==-1&&(u=u.clone()),o.push(u);if(a=ea(o),this.activityRegularizer!=null)throw new Xt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}else{let a=mie(e),i=this.computeOutputShape(a),o,u=gie(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?a[0]:a),i!=null&&i.length>0&&Array.isArray(i[0])?o=i.map((c,l)=>new qi(u,c,this,An(e),t,this.name,l)):o=new qi(u,i,this,An(e),t,this.name),this.addInboundNode(e,o,null,null,a,i,t),this._refCount++,this.activityRegularizer!=null)throw new Xt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((n,r)=>{n!=null&&e[r]!=null&&e[r]!==n&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new Al(`The layer ${this.name} has never been called and thus has no defined output shape.`);let e=[];for(let t of this.inboundNodes){let n=JSON.stringify(t.outputShapes);e.indexOf(n)===-1&&e.push(n)}if(e.length===1){let t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new Al(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new go(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return px(this.weights)}build(e){this.built=!0}getWeights(e=!1){return fC(e?this.trainableWeights:this.weights)}setWeights(e){ie(()=>{let t=this.weights;if(t.length!==e.length)throw new oe(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;let n=[],r=fC(t);for(let s=0;s<r.length;++s){let a=r[s],i=t[s],o=e[s];if(!$.arraysEqual(a.shape,o.shape))throw new oe(`Layer weight shape ${a.shape} not compatible with provided weight shape ${o.shape}`);n.push([i,o])}CN(n)})}addWeight(e,t,n,r,s,a,i,o){if(this._addedWeightNames.indexOf(e)!==-1)throw new oe(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),n==null&&(n="float32"),this.fastWeightInitDuringBuild&&(r=o!=null?o():ir("zeros"));let u=r.apply(t,n),c=new vM(u,n,e,a,i);return u.dispose(),s!=null&&this.addLoss(()=>s.apply(c.read())),a==null&&(a=!0),a?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=An(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(n=>{if(n!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}setMaskMetadata(e,t,n){if(!this.supportsMasking)return;let r=this.computeMask(e,n),s=An(t),a=An(r);if(s.length!==a.length)throw new Error(`${this.name} outputs ${s.length} tensors but ${s.length} masks for those tensors`);for(let i=0;i<s.length;i++)s[i].kerasMask=a[i]}addInboundNode(e,t,n,r,s,a,i=null){let o=An(e);t=An(t),n=An(n),r=An(r),s=hx(s),a=hx(a);let u=[],c=[],l=[];for(let d of o)u.push(d.sourceLayer),c.push(d.nodeIndex),l.push(d.tensorIndex);new gv({outboundLayer:this,inboundLayers:u,nodeIndices:c,tensorIndices:l,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:s,outputShapes:a},i);for(let d=0;d<t.length;d++)t[d].sourceLayer=this,t[d].nodeIndex=this.inboundNodes.length-1,t[d].tensorIndex=d}getConfig(){let e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}};function mie(e){e=An(e);let t=[];for(let n of e)t.push(n.shape);return ea(t)}function gie(e){return"float32"}function IM(e,t,n){if((t==null||n!=null&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),t.inboundNodes.length===0)return[e];{let r=t.inboundNodes[n];if(r.inboundLayers.length===0)return r.inputTensors;{let s=[];for(let a=0;a<r.inboundLayers.length;a++){let i=r.inputTensors[a],o=r.inboundLayers[a],u=r.nodeIndices[a],c=IM(i,o,u);for(let l of c)s.indexOf(l)===-1&&s.push(l)}return s}}}function bie(e){let t=!0;for(let n of An(e))if(!(n instanceof qi)){t=!1;break}return t}function yie(e){let t=!0;for(let n of An(e))if(n instanceof qi){t=!1;break}return t}var km=class extends Qt{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:ov("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new oe("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new oe("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new oe("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];let r=new qi(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new gv({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new oe(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};km.className="InputLayer";Me.registerClass(km);function kM(e){if(e.batchShape==null&&e.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(e.batchShape!=null&&e.shape!=null)throw new oe("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;e.shape!=null&&t==null&&(t=[null].concat(e.shape));let n=e.dtype;return n==null&&(n="float32"),new km({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}function xie(e,t){if(e.dtype==null||e.dtype===t.dtype)return t;try{return Ve(t,e.dtype)}catch{throw new oe(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}var Cp=class CM{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof CM)for(let n in t.id2Value)this.id2Value[n]=t.id2Value[n],n in t.id2Mask&&(this.id2Mask[n]=t.id2Mask[n]);else{if(t==null)return;for(let n of t)this.add(n.key,n.value)}}add(t,n,r){if(this.id2Value[t.id]==null)this.id2Value[t.id]=xie(t,n),this.name2Id[t.name]=t.id,r!=null&&(this.id2Mask[t.id]=r);else throw new oe(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof qi){if(this.id2Value[t.id]==null)throw new oe(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{let n=this.name2Id[t];if(n==null)throw new oe(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[n]}}getMask(t){if(t instanceof qi){if(this.id2Value[t.id]==null)throw new oe(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{let n=this.name2Id[t];if(n==null)throw new oe(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[n]}}disposeMasks(){this.id2Mask!=null&&Lt(this.id2Mask)}},fx=new dM,mx=new dM;function wie(e){fx?.setMaxEntries(e),mx?.setMaxEntries(e)}function Lb(e,t,n,r){let s=n==null?!1:n.training,a=Array.isArray(e),i=a?e:[e],o=i.map(f=>f.name),u=[],c=t.names();for(let f of o)c.indexOf(f)!==-1?u.push(t.getValue(f)):u.push(null);let l=o.join(",")+"|"+t.names().sort().join(","),d=fx.get(l),h;if(d==null){let f=vie(i,t);d=f.sorted,h=f.recipientCounts,fx.put(l,d),mx.put(l,h)}h={},s||Object.assign(h,mx.get(l));let p=new Cp(t);for(let f=0;f<d.length;++f){let m=d[f],g=m.sourceLayer;if(g instanceof km)continue;let b=[],y=[],x=[],w=!1;for(let E of m.inputs){let A=p.getValue(E),k=p.getMask(E);b.push(A),y.push(k),k!=null&&(w=!0),s||(h[E.name]--,h[E.name]===0&&!t.hasKey(E)&&o.indexOf(E.name)===-1&&!A.isDisposed&&E.sourceLayer.stateful!==!0&&x.push(A))}w&&(n=n||{},n.mask=y[0]);let v=An(g.apply(b,n)),I=null;g.supportsMasking&&(I=g.computeMask(b,y));let N=kie(m),T=Array.isArray(N)?N:[N];for(let E=0;E<T.length;++E){p.hasKey(T[E])||p.add(T[E],v[E],Array.isArray(I)?I[0]:I);let A=o.indexOf(T[E].name);A!==-1&&(u[A]=v[E])}s||Lt(x)}return p.disposeMasks(),a?u:u[0]}function vie(e,t){$.assert(e!=null&&e.length>0,()=>"Expected at least one fetch, got none");let n=[],r={};if(e.length===1){let s=vR(e[0],t);n=s.sorted,r=s.recipientMap}else{let s=new Set;for(let a of e){let{sorted:i,recipientMap:o}=vR(a,t);for(let u of i)s.has(u.name)||(n.push(u),s.add(u.name));for(let u in o)r[u]==null&&(r[u]=new Set),o[u].forEach(c=>r[u].add(c))}}return{sorted:n,recipientCounts:Iie(r)}}function Iie(e){let t={};for(let n in e)t[n]=e[n].size;return t}function vR(e,t){let n=new Set,r=[],s={};for(let o of t.names())n.add(o);let a=[],i=[];for(a.push(e);a.length>0;){let o=a[a.length-1];if(n.has(o.name)){a.pop();continue}let u=i[i.length-1]===a.length-1;if(o.inputs.length===0||u)a.pop(),r.push(o),n.add(o.name),u&&i.pop();else{i.push(a.length-1);for(let c of o.inputs)s[c.name]==null&&(s[c.name]=new Set),s[c.name].add(o.name),!n.has(c.name)&&a.push(c)}}return{sorted:r,recipientMap:s}}function kie(e){let t;if(e.sourceLayer.inboundNodes.length===1)t=e.sourceLayer.output;else{let n=null;for(let r=0;r<e.sourceLayer.inboundNodes.length;++r)for(let s of e.sourceLayer.inboundNodes[r].outputTensors)if(s.id===e.id){n=r;break}t=e.sourceLayer.getOutputAt(n)}return t}var Cie=ge();Cie.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,wie);var SM={};Pt(SM,{maxNorm:()=>Sie,minMaxNorm:()=>Eie,nonNeg:()=>Tie,unitNorm:()=>Nie});function SN(e,t){return ie(()=>ls(dt(se(e,e),t,!0)))}var M0=class extends Me.Serializable{getConfig(){return{}}},NN=class extends M0{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return ie(()=>{let t=SN(e,this.axis),n=vs(t,0,this.maxValue);return se(e,it(n,Se(Wr(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};NN.className="MaxNorm";Me.registerClass(NN);var TN=class extends M0{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return ie(()=>it(e,Se(Wr(),SN(e,this.axis))))}getConfig(){return{axis:this.axis}}};TN.className="UnitNorm";Me.registerClass(TN);var EN=class extends M0{apply(e){return Rn(e)}};EN.className="NonNeg";Me.registerClass(EN);var AN=class extends M0{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return ie(()=>{let t=SN(e,this.axis),n=Se(se(this.rate,vs(t,this.minValue,this.maxValue)),se(1-this.rate,t));return se(e,it(n,Se(Wr(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};AN.className="MinMaxNorm";Me.registerClass(AN);var IR={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Hr(e){return fN(e)}function kR(e,t={}){return R0(e,Me.SerializationMap.getMap().classNameMap,t,"constraint")}function jr(e){if(e==null)return null;if(typeof e=="string"){let t={className:e in IR?IR[e]:e,config:{}};return kR(t)}else return e instanceof M0?e:kR(e)}function Sie(e){return new NN(e)}function Nie(e){return new TN(e)}function Tie(){return new EN}function Eie(e){return new AN(e)}var NM={};Pt(NM,{constant:()=>Rie,glorotNormal:()=>Pie,glorotUniform:()=>Lie,heNormal:()=>Bie,heUniform:()=>zie,identity:()=>Mie,leCunNormal:()=>Wie,leCunUniform:()=>Vie,ones:()=>$ie,orthogonal:()=>Uie,randomNormal:()=>Die,randomUniform:()=>_ie,truncatedNormal:()=>Fie,varianceScaling:()=>Oie,zeros:()=>Aie});function Aie(){return new bN}function $ie(){return new uv}function Rie(e){return new yN(e)}function _ie(e){return new xN(e)}function Die(e){return new wN(e)}function Fie(e){return new vN(e)}function Mie(e){return new IN(e)}function Oie(e){return new ua(e)}function Lie(e){return new cv(e)}function Pie(e){return new dv(e)}function Bie(e){return new hv(e)}function zie(e){return new pv(e)}function Wie(e){return new fv(e)}function Vie(e){return new mv(e)}function Uie(e){return new kN(e)}var TM={};Pt(TM,{Layer:()=>Qt,RNN:()=>yl,RNNCell:()=>L0,activation:()=>wle,add:()=>Ale,alphaDropout:()=>hue,average:()=>$le,averagePooling1d:()=>WT,averagePooling2d:()=>VT,averagePooling3d:()=>UT,avgPool1d:()=>Ble,avgPool2d:()=>Wle,avgPool3d:()=>Ule,avgPooling1d:()=>zle,avgPooling2d:()=>Vle,avgPooling3d:()=>Gle,batchNormalization:()=>Ole,bidirectional:()=>sue,categoryEncoding:()=>bue,centerCrop:()=>mue,concatenate:()=>Rle,conv1d:()=>dle,conv2d:()=>hle,conv2dTranspose:()=>ple,conv3d:()=>fle,conv3dTranspose:()=>mle,convLstm2d:()=>eue,convLstm2dCell:()=>tue,cropping2D:()=>ble,dense:()=>vle,depthwiseConv2d:()=>xle,dot:()=>Mle,dropout:()=>Ile,elu:()=>ale,embedding:()=>Ele,flatten:()=>Cle,gaussianDropout:()=>due,gaussianNoise:()=>cue,globalAveragePooling1d:()=>Hle,globalAveragePooling2d:()=>jle,globalMaxPool1d:()=>iue,globalMaxPool2d:()=>oue,globalMaxPooling1d:()=>A8,globalMaxPooling2d:()=>$8,gru:()=>Kle,gruCell:()=>Xle,input:()=>HM,inputLayer:()=>sle,layerNormalization:()=>Lle,leakyReLU:()=>ole,lstm:()=>Qle,lstmCell:()=>Yle,masking:()=>pue,maxPool1d:()=>lue,maxPool2d:()=>uue,maxPooling1d:()=>R8,maxPooling2d:()=>_8,maxPooling3d:()=>qle,maximum:()=>_le,minimum:()=>Dle,multiply:()=>Fle,permute:()=>Tle,prelu:()=>lle,randomWidth:()=>yue,reLU:()=>ile,repeatVector:()=>Sle,rescaling:()=>fue,reshape:()=>Nle,resizing:()=>gue,rnn:()=>nue,separableConv2d:()=>gle,simpleRNN:()=>Jle,simpleRNNCell:()=>Zle,softmax:()=>ule,spatialDropout1d:()=>kle,stackedRNNCells:()=>rue,thresholdedReLU:()=>cle,timeDistributed:()=>aue,upSampling2d:()=>yle,zeroPadding2d:()=>Ple});async function Tl(e){if(e==null)return;let t=[],n=[],r=[];for(let s in e){let a=e[s];if(typeof a!="number"){let i=a;t.push(i.data()),n.push(s),r.push(i)}}if(t.length>0){let s=await Promise.all(t);for(let a=0;a<s.length;++a)e[n[a]]=s[a][0];Lt(r)}}function EM(e){if(e!=null)for(let t in e){let n=e[t];typeof n!="number"&&n.dispose()}}var CR;(function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"})(CR||(CR={}));var Gie=125,Hp=class{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}},AM=class{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(let t of this.callbacks)t.setParams(e)}setModel(e){for(let t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainEnd(e)}},Hie=class extends Hp{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});let n=t.size==null?0:t.size;this.seen+=n;for(let r in t){let s=t[r];if(typeof s=="number")this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+s*n;else{let a;r in this.totals?a=this.totals[r]:this.totals[r]=0;let i=ie(()=>Se(this.totals[r],se(s,n)));this.totals[r]=i,a?.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(let n of this.params.metrics)this.totals[n]!=null&&(typeof this.totals[n]=="number"?t[n]=this.totals[n]/this.seen:ie(()=>{let r=se(it(1,this.seen),this.totals[n]);t[n]=r,this.totals[n].dispose(),zr(t[n])}))}},$M=class extends Hp{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(let n in t)this.history[n]==null&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){let e=[],t=[],n=[];for(let s in this.history){let a=this.history[s];for(let i=0;i<a.length;++i)if(typeof a[i]!="number"){let o=a[i];e.push(o.data()),t.push(s),n.push(i)}}let r=await Promise.all(e);for(let s=0;s<r.length;++s)this.history[t[s]][n[s]].dispose(),this.history[t[s]][n[s]]=r[s][0]}},RM=class extends Hp{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||hN,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=Gie),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");$.isNumber(this.yieldEvery)&&(this.maybeWait=Gae(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){let r=[];this.yield!=null&&(await Tl(n),r.push(this.yield(e,t,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await Tl(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){let n=[];this.epochEnd!=null&&(await Tl(t),n.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){this.batchBegin!=null&&(await Tl(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){let n=[];this.batchEnd!=null&&(await Tl(t),n.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?n.push(this.nextFrameFunc()):$.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){this.trainBegin!=null&&(await Tl(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await Tl(e),await this.trainEnd(e))}};function _M(e,t){return e==null&&(e={}),e instanceof Hp?[e]:Array.isArray(e)&&e[0]instanceof Hp?e:An(e).map(n=>new RM(n,t))}var $N=class ao{constructor(){}static registerCallbackConstructor(t,n){$.assert(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),ao.checkForDuplicate(n),ao.constructors[t]==null&&(ao.constructors[t]=[]),ao.constructors[t].push(n)}static checkForDuplicate(t){for(let n in ao.constructors)ao.constructors[+n].forEach(r=>{if(r===t)throw new oe("Duplicate callback constructor.")})}static clear(){ao.constructors={}}static createCallbacks(t){let n=[];for(let r in ao.constructors){let s=+r;t>=s&&n.push(...ao.constructors[s])}return n.map(r=>new r)}};$N.constructors={};function DM(e,t,n,r,s,a,i,o,u){let c=new $M,l=[new Hie,...$N.createCallbacks(t)];e!=null&&l.push(...e),l.push(c);let d=new AM(l);return d.setParams({epochs:n,initialEpoch:r,samples:s,steps:a,batchSize:i,verbose:t,doValidation:o,metrics:u}),{callbackList:d,history:c}}function zi(e,t={},n=!1){return R0(e,Me.SerializationMap.getMap().classNameMap,t,"layer",n)}function gx(e,t){return ie(()=>{e.dtype!=="float32"&&(e=Ve(e,"float32"));let n=dt(D0(e),t,!0),r=Ca(n.shape,Wr()),s=ls(Oo(n,r));return it(e,s)})}function Wh(e,t){return ie(()=>cr(D0(et(t,e)),-1))}function bv(e,t){return ie(()=>cr(Ar(et(t,e)),-1))}function Cm(e,t){return ie(()=>{let n=et(e,t),r=vs(Ar(e),Wr(),Number.MAX_VALUE),s=Ar(it(n,r));return se(100,cr(s,-1))})}function jie(e,t){return ie(()=>{let n=vs(t,Wr(),Number.MAX_VALUE),r=Ta(Se(1,n)),s=vs(e,Wr(),Number.MAX_VALUE),a=Ta(Se(1,s));return cr(D0(et(r,a)),-1)})}function qie(e,t){return ie(()=>{let n=Oo(0,et(1,se(e,t)));return cr(D0(n),-1)})}function Kie(e,t){return ie(()=>{let n=Oo(0,et(1,se(e,t)));return cr(n,-1)})}function Xie(e,t){return ie(()=>{let n=dt(se(e,t),-1),r=Va(se(et(1,e),t),-1);return Oo(0,Se(1,et(r,n)))})}function Qie(e,t){return ie(()=>{let n=Math.log(2),r=et(t,e),s=et(Se(r,Ph(se(-2,r))),n);return cr(s,-1)})}function fy(e,t,n=!1){return ie(()=>{if(n)t=Su(t);else{let r=dt(t,t.shape.length-1,!0);t=it(t,r)}return t=vs(t,Wr(),1-Wr()),Jn(dt(se(Ve(e,"float32"),Ta(t)),t.shape.length-1))})}function bx(e,t,n=!1){return ie(()=>{let r=Ve(ym(nie(e)),"int32");t=vs(t,Wr(),1-Wr());let s=t.shape,a=ae(Bp(r,s[s.length-1]),s);return fy(a,t,n)})}function Yie(e,t){if(!$.arraysEqual(e.shape,t.shape))throw new oe(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return ie(()=>{let n=Rn(t),r=Jn(Ar(t));return Se(et(n,se(t,e)),v0(Is(r)))})}function yv(e,t){return ie(()=>{let n;return n=vs(t,Wr(),1-Wr()),n=Ta(it(n,et(1,n))),cr(Yie(e,n),-1)})}function Jie(e,t){return ie(()=>{let n=vs(e,Wr(),1),r=vs(t,Wr(),1);return dt(se(e,Ta(it(n,r))),-1)})}function Zie(e,t){return ie(()=>{let n=Ta(Se(Wr(),t));return cr(et(t,se(e,n)),-1)})}function RN(e,t){return ie(()=>{let n=gx(e,-1),r=gx(t,-1),s=se(n,r);return Jn(dt(s,-1))})}var yx={meanSquaredError:Wh,meanAbsoluteError:bv,meanAbsolutePercentageError:Cm,meanSquaredLogarithmicError:jie,squaredHinge:qie,hinge:Kie,categoricalHinge:Xie,logcosh:Qie,categoricalCrossentropy:fy,sparseCategoricalCrossentropy:bx,binaryCrossentropy:yv,kullbackLeiblerDivergence:Jie,poisson:Zie,cosineProximity:RN};function ik(e){if(typeof e=="string"){if(e in yx)return yx[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new oe(t)}else return e}function _N(e,t){return ie(()=>{let n=se(.5,Ea(t)),r=ol(Xs(t,n),e.dtype);return cr(Na(e,r),-1)})}function DN(e,t){return ie(()=>ol(Na(Uc(e,-1),Uc(t,-1)),"float32"))}function FM(e,t){return ie(()=>Ve(dt(di(Na(e,1),Na(t,1))),"float32"))}function eoe(e,t){return ie(()=>Ve(dt(di(Na(e,1),Na(t,0))),"float32"))}function toe(e,t){return ie(()=>Ve(dt(di(Na(e,0),Na(t,1))),"float32"))}function MM(e,t){return ie(()=>{let n=FM(e,t),r=toe(e,t),s=Se(n,r);return Ve(os(Xs(s,0),it(n,s),0),"float32")})}function noe(e,t){return ie(()=>{let n=FM(e,t),r=eoe(e,t),s=Se(n,r);return Ve(os(Xs(s,0),it(n,s),0),"float32")})}function OM(e,t){return yv(e,t)}function LM(e,t){return e.rank===t.rank&&(e=Nu(e,[e.rank-1])),t=Uc(t,-1),t.dtype!==e.dtype&&(t=Ve(t,e.dtype)),Ve(Na(e,t),"float32")}function roe(e,t){return ie(()=>{let n=e.sub(t).square().sum(),r=e.sub(e.mean()).square().sum();return vt(1).sub(n.div(r))})}var soe=Wh,aoe=Wh,ioe=bv,ooe=bv,loe=Cm,uoe=Cm,FN=fy,coe=RN,PM=bx,xx={binaryAccuracy:_N,categoricalAccuracy:DN,precision:MM,categoricalCrossentropy:FN,sparseCategoricalCrossentropy:PM,mse:soe,MSE:aoe,mae:ioe,MAE:ooe,mape:loe,MAPE:uoe,cosine:coe};function doe(e){if(typeof e=="string"&&e in xx)return xx[e];if(typeof e!="string"&&e!=null)return e;throw new oe(`Unknown metric ${e}`)}function m2(e){if(co(e!==null,`Unknown LossOrMetricFn ${e}`),typeof e=="string")return e;{let t;for(let n of Object.keys(yx))if(yx[n]===e){t=n;break}if(t!==void 0)return t;for(let n of Object.keys(xx))if(xx[n]===e){t=n;break}return t!==void 0?t:e.name}}function hoe(e){let t={Adagrad:()=>pc.adagrad(.01),Adadelta:()=>pc.adadelta(1,.95,Wr()),Adam:()=>pc.adam(.001,.9,.999,Wr()),Adamax:()=>pc.adamax(.002,.9,.999,Wr(),0),RMSProp:()=>pc.rmsprop(.001,.9,0,Wr()),SGD:()=>pc.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new oe(`Unknown Optimizer ${e}`)}function SR(e,t,n=!1){if(e==null||typeof e!="object"||Object.getPrototypeOf(e)!==Object.prototype||!mC(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){let r=JSON.stringify(e);r.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function mC(e){if(e===null)return!0;if(typeof e=="object")if(Object.getPrototypeOf(e)===Object.prototype){let t=Object.keys(e);for(let n of t)if(typeof n!="string"||!mC(e[n]))return!1;return!0}else if(Array.isArray(e)){for(let t of e)if(!mC(t))return!1;return!0}else return!1;else{let t=typeof e;return t==="string"||t==="number"||t==="boolean"}}function poe(e,t,n,r=console.log){let s=moe(e),a=["Layer (type)","Input Shape","Output shape","Param #"];s?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map(l=>Math.floor(t*l)));let i;if(!s){a.push("Receives inputs"),i=[];for(let l in e.nodesByDepth)i.push(...e.nodesByDepth[l])}r("_".repeat(t)),wx(a,n,r),r("=".repeat(t));let o=e.layers;for(let l=0;l<o.length;++l)s?goe(o[l],n,r):boe(o[l],n,i,r),r((l===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();let u=foe(e),c=px(e.nonTrainableWeights);r(`Total params: ${u+c}`),r(`Trainable params: ${u}`),r(`Non-trainable params: ${c}`),r("_".repeat(t))}function foe(e){let t;return e.collectedTrainableWeights!=null?t=px(e.collectedTrainableWeights):t=px(e.trainableWeights),t}function moe(e){let t=!0,n=[],r=[];for(let s in e.nodesByDepth)n.push(e.nodesByDepth[s]);for(let s of n){if(s.length>1||s.length===1&&s[0].inboundLayers.length>1){t=!1;break}r.push(...s)}if(t)for(let s of e.layers){let a=!1;for(let i of s.inboundNodes)if(r.indexOf(i)!==-1)if(a){t=!1;break}else a=!0;if(!t)break}return t}function wx(e,t,n=console.log){let r="";for(let s=0;s<e.length;++s)s>0&&(r=r.slice(0,r.length-1)+" "),r+=e[s],r=r.slice(0,t[s]),r+=" ".repeat(t[s]-r.length);n(r)}function goe(e,t,n){let r,s;try{s=e.inboundNodes.map(u=>JSON.stringify(u.inputShapes)).join(",")}catch{s="multiple"}try{r=JSON.stringify(e.outputShape)}catch{r="multiple"}let a=e.name,i=e.getClassName(),o=[`${a} (${i})`,s,r,e.countParams().toString()];wx(o,t,n)}function boe(e,t,n,r){let s,a;try{a=e.inboundNodes.map(d=>JSON.stringify(d.inputShapes)).join(",")}catch{a="multiple"}try{s=JSON.stringify(e.outputShape)}catch{s="multiple"}let i=[];for(let d of e.inboundNodes)if(!(n!=null&&n.length>0&&n.indexOf(d)===-1))for(let h=0;h<d.inboundLayers.length;++h){let p=d.inboundLayers[h].name,f=d.nodeIndices[h],m=d.tensorIndices[h];i.push(`${p}[${f}][${m}]`)}let o=e.name,u=e.getClassName(),c=i.length===0?"":i[0],l=[`${o} (${u})`,a,s,e.countParams().toString(),c];wx(l,t,r);for(let d=1;d<i.length;++d)wx(["","","","",i[d]],t,r)}function BM(e,t,n){return(e==="inboundNodes"||e==="outputLayers"||e==="inputLayers")&&t===0&&typeof n=="string"}function my(e,t){if(e===null)return null;if(typeof e=="string")return yc(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){let n=[],r=e.length;for(let s=0;s<r;++s){let a=e[s];BM(t,s,a)?n.push(a):n.push(my(a,t))}return n}else{let n={};for(let r of Object.keys(e)){let s=e[r];if(r==="name"&&typeof s=="string")n[r]=s;else{let a=yc(r);n[a]=my(s,a)}}return n}}function gC(e,t){if(e==null)return null;if(typeof e=="string")return Xo(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){let n=[],r=e.length;for(let s=0;s<r;++s){let a=e[s];BM(t,s,a)?n.push(a):n.push(gC(a,t))}return n}else{let n={};for(let r of Object.keys(e)){let s=e[r],a=Xo(r);(r==="name"||r==="className")&&typeof s=="string"?n[a]=s:n[a]=gC(s,r)}return n}}var MN="4.22.0",yoe=e=>{let t=Object.keys(e);if(t.length===0)return!1;let n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))},xoe=class io extends Qt{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,this.name==null){let y=this.getClassName().toLowerCase();this.name=ov(y)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],Vl(this.inputs).length!==this.inputs.length)throw new oe(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(y=>y.name)}`);Vl(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(y=>y.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let y of this.outputs){let x=y.sourceLayer,w=y.nodeIndex,v=y.tensorIndex;this.outputLayers.push(x),this.outputLayersNodeIndices.push(w),this.outputLayersTensorIndices.push(v)}for(let y of this.inputs){let x=y.sourceLayer,w=y.nodeIndex,v=y.tensorIndex;co(w===0,"input layer has >1 nodes"),co(v===0,"input layer has >1 tensors"),this.inputLayers.push(x),this.inputLayersNodeIndices.push(w),this.inputLayersTensorIndices.push(v)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let y=0;y<this.inputLayers.length;y++){let x=this.inputLayers[y];if(!(x instanceof km))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${y} (0-based) originates from layer type ${x.getClassName()}.`);this.inputNames.push(x.name),this.feedInputShapes.push(x.batchInputShape),this.feedInputNames.push(x.name)}for(let y of this.outputLayers)this.outputNames.push(y.name);this.internalInputShapes=this.inputs.map(y=>y.shape),this.internalOutputShapes=this.outputs.map(y=>y.shape);let n={},r={},s={},a={},i={},o=[],u=(y,x,w,v,I,N)=>{(v==null||I==null||N==null)&&(v=y.sourceLayer,I=y.nodeIndex,N=y.tensorIndex);let T=v.inboundNodes[I];if(w.indexOf(T)!==-1)throw new go(`The tensor ${y.name} at layer "${v.name}" is part of a cycle.`);if(x.indexOf(T)!==-1)return;this.containerNodes.add(io.nodeKey(v,I)),v.id in i||(i[v.id]=Object.keys(i).length),w.indexOf(T)===-1&&w.push(T);let E=T.inboundLayers.length;for(let A=0;A<E;A++){let k=T.inputTensors[A],C=T.inboundLayers[A],M=T.nodeIndices[A],L=T.tensorIndices[A];u(k,x,w,C,M,L)}for(x.push(T);w.indexOf(T)>=0;)w.splice(w.indexOf(T),1);o.push(T)},c=[],l=[];for(let y of this.outputs)u(y,c,l);let d=o.slice().reverse();for(let y of d){r[y.id]=y,y.id in n||(n[y.id]=0);let x=n[y.id],w=s[y.outboundLayer.id]==null?0:s[y.outboundLayer.id];x=Math.max(x,w),s[y.outboundLayer.id]=x,a[y.outboundLayer.id]=y.outboundLayer,n[y.id]=x;for(let v=0;v<y.inboundLayers.length;v++){let I=y.inboundLayers[v],N=y.nodeIndices[v],T=I.inboundNodes[N],E=n[T.id]==null?0:n[T.id];n[T.id]=Math.max(x+1,E),r[T.id]=T}}let h={};for(let y in n){let x=n[y];x in h||(h[x]=[]),h[x].push(r[y])}let p={};for(let y in s){let x=s[y];x in p||(p[x]=[]),p[x].push(a[y])}let f=Object.keys(p).map(y=>parseInt(y,10)).sort(h2);this.layers=[];for(let y of f){let x=p[y];x.sort((w,v)=>{let I=i[w.id],N=i[v.id];return I<N?-1:I>N?1:0});for(let w of x)w instanceof io&&this.internalContainerRefs.push(w),this.layers.push(w)}this.layersByDepth=p,f=Object.keys(h).map(y=>parseInt(y,10)).sort(h2);let m=this.inputs.slice(),g=[];for(let y of f)for(let x of h[y]){let w=x.outboundLayer;if(w!=null){for(let v of x.inputTensors)if(m.indexOf(v)===-1)throw new go(`Graph disconnected: cannot obtain value for tensor ${v} at layer "${w.name}". The following previous layers were accessed without issue: ${g}`);for(let v of x.outputTensors)m.push(v);g.push(w.name)}}this.nodesByDepth=h;let b=this.layers.map(y=>y.name);for(let y of b){let x=b.filter(w=>w===y).length;if(x!==1)throw new go(`The name "${y}" is used ${x} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(b))}this.outboundNodes=[],this.inboundNodes=[],new gv({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(y=>null),outputMasks:this.outputs.map(y=>null),inputShapes:this.inputs.map(y=>y.shape),outputShapes:this.outputs.map(y=>y.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(let n of this.layers)t.numDisposedVariables+=n.dispose().numDisposedVariables;for(let n of this.internalContainerRefs)t.numDisposedVariables+=n.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(n=>{n._trainableWeights.forEach(r=>r.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new oe("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(let n of this.layers)t=t.concat(n.trainableWeights);return t}get nonTrainableWeights(){let t=[];for(let n of this.layers)t.push(...n.nonTrainableWeights);if(!this.trainable){let n=[];for(let r of this.layers)n.push(...r.trainableWeights);return n.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,n=!0){let r={},s=0,a=yoe(t);a&&this.parseWeights(t);for(let o of this.layers)for(let[u,c]of o.weights.entries()){let l=a?`${c.name.split("/").slice(0,-1).join("/")+"/"}${u}`:c.originalName;if(r[l]!=null)throw new oe(`Duplicate weight name: ${l}`);r[l]=c,s++}let i=[];for(let o in t){let u=o;if(r[o]==null){let c=o.split("/");u=c.slice(0,-2).concat([c[c.length-1]]).join("/")}if(r[u]!=null)i.push([r[u],t[o]]);else if(n)throw new oe(`Provided weight data has no target variable: ${o}`);delete r[u]}if(n){let o=[];for(let u in r)o.push(u);if(o.length>0)throw new oe(`${o.length} of ${s} weights are not set: ${o}`)}CN(i)}parseWeights(t){for(let n in Object.keys(t)){let r=n.split("/"),s=["vars","layer_checkpoint_dependencies"],a=r.map(i=>i.startsWith("_")?i.slice(1):i).filter(i=>!s.includes(i)).join("/");a!==n&&(t[a]=t[n],delete t[n])}}updatedConfig(){let t=this.getConfig(),n={};return n.className=this.getClassName(),n.config=t,n.kerasVersion=`tfjs-layers ${MN}`,n.backend="TensorFlow.js",n}toJSON(t,n=!0){let r=gC(this.updatedConfig());return n?JSON.stringify(r):r}call(t,n){return ie(()=>{t=An(t);let r=new Cp;for(let s=0;s<this.inputs.length;++s)r.add(this.inputs[s],t[s]);return Lb(this.outputs,r,n)})}computeMask(t,n){return ie(()=>{t=An(t);let r;return n==null?r=Kc(null,t.length):r=An(n),this.runInternalGraph(t,r)[1]})}computeOutputShape(t){let n=hx(t);if(n.length!==this.inputLayers.length)throw new oe(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);let r={};for(let o=0;o<n.length;o++){let u=this.inputLayers[o],c=n[o],l=u.name+"_0_0";r[l]=c}let s=Object.keys(this.nodesByDepth).map(o=>parseInt(o,10)).sort(h2);if(s.length>1)for(let o of s){let u=this.nodesByDepth[o];for(let c of u){let l=c.outboundLayer;if(this.inputLayers.map(m=>m.id).indexOf(l.id)!==-1)continue;let d=[];for(let m=0;m<c.inboundLayers.length;m++){let g=c.inboundLayers[m],b=c.nodeIndices[m],y=c.tensorIndices[m],x=`${g.name}_${b}_${y}`,w=r[x];d.push(w)}let h=l.computeOutputShape(ea(d)),p=hx(h),f=l.inboundNodes.indexOf(c);for(let m=0;m<p.length;m++){let g=`${l.name}_${f}_${m}`;r[g]=p[m]}}}let a=[],i=[];for(let o=0;o<this.outputLayers.length;o++){let u=this.outputLayers[o],c=this.outputLayersNodeIndices[o],l=this.outputLayersTensorIndices[o],d=`${u.name}_${c}_${l}`;i.push(d)}for(let o=0;o<i.length;o++){let u=i[o];co(u in r),a.push(r[u])}return ea(a)}runInternalGraph(t,n){n==null&&(n=Kc(null,t.length));let r={};for(let u=0;u<this.inputs.length;++u){let c=this.inputs[u],l=t[u],d=n[u];r[c.id]=[l,d]}let s=Object.keys(this.nodesByDepth).map(u=>parseInt(u,10)).sort(h2);for(let u of s){let c=this.nodesByDepth[u];for(let l of c){let d=l.outboundLayer,h=l.inputTensors,p=l.outputTensors,f=new Array;for(let m of h)m.id in r&&f.push(r[m.id]);if(f.length===h.length){let m={},g,b,y,x;if(l.callArgs!=null&&(m=l.callArgs),f.length===1){let[w,v]=f[0];m.mask==null&&(m.mask=v),y=An(d.call(w,m)),x=An(d.computeMask(w,v)),g=[w],b=[v]}else g=f.map(w=>w[0]),b=f.map(w=>w[1]),m.mask==null&&(m.mask=b),y=An(d.call(g,m)),x=An(d.computeMask(g,b));if(d.activityRegularizer)throw new Xt("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let w=0;w<p.length;++w){let v=p[w],I=y[w],N=x[w];r[v.id]=[I,N]}}}}let a=[],i=[],o=[];for(let u of this.outputs){co(u.id in r,`Could not compute output ${u.name} : ${u.id}`);let[c,l]=r[u.id];o.push(c.shape),a.push(c),i.push(l)}return[a,i,o]}buildNodeConversionMap(t){let n={},r;for(let s of this.layers){r=s instanceof io?1:0;for(let a=0;a<s.inboundNodes.length;a++){let i=io.nodeKey(s,a);this.containerNodes.has(i)&&(n[i]=r,r+=1)}}return n}getLayer(t,n){if(n!=null)return this.findLayer(n);if(t==null)throw new oe("Provide either a layer name or layer index");if(typeof t=="number")return this.findLayer(t);for(let r of this.layers)if(r.name===t)return r;throw new oe(`No such layer: ${t}`)}findLayer(t){if(this.layers.length<=t)throw new oe(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}calculateLosses(){return ie(()=>{let t=[];for(let n of this.layers)for(let r=0;r<n.inboundNodes.length;++r){let s=io.nodeKey(n,r);this.containerNodes.has(s)&&t.push(...n.calculateLosses())}return t})}getConfig(){let t={name:this.name},n=this.buildNodeConversionMap(this.layers),r=[];for(let i of this.layers){let o=i.getClassName(),u=i.getConfig(),c=[];for(let d=0;d<i.inboundNodes.length;d++){let h=i.inboundNodes[d],p=io.nodeKey(i,d),f={};if(this.containerNodes.has(p)){if(h.callArgs)try{JSON.stringify(h.callArgs),f=h.callArgs}catch{console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${h.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),f={}}if(h.inboundLayers.length>0){let m=[];for(let g=0;g<h.inboundLayers.length;g++){let b=h.inboundLayers[g],y=h.nodeIndices[g],x=h.tensorIndices[g],w=io.nodeKey(b,y),v=n[w];v==null&&(v=0),m.push([b.name,v,x,f])}c.push(m)}}}let l={};l.name=i.name,l.className=o,l.config=u,l.inboundNodes=c,r.push(l)}t.layers=r;let s=[];for(let i=0;i<this.inputLayers.length;i++){let o=this.inputLayers[i],u=this.inputLayersNodeIndices[i],c=io.nodeKey(o,u);if(!this.containerNodes.has(c))continue;let l=n[c];l==null&&(l=0);let d=this.inputLayersTensorIndices[i];s.push([o.name,l,d])}t.inputLayers=s;let a=[];for(let i=0;i<this.outputLayers.length;i++){let o=this.outputLayers[i],u=this.outputLayersNodeIndices[i],c=io.nodeKey(o,u);if(!this.containerNodes.has(c))continue;let l=n[c];l==null&&(l=0);let d=this.outputLayersTensorIndices[i];a.push([o.name,l,d])}return t.outputLayers=a,t}static fromConfig(t,n,r={},s=!1){let a={},i={};function o(g,b){g.name in i?i[g.name].push(b):i[g.name]=[b]}function u(g,b){let y=[],x;for(let w of b){let v=w[0],I=w[1],N=w[2];if(x=w[3]==null?{}:w[3],!(v in a)){o(g,b);return}let T=a[v];if(T.inboundNodes.length<=I){o(g,b);return}let E=T.inboundNodes[I];y.push(E.outputTensors[N])}y.length>0&&g.apply(ea(y),x)}function c(g){let b=g.name,y=zi(g,n.customObjects!=null?n.customObjects:{});y.setFastWeightInitDuringBuild(s),a[b]=y,g.inboundNodes.forEach(x=>{if(!(x instanceof Array))throw new oe(`Corrupted configuration, expected array for nodeData: ${x}`);o(y,x)})}let l=n.name,d=n.layers;for(let g of d)c(g);for(;!Uae(i);)for(let g of d){let b=a[g.name];if(b.name in i){let y=i[b.name];delete i[b.name];for(let x of y)u(b,x)}}let h=[],p=[],f=n.inputLayers;for(let g of f){let b=g[0],y=g[1],x=g[2];co(b in a);let w=a[b].inboundNodes[y].outputTensors;h.push(w[x])}let m=n.outputLayers;for(let g of m){let b=g[0],y=g[1],x=g[2];co(b in a);let w=a[b].inboundNodes[y].outputTensors;p.push(w[x])}return new t({inputs:h,outputs:p,name:l})}get stateful(){if(this._stateful)throw new oe("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let t of this.layers)if(t.stateful)return!0;return!1}resetStates(){ie(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}};function woe(e,t,n){let r=t.length;if(e==null||Array.isArray(e)&&e.length===0)return t.map(s=>null);if(r===1)return Array.isArray(e)&&e.length===1?e:typeof e=="object"&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}else if(typeof e=="object"&&Object.keys(e).length>0&&typeof e[Object.keys(e)[0]]=="object"){let s=[];return t.forEach(a=>{a in e?s.push(e[a]):s.push(null)}),s}else throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}function zM(e,t){return woe(e,t,"classWeight")}async function WM(e,t,n,r){if(n!=null){let s=ie(()=>{if(e.shape.length===1)return xo(e);if(e.shape.length===2){if(e.shape[1]>1)return Uc(e,1);if(e.shape[1]===1)return ae(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),a=Array.from(await s.data());Lt(s);let i=[];return a.forEach(o=>{if(n[o]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${o} exists in the data but not in classWeight`);i.push(n[o])}),Tn(i,"float32")}else return null}function voe(e,t){return se(e,t)}var Ioe=32;function VM(e,t){let n,r,s=t;n=s.xs,r=s.ys,$.assert(n!=null&&r!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);let a=NR("input",e.inputNames,n),i=NR("output",e.outputNames,r),o=a[0].shape[0];$.assert(a.length===e.inputs.length,()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${a.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`),$.assert(i.length===e.outputs.length,()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`);for(let u=0;u<a.length;u++)$.assert(a[u].shape[0]===o,()=>`Batch size mismatch: input ${e.inputNames[u]} has ${a[u].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);for(let u=0;u<i.length;u++)$.assert(i[u].shape[0]===o,()=>`Batch size mismatch: output ${e.outputNames[u]} has ${i[u].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);return{xs:a,ys:i}}function NR(e,t,n){if(n instanceof Wt)return[n];if(Array.isArray(n))return $.assert(n.length===t.length,()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`),n;{let r=[];for(let s of t){if(n[s]==null)throw new oe(`The feature data generated by the dataset lacks the required ${e} key '${s}'.`);r.push(n[s])}return r}}function koe(e){if(e.length===3)throw new Xt("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}async function Coe(e,t,n){let r=n.batchesPerEpoch!=null;if($.assert(e.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),$.assert(n!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),$.assert(n.epochs!=null&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),$.assert(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),$.assert(n.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{let s=n.validationData!=null,a,i;if(s)if(TR(n.validationData))$.assert(n.validationBatches==null||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{let g=koe(n.validationData);a=g.xs,i=g.ys}let o=e.makeTrainFunction(),u=e.getDedupedMetricsNames(),c;s?c=u.slice().concat(u.map(g=>"val_"+g)):c=u.slice();let l=_M(n.callbacks,n.yieldEvery),d=n.verbose==null?1:n.verbose,{callbackList:h,history:p}=DM(l,d,n.epochs,null,null,Soe(t,n),null,s,c);h.setModel(e),e.history=p,await h.onTrainBegin(),e.stopTraining_=!1;let f=n.initialEpoch==null?0:n.initialEpoch,m=await t.iterator();for(;f<n.epochs;){let g={};await h.onEpochBegin(f);let b=0,y=0;for(r||(m=await t.iterator());!r||b<n.batchesPerEpoch;){let x=await m.next();if(r&&x.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${b} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(x.value!=null){let{xs:w,ys:v}=VM(e,x.value),I={};I.batch=y,I.size=w[0].shape[0],await h.onBatchBegin(y,I);let N=[];if(n.classWeight!=null){let A=zM(n.classWeight,e.outputNames);for(let k=0;k<A.length;++k)N.push(await WM(v[k],null,A[k]))}let T=w.concat(v).concat(N),E=o(T);Lt(T);for(let A=0;A<u.length;++A){let k=u[A],C=E[A];I[k]=C,zr(C)}await h.onBatchEnd(y,I),EM(I),y++,b++}if(r?b>=n.batchesPerEpoch:x.done){if(s){let w;TR(n.validationData)?w=An(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):w=An(e.evaluate(a,i,{batchSize:n.validationBatchSize==null?Ioe:n.validationBatchSize,verbose:0}));for(let v=0;v<e.metricsNames.length;++v)g[`val_${e.metricsNames[v]}`]=w[v]}break}if(e.stopTraining_)break}if(await h.onEpochEnd(f,g),f++,e.stopTraining_)break}return await h.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function Soe(e,t){let n=null;return t.batchesPerEpoch!=null?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}function TR(e){return typeof e.iterator=="function"}function Noe(e){return typeof e.next=="function"}async function Toe(e,t,n){n=n||{};let r=n.batches!=null,s=e.testFunction,a=[];if(n.verbose>0)throw new Xt("Verbose mode is not implemented yet.");$.assert(!r||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);let i=Noe(t)?t:await t.iterator(),o=0,u=0;for(;!r||u<n.batches;){let c=await i.next();if(a=ie(()=>{if(c.value){let{xs:l,ys:d}=VM(e,c.value),h=l.concat(d),p=ie(()=>s(h));if(Lt(h),u===0)for(let m=0;m<p.length;++m)a.push(vt(0));let f=h[0].shape[0];for(let m=0;m<p.length;++m){let g=p[m],b=a[m];a[m]=ie(()=>Se(a[m],se(f,g))),u>0&&Lt(b)}Lt(p),o+=f,++u}return a}),c.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let c=0;c<a.length;++c){let l=a[c];a[c]=it(a[c],o),Lt(l)}return ea(a)}function ok(e){$.assert(e>0&&Number.isInteger(e),()=>`batchSize is required to be a positive integer, but got ${e}`)}function Tb(e,t,n){return e==null?[null]:Array.isArray(e)?e.map(r=>$c(r,t,n-t)):$c(e,t,n-t)}function bC(e,t){return ie(()=>e==null?null:Array.isArray(e)?e.map(n=>bC(n,t)):xM(e,t.dtype==="int32"?t:Ve(t,"int32")))}function lk(e,t){let n=[],r=0,s=null;for(;r<e;)s=r+t,s>=e&&(s=e),n.push([r,s]),r=s;return n}function UM(e){let t=[];e instanceof Wt&&(e=[e]);for(let n=0;n<e.length;++n){let r=e[n];if(r.rank===1)t.push(_0(r,1));else{if(r.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function Ai(e,t){if(e==null)return;let n=[];if(t instanceof Wt)n.push(t.id);else if(Array.isArray(t))t.forEach(s=>n.push(s.id));else if(t!=null)for(let s in t){let a=t[s];n.push(a.id)}let r=[];if(e instanceof Wt)n.indexOf(e.id)===-1&&r.push(e);else if(Array.isArray(e))e.forEach(s=>{n.indexOf(s.id)===-1&&r.push(s)});else if(e!=null)for(let s in e){let a=e[s];n.indexOf(a.id)===-1&&r.push(a)}r.forEach(s=>{s.isDisposed||s.dispose()})}function Eoe(e){return e instanceof Wt}function yC(e){return Array.isArray(e)}function ER(e){return!Eoe(e)&&!yC(e)}function AR(e,t,n,r=!0,s=""){if(t==null||t.length===0){if(e!=null){let i=!1;if(yC(e)&&e.length>0)i=!0;else if(ER(e)){for(let o in e)if(e.hasOwnProperty(o)){i=!0;break}}else i=!0;if(i)throw new oe(`Error when checking model ${s} expected no data, but got ${e}`)}return[]}if(e==null)return t.map(i=>null);let a;if(ER(e)){e=e,a=[];for(let i of t){if(e[i]==null)throw new oe(`No data provided for "${i}". Need data for each key in: ${t}`);a.push(e[i])}}else if(yC(e)){if(e=e,e.length!==t.length)throw new oe(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);a=e}else{if(e=e,t.length>1)throw new oe(`The model ${s} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);a=[e]}if(a=UM(a),n!=null)for(let i=0;i<t.length;++i){if(n[i]==null)continue;let o=a[i];if(o.shape.length!==n[i].length)throw new oe(`Error when checking ${s}: expected ${t[i]} to have ${n[i].length} dimension(s). but got array with shape ${o.shape}`);for(let u=0;u<n[i].length;++u){if(u===0&&!r)continue;let c=o.shape[u],l=n[i][u];if(l!=null&&l>=0&&c!==l)throw new oe(`${s} expected a batch of elements where each example has shape [${n[i].slice(1,n[i].length)}] (i.e.,tensor shape [*,${n[i].slice(1,n[i].length)}]) but the ${s} received an input with ${o.shape[0]} examples, each with shape [${o.shape.slice(1,o.shape.length)}] (tensor shape [${o.shape}])`)}}return a}function Aoe(e,t,n){let r=Vl(e.map(a=>a.shape[0]));r.sort();let s=Vl(t.map(a=>a.shape[0]));if(s.sort(),r.length>1)throw new oe(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(a=>a.shape))}`);if(s.length>1)throw new oe(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(a=>a.shape))}`);if(r.length>0&&s.length>0&&!$.arraysEqual(r,s))throw new oe(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${s[0]} target sample(s).`)}function $oe(e,t,n){let r=[Wh,yv,fy];for(let s=0;s<e.length;++s){let a=e[s],i=t[s],o=n[s];if(i!=null){if(i===fy&&a.shape[a.shape.length-1]===1)throw new oe(`You are passing a target array of shape ${a.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(r.indexOf(i)!==-1){let u=a.shape.slice(1),c=o.slice(1);for(let l=0;l<u.length;++l){let d=u[l],h=c[l];if(h!=null&&d!==h)throw new oe(`A target Tensor with shape ${a.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function $R(e,t,n,r=!0,s=""){let a;if(Array.isArray(e)){if(e.length!==t.length)throw new oe(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);a=e}else{if(t.length>1)throw new oe(`The model expects ${t.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);a=[e]}if(n!=null)for(let i=0;i<t.length;++i){if(n[i]==null)continue;let o=a[i];if(o.shape.length!==n[i].length)throw new oe(`Error when checking ${s}: expected ${t[i]} to have ${n[i].length} dimension(s), but got array with shape ${JSON.stringify(o.shape)}`);for(let u=0;u<n[i].length;++u){if(u===0&&!r)continue;let c=o.shape[u],l=n[i][u];if(l!=null&&l!==c)throw new oe(`Error when checking ${s}: expected ${t[i]} to have shape ${JSON.stringify(n[i])} but got array with shape ${JSON.stringify(o.shape)}.`)}}}function Roe(e,t){if(e==null||Array.isArray(e)&&e.length===0)return t.map(r=>[]);let n;if(typeof e=="string"||typeof e=="function")n=[e];else if(Array.isArray(e)||typeof e=="object")n=e;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);if(Array.isArray(n))return t.map(r=>n);{let r=[];for(let s of t){let a=n.hasOwnProperty(s)?n[s]:[];Array.isArray(a)||(a=[a]),r.push(a)}return r}}var _oe="layers-model",rl=class extends xoe{constructor(e){super(e),this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new oe("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");poe(this,e,t,n)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=hoe(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof bl))throw new oe("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(let a in e.loss)if(this.outputNames.indexOf(a)===-1)throw new oe(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(let a of this.outputNames)e.loss[a]==null&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),t.push(ik(e.loss[a]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new oe(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(a=>ik(a))}else{let a=ik(e.loss);this.outputs.forEach(i=>{t.push(a)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){let i=this.internalOutputShapes[a],o=this.outputNames[a];this.feedOutputNames.push(o),this.feedOutputShapes.push(i),this.feedLossFns.push(this.lossFunctions[a])}let n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Ac("loss",()=>{for(let a=0;a<this.outputs.length;++a){if(n.indexOf(a)!==-1)continue;let i=this.lossFunctions[a];this.outputs.length>1&&(this.metricsTensors.push([i,a]),this.metricsNames.push(this.outputNames[a]+"_loss"))}});let r=Roe(e.metrics,this.outputNames),s=(a,i,o)=>{this.outputNames.length>1&&(i=this.outputNames[a]+"_"+i),this.metricsNames.push(i),this.metricsTensors.push([o,a])};Ac("metric",()=>{for(let a=0;a<this.outputs.length;++a){if(n.indexOf(a)!==-1)continue;let i=r[a];(o=>{let u="",c,l,d;for(let h of o){if(typeof h=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(h)!==-1){let f=this.internalOutputShapes[a];f[f.length-1]===1||this.lossFunctions[a]===yv?["accuracy","acc"].indexOf(h)!==-1?l=_N:["crossentropy","ce"].indexOf(h)!==-1&&(l=OM):this.lossFunctions[a]===bx?["accuracy","acc"].indexOf(h)!==-1?l=LM:["crossentropy","ce"].indexOf(h)!==-1&&(l=PM):["accuracy","acc"].indexOf(h)!==-1?l=DN:["crossentropy","ce"].indexOf(h)!==-1&&(l=FN);let m;["accuracy","acc"].indexOf(h)!==-1?m="acc":["crossentropy","ce"].indexOf(h)!==-1&&(m="ce"),d=l,c=u+m}else d=doe(h),c=u+m2(h);let p;Ac(c,()=>{p=d}),s(a,c,p)}})(i)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){let r=n.batchSize==null?32:n.batchSize;ok(r);let s=this.standardizeUserDataXY(e,t,!0,r);try{let a=s[0].concat(s[1]);this.makeTestFunction();let i=this.testFunction,o=this.testLoop(i,a,r,n.verbose,n.steps);return ea(o)}finally{Ai(s[0],e),Ai(s[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),Toe(this,e,t)}checkNumSamples(e,t,n,r="steps"){let s;if(n!=null){if(s=null,t!=null)throw new oe(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?s=e[0].shape[0]:s=e.shape[0];else throw new oe(`Either the input data should have a defined shape, or ${r} shoud be specified.`);return s}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new oe("`outputs` is an empty Array, which is not allowed.");let n=Array.isArray(t),r=n?t:[t],s=this.retrieveSymbolicTensors(r),a=new Cp;if(e instanceof Wt&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new oe(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let o=0;o<this.inputs.length;++o)a.add(this.inputs[o],e[o])}else for(let o of this.inputs){let u=e[o.name];if(u==null)throw new oe(`No value is provided for the model's input ${o.name}`);a.add(o,u)}let i=Lb(s,a);return n?i:i[0]}retrieveSymbolicTensors(e){let t=Kc(null,e.length),n=e.length;for(let r of this.layers){let s=Array.isArray(r.output)?r.output:[r.output],a=s.map(i=>i.name);for(let i=0;i<e.length;++i){let o=a.indexOf(e[i]);if(o!==-1&&(t[i]=s[o],n--),n===0)break}if(n===0)break}if(n>0){let r=[];throw t.forEach((s,a)=>{s==null&&r.push(e[a])}),new oe(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(r)}`)}return t}predictLoop(e,t=32,n=!1){return ie(()=>{let r=this.checkNumSamples(e);if(n)throw new Xt("Verbose predictLoop() is not implemented yet.");let s=lk(r,t),a=this.outputs.map(i=>[]);for(let i=0;i<s.length;++i)ie(()=>{let o=s[i][0],u=s[i][1],c=Tb(e,o,u),l=[];if(Array.isArray(c))for(let h=0;h<c.length;++h)l.push({key:this.inputs[h],value:c[h]});else l.push({key:this.inputs[0],value:c});let d=new Cp(l);return Lb(this.outputs,d)}).forEach((o,u)=>a[u].push(o));return ea(a.map(i=>Bn(i,0)))})}predict(e,t={}){let n=UM(e);$R(n,this.inputNames,this.feedInputShapes,!1);try{let r=t.batchSize==null?32:t.batchSize;return ok(r),this.predictLoop(n,r)}finally{Ai(n,e)}}predictOnBatch(e){$R(e,this.inputNames,this.feedInputShapes,!0);let t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,r){if(this.optimizer_==null)throw new go("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let s=[];for(let a=0;a<this.feedOutputShapes.length;++a){let i=this.feedOutputShapes[a];this.feedLossFns[a]===bx?s.push(i.slice(0,i.length-1).concat([1])):s.push(i)}if(e=AR(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=AR(t,this.feedOutputNames,s,!1,"target"),Aoe(e,t),$oe(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&r!=null&&r>0&&e[0].shape[0]%r!==0)throw new oe(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,r,s=!0,a){let[i,o]=this.standardizeUserDataXY(e,t,s,a);if(n!=null)throw new Error("sample weight is not supported yet.");let u=null;if(r!=null){let c=zM(r,this.outputNames);u=[];for(let l=0;l<c.length;++l)u.push(await WM(o[l],null,c[l]))}return[i,o,u]}testLoop(e,t,n,r=0,s){return ie(()=>{let a=this.checkNumSamples(t,n,s,"steps"),i=[];if(r>0)throw new Xt("Verbose mode is not implemented yet.");if(s!=null)throw new Xt("steps mode in testLoop() is not implemented yet");{let o=lk(a,n),u=Tn(Hi(0,a));for(let c=0;c<o.length;++c){let l=o[c][0],d=o[c][1],h=$c(u,l,d-l),p=bC(t,h),f=e(p);if(c===0)for(let m=0;m<f.length;++m)i.push(vt(0));for(let m=0;m<f.length;++m){let g=f[m];i[m]=Se(i[m],se(d-l,g))}}for(let c=0;c<i.length;++c)i[c]=it(i[c],a)}return i})}getDedupedMetricsNames(){let e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){let r=e[n],s=r;if(mR(e,r)>1){let a=mR(e.slice(0,n),r);s+=`_${a}`}t.push(s)}return t}makeTrainFunction(){return e=>{let t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),a=[],i=()=>{let u=[];for(let h=0;h<this.inputs.length;++h)u.push({key:this.inputs[h],value:n[h]});let c=new Cp(u),l=Lb(this.outputs,c,{training:!0}),d;for(let h=0;h<this.lossFunctions.length;++h){let p=this.lossFunctions[h],f=p(r[h],l[h]);s[h]!=null&&(f=voe(f,s[h]));let m=cr(f);t.push(m),h===0?d=f:d=Se(d,f)}for(let h=0;h<this.metricsTensors.length;++h){let p;if(this.outputs.length>1&&h<this.outputs.length)p=t[h];else{let f=this.metricsTensors[h][0],m=this.metricsTensors[h][1];p=cr(f(r[m],l[m]))}zr(p),a.push(p)}return d=cr(d),this.calculateLosses().forEach(h=>{d=Se(d,h)}),d},o=this.collectedTrainableWeights.map(u=>u.read());return[this.optimizer_.minimize(i,!0,o)].concat(a)}}makeTestFunction(){this.testFunction=e=>ie(()=>{let t=[],n,r=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let u=0;u<this.inputs.length;++u)a.push({key:this.inputs[u],value:r[u]});let i=new Cp(a),o=Lb(this.outputs,i);for(let u=0;u<this.lossFunctions.length;++u){let c=this.lossFunctions[u],l=cr(c(s[u],o[u]));u===0?n=l:n=Se(n,l),t.push(n)}for(let u=0;u<this.metricsTensors.length;++u){let c=this.metricsTensors[u][0],l=this.metricsTensors[u][1],d=cr(c(s[l],o[l]));t.push(d)}return t})}async fit(e,t,n={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let r,s,a,i,o,u,c,l,d;try{let h=n.batchSize==null?32:n.batchSize;ok(h);let p=await this.standardizeUserData(e,t,n.sampleWeight,n.classWeight,!1,h);r=p[0],s=p[1],d=p[2];let f=!1,m;if(n.validationData!=null&&n.validationData.length>0){if(f=!0,n.validationData.length===2)o=n.validationData[0],u=n.validationData[1];else throw n.validationData.length===3?new Xt("validationData including sample weights is not supported yet."):new oe(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);let I=await this.standardizeUserData(o,u,null,null,!0,h);c=I[0],l=I[1],m=c.concat(l)}else if(n.validationSplit!=null&&n.validationSplit>0&&n.validationSplit<1){f=!0;let I=Math.floor(r[0].shape[0]*(1-n.validationSplit)),N=r[0].shape[0];c=Tb(r,I,N),a=r,r=Tb(r,0,I),l=Tb(s,I,N),i=s,s=Tb(s,0,I),m=c.concat(l)}else n.validationSteps!=null&&(f=!0);let g=r.concat(s).concat(d);this.checkTrainableWeightsConsistency();let b=this.makeTrainFunction(),y=this.getDedupedMetricsNames(),x,w;f?(this.makeTestFunction(),x=this.testFunction,w=y.slice().concat(y.map(I=>"val_"+I))):(x=null,m=[],w=y.slice());let v=_M(n.callbacks,n.yieldEvery);return await this.fitLoop(b,g,y,h,n.epochs,n.verbose,v,x,m,n.shuffle,w,n.initialEpoch,null,null)}finally{this.isTraining=!1,Ai(r,e),Ai(s,t),Ai(a,e),Ai(i,t),Ai(c,o),Ai(l,u),d!=null&&Lt(d)}}async fitLoop(e,t,n,r,s,a,i,o,u,c,l,d,h,p){r==null&&(r=32),s==null&&(s=1),c==null&&(c=!0),d==null&&(d=0);let f=!1;if(o!=null&&u!=null&&(f=!0),p!=null&&(f=!0,h==null))throw new oe("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let m=this.checkNumSamples(t,r,h,"steps_per_epoch"),g;m!=null&&(g=Hi(0,m)),a==null&&(a=1);let{callbackList:b,history:y}=DM(i,a,s,d,m,h,r,f,l);b.setModel(this),this.history=y,await b.onTrainBegin(),this.stopTraining_=!1;for(let x=d;x<s;++x){await b.onEpochBegin(x);let w={};if(h!=null)throw new Xt("stepsPerEpoch mode is not implemented yet.");{if(c==="batch")throw new Xt("batch shuffling is not implemneted yet");c&&$.shuffle(g);let v=Tn(g),I=lk(m,r);for(let N=0;N<I.length;++N){let T={};if(await b.onBatchBegin(N,T),ie(()=>{let E=I[N][0],A=I[N][1],k=$c(v,E,A-E);T.batch=N,T.size=A-E;let C=bC(t,k),M=e(C);for(let L=0;L<n.length;++L){let O=n[L],B=M[L];T[O]=B,zr(B)}if(N===I.length-1&&f){let L=this.testLoop(o,u,r);for(let O=0;O<n.length;++O){let B=n[O],G=L[O];zr(G),w["val_"+B]=G}}}),await b.onBatchEnd(N,T),EM(T),this.stopTraining_)break}v.dispose()}if(await b.onEpochEnd(x,w),this.stopTraining_)break}return await b.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return Coe(this,e,t)}async trainOnBatch(e,t){let n=await this.standardizeUserData(e,t),r=n[0],s=n[1],a=this.makeTrainFunction()(r.concat(s)),i=[];for(let o of a){let u=await o.data();i.push(u[0])}return Lt(a),Ai(n[0],e),Ai(n[1],t),ea(i)}getNamedWeights(e){let t=[],n=e!=null&&e.trainableOnly,r=n?this.trainableWeights:this.weights,s=this.getWeights(n);for(let a=0;a<r.length;++a)n&&!r[a].trainable||t.push({name:r[a].originalName,tensor:s[a]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){let e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){let t=Zk().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-Zk().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=Xo(this.loss);else if(Array.isArray(this.loss)){for(let t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>Xo(t))}else{let t=Object.keys(this.loss);e={};let n=this.loss;for(let r of t)if(typeof n[r]=="string")e[r]=Xo(n[r]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[Xo(m2(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>Xo(m2(e)));{let e={};for(let t in this.metrics)e[t]=Xo(m2(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");let t=my(e.optimizer_config),n=zi(t),r;if(typeof e.loss=="string")r=yc(e.loss);else if(Array.isArray(e.loss))r=e.loss.map(a=>yc(a));else if(e.loss!=null){r={};for(let a in e.loss)r[a]=yc(e.loss[a])}let s;if(Array.isArray(e.metrics))s=e.metrics.map(a=>yc(a));else if(e.metrics!=null){s={};for(let a in e.metrics)s[a]=yc(e.metrics[a])}this.compile({loss:r,metrics:s,optimizer:n})}async save(e,t){if(typeof e=="string"){let s=fs.getSaveHandlers(e);if(s.length===0)throw new oe(`Cannot find any save handlers for URL '${e}'`);if(s.length>1)throw new oe(`Found more than one (${s.length}) save handlers for URL '${e}'`);e=s[0]}if(e.save==null)throw new oe("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let n=await fs.encodeWeights(this.getNamedWeights(t)),r={modelTopology:this.toJSON(null,!1),format:_oe,generatedBy:`TensorFlow.js tfjs-layers v${MN}`,convertedBy:null};if(t!=null&&t.includeOptimizer&&this.optimizer!=null){r.trainingConfig=this.getTrainingConfig();let s="optimizer",{data:a,specs:i}=await fs.encodeWeights(await this.optimizer.getWeights(),s);n.specs.push(...i),n.data=fs.concatenateArrayBuffers([n.data,a])}return this.userDefinedMetadata!=null&&(SR(this.userDefinedMetadata,this.name,!0),r.userDefinedMetadata=this.userDefinedMetadata),r.weightData=n.data,r.weightSpecs=n.specs,e.save(r)}setUserDefinedMetadata(e){SR(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}};rl.className="Model";Me.registerClass(rl);var GM=class extends rl{};GM.className="Functional";Me.registerClass(GM);async function Doe(e,t){"modelTopology"in e||(e={modelTopology:e}),e=e;let n=e.modelTopology;n.model_config!=null&&(n=n.model_config);let r=my(n),s=zi(r,t);if(e.weightsManifest!=null){let a=await fs.loadWeights(e.weightsManifest,e.pathPrefix,s.weights.map(o=>o.originalName)),i={};for(let o of s.weights)i[o.originalName]=a[o.originalName];s.loadWeights(i),Lt(a)}return s}async function Foe(e,t){if(t==null&&(t={}),typeof e=="string"){let n=fs.getLoadHandlers(e,t);if(n.length===0)n.push(fs.browserHTTPRequest(e,t));else if(n.length>1)throw new oe(`Found more than one (${n.length}) load handlers for URL '${e}'`);e=n[0]}return Moe(e,void 0,t)}async function Moe(e,t,n){if(n==null&&(n={}),e.load==null)throw new oe("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let r=await e.load(),s=r.modelTopology;s.model_config!=null&&(s=s.model_config);let a=n.strict==null?!0:n.strict,i=r.weightData!=null&&r.weightSpecs!=null&&a,o=zi(my(s),t,i),u=r.trainingConfig;if(u!=null&&o.loadTrainingConfig(u),r.userDefinedMetadata!=null&&o.setUserDefinedMetadata(r.userDefinedMetadata),r.weightData!=null){if(r.weightSpecs==null)throw new oe("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");let{modelWeights:c,optimizerWeights:l}=Ooe(r.weightData,r.weightSpecs);o.loadWeights(c,a),o.optimizer!=null&&l.length>0&&await o.optimizer.setWeights(l),Lt(c),Lt(l.map(d=>d.tensor))}return o}function Ooe(e,t){let n=fs.decodeWeights(e,t),r={},s=[];return t.forEach(a=>{a.group==="optimizer"?s.push({name:a.name,tensor:n[a.name]}):r[a.name]=n[a.name]}),{modelWeights:r,optimizerWeights:s}}var xv=class xC extends rl{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=t.name!=null?t.name:ov("sequential_"),t.layers!=null)for(let n of t.layers)this.add(n)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(n=>n<0))throw new oe(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){let n=t instanceof xC||t instanceof rl,r;if(n){if(r=t,r.outputs.length!==1)throw new oe("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(r.inputs.length!==1)throw new oe("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null)throw new oe("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let s=kM({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(s)}if(n)this.outputs=r.outputs,this.inputs=r.inputs;else{if(t.inboundNodes.length!==1)throw new oe(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(t.inboundNodes[0].outputTensors.length!==1)throw new oe("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=IM(this.outputs[0])}this.inboundNodes=[],new gv({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Kc(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(s=>s.shape),outputShapes:this.outputs[0].shape})}else{let s=t.apply(this.outputs[0]);if(Array.isArray(s))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[s],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,n){return this.model==null&&this.build(),this.model.call(t,n)}build(t){if(fn(t),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new rl({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,n,r=console.log){this.built||this.build(),super.summary(t,n,r)}setWeights(t){this.model==null&&this.build(),this.model.setWeights(t)}evaluate(t,n,r={}){if(!this.built)throw new go("The model needs to be compiled before being used.");return this.model.evaluate(t,n,r)}async evaluateDataset(t,n){if(!this.built)throw new go("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,n)}predict(t,n={}){return this.model==null&&this.build(),this.model.predict(t,n)}predictOnBatch(t){return this.model==null&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,n,r={}){if(!this.built)throw new go("The model needs to be compiled before being used.");return this.model.fit(t,n,r)}async fitDataset(t,n){if(!this.built)throw new go("The model needs to be compiled before being used.");return this.model.fitDataset(t,n)}async trainOnBatch(t,n){return this.model.trainOnBatch(t,n)}static fromConfig(t,n,r={},s=!1){let a,i={};if(n instanceof Array){if(n[0].className==null||n[0].className==="Merge")throw new oe("Legacy serialization format not supported yet.");a=n}else $.assert(n.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),a=n.layers,delete n.layers,i=n;let o=new t(i);if(!(o instanceof xC))throw new Xt(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(let u of a){let c=zi(u,void 0,s);s&&c.setFastWeightInitDuringBuild(!0),o.add(c)}return o}set stopTraining(t){if(this.model==null)throw new oe("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(this.model==null)throw new oe("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let t=[];for(let n of this.layers){let r={};r.className=n.getClassName(),r.config=n.getConfig(),t.push(r)}return{name:this.name,layers:t}}};xv.className="Sequential";Me.registerClass(xv);function Loe(e){return new rl(e)}function Poe(e){return new xv(e)}function HM(e){return kM(e)}function Boe(e,t){$N.registerCallbackConstructor(e,t)}var Ns=class extends Me.Serializable{getConfig(){return{}}},jM=class extends Ns{apply(e,t=1){return sie(e,t)}};jM.className="elu";Me.registerClass(jM);var qM=class extends Ns{apply(e){return Gw(e)}};qM.className="selu";Me.registerClass(qM);var KM=class extends Ns{apply(e){return Rn(e)}};KM.className="relu";Me.registerClass(KM);var XM=class extends Ns{apply(e){return ie(()=>tu(6,Rn(e)))}};XM.className="relu6";Me.registerClass(XM);var QM=class extends Ns{apply(e){return e}};QM.className="linear";Me.registerClass(QM);var YM=class extends Ns{apply(e){return ci(e)}};YM.className="sigmoid";Me.registerClass(YM);var JM=class extends Ns{apply(e){return iie(e)}};JM.className="hardSigmoid";Me.registerClass(JM);var ZM=class extends Ns{apply(e){return Ph(e)}};ZM.className="softplus";Me.registerClass(ZM);var e8=class extends Ns{apply(e){return aie(e)}};e8.className="softsign";Me.registerClass(e8);var t8=class extends Ns{apply(e){return eu(e)}};t8.className="tanh";Me.registerClass(t8);var ON=class extends Ns{apply(e,t=-1){return Su(e,t)}};ON.className="softmax";Me.registerClass(ON);var n8=class extends Ns{apply(e,t=-1){return Lw(e,t)}};n8.className="logSoftmax";Me.registerClass(n8);var r8=class extends Ns{apply(e){return ie(()=>ie(()=>{let t=Math.sqrt(2),n=se(.5,Se(1,Fw(it(e,t))));return se(e,n)}))}};r8.className="gelu";Me.registerClass(r8);var s8=class extends Ns{apply(e){return ie(()=>se(.5,se(e,Se(1,eu(se(ls(it(2,Math.PI)),Se(e,se(.044715,To(e,3)))))))))}};s8.className="gelu_new";Me.registerClass(s8);var a8=class extends Ns{apply(e){return ie(()=>se(e,eu(Ph(e))))}};a8.className="mish";Me.registerClass(a8);var i8=class extends Ns{apply(e,t=1){return ie(()=>se(ci(se(e,t)),e))}};i8.className="swish";Me.registerClass(i8);function su(e){return e.getClassName()}function uk(e,t={}){return R0(e,Me.SerializationMap.getMap().classNameMap,t,"activation")}function au(e){if(e==null){let t={};return t.className="linear",t.config={},uk(t)}if(typeof e=="string"){let t={};return t.className=e,t.config={},uk(t)}else return e instanceof Ns?e:uk(e)}function LN(e){if(e!=null&&typeof e!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}var o8=class extends Me.Serializable{},O0=class extends o8{constructor(e){super(),LN(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return ie(()=>{let t=dr([1]);return this.hasL1&&(t=Se(t,dt(se(this.l1,Ar(e))))),this.hasL2&&(t=Se(t,dt(se(this.l2,D0(e))))),ae(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}};O0.className="L1L2";Me.registerClass(O0);function zoe(e){return LN(e),new O0({l1:e!=null?e.l1:null,l2:0})}function Woe(e){return LN(e),new O0({l2:e!=null?e.l2:null,l1:0})}var RR={l1l2:"L1L2"};function Gn(e){return fN(e)}function _R(e,t={}){return R0(e,Me.SerializationMap.getMap().classNameMap,t,"regularizer")}function lr(e){if(e==null)return null;if(typeof e=="string"){let t={className:e in RR?RR[e]:e,config:{}};return _R(t)}else return e instanceof o8?e:_R(e)}var PN=class extends Qt{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=Ft(e);let n=Rn(e);return this.maxValue!=null&&(n=vs(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){let e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}};PN.className="ReLU";Me.registerClass(PN);var BN=class extends Qt{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=Ft(e);return w0(n,this.alpha)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};BN.className="LeakyReLU";Me.registerClass(BN);var zN=class extends Qt{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=ir(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=lr(e.alphaRegularizer),this.alphaConstraint=jr(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new oe(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=fn(e);let t=e.slice(1);if(this.sharedAxes!=null)for(let r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let n={};if(this.sharedAxes!=null)for(let r=1;r<e.length;++r)n[r]=e[r];this.inputSpec=[new Rr({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=Ft(e),N0(e,this.alpha.read())}getConfig(){let e={alphaInitializer:hr(this.alphaInitializer),alphaRegularizer:Gn(this.alphaRegularizer),alphaConstraint:Hr(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}};zN.className="PReLU";Me.registerClass(zN);var WN=class extends Qt{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new Xt(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=Ft(e);return gm(n)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};WN.className="ELU";Me.registerClass(WN);var VN=class extends Qt{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){let n=Ft(e);return se(n,Ve(Xs(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){let e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}};VN.className="ThresholdedReLU";Me.registerClass(VN);var UN=class extends Qt{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new ON().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){return ie(()=>{let n=Ft(e),r=t.mask;if(r!=null){let s=se(et(ra(n.shape),Ve(r,n.dtype)),vt(-1e9));n=Se(n,s)}return this.axis instanceof Array?this.axis.length>1?Is(et(n,I0(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)})}computeOutputShape(e){return e}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};UN.className="Softmax";Me.registerClass(UN);function Ep(e,t,n){if(typeof e=="number")return Kc(e,t);if(e.length!==t)throw new oe(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let r=0;r<t;++r){let s=e[r];if(!eie(s))throw new oe(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${s}`)}return e}function Wi(e,t,n,r,s=1){if(e==null)return e;let a=t+(t-1)*(s-1),i;return n==="same"?i=e:i=e-a+1,Math.floor((i+r-1)/r)}function ho(e,t,n,r){if(e==null)return null;if(r==="valid")e=e*t+ru([n-t,0]);else if(r==="same")e=e*t;else throw new oe(`Unsupport padding mode: ${r}.`);return e}function GN(e,t){return ie(()=>(kr(t),t==="channelsFirst"?Gt(e,[0,2,3,1]):e))}function l8(e,t){return ie(()=>(kr(t),t==="channelsFirst"?Gt(e,[0,2,3,4,1]):e))}function Voe(e,t,n,r=1,s="valid",a,i=1){return ie(()=>{if(a==null&&(a=ji()),kr(a),e.shape.length!==3)throw new oe(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(t.shape.length!==3)throw new oe(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(n!=null&&n.shape.length!==1)throw new oe(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);if(a==="channelsFirst"&&(e=Gt(e,[0,2,1])),s==="causal")throw new Xt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=$w(e,t,r,s==="same"?"same":"valid","NWC",i);return n!=null&&(o=Zi(o,n)),o})}function DR(e,t,n,r=[1,1],s="valid",a,i,o=null){return ie(()=>{if(a==null&&(a=ji()),kr(a),e.rank!==3&&e.rank!==4)throw new oe(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(t.rank!==3&&t.rank!==4)throw new oe(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let u=GN(e,a);if(s==="causal")throw new Xt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return u=Up.conv2d({x:u,filter:t,strides:r,pad:s==="same"?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),a==="channelsFirst"&&(u=Gt(u,[0,3,1,2])),u})}function Uoe(e,t,n,r=[1,1,1],s="valid",a,i){return ie(()=>{if(a==null&&(a=ji()),kr(a),e.rank!==4&&e.rank!==5)throw new oe(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(t.rank!==4&&t.rank!==5)throw new oe(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=l8(e,a);if(s==="causal")throw new Xt("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=y3(o,t,r,s==="same"?"same":"valid","NDHWC",i),n!=null&&(o=Zi(o,n)),a==="channelsFirst"&&(o=Gt(o,[0,4,1,2,3])),o})}var u8=class c8 extends Qt{constructor(t,n){if(super(n),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",c8.verifyArgs(n),this.rank=t,as(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Xt(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Ep(n.kernelSize,t,"kernelSize"),this.strides=Ep(n.strides==null?1:n.strides,t,"strides"),this.padding=n.padding==null?"valid":n.padding,Xa(this.padding),this.dataFormat=n.dataFormat==null?"channelsLast":n.dataFormat,kr(this.dataFormat),this.activation=au(n.activation),this.useBias=n.useBias==null?!0:n.useBias,this.biasInitializer=ir(n.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=jr(n.biasConstraint),this.biasRegularizer=lr(n.biasRegularizer),this.activityRegularizer=lr(n.activityRegularizer),this.dilationRate=Ep(n.dilationRate==null?1:n.dilationRate,t,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new oe(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new oe(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new oe(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(t){if(co("kernelSize"in t,"required key 'kernelSize' not in config"),typeof t.kernelSize!="number"&&!mN(t.kernelSize,"number",1,3))throw new oe(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){let t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:su(this.activation),useBias:this.useBias,biasInitializer:hr(this.biasInitializer),biasRegularizer:Gn(this.biasRegularizer),activityRegularizer:Gn(this.activityRegularizer),biasConstraint:Hr(this.biasConstraint)},n=super.getConfig();return Object.assign(t,n),t}},wv=class d8 extends u8{constructor(t,n){super(t,n),this.kernel=null,d8.verifyArgs(n),this.filters=n.filters,as(this.filters,"filters"),this.kernelInitializer=ir(n.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=jr(n.kernelConstraint),this.kernelRegularizer=lr(n.kernelRegularizer)}build(t){t=fn(t);let n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null)throw new oe(`The channel dimension of the input should be defined. Found ${t[n]}`);let r=t[n],s=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[n]:r}}],this.built=!0}call(t,n){return ie(()=>{t=Ft(t);let r,s=this.bias==null?null:this.bias.read(),a=pM(this.activation.getClassName());if(a!=null&&this.rank===2)r=DR(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate,a);else{if(this.rank===1)r=Voe(t,this.kernel.read(),s,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)r=DR(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)r=Uoe(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Xt("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(r=this.activation.apply(r))}return r})}computeOutputShape(t){t=fn(t);let n=[],r=this.dataFormat==="channelsLast"?t.slice(1,t.length-1):t.slice(2);for(let a=0;a<r.length;++a){let i=Wi(r[a],this.kernelSize[a],this.padding,this.strides[a],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[a]);n.push(i)}let s=[t[0]];return this.dataFormat==="channelsLast"?(s=s.concat(n),s.push(this.filters)):(s.push(this.filters),s=s.concat(n)),s}getConfig(){let t={filters:this.filters,kernelInitializer:hr(this.kernelInitializer),kernelRegularizer:Gn(this.kernelRegularizer),kernelConstraint:Hr(this.kernelConstraint)},n=super.getConfig();return Object.assign(t,n),t}static verifyArgs(t){if(!("filters"in t)||typeof t.filters!="number"||t.filters<1)throw new oe(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}},vv=class h8 extends wv{constructor(t){super(2,t),h8.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!mN(t.kernelSize,"number",1,2))throw new oe(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}};vv.className="Conv2D";Me.registerClass(vv);var Iv=class p8 extends wv{constructor(t){super(3,t),p8.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3)))throw new oe(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}};Iv.className="Conv3D";Me.registerClass(Iv);var HN=class extends vv{constructor(e){if(super(e),this.inputSpec=[new Rr({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new oe(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=fn(e),e.length!==4)throw new oe("Input should have rank 4; Received input shape: "+JSON.stringify(e));let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new oe("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Rr({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return ie(()=>{let n=Ft(e);if(n.shape.length!==4)throw new oe(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let r=n.shape,s=r[0],a,i;this.dataFormat==="channelsFirst"?(a=2,i=3):(a=1,i=2);let o=r[a],u=r[i],c=this.kernelSize[0],l=this.kernelSize[1],d=this.strides[0],h=this.strides[1],p=ho(o,d,c,this.padding),f=ho(u,h,l,this.padding),m=[s,p,f,this.filters];this.dataFormat!=="channelsLast"&&(n=Gt(n,[0,2,3,1]));let g=Rw(n,this.kernel.read(),m,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(g=Gt(g,[0,3,1,2])),this.bias!=null&&(g=Zi(g,this.bias.read(),this.dataFormat)),this.activation!=null&&(g=this.activation.apply(g)),g})}computeOutputShape(e){e=fn(e);let t=e.slice(),n,r,s;this.dataFormat==="channelsFirst"?(n=1,r=2,s=3):(n=3,r=1,s=2);let a=this.kernelSize[0],i=this.kernelSize[1],o=this.strides[0],u=this.strides[1];return t[n]=this.filters,t[r]=ho(t[r],o,a,this.padding),t[s]=ho(t[s],u,i,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};HN.className="Conv2DTranspose";Me.registerClass(HN);var jN=class extends Iv{constructor(e){if(super(e),this.inputSpec=[new Rr({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new oe(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=fn(e),e.length!==5)throw new oe("Input should have rank 5; Received input shape: "+JSON.stringify(e));let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new oe("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Rr({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return ie(()=>{let n=Ft(e);if(n.shape.length!==5)throw new oe(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let r=n.shape,s=r[0],a,i,o;this.dataFormat==="channelsFirst"?(o=2,a=3,i=4):(o=1,a=2,i=3);let u=r[o],c=r[a],l=r[i],d=this.kernelSize[0],h=this.kernelSize[1],p=this.kernelSize[2],f=this.strides[0],m=this.strides[1],g=this.strides[2],b=ho(u,f,d,this.padding),y=ho(c,m,h,this.padding),x=ho(l,g,p,this.padding),w=[s,b,y,x,this.filters];this.dataFormat!=="channelsLast"&&(n=Gt(n,[0,2,3,4,1]));let v=x3(n,this.kernel.read(),w,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(v=Gt(v,[0,4,1,2,3])),this.bias!==null&&(v=Zi(v,this.bias.read(),this.dataFormat)),this.activation!==null&&(v=this.activation.apply(v)),v})}computeOutputShape(e){e=fn(e);let t=e.slice(),n,r,s,a;this.dataFormat==="channelsFirst"?(n=1,r=2,s=3,a=4):(n=4,r=1,s=2,a=3);let i=this.kernelSize[0],o=this.kernelSize[1],u=this.kernelSize[2],c=this.strides[0],l=this.strides[1],d=this.strides[2];return t[n]=this.filters,t[r]=ho(t[r],c,i,this.padding),t[s]=ho(t[s],l,o,this.padding),t[a]=ho(t[a],d,u,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};jN.className="Conv3DTranspose";Me.registerClass(jN);var f8=class extends wv{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new oe("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new oe("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new oe(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=ir(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=lr(t.depthwiseRegularizer),this.depthwiseConstraint=jr(t.depthwiseConstraint),this.pointwiseInitializer=ir(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=lr(t.pointwiseRegularizer),this.pointwiseConstraint=jr(t.pointwiseConstraint)}build(e){if(e=fn(e),e.length<this.rank+2)throw new oe(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new oe(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);let n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),s=[];for(let i=0;i<this.rank;++i)s.push(1);s.push(n*this.depthMultiplier,this.filters);let a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",s,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):this.bias=null,this.inputSpec=[new Rr({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return ie(()=>{e=Ft(e);let n;if(this.rank===1)throw new Xt("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=Gt(e,[0,2,3,1])),n=wm(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(n=Zi(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),this.dataFormat==="channelsFirst"&&(n=Gt(n,[0,3,1,2])),n})}getConfig(){let e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=hr(this.depthwiseInitializer),e.pointwiseInitializer=hr(this.pointwiseInitializer),e.depthwiseRegularizer=Gn(this.depthwiseRegularizer),e.pointwiseRegularizer=Gn(this.pointwiseRegularizer),e.depthwiseConstraint=Hr(this.depthwiseConstraint),e.pointwiseConstraint=Hr(this.pointwiseConstraint),e}};f8.className="SeparableConv";var qN=class extends f8{constructor(e){super(2,e)}};qN.className="SeparableConv2D";Me.registerClass(qN);var KN=class m8 extends wv{constructor(t){super(1,t),m8.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){let t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!mN(t.kernelSize,"number",1,1))throw new oe(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}};KN.className="Conv1D";Me.registerClass(KN);var XN=class extends Qt{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return ie(()=>{if(e=Ft(e),this.dataFormat==="channelsLast"){let n=f2(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return f2(n,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{let n=f2(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return f2(n,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};XN.className="Cropping2D";Me.registerClass(XN);var QN=class extends Qt{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,kr(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,Yae(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){let t=e[2]==null?null:this.size[0]*e[2],n=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,n]}else{let t=e[1]==null?null:this.size[0]*e[1],n=e[2]==null?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return ie(()=>{let n=Ft(e),r=n.shape;if(this.dataFormat==="channelsFirst"){n=Gt(n,[0,2,3,1]);let s=this.size[0]*r[2],a=this.size[1]*r[3],i=this.interpolation==="nearest"?La.resizeNearestNeighbor(n,[s,a]):La.resizeBilinear(n,[s,a]);return Gt(i,[0,3,1,2])}else{let s=this.size[0]*r[1],a=this.size[1]*r[2];return this.interpolation==="nearest"?La.resizeNearestNeighbor(n,[s,a]):La.resizeBilinear(n,[s,a])}})}getConfig(){let e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}};QN.className="UpSampling2D";Me.registerClass(QN);function Goe(e,t,n=[1,1],r="valid",s,a){return ie(()=>{s==null&&(s=ji()),kr(s);let i=GN(e,s);if(e.rank!==4)throw new oe(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(t.rank!==4)throw new oe(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=Lh(i,t,n,r==="same"?"same":"valid","NHWC",a),s==="channelsFirst"&&(i=Gt(i,[0,3,1,2])),i})}var YN=class extends u8{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=ir(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=jr(e.depthwiseConstraint),this.depthwiseRegularizer=lr(e.depthwiseRegularizer)}build(e){if(e=fn(e),e.length<4)throw new oe(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);let t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new oe(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);let n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return ie(()=>{e=Ft(e);let n=Goe(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(n=Zi(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),n})}computeOutputShape(e){e=fn(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,s=Wi(t,this.kernelSize[0],this.padding,this.strides[0]),a=Wi(n,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],r,s,a]:[e[0],s,a,r]}getConfig(){let e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=hr(this.depthwiseInitializer),e.depthwiseRegularizer=Gn(this.depthwiseRegularizer),e.depthwiseConstraint=Hr(this.depthwiseRegularizer),e}};YN.className="DepthwiseConv2D";Me.registerClass(YN);function g8(e,t,n,r){if(Array.isArray(e)){if(t!=null||n!=null)throw new oe("When inputs is an array, neither initialState or constants should be provided");r!=null&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function s(a){return a==null||Array.isArray(a)?a:[a]}return t=s(t),n=s(n),{inputs:e,initialState:t,constants:n}}function b8(e,t,n,r=!1,s,a,i=!1,o=!1){return ie(()=>{let u=t.shape.length;if(u<3)throw new oe(`Input should be at least 3D, but is ${u}D.`);let c=[1,0].concat(Hi(2,u));t=Gt(t,c),a!=null,i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),s!=null&&(s=Ve(Ve(s,"bool"),"float32"),s.rank===u-1&&(s=ns(s,-1)),s=Gt(s,c)),r&&(t=qa(t,0),s!=null&&(s=qa(s,0)));let l=[],d,h=n,p=t.shape[0],f=br(t),m;s!=null&&(m=br(s));for(let b=0;b<p;++b){let y=f[b],x=ie(()=>e(y,h));if(s==null)d=x[0],h=x[1];else{let w=ie(()=>{let v=m[b],I=et(Ea(v),v),N=Se(se(x[0],v),se(h[0],I)),T=h.map((E,A)=>Se(se(x[1][A],v),se(E,I)));return{output:N,newStates:T}});d=w.output,h=w.newStates}o&&l.push(d)}let g;return o&&(g=Dr(l,1)),[d,g,h]})}var yl=class y8 extends Qt{constructor(t){super(t);let n;if(t.cell==null)throw new oe("cell property is missing for the constructor of RNN.");if(Array.isArray(t.cell)?n=new Sv({cells:t.cell}):n=t.cell,n.stateSize==null)throw new oe("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=n,this.returnSequences=t.returnSequences==null?!1:t.returnSequences,this.returnState=t.returnState==null?!1:t.returnState,this.goBackwards=t.goBackwards==null?!1:t.goBackwards,this._stateful=t.stateful==null?!1:t.stateful,this.unroll=t.unroll==null?!1:t.unroll,this.supportsMasking=!0,this.inputSpec=[new Rr({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return Hi(0,t).map(n=>null)}else return this.states_}setStates(t){this.states_=t}computeOutputShape(t){pC(t)&&(t=t[0]),t=t;let n=this.cell.stateSize;Array.isArray(n)||(n=[n]);let r=n[0],s;if(this.returnSequences?s=[t[0],t[1],r]:s=[t[0],r],this.returnState){let a=[];for(let i of n)a.push([t[0],i]);return[s].concat(a)}else return s}computeMask(t,n){return ie(()=>{Array.isArray(n)&&(n=n[0]);let r=this.returnSequences?n:null;if(this.returnState){let s=this.states.map(a=>null);return[r].concat(s)}else return r})}get states(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,n=[];for(let r=0;r<t;++r)n.push(null);return n}else return this.states_}set states(t){this.states_=t}build(t){if(this.numConstants!=null)throw new Xt("Constants support is not implemented in RNN yet.");pC(t)&&(t=t[0]),t=t;let n=this.stateful?t[0]:null,r=t.slice(2);this.inputSpec[0]=new Rr({shape:[n,null,...r]});let s=[t[0]].concat(t.slice(2));this.cell.build(s);let a;if(Array.isArray(this.cell.stateSize)?a=this.cell.stateSize:a=[this.cell.stateSize],this.stateSpec!=null){if(!$.arraysEqual(this.stateSpec.map(i=>i.shape[i.shape.length-1]),a))throw new oe(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(i=>new Rr({shape:[null,i]}));this.stateful&&this.resetStates()}resetStates(t,n=!1){ie(()=>{if(!this.stateful)throw new Al("Cannot call resetStates() on an RNN Layer that is not stateful.");let r=this.inputSpec[0].shape[0];if(r==null)throw new oe("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>dr([r,s])):this.states_=[dr([r,this.cell.stateSize])];else if(t==null)Lt(this.states_),this.keptStates!=null&&(Lt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>dr([r,s])):this.states_[0]=dr([r,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new oe(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);n===!0?this.keptStates.push(this.states_.slice()):Lt(this.states_);for(let s=0;s<this.states_.length;++s){let a=t[s],i=Array.isArray(this.cell.stateSize)?this.cell.stateSize[s]:this.cell.stateSize,o=[r,i];if(!$.arraysEqual(a.shape,o))throw new oe(`State ${s} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${a.shape}`);this.states_[s]=a}}this.states_=this.states_.map(s=>zr(s.clone()))})}apply(t,n){let r=n==null?null:n.initialState,s=n==null?null:n.constants;n==null&&(n={});let a=g8(t,r,s,this.numConstants);t=a.inputs,r=a.initialState,s=a.constants;let i=[],o=[];if(r!=null){n.initialState=r,i=i.concat(r),this.stateSpec=[];for(let u of r)this.stateSpec.push(new Rr({shape:u.shape}));o=o.concat(this.stateSpec)}if(s!=null&&(n.constants=s,i=i.concat(s),this.numConstants=s.length),i[0]instanceof qi){let u=[t].concat(i),c=this.inputSpec.concat(o),l=this.inputSpec;this.inputSpec=c;let d=super.apply(u,n);return this.inputSpec=l,d}else return super.apply(t,n)}call(t,n){return ie(()=>{let r=n==null?null:n.mask,s=n==null?null:n.training,a=n==null?null:n.initialState;t=Ft(t),a==null&&(this.stateful?a=this.states_:a=this.getInitialState(t));let i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(a.length!==i)throw new oe(`RNN Layer has ${i} state(s) but was passed ${a.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let o={training:s},u=b8((p,f)=>{let m=this.cell.call([p].concat(f),o);return[m[0],m.slice(1)]},t,a,this.goBackwards,r,null,this.unroll,this.returnSequences),c=u[0],l=u[1],d=u[2];this.stateful&&this.resetStates(d,s);let h=this.returnSequences?l:c;return this.returnState?[h].concat(d):h})}getInitialState(t){return ie(()=>{let n=dr(t.shape);return n=dt(n,[1,2]),n=_0(n),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(r=>r>1?dC(n,[1,r]):n):this.cell.stateSize>1?[dC(n,[1,this.cell.stateSize])]:[n]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){let t=super.getConfig(),n={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(n.numConstants=this.numConstants);let r=this.cell.getConfig();return this.getClassName()===y8.className&&(n.cell={className:this.cell.getClassName(),config:r}),Object.assign(Object.assign(Object.assign({},r),t),n)}static fromConfig(t,n,r={}){let s=n.cell,a=zi(s,r);return new t(Object.assign(n,{cell:a}))}};yl.className="RNN";Me.registerClass(yl);var L0=class extends Qt{},kv=class extends L0{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,as(this.units,"units"),this.activation=au(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=ir(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ir(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ir(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=lr(e.kernelRegularizer),this.recurrentRegularizer=lr(e.recurrentRegularizer),this.biasRegularizer=lr(e.biasRegularizer),this.kernelConstraint=jr(e.kernelConstraint),this.recurrentConstraint=jr(e.recurrentConstraint),this.biasConstraint=jr(e.biasConstraint),this.dropout=Gp([1,ru([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Gp([1,ru([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=fn(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return ie(()=>{if(e=e,e.length!==2)throw new oe(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];let r=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=iu({ones:()=>Ea(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=iu({ones:()=>Ea(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let s,a=this.dropoutMask,i=this.recurrentDropoutMask;a!=null?s=vo(se(e,a),this.kernel.read()):s=vo(e,this.kernel.read()),this.bias!=null&&(s=Zi(s,this.bias.read())),i!=null&&(n=se(n,i));let o=Se(s,vo(n,this.recurrentKernel.read()));return this.activation!=null&&(o=this.activation.apply(o)),[o,o]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:su(this.activation),useBias:this.useBias,kernelInitializer:hr(this.kernelInitializer),recurrentInitializer:hr(this.recurrentInitializer),biasInitializer:hr(this.biasInitializer),kernelRegularizer:Gn(this.kernelRegularizer),recurrentRegularizer:Gn(this.recurrentRegularizer),biasRegularizer:Gn(this.biasRegularizer),activityRegularizer:Gn(this.activityRegularizer),kernelConstraint:Hr(this.kernelConstraint),recurrentConstraint:Hr(this.recurrentConstraint),biasConstraint:Hr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}};kv.className="SimpleRNNCell";Me.registerClass(kv);var JN=class extends yl{constructor(e){e.cell=new kv(e),super(e)}call(e,t){return ie(()=>{this.cell.dropoutMask!=null&&(Lt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Lt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,r=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})})}static fromConfig(e,t){return new e(t)}};JN.className="SimpleRNN";Me.registerClass(JN);var Cv=class extends L0{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new oe("GRUCell does not support reset_after parameter set to true.");this.units=e.units,as(this.units,"units"),this.activation=au(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=au(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=ir(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ir(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ir(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=lr(e.kernelRegularizer),this.recurrentRegularizer=lr(e.recurrentRegularizer),this.biasRegularizer=lr(e.biasRegularizer),this.kernelConstraint=jr(e.kernelConstraint),this.recurrentConstraint=jr(e.recurrentConstraint),this.biasConstraint=jr(e.biasConstraint),this.dropout=Gp([1,ru([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Gp([1,ru([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=fn(e);let t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return ie(()=>{if(e=e,e.length!==2)throw new oe(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training==null?!1:t.training,r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=iu({ones:()=>Ea(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=iu({ones:()=>Ea(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));let s=this.dropoutMask,a=this.recurrentDropoutMask,i,o,u;0<this.dropout&&this.dropout<1&&(e=se(e,s[0]));let c=vo(e,this.kernel.read());this.useBias&&(c=Zi(c,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=se(r,a[0]));let l=this.recurrentKernel.read(),[d,h]=sa(l,[2*this.units,this.units],l.rank-1),p=vo(r,d),[f,m,g]=sa(c,3,c.rank-1),[b,y]=sa(p,2,p.rank-1);i=this.recurrentActivation.apply(Se(f,b)),o=this.recurrentActivation.apply(Se(m,y));let x=vo(se(o,r),h);u=this.activation.apply(Se(g,x));let w=Se(se(i,r),se(Se(1,Jn(i)),u));return[w,w]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:su(this.activation),recurrentActivation:su(this.recurrentActivation),useBias:this.useBias,kernelInitializer:hr(this.kernelInitializer),recurrentInitializer:hr(this.recurrentInitializer),biasInitializer:hr(this.biasInitializer),kernelRegularizer:Gn(this.kernelRegularizer),recurrentRegularizer:Gn(this.recurrentRegularizer),biasRegularizer:Gn(this.biasRegularizer),activityRegularizer:Gn(this.activityRegularizer),kernelConstraint:Hr(this.kernelConstraint),recurrentConstraint:Hr(this.recurrentConstraint),biasConstraint:Hr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}};Cv.className="GRUCell";Me.registerClass(Cv);var ZN=class extends yl{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Cv(e),super(e)}call(e,t){return ie(()=>{this.cell.dropoutMask!=null&&(Lt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Lt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,r=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};ZN.className="GRU";Me.registerClass(ZN);var P0=class extends L0{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,as(this.units,"units"),this.activation=au(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=au(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=ir(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ir(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ir(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=lr(e.kernelRegularizer),this.recurrentRegularizer=lr(e.recurrentRegularizer),this.biasRegularizer=lr(e.biasRegularizer),this.kernelConstraint=jr(e.kernelConstraint),this.recurrentConstraint=jr(e.recurrentConstraint),this.biasConstraint=jr(e.biasConstraint),this.dropout=Gp([1,ru([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Gp([1,ru([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=fn(e);let n=e[e.length-1];this.kernel=this.addWeight("kernel",[n,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let r;if(this.useBias){if(this.unitForgetBias){let s=this.biasInitializer,a=this.units;r=new(t=class extends gi{apply(i,o){let u=s.apply([a]),c=new uv().apply([a]),l=s.apply([a*2]);return bR(bR(u,c),l)}},t.className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return ie(()=>{let n=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new oe(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1],s=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=iu({ones:()=>Ea(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=iu({ones:()=>Ea(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let a=this.dropoutMask,i=this.recurrentDropoutMask,o,u,c,l;0<this.dropout&&this.dropout<1&&(e=se(e,a[0]));let d=vo(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=se(r,i[0])),d=Se(d,vo(r,this.recurrentKernel.read())),this.useBias&&(d=Zi(d,this.bias.read()));let[h,p,f,m]=sa(d,4,d.rank-1);o=this.recurrentActivation.apply(h),u=this.recurrentActivation.apply(p),c=Se(se(u,s),se(o,this.activation.apply(f))),l=this.recurrentActivation.apply(m);let g=se(l,this.activation.apply(c));return[g,g,c]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:su(this.activation),recurrentActivation:su(this.recurrentActivation),useBias:this.useBias,kernelInitializer:hr(this.kernelInitializer),recurrentInitializer:hr(this.recurrentInitializer),biasInitializer:hr(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Gn(this.kernelRegularizer),recurrentRegularizer:Gn(this.recurrentRegularizer),biasRegularizer:Gn(this.biasRegularizer),activityRegularizer:Gn(this.activityRegularizer),kernelConstraint:Hr(this.kernelConstraint),recurrentConstraint:Hr(this.recurrentConstraint),biasConstraint:Hr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}};P0.className="LSTMCell";Me.registerClass(P0);var eT=class extends yl{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new P0(e),super(e)}call(e,t){return ie(()=>{this.cell.dropoutMask!=null&&(Lt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Lt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,r=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};eT.className="LSTM";Me.registerClass(eT);var Sv=class extends L0{constructor(e){super(e),this.cells=e.cells}get stateSize(){let e=[];for(let t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return ie(()=>{e=e;let n=e.slice(1),r=[];for(let i of this.cells.slice().reverse())Array.isArray(i.stateSize)?r.push(n.splice(0,i.stateSize.length)):r.push(n.splice(0,1));r.reverse();let s=[],a;for(let i=0;i<this.cells.length;++i){let o=this.cells[i];n=r[i],i===0?a=[e[0]].concat(n):a=[a[0]].concat(n),a=o.call(a,t),s.push(a.slice(1))}n=[];for(let i of s.slice().reverse())n.push(...i);return[a[0]].concat(n)})}build(e){pC(e)&&(e=e[0]),e=e;let t;this.cells.forEach((n,r)=>{Ac(`RNNCell_${r}`,()=>{n.build(e),Array.isArray(n.stateSize)?t=n.stateSize[0]:t=n.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){let e=super.getConfig(),t=r=>({className:r.getClassName(),config:r.getConfig()}),n={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),n)}static fromConfig(e,t,n={}){let r=[];for(let s of t.cells)r.push(zi(s,n));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];let e=[];for(let t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let n of this.cells)t.push(...n.trainableWeights);return t.concat(e)}return e}getWeights(){let e=[];for(let t of this.cells)e.push(...t.weights);return fC(e)}setWeights(e){let t=[];for(let n of this.cells){let r=n.weights.length,s=e.splice(r);for(let a=0;a<n.weights.length;++a)t.push([n.weights[a],s[a]])}CN(t)}};Sv.className="StackedRNNCells";Me.registerClass(Sv);function iu(e){let{ones:t,rate:n,training:r=!1,count:s=1,dropoutFunc:a}=e,i=()=>a!=null?a(t(),n):wM(t(),n),o=()=>F0(i,t,r);return!s||s<=1?zr(o().clone()):Array(s).fill(void 0).map(o).map(u=>zr(u.clone()))}var Hoe=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(e!=null&&typeof Object.getOwnPropertySymbols=="function")for(var s=0,r=Object.getOwnPropertySymbols(e);s<r.length;s++)t.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(e,r[s])&&(n[r[s]]=e[r[s]]);return n},x8=class extends yl{constructor(e){if(e.unroll)throw new Xt("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Xt("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new Rr({ndim:5})]}call(e,t){return ie(()=>{if(this.cell.dropoutMask!=null&&(Lt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Lt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new oe("ConvRNN2D cell does not support constants");let n=t==null?null:t.mask,r=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return ie(()=>{let{stateSize:t}=this.cell,n=e.shape,r=this.computeSingleOutputShape(n),s=[r[0],...r.slice(2)],a=dr(s);return Array.isArray(t)?Array(t.length).fill(a):[a]})}resetStates(e,t=!1){ie(()=>{if(!this.stateful)throw new Al("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),s=[r[0],...r.slice(2)];if(n[0]==null)throw new oe("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>dr(s)):this.states_=[dr(s)];else if(e==null)Lt(this.states_),this.keptStates!=null&&(Lt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>dr(s)):this.states_[0]=dr(s);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new oe(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):Lt(this.states_);for(let a=0;a<this.states_.length;++a){let i=e[a],o=s;if(!$.arraysEqual(i.shape,o))throw new oe(`State ${a} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${i.shape}`);this.states_[a]=i}}this.states_=this.states_.map(a=>zr(a.clone()))})}computeSingleOutputShape(e){let{dataFormat:t,filters:n,kernelSize:r,padding:s,strides:a,dilationRate:i}=this.cell,o=t==="channelsFirst",u=e[o?3:2],c=e[o?4:3],l=Wi(u,r[0],s,a[0],i[0]),d=Wi(c,r[1],s,a[1],i[1]);return[...e.slice(0,2),...o?[n,l,d]:[l,d,n]]}};x8.className="ConvRNN2D";var Nv=class extends P0{constructor(e){let{filters:t,kernelSize:n,strides:r,padding:s,dataFormat:a,dilationRate:i}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,as(this.filters,"filters"),this.kernelSize=Ep(n,2,"kernelSize"),this.kernelSize.forEach(o=>as(o,"kernelSize")),this.strides=Ep(r||1,2,"strides"),this.strides.forEach(o=>as(o,"strides")),this.padding=s||"valid",Xa(this.padding),this.dataFormat=a||"channelsLast",kr(this.dataFormat),this.dilationRate=Ep(i||1,2,"dilationRate"),this.dilationRate.forEach(o=>as(o,"dilationRate"))}build(e){var t;e=fn(e);let n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new oe(`The channel dimension of the input should be defined. Found ${e[n]}`);let r=e[n],s=4,a=this.kernelSize.concat([r,this.filters*s]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let i=this.kernelSize.concat([this.filters,this.filters*s]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",i,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let o;if(this.unitForgetBias){let u=this.biasInitializer,c=this.filters;o=new(t=class extends gi{apply(l,d){let h=u.apply([c]),p=ra([c]),f=u.apply([c*2]);return gN([h,p,f])}},t.className="CustomInit",t)}else o=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*s],null,o,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return ie(()=>{if(e.length!==3)throw new oe(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training||!1,r=e[0],s=e[1],a=e[2],i=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=iu({ones:()=>Ea(r),rate:this.dropout,training:n,count:i,dropoutFunc:this.dropoutFunc}));let o=this.dropoutMask,u=(q,Q,K)=>!Q||!Q[K]?q:se(Q[K],q),c=u(r,o,0),l=u(r,o,1),d=u(r,o,2),h=u(r,o,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=iu({ones:()=>Ea(s),rate:this.recurrentDropout,training:n,count:i,dropoutFunc:this.dropoutFunc}));let p=this.recurrentDropoutMask,f=u(s,p,0),m=u(s,p,1),g=u(s,p,2),b=u(s,p,3),y=3,[x,w,v,I]=sa(this.kernel.read(),i,y),[N,T,E,A]=this.useBias?sa(this.bias.read(),i):[null,null,null,null];c=this.inputConv(c,x,N,this.padding),l=this.inputConv(l,w,T,this.padding),d=this.inputConv(d,v,E,this.padding),h=this.inputConv(h,I,A,this.padding);let[k,C,M,L]=sa(this.recurrentKernel.read(),i,y);f=this.recurrentConv(f,k),m=this.recurrentConv(m,C),g=this.recurrentConv(g,M),b=this.recurrentConv(b,L);let O=this.recurrentActivation.apply(Se(c,f)),B=this.recurrentActivation.apply(Se(l,m)),G=Se(se(B,a),se(O,this.activation.apply(Se(d,g)))),z=se(this.recurrentActivation.apply(Se(h,b)),this.activation.apply(G));return[z,z,G]})}getConfig(){let e=super.getConfig(),{units:t}=e,n=Hoe(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),r)}inputConv(e,t,n,r){let s=Vs(e,t,this.strides,r||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return n?Zi(s,n,this.dataFormat):s}recurrentConv(e,t){return Vs(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}};Nv.className="ConvLSTM2DCell";Me.registerClass(Nv);var tT=class extends x8{constructor(e){let t=new Nv(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}};tT.className="ConvLSTM2D";Me.registerClass(tT);var Tv=class extends Qt{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;let t=e.shape,n=[];for(let r=0;r<this.noiseShape.length;++r)n.push(this.noiseShape[r]==null?t[r]:this.noiseShape[r]);return n}call(e,t){return ie(()=>{this.invokeCallHook(e,t);let n=Ft(e);if(0<this.rate&&this.rate<1){let r=t.training==null?!1:t.training,s=this.getNoiseShape(n);return F0(()=>wM(n,this.rate,s,this.seed),()=>n,r)}return e})}getConfig(){let e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}};Tv.className="Dropout";Me.registerClass(Tv);var nT=class extends Tv{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){let t=e.shape;return[t[0],1,t[2]]}};nT.className="SpatialDropout1D";Me.registerClass(nT);var rT=class extends Qt{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,as(this.units,"units"),this.activation=au(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=ir(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=ir(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=jr(e.kernelConstraint),this.biasConstraint=jr(e.biasConstraint),this.kernelRegularizer=lr(e.kernelRegularizer),this.biasRegularizer=lr(e.biasRegularizer),this.activityRegularizer=lr(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=fn(e);let t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=fn(e);let t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return ie(()=>{this.invokeCallHook(e,t);let n=Ft(e),r=pM(this.activation.getClassName()),s;return r!=null?s=vo(n,this.kernel.read(),r,this.bias?this.bias.read():null):(s=vo(n,this.kernel.read()),this.bias!=null&&(s=Zi(s,this.bias.read())),this.activation!=null&&(s=this.activation.apply(s))),s})}getConfig(){let e={units:this.units,activation:su(this.activation),useBias:this.useBias,kernelInitializer:hr(this.kernelInitializer),biasInitializer:hr(this.biasInitializer),kernelRegularizer:Gn(this.kernelRegularizer),biasRegularizer:Gn(this.biasRegularizer),activityRegularizer:Gn(this.activityRegularizer),kernelConstraint:Hr(this.kernelConstraint),biasConstraint:Hr(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}};rT.className="Dense";Me.registerClass(rT);var sT=class extends Qt{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=fn(e);for(let t of e.slice(1))if(t==null)throw new oe(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],Ul(e,1)]}call(e,t){return ie(()=>{this.invokeCallHook(e,t);let n=Ft(e);if(this.dataFormat==="channelsFirst"&&n.rank>1){let r=[0];for(let s=2;s<n.rank;++s)r.push(s);r.push(1),n=Gt(n,r)}return rie(n)})}getConfig(){let e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);let t=super.getConfig();return Object.assign(e,t),e}};sT.className="Flatten";Me.registerClass(sT);var aT=class extends Qt{constructor(e){super(e),this.supportsMasking=!0,this.activation=au(e.activation)}call(e,t){return ie(()=>{this.invokeCallHook(e,t);let n=Ft(e);return this.activation.apply(n)})}getConfig(){let e={activation:su(this.activation)},t=super.getConfig();return Object.assign(e,t),e}};aT.className="Activation";Me.registerClass(aT);var iT=class extends Qt{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return ie(()=>(e=Ft(e),tie(e,this.n)))}getConfig(){let e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}};iT.className="RepeatVector";Me.registerClass(iT);var oT=class extends Qt{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){let n="Total size of new array must be unchanged.",r=t.slice(),s=1,a=null;for(let o=0;o<r.length;++o){let u=r[o];if(this.isUnknown(u))if(a===null)a=o;else throw new oe("Can only specifiy one unknown dimension.");else s*=u}let i=Ul(e);if(a!==null){if(s===0||i%s!==0)throw new oe(n);r[a]=i/s}else if(i!==s)throw new oe(n);return r}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return ie(()=>{this.invokeCallHook(e,t);let n=Ft(e),r=n.shape,s=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return ae(n,s)})}getConfig(){let e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}};oT.className="Reshape";Me.registerClass(oT);var lT=class extends Qt{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);let t=Hi(1,e.dims.length+1);if(!$.arraysEqual(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Rr({ndim:this.dims.length+1})]}computeOutputShape(e){e=fn(e);let t=e.slice();return this.dims.forEach((n,r)=>{t[r+1]=e[n]}),t}call(e,t){return Gt(Ft(e),this.dimsIncludingBatch)}getConfig(){let e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}};lT.className="Permute";Me.registerClass(lT);var uT=class extends Qt{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){let n=Ft(e);return cy(jc(n,this.maskValue),-1)}call(e,t){return ie(()=>{this.invokeCallHook(e,t);let n=Ft(e),r=cy(jc(n,this.maskValue),-1,!0);return se(n,Ve(r,n.dtype))})}};uT.className="Masking";Me.registerClass(uT);var cT=class extends Qt{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(An(e.inputLength))}this.inputDim=e.inputDim,as(this.inputDim,"inputDim"),this.outputDim=e.outputDim,as(this.outputDim,"outputDim"),this.embeddingsInitializer=ir(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=lr(e.embeddingsRegularizer),this.activityRegularizer=lr(e.activityRegularizer),this.embeddingsConstraint=jr(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return ie(()=>this.maskZero?(e=Ft(e),jc(e,sn(e))):null)}computeOutputShape(e){if(e=fn(e),this.inputLength==null)return[...e,this.outputDim];let t=An(this.inputLength);if(t.length!==e.length-1)throw new oe(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let r=0;r<t.length;++r){let s=t[r],a=e[r+1];if(s!=null&&a!=null&&s!==a)throw new oe(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);s==null&&(t[n]=a),n++}}return[e[0],...t,this.outputDim]}call(e,t){return ie(()=>{this.invokeCallHook(e,t);let n=Ft(e);n.dtype!=="int32"&&(n=ol(n,"int32"));let r=xM(this.embeddings.read(),ae(n,[n.size]));return ae(r,fn(this.computeOutputShape(n.shape)))})}getConfig(){let e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:hr(this.embeddingsInitializer),embeddingsRegularizer:Gn(this.embeddingsRegularizer),activityRegularizer:Gn(this.activityRegularizer),embeddingsConstraint:Hr(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}};cT.className="Embedding";Me.registerClass(cT);var Vh=class extends Qt{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new Xt}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;let n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){let s=e[e.length-t.length+r],a=t[r];if(s==null||a==null||s<0||a<0)n.push(null);else if(s===1)n.push(a);else if(a===1)n.push(s);else{if(s!==a)throw new oe("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(s)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[fn(e)]),e=e,e.length<2)throw new oe(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(let s of e)s!=null&&s[0]!==null&&t.push(s[0]);if(t=Vl(t),t.length>1)throw new oe(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=e[0]==null?null:e[0].slice(1);for(let s=1;s<e.length;++s){let a=e[s]==null?null:e[s].slice(1);n=this.computeElementwiseOpOutputShape(n,a)}let r=e.map(s=>s.length);e.indexOf(null)===-1&&Vl(r).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return ie(()=>{if(e=e,this.reshapeRequired){let n=[],r=e.map(s=>s.rank);if(r.indexOf(null)===-1){let s=ru(r);for(let a of e){let i=a.rank;for(let o=0;o<s-i;++o)a=_0(a,1);n.push(a)}return this.mergeFunction(n)}else{let s=!1;for(let o of e){let u=o.rank;if(u==null){let c=o.shape,l=c[0],d=c.slice(1).concat([l]),h=ae(o,[l].concat(Ul(c.slice(1))));h=Gt(h,[1,0]),h=ae(h,d),n.push(h),s=!0}else if(u>1){let c=Hi(1,u).concat([0]);n.push(Gt(o,c)),s=!0}else n.push(o)}let a=this.mergeFunction(n),i=a.rank;if(s){if(i==null){let o=a.shape,u=o.length,c=o[u-1],l=[c].concat(o.slice(0,o.length-1));a=ae(Gt(ae(a,[-1,c]),[1,0]),l)}else if(i>1){let o=[i-1].concat(Hi(0,i-1));a=Gt(a,o)}}return a}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let r=1;r<e.length;++r){let s=e[r]==null?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,s)}let n=[];for(let r of e)r!=null&&r[0]!==null&&n.push(r[0]);return n=Vl(n),n.length===1?t=n.concat(t):t=[null].concat(t),t}computeMask(e,t){return ie(()=>{if(t==null)return null;if(!Array.isArray(t))throw new oe("`mask` should be an Array");if(!Array.isArray(e))throw new oe("`inputs` should be an Array");if(t.length!==e.length)throw new oe(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(r=>r==null))return null;t=t.map(r=>r==null?r:ns(r,0));let n=t[0];for(let r=1;r<t.length-1;++r)n=di(n,t[r]);return n})}},dT=class extends Vh{constructor(e){super(e)}mergeFunction(e){return ie(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Se(t,e[n]);return t})}};dT.className="Add";Me.registerClass(dT);var hT=class extends Vh{constructor(e){super(e)}mergeFunction(e){return ie(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=se(t,e[n]);return t})}};hT.className="Multiply";Me.registerClass(hT);var pT=class extends Vh{constructor(e){super(e)}mergeFunction(e){return ie(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Se(t,e[n]);return se(1/e.length,t)})}};pT.className="Average";Me.registerClass(pT);var fT=class extends Vh{constructor(e){super(e)}mergeFunction(e){return ie(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Oo(t,e[n]);return t})}};fT.className="Maximum";Me.registerClass(fT);var mT=class extends Vh{constructor(e){super(e)}mergeFunction(e){return ie(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=tu(t,e[n]);return t})}};mT.className="Minimum";Me.registerClass(mT);var gT=class extends Vh{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new oe("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(let r of e)if(r!=null){t=!1;break}if(t)return;let n=[];for(let r=0;r<e.length;++r){let s=e[r].slice();s.splice(this.axis,1);let a=!1;for(let i of n)if($.arraysEqual(i,s)){a=!0;break}a||n.push(s)}if(n.length>1)throw new oe("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return ie(()=>gN(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new oe("A `Concatenate` layer should be called on a list of inputs.");let t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(let s of t.slice(1)){if(n[r]==null||s[r]==null){n[r]=null;break}n[r]+=s[r]}return n}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new oe("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new oe("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new oe(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return ie(()=>{let n=!0;if(t.forEach(a=>{if(a!=null){n=!1;return}}),n)return null;let r=[];for(let a=0;a<e.length;++a)t[a]==null?r.push(Ve(Ea(e[a]),"bool")):t[a].rank<e[a].rank?r.push(ns(t[a],-1)):r.push(t[a]);let s=Bn(r,this.axis);return Aw(s,-1,!1)})}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};gT.className="Concatenate";Me.registerClass(gT);function Eb(e,t){for(;e<0;)e+=t;return e}function joe(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new Xt("batchDot is not implemented for tensors of 4D or higher rank yet");if($.assert(e.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`),$.assert(e.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof n=="number"&&(n=[n,n]),e.dtype==="complex64"||t.dtype==="complex64")throw new Xt("batchDot is not implemented for complex64-type Tensors yet.");let r=e.shape.length,s=t.shape.length;n==null&&(n=[r-1,s-2]);let a=n;return ie(()=>{let i;if(r>s){i=r-s;let u=[];for(let c=0;c<i;++c)u.push(1);t=ae(t,t.shape.concat(u))}else if(s>r){i=s-r;let u=[];for(let c=0;c<i;++c)u.push(1);e=ae(e,e.shape.concat(u))}else i=0;let o;if(e.shape.length===2&&t.shape.length===2)a[0]===a[1]?o=dt(se(e,t),a[0]):o=dt(se(Gt(e,[1,0]),t),a[1]);else{let u=a[0]!==e.shape.length-1,c=a[1]===t.shape.length-1;o=Ut(e,t,u,c)}if(i>0){let u;r>s?u=r+s-3:u=r-1;let c=[];for(let l=u;l<u+i;++l)c.push(l);o=Nu(o,c)}return o.shape.length===1&&(o=ns(o,1)),o})}var bT=class extends Vh{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){$.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0],n=e[1];if(t.length>3||n.length>3)throw new Xt("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new oe(`Dimension incompatibility: ${t[r[0]]} !== ${n[r[1]]}`)}mergeFunction(e){if(e.length!==2)throw new oe(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],n=e[1],r;return Array.isArray(this.axes)?r=this.axes.map((s,a)=>Eb(s,e[a].shape.length)):r=[Eb(this.axes,t.shape.length),Eb(this.axes,n.shape.length)],this.normalize&&(t=gx(t,r[0]),n=gx(n,r[1])),joe(t,n,r)}interpretAxes(e,t){let n;return Array.isArray(this.axes)?n=this.axes:n=[Eb(this.axes,e.length),Eb(this.axes,t.length)],n}computeOutputShape(e){$.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new Xt("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);let s=t.concat(n);return s.length===1&&s.push(1),s}computeMask(e,t){return null}getConfig(){let e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}};bT.className="Dot";Me.registerClass(bT);var yT=class extends Qt{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),n={stddev:this.stddev};return Object.assign(n,t),n}call(t,n){return ie(()=>{this.invokeCallHook(t,n);let r=Ft(t);return F0(()=>Se(lv(r.shape,0,this.stddev),r),()=>r,n.training||!1)})}};yT.className="GaussianNoise";Me.registerClass(yT);var xT=class extends Qt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return ie(()=>{this.invokeCallHook(e,t);let n=Ft(e);return this.rate>0&&this.rate<1?F0(()=>{let r=Math.sqrt(this.rate/(1-this.rate));return se(n,lv(n.shape,1,r))},()=>n,t.training||!1):n})}};xT.className="GaussianDropout";Me.registerClass(xT);var wT=class extends Qt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Ft(e).shape}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return ie(()=>{if(this.rate<1&&this.rate>0){let n=this._getNoiseShape(e);return F0(()=>{let r=Ft(e),s=-1.6732632423543772*1.0507009873554805,a=ml(Cu(n),this.rate);a=ol(a,"float32");let i=((1-this.rate)*(1+this.rate*s**2))**-.5,o=-i*s*this.rate,u=Se(se(r,a),se(Se(a,-1),s));return Se(se(u,i),o)},()=>Ft(e),t.training||!1)}return e})}};wT.className="AlphaDropout";Me.registerClass(wT);function gy(e,t,n,r,s,a=.001){let i;if(e.rank===2)i=l3(e,t,n,r,s,a);else if(e.rank===3)i=u3(e,t,n,r,s,a);else if(e.rank===4)i=c3(e,t,n,r,s,a);else throw new Xt(`batchNormalization is not implemented for array of rank ${e.rank} yet`);return i}function qoe(e,t,n,r,s=.001){return ie(()=>{let a=C0(e,r),i=a.mean,o=a.variance;return[gy(e,i,o,n,t,s),i,o]})}function Koe(e,t,n,r,s=.001){return ie(()=>{let a=C0(e,r),i=a.mean,o=a.variance,u=[];for(let p of Hi(0,e.rank))r.indexOf(p)!==-1?u.push(1):u.push(e.shape[p]);let c=ae(i,u),l=ae(o,u),d=t==null?null:ae(t,u),h=n==null?null:ae(n,u);return[gy(e,c,l,h,d,s),i,o]})}function Xoe(e,t,n,r,s=.001){return $.arraysEqual(r.slice().sort(),Hi(0,e.rank-1))?qoe(e,t,n,r,s):Koe(e,t,n,r,s)}var vT=class extends Qt{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=ir(e.betaInitializer||"zeros"),this.gammaInitializer=ir(e.gammaInitializer||"ones"),this.movingMeanInitializer=ir(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=ir(e.movingVarianceInitializer||"ones"),this.betaConstraint=jr(e.betaConstraint),this.gammaConstraint=jr(e.gammaConstraint),this.betaRegularizer=lr(e.betaRegularizer),this.gammaRegularizer=lr(e.gammaRegularizer)}build(e){e=fn(e);let t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(n==null)throw new oe(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Rr({ndim:e.length,axes:{[t]:n}})];let r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return ie(()=>{let n=t.training==null?!1:t.training,r=Ft(e),s=r.shape,a=s.length,i=Hi(0,a),o=this.axis>=0?this.axis:this.axis+a;i.splice(o,1);let u=Kc(1,a);u[o]=s[o];let c=i.slice();c.sort();let l=!$.arraysEqual(c,Hi(0,a).slice(0,a-1)),d=()=>{if(l){let g=ae(this.movingMean.read(),u),b=ae(this.movingVariance.read(),u),y=this.center?ae(this.beta.read(),u):null,x=this.scale?ae(this.gamma.read(),u):null;return gy(r,g,b,y,x,this.epsilon)}else return gy(r,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!n)return d();let[h,p,f]=Xoe(r,this.gamma.read(),this.beta.read(),i,this.epsilon),m=(g,b,y)=>{ie(()=>{let x=1-y,w=g.read(),v=se(et(w,b),x);g.write(et(w,v))})};return m(this.movingMean,p,this.momentum),m(this.movingVariance,f,this.momentum),h})}getConfig(){let e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:hr(this.betaInitializer),gammaInitializer:hr(this.gammaInitializer),movingMeanInitializer:hr(this.movingMeanInitializer),movingVarianceInitializer:hr(this.movingVarianceInitializer),betaRegularizer:Gn(this.betaRegularizer),gammaRegularizer:Gn(this.gammaRegularizer),betaConstraint:Hr(this.betaConstraint),gammaConstraint:Hr(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}};vT.className="BatchNormalization";Me.registerClass(vT);var IT=class extends Qt{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(let t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=ir(e.betaInitializer||"zeros"),this.gammaInitializer=ir(e.gammaInitializer||"ones"),this.betaRegularizer=lr(e.betaRegularizer),this.gammaRegularizer=lr(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=fn(e);let t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let s=0;s<this.axis.length;++s)this.axis[s]<0&&(this.axis[s]+=t);for(let s of this.axis)if(s<0||s>=t)throw new Error(`Invalid axis: ${s}`);if(this.axis.length!==Vl(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let n=this.axis.map(s=>e[s]),r=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){let n=Ft(e),r=n.shape,s=r.length;return ie(()=>{let{mean:a,variance:i}=C0(n,this.axis,!0),o=Kc(1,s);for(let p of this.axis)o[p]=r[p];let u=p=>p!=null&&p.shape.length!==s?ae(p,o):p,c=this.scale?u(this.gamma.read()):null,l=this.center?u(this.beta.read()):null,d=[],h=[];for(let p=0;p<s;++p)this.axis.indexOf(p)!==-1?(d.push(r[p]),h.push(1)):(d.push(1),h.push(r[p]));return a=Ia(a,d),i=Ia(i,d),c!=null&&(c=Ia(c,h)),l!=null&&(l=Ia(l,h)),gy(n,a,i,l,c,this.epsilon)})}getConfig(){let e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:hr(this.betaInitializer),gammaInitializer:hr(this.gammaInitializer),betaRegularizer:Gn(this.betaRegularizer),gammaRegularizer:Gn(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}};IT.className="LayerNormalization";Me.registerClass(IT);function Qoe(e,t,n){return ie(()=>{if(e.rank!==4)throw new oe(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new oe("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(n==null&&(n=ji()),n!=="channelsLast"&&n!=="channelsFirst")throw new oe(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return n==="channelsFirst"?r=[[0,0],[0,0],t[0],t[1]]:r=[[0,0],t[0],t[1],[0,0]],Ji(e,r)})}var kT=class extends Qt{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?ji():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new oe(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new oe(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new oe(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new Rr({ndim:4})]}computeOutputShape(e){e=fn(e);let t,n;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?n=e[3]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],e[1],t,n]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?n=e[2]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],t,n,e[3]])}call(e,t){return ie(()=>Qoe(Ft(e),this.padding,this.dataFormat))}getConfig(){let e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};kT.className="ZeroPadding2D";Me.registerClass(kT);function Ev(e,t,n,r,s,a){return ie(()=>{kr(s),mM(a),Xa(r),n==null&&(n=[1,1]),r==null&&(r="valid"),s==null&&(s=ji()),a==null&&(a="max"),e=GN(e,s);let i,o=r==="same"?"same":"valid";return a==="max"?i=Zr(e,t,n,o):i=fl(e,t,n,o),s==="channelsFirst"&&(i=Gt(i,[0,3,1,2])),i})}function w8(e,t,n,r,s,a){return ie(()=>{kr(s),mM(a),Xa(r),n==null&&(n=[1,1,1]),r==null&&(r="valid"),s==null&&(s=ji()),a==null&&(a="max"),e=l8(e,s);let i,o=r==="same"?"same":"valid";return a==="max"?i=F3(e,t,n,o):i=o3(e,t,n,o),s==="channelsFirst"&&(i=Gt(i,[0,4,1,2,3])),i})}var v8=class extends Qt{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new oe(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(as(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new oe(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);as(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,Xa(this.padding),this.inputSpec=[new Rr({ndim:3})]}computeOutputShape(e){e=fn(e);let t=Wi(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return ie(()=>{this.invokeCallHook(e,t),e=_0(Ft(e),2);let n=this.poolingFunction(Ft(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Nu(n,[2])})}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}},CT=class extends v8{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return kr(s),Xa(r),Ev(e,t,n,r,s,"max")}};CT.className="MaxPooling1D";Me.registerClass(CT);var ST=class extends v8{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return kr(s),Xa(r),Ev(e,t,n,r,s,"avg")}};ST.className="AveragePooling1D";Me.registerClass(ST);var I8=class extends Qt{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new oe(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];as(this.poolSize,"poolSize"),as(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,kr(this.dataFormat),Xa(this.padding),this.inputSpec=[new Rr({ndim:4})]}computeOutputShape(e){e=fn(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=Wi(t,this.poolSize[0],this.padding,this.strides[0]),n=Wi(n,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return ie(()=>(this.invokeCallHook(e,t),this.poolingFunction(Ft(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},NT=class extends I8{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return kr(s),Xa(r),Ev(e,t,n,r,s,"max")}};NT.className="MaxPooling2D";Me.registerClass(NT);var TT=class extends I8{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return kr(s),Xa(r),Ev(e,t,n,r,s,"avg")}};TT.className="AveragePooling2D";Me.registerClass(TT);var k8=class extends Qt{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new oe(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];as(this.poolSize,"poolSize"),as(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,kr(this.dataFormat),Xa(this.padding),this.inputSpec=[new Rr({ndim:5})]}computeOutputShape(e){e=fn(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=Wi(t,this.poolSize[0],this.padding,this.strides[0]),n=Wi(n,this.poolSize[1],this.padding,this.strides[1]),r=Wi(r,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return ie(()=>(this.invokeCallHook(e,t),this.poolingFunction(Ft(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},ET=class extends k8{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return kr(s),Xa(r),w8(e,t,n,r,s,"max")}};ET.className="MaxPooling3D";Me.registerClass(ET);var AT=class extends k8{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return kr(s),Xa(r),w8(e,t,n,r,s,"avg")}};AT.className="AveragePooling3D";Me.registerClass(AT);var C8=class extends Qt{constructor(e){super(e),this.inputSpec=[new Rr({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new Xt}},$T=class extends C8{constructor(e){super(e||{})}call(e,t){return ie(()=>{let n=Ft(e);return cr(n,1)})}};$T.className="GlobalAveragePooling1D";Me.registerClass($T);var RT=class extends C8{constructor(e){super(e||{})}call(e,t){return ie(()=>{let n=Ft(e);return Va(n,1)})}};RT.className="GlobalMaxPooling1D";Me.registerClass(RT);var S8=class extends Qt{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,kr(this.dataFormat),this.inputSpec=[new Rr({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new Xt}getConfig(){let e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},_T=class extends S8{call(e,t){return ie(()=>{let n=Ft(e);return this.dataFormat==="channelsLast"?cr(n,[1,2]):cr(n,[2,3])})}};_T.className="GlobalAveragePooling2D";Me.registerClass(_T);var DT=class extends S8{call(e,t){return ie(()=>{let n=Ft(e);return this.dataFormat==="channelsLast"?Va(n,[1,2]):Va(n,[2,3])})}};DT.className="GlobalMaxPooling2D";Me.registerClass(DT);var N8=class extends Qt{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){let e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){let r=t.layer,s=zi(r,n);delete t.layer;let a={layer:s};return Object.assign(a,t),new e(a)}},FT=class extends N8{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=fn(e),e.length<3)throw new oe(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];let t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=fn(e);let t=[e[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))}call(e,t){return ie(()=>(e=Ft(e),b8((n,r)=>[Ft(this.layer.call(n,t)),[]],e,[],!1,null,null,!1,!0)[1]))}};FT.className="TimeDistributed";Me.registerClass(FT);function Yoe(e){zh(Qae,"BidirectionalMergeMode",e)}var Joe="concat",MT=class extends N8{constructor(e){super(e);let t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=zi(n),t.goBackwards=t.goBackwards!==!0;let r={};if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=zi(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?Joe:e.mergeMode,Yoe(this.mergeMode),e.weights)throw new Xt("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){let t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let n,r,s;return this.returnState&&(s=t.slice(1)),n=t[0],n=n,this.mergeMode==="concat"?(n[n.length-1]*=2,r=[n]):this.mergeMode==null?r=[n,n.slice()]:r=[n],this.returnState?this.mergeMode==null?r.concat(s).concat(s.slice()):[n].concat(s).concat(s.slice()):ea(r)}apply(e,t){let n=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});let s=g8(e,n,r,this.numConstants);if(e=s.inputs,n=s.initialState,r=s.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(n==null||n.length===0)&&r==null)return super.apply(e,t);let a=[],i=[];if(n!=null){let u=n.length;if(u%2>0)throw new oe("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,a.push(...n);let c=n.map(l=>new Rr({shape:l.shape}));this.forwardLayer.stateSpec=c.slice(0,u/2),this.backwardLayer.stateSpec=c.slice(u/2),i.push(...c)}if(r!=null)throw new Xt("Support for constants in Bidirectional layers is not implemented yet.");let o=a[0]instanceof qi;for(let u of a)if(u instanceof qi!==o)throw new oe("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){let u=[e].concat(a),c=this.inputSpec.concat(i),l=this.inputSpec;this.inputSpec=c;let d=super.apply(u,t);return this.inputSpec=l,d}else return super.apply(e,t)}call(e,t){return ie(()=>{let n=t.initialState,r,s;if(n==null)r=this.forwardLayer.call(e,t),s=this.backwardLayer.call(e,t);else{let o=n.slice(0,n.length/2),u=n.slice(n.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:o})),s=this.backwardLayer.call(e,Object.assign(t,{initialState:u}))}let a;this.returnState&&(Array.isArray(r)&&(a=r.slice(1).concat(s.slice(1))),r=r[0],s=s[0]),this.returnSequences&&(s=qa(s,1));let i;return this.mergeMode==="concat"?i=gN([r,s]):this.mergeMode==="sum"?i=Se(r,s):this.mergeMode==="ave"?i=se(.5,Se(r,s)):this.mergeMode==="mul"?i=se(r,s):this.mergeMode==null&&(i=[r,s]),this.returnState?this.mergeMode==null?i.concat(a):[i].concat(a):i})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Ac(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),Ac(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let n;if(this.returnSequences?this.mergeMode==null?n=[t,t]:n=t:this.mergeMode==null?n=[null,null]:n=null,this.returnState){let r=this.forwardLayer.states.map(s=>null);return Array.isArray(n)?n.concat(r).concat(r):[n].concat(r).concat(r)}else return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){let e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){let n=zi(t.layer);if(delete t.layer,t.numConstants!=null)throw new Xt("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let r=t;return r.layer=n,new e(r)}};MT.className="Bidirectional";Me.registerClass(MT);var OT=class extends Qt{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){let e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return ie(()=>(e=Ft(e),e.dtype!=="float32"&&(e=ol(e,"float32")),Se(se(e,this.scale),this.offset)))}};OT.className="Rescaling";Me.registerClass(OT);var{resizeBilinear:Zoe,cropAndResize:ele}=La,LT=class extends Qt{constructor(t){super(t),this.height=t.height,this.width=t.width}centerCrop(t,n,r,s,a,i,o,u){return ie(()=>{let c,l=!1,d=n/i,h=r/o,p=(s+n)/i,f=(a+r)/o,m=[d,h,p,f],g=[];t.rank===3?(l=!0,c=Dr([t])):c=t;for(let w=0;w<c.shape[0];w++)g.push(m);let b=zs(g,[g.length,4]),y=qc(0,g.length,1,"int32"),x=ele(c,b,y,[s,a],"nearest");return ol(l?Ft(br(x)):x,u)})}upsize(t,n,r,s){return ie(()=>{let a=Zoe(t,[n,r]);return ol(a,s)})}call(t,n){return ie(()=>{let r=Ft(t),s=r.dtype,a=r.shape,i=a[a.length-3],o=a[a.length-2],u=0;i!==this.height&&(u=Math.floor((i-this.height)/2));let c=0;return o!==this.width&&(c=Math.floor((o-this.width)/2),c===0&&(c=1)),u>=0&&c>=0?this.centerCrop(r,u,c,this.height,this.width,i,o,s):this.upsize(t,this.height,this.width,s)})}getConfig(){let t={height:this.height,width:this.width},n=super.getConfig();return Object.assign(t,n),t}computeOutputShape(t){t=fn(t);let n=t.length-3,r=t.length-2;return t[n]=this.height,t[r]=this.width,t}};LT.className="CenterCrop";Me.registerClass(LT);function tle(e,t,n,r){let s=Ft(e);if(s.dtype!=="int32"&&(s=ol(s,"int32")),t==="int")return s;let a=s.shape;if(s.rank===0&&(s=ns(s,-1)),t==="oneHot"&&s.shape[s.shape.length-1]!==1&&(s=ns(s,-1)),s.rank>2)throw new oe(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${a} which would result in output rank ${s.rank}.`);let i=["multiHot","oneHot"].includes(t),o=s,u;if(typeof r<"u"&&t==="count"?u=cx(o,r,n,i):u=cx(o,[],n,i),t!=="tfIdf")return u;if(r)return se(u,r);throw new oe("When outputMode is 'tfIdf', weights must be provided.")}var PT=class extends Qt{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){let e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=fn(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return ie(()=>{e=Ft(e),e.dtype!=="int32"&&(e=ol(e,"int32"));let n;if(typeof t.countWeights<"u"){if(this.outputMode!=="count")throw new oe(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);n=Ft(t.countWeights)}let r=Va(e),s=Lp(e),a=Xs(this.numTokens,r).bufferSync().get(0),i=ml(s,0).bufferSync().get(0);if(!(a&&i))throw new oe(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return tle(e,this.outputMode,this.numTokens,n)})}};PT.className="CategoryEncoding";Me.registerClass(PT);var nle=["bilinear","nearest"],FR=new Set(nle),BT=class extends Qt{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(FR.has(e.interpolation))this.interpolation=e.interpolation;else throw new oe(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=fn(e);let t=e[2];return[this.height,this.width,t]}getConfig(){let e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return ie(()=>{let n=[this.height,this.width];if(this.interpolation==="bilinear")return La.resizeBilinear(e,n,!this.cropToAspectRatio);if(this.interpolation==="nearest")return La.resizeNearestNeighbor(e,n,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...FR]} are supported`)})}};BT.className="Resizing";Me.registerClass(BT);var T8=class{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}};T8.className="RandomSeed";var E8=class extends Qt{constructor(e){super(e),this.randomGenerator=new T8(e.seed)}getConfig(){let e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}};E8.className="BaseRandomLayer";var rle=["bilinear","nearest"],MR=new Set(rle),zT=class extends E8{constructor(e){super(e);let{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new oe(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new oe(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new oe(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(n)if(MR.has(n))this.interpolation=n;else throw new oe(`Invalid interpolation parameter: ${n} is not implemented`)}getConfig(){let e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=fn(e);let t=e[2];return[this.imgHeight,-1,t]}call(e,t){return ie(()=>{let n=Ft(e);this.imgHeight=n.shape[n.shape.length-3];let r=n.shape[n.shape.length-2];this.widthFactor=Cu([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let s=this.widthFactor.dataSync()[0]*r;s=Math.round(s);let a=[this.imgHeight,s];switch(this.interpolation){case"bilinear":return La.resizeBilinear(e,a);case"nearest":return La.resizeNearestNeighbor(e,a);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...MR]} are supported`)}})}};zT.className="RandomWidth";Me.registerClass(zT);function sle(e){return new km(e)}function ale(e){return new WN(e)}function ile(e){return new PN(e)}function ole(e){return new BN(e)}function lle(e){return new zN(e)}function ule(e){return new UN(e)}function cle(e){return new VN(e)}function dle(e){return new KN(e)}function hle(e){return new vv(e)}function ple(e){return new HN(e)}function fle(e){return new Iv(e)}function mle(e){return new jN(e)}function gle(e){return new qN(e)}function ble(e){return new XN(e)}function yle(e){return new QN(e)}function xle(e){return new YN(e)}function wle(e){return new aT(e)}function vle(e){return new rT(e)}function Ile(e){return new Tv(e)}function kle(e){return new nT(e)}function Cle(e){return new sT(e)}function Sle(e){return new iT(e)}function Nle(e){return new oT(e)}function Tle(e){return new lT(e)}function Ele(e){return new cT(e)}function Ale(e){return new dT(e)}function $le(e){return new pT(e)}function Rle(e){return new gT(e)}function _le(e){return new fT(e)}function Dle(e){return new mT(e)}function Fle(e){return new hT(e)}function Mle(e){return new bT(e)}function Ole(e){return new vT(e)}function Lle(e){return new IT(e)}function Ple(e){return new kT(e)}function WT(e){return new ST(e)}function Ble(e){return WT(e)}function zle(e){return WT(e)}function VT(e){return new TT(e)}function Wle(e){return VT(e)}function Vle(e){return VT(e)}function UT(e){return new AT(e)}function Ule(e){return UT(e)}function Gle(e){return UT(e)}function Hle(e){return new $T(e)}function jle(e){return new _T(e)}function A8(e){return new RT(e)}function $8(e){return new DT(e)}function R8(e){return new CT(e)}function _8(e){return new NT(e)}function qle(e){return new ET(e)}function Kle(e){return new ZN(e)}function Xle(e){return new Cv(e)}function Qle(e){return new eT(e)}function Yle(e){return new P0(e)}function Jle(e){return new JN(e)}function Zle(e){return new kv(e)}function eue(e){return new tT(e)}function tue(e){return new Nv(e)}function nue(e){return new yl(e)}function rue(e){return new Sv(e)}function sue(e){return new MT(e)}function aue(e){return new FT(e)}var iue=A8,oue=$8,lue=R8,uue=_8;function cue(e){return new yT(e)}function due(e){return new xT(e)}function hue(e){return new wT(e)}function pue(e){return new uT(e)}function fue(e){return new OT(e)}function mue(e){return new LT(e)}function gue(e){return new BT(e)}function bue(e){return new PT(e)}function yue(e){return new zT(e)}var D8={};Pt(D8,{MAPE:()=>Aue,MSE:()=>_ue,binaryAccuracy:()=>xue,binaryCrossentropy:()=>wue,categoricalAccuracy:()=>Iue,categoricalCrossentropy:()=>kue,cosineProximity:()=>Nue,mape:()=>$ue,meanAbsoluteError:()=>Tue,meanAbsolutePercentageError:()=>Eue,meanSquaredError:()=>Rue,mse:()=>Due,precision:()=>Cue,r2Score:()=>Fue,recall:()=>Sue,sparseCategoricalAccuracy:()=>vue});function xue(e,t){return _N(e,t)}function wue(e,t){return OM(e,t)}function vue(e,t){return LM(e,t)}function Iue(e,t){return DN(e,t)}function kue(e,t){return FN(e,t)}function Cue(e,t){return MM(e,t)}function Sue(e,t){return noe(e,t)}function Nue(e,t){return RN(e,t)}function Tue(e,t){return bv(e,t)}function Eue(e,t){return Cm(e,t)}function Aue(e,t){return Cm(e,t)}function $ue(e,t){return Cm(e,t)}function Rue(e,t){return Wh(e,t)}function _ue(e,t){return Wh(e,t)}function Due(e,t){return Wh(e,t)}function Fue(e,t){return roe(e,t)}var F8={};Pt(F8,{modelFromJSON:()=>Doe});var M8={};Pt(M8,{l1:()=>Oue,l1l2:()=>Mue,l2:()=>Lue});function Mue(e){return new O0(e)}function Oue(e){return zoe(e)}function Lue(e){return Woe(e)}var O8=class extends Hp{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof rl))throw new Error("model must be a LayersModel, not some other Container");this.model=e}};function g2(e,t){return e<t}function OR(e,t){return e>t}var L8=class extends O8{constructor(e){if(super(),e==null&&(e={}),e.restoreBestWeights)throw new Xt("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,["auto","min","max"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.mode==="min"?this.monitorFunc=g2:this.mode==="max"?this.monitorFunc=OR:this.monitor.indexOf("acc")!==-1?this.monitorFunc=OR:this.monitorFunc=g2,this.monitorFunc===g2&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===g2?1/0:-1/0}async onEpochEnd(e,t){await Tl(t);let n=this.getMonitorValue(t);n!=null&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){e==null&&(e={});let t=e[this.monitor];return t==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}};function Pue(e){return new L8(e)}var Bue={earlyStopping:Pue},zue=ge();zue.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var ba;(function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"})(ba||(ba={}));var LR;(function(e){(function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"})(e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))})(LR||(LR={}));var GT={};function Wue(e,t){let n={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t};GT[e]=n}function P8(e){return GT[e]}function Vue(e){delete GT[e]}function R(e,t,n,r,s){let a=t.inputParams[e];if(a&&a.inputIndexStart!==void 0){let o=a.inputIndexStart,u=a.inputIndexEnd===0?void 0:a.inputIndexEnd===void 0?o+1:a.inputIndexEnd,c=o<0?t.inputNames.length+o:o;if(a.type==="tensor")return ds(t.inputNames[c],n,r,s);if(a.type==="tensors"){let h=t.inputs.slice(o,u);return t.inputNames.slice(o,u).filter((p,f)=>{var m;return((m=h[f])===null||m===void 0?void 0:m.op)!=="NoOp"}).map(p=>ds(p,n,r,s))}let l=ds(t.inputNames[c],n,r,s),d=l.dataSync();return a.type==="number"?d[0]:$.toNestedArray(l.shape,d)}let i=t.attrParams[e];return i&&i.value}function ds(e,t,n,r){let[s,a]=xa(e,n);if(r!=null){let o=r.getHashTableHandleByName(s);if(o!=null)return o}let i=n.currentContextIds.find(o=>!!t[vx(s,o)]);return i!==void 0?t[vx(s,i)][a]:void 0}function PR(e,t,n){return t[vx(e,n.currentContextId)]}function Qo(e,t){let[n,r,s]=xa(e,t);return[vx(n,t&&t.currentContextId),r,s]}function vx(e,t){return t?`${e}-${t}`:e}function xa(e,t){if(e==="")return["",0,void 0];let n=t!=null&&t.parseNodeNameCache!=null;if(n){let a=t.parseNodeNameCache.get(e);if(a!=null)return a}let r=e.split(":"),s;if(r.length===1)s=[e,0,void 0];else{let a=r[0],i=r.length===3?r[1]:void 0,o=Number(r[r.length-1]);s=[a,o,i]}return n&&t.parseNodeNameCache.set(e,s),s}function V2(e,t,n){let r=R("pad",e,t,n);if(r==="explicit"){r=R("explicitPaddings",e,t,n);let s=[[0,0],[0,0],[0,0],[0,0]];for(let a=0;a<4;a++)s[a][0]=r[a*2],s[a][1]=r[a*2+1];return s}return r}function Yo(e){return e.kept?e:xo(e)}var B8={};Pt(B8,{json:()=>Uue});var Uue=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],z8={};Pt(z8,{json:()=>Gue});var Gue=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],W8={};Pt(W8,{json:()=>Hue});var Hue=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],V8={};Pt(V8,{json:()=>jue});var jue=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],U8={};Pt(U8,{json:()=>que});var que=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],G8={};Pt(G8,{json:()=>Kue});var Kue=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],H8={};Pt(H8,{json:()=>Xue});var Xue=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],j8={};Pt(j8,{json:()=>Que});var Que=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],q8={};Pt(q8,{json:()=>Yue});var Yue=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],K8={};Pt(K8,{json:()=>Jue});var Jue=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],X8={};Pt(X8,{json:()=>Zue});var Zue=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],Q8={};Pt(Q8,{json:()=>ece});var ece=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],Y8={};Pt(Y8,{json:()=>tce});var tce=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],J8={};Pt(J8,{json:()=>nce});var nce=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Z8={};Pt(Z8,{json:()=>rce});var rce=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],eO={};Pt(eO,{json:()=>sce});var sce=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],tO={};Pt(tO,{json:()=>ace});var ace=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],nO={};Pt(nO,{json:()=>ice});var ice=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],rO={};Pt(rO,{json:()=>oce});var oce=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],BR=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let e=[B8,z8,W8,V8,U8,G8,H8,j8,q8,K8,X8,Q8,Y8,J8,Z8,eO,tO,nO,rO],t=[].concat(...e.map(n=>n.json));this.opMappers=t.reduce((n,r)=>(n[r.tfOpName]=r,n),{})}transformGraph(e,t={}){let n=e.node,r=[],s=[],a=[],i=n.reduce((f,m)=>(f[m.name]=this.mapNode(m),m.op.startsWith("Placeholder")?r.push(f[m.name]):m.op==="Const"?s.push(f[m.name]):(m.input==null||m.input.length===0)&&a.push(f[m.name]),f),{}),o=[],u=[],c={},l={};t!=null&&(c=this.mapSignatureEntries(t.inputs),l=this.mapSignatureEntries(t.outputs));let d=Object.keys(i);d.forEach(f=>{let m=i[f];m.inputNames.forEach((g,b)=>{let[y,,x]=Qo(g),w=i[y];if(w.outputs!=null){let v=w.outputs.indexOf(x);if(v!==-1){let I=`${y}:${v}`;m.inputNames[b]=I}}m.inputs.push(w),w.children.push(m)})}),Object.keys(l).length===0?d.forEach(f=>{let m=i[f];m.children.length===0&&u.push(m)}):Object.keys(l).forEach(f=>{let[m]=Qo(f),g=i[m];g!=null&&(g.signatureKey=l[f],u.push(g))}),Object.keys(c).length>0?Object.keys(c).forEach(f=>{let[m]=Qo(f),g=i[m];g&&(g.signatureKey=c[f],o.push(g))}):o=r;let h={};e.library!=null&&e.library.function!=null&&(h=e.library.function.reduce((f,m)=>(f[m.signature.name]=this.mapFunction(m),f),{}));let p={nodes:i,inputs:o,outputs:u,weights:s,placeholders:r,signature:t,functions:h};return a.length>0&&(p.initNodes=a),p}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,n)=>(t[e[n].name]=n,t),{})}mapNode(e){let t=P8(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});let n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(r=>r.startsWith("^")?r.slice(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(n.inputParams=t.inputs.reduce((r,s)=>(r[s.name]={type:s.type,inputIndexStart:s.start,inputIndexEnd:s.end},r),{})),t.attrs!=null&&(n.attrParams=t.attrs.reduce((r,s)=>{let a=s.type,i;switch(s.type){case"string":i=wC(e.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=wC(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"string[]":i=TC(e.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=TC(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"number":i=IC(e.attr,s.tfName,s.defaultValue||0),i===void 0&&s.tfDeprecatedName&&(i=IC(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"number[]":i=NC(e.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=NC(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool":i=vC(e.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=vC(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool[]":i=AC(e.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=AC(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape":i=SC(e.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=SC(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape[]":i=EC(e.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=EC(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype":i=kC(e.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=kC(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype[]":i=CC(e.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=CC(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"func":i=zR(e.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=zR(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${s.type} for op: ${e.op}`)}return r[s.name]={value:i,type:a},r},{})),n}mapFunction(e){let t=e.nodeDef,n=[],r=[],s={};t!=null&&(s=t.reduce((c,l)=>(c[l.name]=this.mapNode(l),l.op==="Const"&&r.push(c[l.name]),c),{}));let a=[],i=[];e.signature.inputArg.forEach(c=>{let[l]=Qo(c.name),d={name:l,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:HT(c.type),type:"dtype"}},children:[]};d.signatureKey=c.name,a.push(d),s[l]=d}),Object.keys(s).forEach(c=>{let l=s[c];l.inputNames.forEach((d,h)=>{let[p,,f]=Qo(d),m=s[p];if(m.outputs!=null){let g=m.outputs.indexOf(f);if(g!==-1){let b=`${p}:${g}`;l.inputNames[h]=b}}l.inputs.push(m),m.children.push(l)})});let o=e.ret;e.signature.outputArg.forEach(c=>{let[l,d]=Qo(o[c.name]),h=s[l];h!=null&&(h.defaultOutput=d,i.push(h))});let u=this.mapArgsToSignature(e);return{nodes:s,inputs:a,outputs:i,weights:r,placeholders:n,signature:u}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n),t),{}),outputs:e.signature.outputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t),{})}}mapArgToTensorInfo(e,t){let n=e.name;return t!=null&&(n=t[n]),{name:n,dtype:e.type}}};function lce(e){let t=ge().global;if(typeof t.atob<"u")return t.atob(e);if(typeof Buffer<"u")return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function sO(e,t){let n=Array.isArray(e)?String.fromCharCode.apply(null,e):lce(e);return t?n:n.toLowerCase()}function wC(e,t,n,r=!1){let s=e[t];return s!=null?sO(s.s,r):n}function vC(e,t,n){let r=e[t];return r?r.b:n}function IC(e,t,n){let r=e[t]||{},s=r.i!=null?r.i:r.f!=null?r.f:n;return typeof s=="number"?s:parseInt(s,10)}function HT(e){switch(typeof e=="string"&&(e=ba[e]),e){case ba.DT_FLOAT:case ba.DT_HALF:return"float32";case ba.DT_INT32:case ba.DT_INT64:case ba.DT_INT8:case ba.DT_UINT8:return"int32";case ba.DT_BOOL:return"bool";case ba.DT_DOUBLE:return"float32";case ba.DT_STRING:return"string";case ba.DT_COMPLEX64:case ba.DT_COMPLEX128:return"complex64";default:return null}}function zR(e,t,n){let r=e[t];return r&&r.func?r.func.name:n}function kC(e,t,n){let r=e[t];return r&&r.type?HT(r.type):n}function CC(e,t,n){let r=e[t];return r&&r.list&&r.list.type?r.list.type.map(s=>HT(s)):n}function aO(e){if(!e.unknownRank)return e.dim!=null?e.dim.map(t=>typeof t.size=="number"?t.size:parseInt(t.size,10)):[]}function SC(e,t,n){let r=e[t];return r&&r.shape?aO(r.shape):n}function NC(e,t,n){let r=e[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(s=>typeof s=="number"?s:parseInt(s,10)):n}function TC(e,t,n,r=!1){let s=e[t];return s&&s.list&&s.list.s?s.list.s.map(a=>sO(a,r)):n}function EC(e,t,n){let r=e[t];return r&&r.list&&r.list.shape?r.list.shape.map(s=>aO(s)):n}function AC(e,t,n){let r=e[t];return r&&r.list&&r.list.b?r.list.b:n}var uce=class{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(r=>this.getInput(r)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((r,s)=>(r[s]=this.getAttr(s),r),{}))}getInput(e){return ds(e,this.tensorMap,this.context)}getAttr(e,t){let n=this.node.rawAttrs[e];if(n.tensor!=null)return ds(e,this.tensorMap,this.context);if(n.i!=null||n.f!=null)return IC(this.node.rawAttrs,e,t);if(n.s!=null)return wC(this.node.rawAttrs,e,t);if(n.b!=null)return vC(this.node.rawAttrs,e,t);if(n.shape!=null)return SC(this.node.rawAttrs,e,t);if(n.type!=null)return kC(this.node.rawAttrs,e,t);if(n.list!=null){if(n.list.i!=null||n.list.f!=null)return NC(this.node.rawAttrs,e,t);if(n.list.s!=null)return TC(this.node.rawAttrs,e,t);if(n.list.shape!=null)return EC(this.node.rawAttrs,e,t);if(n.list.b!=null)return AC(this.node.rawAttrs,e,t);if(n.list.type!=null)return CC(this.node.rawAttrs,e,t)}return t}},cs={};Pt(cs,{OP_SCOPE_SUFFIX:()=>qS,abs:()=>Ar,acos:()=>JS,acosh:()=>ZS,add:()=>Se,addN:()=>x6,all:()=>Aw,any:()=>cy,argMax:()=>Uc,argMin:()=>e3,asin:()=>t3,asinh:()=>n3,atan:()=>r3,atan2:()=>s3,atanh:()=>a3,avgPool:()=>fl,avgPool3d:()=>o3,basicLSTMCell:()=>k6,batchNorm:()=>Oh,batchNorm2d:()=>l3,batchNorm3d:()=>u3,batchNorm4d:()=>c3,batchToSpaceND:()=>b0,bincount:()=>d3,bitwiseAnd:()=>C6,booleanMaskAsync:()=>p5,broadcastArgs:()=>S6,broadcastTo:()=>Ec,buffer:()=>Ht,cast:()=>Ve,ceil:()=>h3,clipByValue:()=>vs,clone:()=>xo,complex:()=>il,concat:()=>Bn,concat1d:()=>p3,concat2d:()=>f3,concat3d:()=>m3,concat4d:()=>g3,conv1d:()=>$w,conv2d:()=>Vs,conv2dTranspose:()=>Rw,conv3d:()=>y3,conv3dTranspose:()=>x3,cos:()=>y0,cosh:()=>_w,cosineWindow:()=>tv,cumprod:()=>py,cumsum:()=>Dw,denseBincount:()=>cx,depthToSpace:()=>w3,depthwiseConv2d:()=>Lh,diag:()=>T6,dilation2d:()=>v3,div:()=>it,divNoNan:()=>I3,dot:()=>k3,dropout:()=>J3,einsum:()=>bc,elu:()=>gm,enclosingPowerOfTwo:()=>Z3,ensureShape:()=>A6,equal:()=>Na,erf:()=>Fw,euclideanNorm:()=>N3,exp:()=>Is,expandDims:()=>ns,expm1:()=>T3,eye:()=>Mw,fft:()=>E0,fill:()=>Ca,floor:()=>ym,floorDiv:()=>Ew,fused:()=>Up,gather:()=>xm,gatherND:()=>b5,greater:()=>Xs,greaterEqual:()=>ml,ifft:()=>Vp,imag:()=>x0,image:()=>La,inTopKAsync:()=>y5,irfft:()=>Kw,isFinite:()=>E3,isInf:()=>A3,isNaN:()=>$3,leakyRelu:()=>w0,less:()=>Pp,lessEqual:()=>ku,linalg:()=>nN,linspace:()=>F6,localResponseNormalization:()=>R3,log:()=>Ta,log1p:()=>v0,logSigmoid:()=>_3,logSoftmax:()=>Lw,logSumExp:()=>I0,logicalAnd:()=>di,logicalNot:()=>k0,logicalOr:()=>Pw,logicalXor:()=>D3,losses:()=>$5,lowerBound:()=>O6,matMul:()=>Ut,max:()=>Va,maxPool:()=>Zr,maxPool3d:()=>F3,maxPoolWithArgmax:()=>L6,maximum:()=>Oo,mean:()=>cr,meshgrid:()=>P6,min:()=>Lp,minimum:()=>tu,mirrorPad:()=>M3,mod:()=>O3,moments:()=>C0,movingAverage:()=>f5,mul:()=>se,multiRNNCell:()=>B6,multinomial:()=>z6,neg:()=>Jn,norm:()=>bm,notEqual:()=>jc,oneHot:()=>Bp,ones:()=>ra,onesLike:()=>Ea,op:()=>ne,outerProduct:()=>W6,pad:()=>Ji,pad1d:()=>V6,pad2d:()=>U6,pad3d:()=>G6,pad4d:()=>H6,pool:()=>L3,pow:()=>To,prelu:()=>N0,print:()=>YS,prod:()=>P3,raggedGather:()=>j6,raggedRange:()=>q6,raggedTensorToTensor:()=>K6,rand:()=>X6,randomGamma:()=>Z6,randomNormal:()=>zw,randomStandardNormal:()=>e5,randomUniform:()=>Cu,randomUniformInt:()=>t5,range:()=>qc,real:()=>zp,reciprocal:()=>U3,relu:()=>Rn,relu6:()=>Ww,reshape:()=>ae,reverse:()=>qa,reverse1d:()=>n5,reverse2d:()=>r5,reverse3d:()=>s5,reverse4d:()=>a5,rfft:()=>A0,round:()=>Vw,rsqrt:()=>Uw,scalar:()=>vt,scatterND:()=>m5,searchSorted:()=>Bw,selu:()=>Gw,separableConv2d:()=>wm,setdiff1dAsync:()=>i5,sigmoid:()=>ci,sign:()=>G3,signal:()=>A5,sin:()=>Hw,sinh:()=>jw,slice:()=>en,slice1d:()=>T0,slice2d:()=>qw,slice3d:()=>vm,slice4d:()=>Wp,softmax:()=>Su,softplus:()=>Ph,spaceToBatchND:()=>S0,sparse:()=>R5,sparseToDense:()=>g5,spectral:()=>E5,split:()=>sa,sqrt:()=>ls,square:()=>Pn,squaredDifference:()=>Xw,squeeze:()=>Nu,stack:()=>Dr,step:()=>Bh,stridedSlice:()=>H3,string:()=>_5,sub:()=>et,sum:()=>dt,tan:()=>j3,tanh:()=>eu,tensor:()=>zs,tensor1d:()=>Tn,tensor2d:()=>wo,tensor3d:()=>Qw,tensor4d:()=>nu,tensor5d:()=>o5,tensor6d:()=>l5,tensorScatterUpdate:()=>c5,tile:()=>Ia,topk:()=>K3,transpose:()=>Gt,truncatedNormal:()=>Zw,unique:()=>X3,unsortedSegmentSum:()=>ev,unstack:()=>br,upperBound:()=>d5,variable:()=>Q3,where:()=>os,whereAsync:()=>Y3,zeros:()=>dr,zerosLike:()=>sn});var cce=(e,t,n,r=cs)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(R("a",e,t,n),R("b",e,t,n))];case"AddN":return[r.addN(R("tensors",e,t,n))];case"FloorMod":case"Mod":return[r.mod(R("a",e,t,n),R("b",e,t,n))];case"Mul":return[r.mul(R("a",e,t,n),R("b",e,t,n))];case"RealDiv":case"Div":return[r.div(R("a",e,t,n),R("b",e,t,n))];case"DivNoNan":return[r.divNoNan(R("a",e,t,n),R("b",e,t,n))];case"FloorDiv":return[r.floorDiv(R("a",e,t,n),R("b",e,t,n))];case"Sub":return[r.sub(R("a",e,t,n),R("b",e,t,n))];case"Minimum":return[r.minimum(R("a",e,t,n),R("b",e,t,n))];case"Maximum":return[r.maximum(R("a",e,t,n),R("b",e,t,n))];case"Pow":return[r.pow(R("a",e,t,n),R("b",e,t,n))];case"SquaredDifference":return[r.squaredDifference(R("a",e,t,n),R("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},dce=(e,t,n,r=cs)=>{switch(e.op){case"Abs":case"ComplexAbs":return[r.abs(R("x",e,t,n))];case"Acos":return[r.acos(R("x",e,t,n))];case"Acosh":return[r.acosh(R("x",e,t,n))];case"Asin":return[r.asin(R("x",e,t,n))];case"Asinh":return[r.asinh(R("x",e,t,n))];case"Atan":return[r.atan(R("x",e,t,n))];case"Atan2":return[r.atan2(R("x",e,t,n),R("y",e,t,n))];case"Atanh":return[r.atanh(R("x",e,t,n))];case"Ceil":return[r.ceil(R("x",e,t,n))];case"Complex":return[r.complex(R("real",e,t,n),R("imag",e,t,n))];case"Cos":return[r.cos(R("x",e,t,n))];case"Cosh":return[r.cosh(R("x",e,t,n))];case"Elu":return[r.elu(R("x",e,t,n))];case"Erf":return[r.erf(R("x",e,t,n))];case"Exp":return[r.exp(R("x",e,t,n))];case"Expm1":return[r.expm1(R("x",e,t,n))];case"Floor":return[r.floor(R("x",e,t,n))];case"Log":return[r.log(R("x",e,t,n))];case"Log1p":return[r.log1p(R("x",e,t,n))];case"Imag":return[r.imag(R("x",e,t,n))];case"Neg":return[r.neg(R("x",e,t,n))];case"Reciprocal":return[r.reciprocal(R("x",e,t,n))];case"Real":return[r.real(R("x",e,t,n))];case"Relu":return[r.relu(R("x",e,t,n))];case"Round":return[r.round(R("x",e,t,n))];case"Selu":return[r.selu(R("x",e,t,n))];case"Sigmoid":return[r.sigmoid(R("x",e,t,n))];case"Sin":return[r.sin(R("x",e,t,n))];case"Sign":return[r.sign(R("x",e,t,n))];case"Sinh":return[r.sinh(R("x",e,t,n))];case"Softplus":return[r.softplus(R("x",e,t,n))];case"Sqrt":return[r.sqrt(R("x",e,t,n))];case"Square":return[r.square(R("x",e,t,n))];case"Tanh":return[r.tanh(R("x",e,t,n))];case"Tan":return[r.tan(R("x",e,t,n))];case"ClipByValue":return[r.clipByValue(R("x",e,t,n),R("clipValueMin",e,t,n),R("clipValueMax",e,t,n))];case"Relu6":return[r.relu6(R("x",e,t,n))];case"Rsqrt":return[r.rsqrt(ds(e.inputNames[0],t,n))];case"LeakyRelu":return[r.leakyRelu(R("x",e,t,n),R("alpha",e,t,n))];case"Prelu":return[r.prelu(R("x",e,t,n),R("alpha",e,t,n))];case"IsNan":return[r.isNaN(ds(e.inputNames[0],t,n))];case"IsInf":return[r.isInf(ds(e.inputNames[0],t,n))];case"IsFinite":return[r.isFinite(ds(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function ii(e,t,n=""){if(!(typeof e=="number"||typeof t=="number")){$.assert(e.length===t.length,()=>n+` Shapes ${e} and ${t} must match`);for(let r=0;r<e.length;r++){let s=e[r],a=t[r];$.assert(s<0||a<0||s===a,()=>n+` Shapes ${e} and ${t} must match`)}}}function WR(e){return!(typeof e=="number"||e.some(t=>t<0))}function Ab(e,t,n){let r=$C(e,n),s=!WR(r);if(s&&t.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&t.forEach(a=>{r=$C(a.shape,r)}),!WR(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function $C(e,t){if(typeof e=="number")return t;if(typeof t=="number")return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);let n=[];for(let r=0;r<e.length;++r){let s=e[r],a=t[r];if(s>=0&&a>=0&&s!==a)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[r]=s>=0?s:a}return n}var hce=class{constructor(e,t,n,r,s,a,i){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=s,this.dynamicSize=a,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=vt(0),zr(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);let t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);let n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),ii(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,zr(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((n,r)=>this.write(n,t[r]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let r=0;r<this.size();r++)e.push(r)}if(e.length===0)return zs([],[0].concat(this.elementShape));let n=this.readMany(e);return ii(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),Dr(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return zs([],[0].concat(this.elementShape));let t=[];for(let r=0;r<this.size();r++)t.push(r);let n=this.readMany(t);return ii(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),Bn(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);let n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,br(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0,r=e.map(o=>(n+=o,n));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);let s=n===0?0:t.size/n,a=[];ie(()=>{t=ae(t,[1,n,s]);for(let o=0;o<e.length;++o){let u=[0,o===0?0:r[o-1],0],c=[1,e[o],s];a[o]=ae(en(t,u,c),this.elementShape)}return a});let i=[];for(let o=0;o<e.length;o++)i[o]=o;this.writeMany(i,a)}},Av=class RC{get id(){return this.idTensor.id}constructor(t,n,r,s=-1){this.tensors=t,this.elementShape=n,this.elementDtype=r,t?.forEach(a=>{if(r!==a.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${a.dtype}`);ii(n,a.shape,"TensorList shape mismatch: "),zr(a)}),this.idTensor=vt(0),this.maxNumElements=s,zr(this.idTensor)}copy(){return new RC([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(n=>{(t==null||!t.has(n.id))&&n.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,n,r=-1){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(r!==-1&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);ii(t,this.elementShape,"TensorList shape mismatch: ");let s=Ab(this.elementShape,this.tensors,t);return ie(()=>{let a=this.tensors.map(i=>ae(i,s));return Dr(a,0)})}popBack(t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");let r=Ab(this.elementShape,this.tensors,t),s=this.tensors.pop();return s.kept=!1,ii(s.shape,t,"TensorList shape mismatch: "),ae(s,r)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(ii(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");zr(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(this.maxNumElements!==-1&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);let n=new RC([],this.elementShape,this.elementDtype,this.maxNumElements);n.tensors.length=t;for(let r=0;r<Math.min(this.tensors.length,t);++r)n.tensors[r]=this.tensors[r];return n}getItem(t,n,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(this.tensors[t]==null)throw new Error(`element at index ${t} is null.`);ii(this.tensors[t].shape,n,"TensorList shape mismatch: ");let s=Ab(this.elementShape,this.tensors,n);return ae(this.tensors[t],s)}setItem(t,n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(t<0||this.maxNumElements!==-1&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);ii(this.elementShape,n.shape,"TensorList shape mismatch: "),zr(n),this.tensors[t]!=null&&(this.tensors[t].kept=!1),this.tensors[t]=n}gather(t,n,r){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);ii(this.elementShape,r,"TensorList shape mismatch: "),t=t.slice(0,this.size());let s=Ab(this.elementShape,this.tensors,r);return t.length===0?zs([],[0].concat(s)):ie(()=>{let a=t.map(i=>ae(this.tensors[i],s));return Dr(a,0)})}concat(t,n){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);ii(this.elementShape,n,"TensorList shape mismatch: ");let r=Ab(this.elementShape,this.tensors,n);return this.size()===0?zs([],[0].concat(r)):ie(()=>{let s=this.tensors.map(a=>ae(a,r));return Bn(s,0)})}};function pce(e,t,n){let r=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);let s=e.shape.slice(1);ii(s,t,"TensorList shape mismatch: ");let a=br(e);return new Av(a,t,r)}function fce(e,t,n,r){return new Av([],e,t,r)}function mce(e,t,n,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);let s=Math.max(...t);if(r!=null&&r!==-1&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);let a=new Av([],n,e.dtype,r),i=br(e,0);return t.forEach((o,u)=>{a.setItem(o,i[u])}),a}function gce(e,t,n){let r=0,s=t.map(l=>(r+=l,r));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${e.shape}`);let a=e.shape.slice(1),i=$C(a,n),o=r===0?0:e.size/r,u=ie(()=>{let l=[];e=ae(e,[1,r,o]);for(let d=0;d<t.length;++d){let h=[0,d===0?0:s[d-1],0],p=[1,t[d],o];l[d]=ae(en(e,h,p),i)}return e.dispose(),l}),c=new Av([],n,e.dtype,t.length);for(let l=0;l<u.length;l++)c.setItem(l,u[l]);return c}var bce=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{let r=R("thenBranch",e,t,n),s=R("elseBranch",e,t,n),a=R("cond",e,t,n),i=R("args",e,t,n);return(await a.data())[0]?n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[s].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{let r=R("body",e,t,n),s=R("cond",e,t,n),a=R("args",e,t,n),i=await n.functionMap[s].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap),o=a.map(l=>l.id),u=await i[0].data();i.forEach(l=>{!l.kept&&o.indexOf(l.id)===-1&&l.dispose()});let c=a;for(;u[0];){let l=c;c=await n.functionMap[r].executeFunctionAsync(c,n.tensorArrayMap,n.tensorListMap);let d=c.map(p=>p.id);l.forEach(p=>{!p.kept&&o.indexOf(p.id)===-1&&d.indexOf(p.id)===-1&&p.dispose()});let h=await n.functionMap[s].executeFunctionAsync(c,n.tensorArrayMap,n.tensorListMap);u=await h[0].data(),h.forEach(p=>{!p.kept&&o.indexOf(p.id)===-1&&d.indexOf(p.id)===-1&&p.dispose()})}return c}case"LoopCond":{let r=R("pred",e,t,n);return[Yo(r)]}case"Switch":{let r=R("pred",e,t,n),s=R("data",e,t,n);return s.kept||(s=Yo(s)),(await r.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{let r=e.inputNames.find(s=>ds(s,t,n)!==void 0);if(r){let s=ds(r,t,n);return[Yo(s)]}return}case"Enter":{let r=R("frameName",e,t,n),s=R("tensor",e,t,n);return n.enterFrame(r),[Yo(s)]}case"Exit":{let r=R("tensor",e,t,n);return n.exitFrame(),[Yo(r)]}case"NextIteration":{let r=R("tensor",e,t,n);return n.nextIteration(),[Yo(r)]}case"TensorArrayV3":{let r=R("size",e,t,n),s=R("dtype",e,t,n),a=R("elementShape",e,t,n),i=R("dynamicSize",e,t,n),o=R("clearAfterRead",e,t,n),u=R("identicalElementShapes",e,t,n),c=R("name",e,t,n),l=new hce(c,s,r,a,u,i,o);return n.addTensorArray(l),[l.idTensor,vt(1)]}case"TensorArrayWriteV3":{let r=R("tensorArrayId",e,t,n),s=R("index",e,t,n),a=R("tensor",e,t,n),i=n.getTensorArray(r.id);return i.write(s,a),[i.idTensor]}case"TensorArrayReadV3":{let r=R("tensorArrayId",e,t,n),s=R("index",e,t,n);return[n.getTensorArray(r.id).read(s)]}case"TensorArrayGatherV3":{let r=R("tensorArrayId",e,t,n),s=R("indices",e,t,n),a=R("dtype",e,t,n);return[n.getTensorArray(r.id).gather(s,a)]}case"TensorArrayScatterV3":{let r=R("tensorArrayId",e,t,n),s=R("indices",e,t,n),a=R("tensor",e,t,n),i=n.getTensorArray(r.id);return i.scatter(s,a),[i.idTensor]}case"TensorArrayConcatV3":{let r=R("tensorArrayId",e,t,n),s=n.getTensorArray(r.id),a=R("dtype",e,t,n);return[s.concat(a)]}case"TensorArraySplitV3":{let r=R("tensorArrayId",e,t,n),s=R("tensor",e,t,n),a=R("lengths",e,t,n),i=n.getTensorArray(r.id);return i.split(a,s),[i.idTensor]}case"TensorArraySizeV3":{let r=R("tensorArrayId",e,t,n),s=n.getTensorArray(r.id);return[vt(s.size(),"int32")]}case"TensorArrayCloseV3":{let r=R("tensorArrayId",e,t,n),s=n.getTensorArray(r.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{let r=R("tensorListId",e,t,n),s=R("index",e,t,n),a=R("tensor",e,t,n),i=n.getTensorList(r.id);return i.setItem(s,a),[i.idTensor]}case"TensorListGetItem":{let r=R("tensorListId",e,t,n),s=R("index",e,t,n),a=R("elementShape",e,t,n),i=R("elementDType",e,t,n);return[n.getTensorList(r.id).getItem(s,a,i)]}case"TensorListScatterV2":case"TensorListScatter":{let r=R("indices",e,t,n),s=R("tensor",e,t,n),a=R("elementShape",e,t,n),i=R("numElements",e,t,n),o=mce(s,r,a,i);return n.addTensorList(o),[o.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let r=R("elementShape",e,t,n),s=R("elementDType",e,t,n),a;e.op==="TensorListReserve"?a="numElements":a="maxNumElements";let i=R(a,e,t,n),o=e.op==="TensorListReserve"?-1:i,u=fce(r,s,i,o);return n.addTensorList(u),[u.idTensor]}case"TensorListGather":{let r=R("tensorListId",e,t,n),s=R("indices",e,t,n),a=R("elementShape",e,t,n),i=R("elementDType",e,t,n);return[n.getTensorList(r.id).gather(s,i,a)]}case"TensorListStack":{let r=R("tensorListId",e,t,n),s=R("elementShape",e,t,n),a=R("elementDType",e,t,n),i=R("numElements",e,t,n);return[n.getTensorList(r.id).stack(s,a,i)]}case"TensorListFromTensor":{let r=R("tensor",e,t,n),s=R("elementShape",e,t,n),a=R("elementDType",e,t,n),i=pce(r,s,a);return n.addTensorList(i),[i.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{let r=R("tensorListId",e,t,n),s=n.getTensorList(r.id),a=R("dtype",e,t,n),i=R("elementShape",e,t,n);return[s.concat(a,i)]}case"TensorListPushBack":{let r=R("tensorListId",e,t,n),s=R("tensor",e,t,n),a=n.getTensorList(r.id);return a.pushBack(s),[a.idTensor]}case"TensorListPopBack":{let r=R("tensorListId",e,t,n),s=R("elementShape",e,t,n),a=R("elementDType",e,t,n);return[n.getTensorList(r.id).popBack(s,a)]}case"TensorListSplit":{let r=R("tensor",e,t,n),s=R("elementShape",e,t,n),a=R("lengths",e,t,n),i=gce(r,a,s);return n.addTensorList(i),[i.idTensor]}case"TensorListLength":{let r=R("tensorListId",e,t,n),s=n.getTensorList(r.id);return[vt(s.size(),"int32")]}case"TensorListResize":{let r=R("tensorListId",e,t,n),s=R("size",e,t,n),a=n.getTensorList(r.id).resize(s);return n.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function VR(e,t,n){let[r,s]=R("fusedOps",e,t,n),a=r==="biasadd",i=!a,o=s==="prelu",u=r==="fusedbatchnorm",c=R("numArgs",e,t,n);if(a){if(o&&c!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&a&&c!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let l=R("strides",e,t,n),d=V2(e,t,n),h=R("dataFormat",e,t,n).toUpperCase(),p=R("dilations",e,t,n),[f,m]=R("args",e,t,n);i&&(m=f,f=void 0);let g=R("leakyreluAlpha",e,t,n);return{stride:l,pad:d,dataFormat:h,dilations:p,biasArg:f,preluArg:m,activationFunc:s,leakyreluAlpha:g}}var yce=(e,t,n,r=cs)=>{switch(e.op){case"Conv1D":{let s=R("stride",e,t,n),a=R("pad",e,t,n),i=R("dataFormat",e,t,n).toUpperCase(),o=R("dilation",e,t,n);return[r.conv1d(R("x",e,t,n),R("filter",e,t,n),s,a,i,o)]}case"Conv2D":{let s=R("strides",e,t,n),a=V2(e,t,n),i=R("dataFormat",e,t,n).toUpperCase(),o=R("dilations",e,t,n);return[r.conv2d(R("x",e,t,n),R("filter",e,t,n),[s[1],s[2]],a,i,[o[1],o[2]])]}case"_FusedConv2D":{let{stride:s,pad:a,dataFormat:i,dilations:o,biasArg:u,preluArg:c,activationFunc:l,leakyreluAlpha:d}=VR(e,t,n);return[r.fused.conv2d({x:R("x",e,t,n),filter:R("filter",e,t,n),strides:[s[1],s[2]],pad:a,dataFormat:i,dilations:[o[1],o[2]],bias:u,activation:l,preluActivationWeights:c,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{let{stride:s,pad:a,dataFormat:i,dilations:o,biasArg:u,preluArg:c,activationFunc:l,leakyreluAlpha:d}=VR(e,t,n);return[r.fused.depthwiseConv2d({x:R("x",e,t,n),filter:R("filter",e,t,n),strides:[s[1],s[2]],pad:a,dataFormat:i,dilations:[o[1],o[2]],bias:u,activation:l,preluActivationWeights:c,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let s=R("outputShape",e,t,n),a=R("strides",e,t,n),i=V2(e,t,n);return[r.conv2dTranspose(R("x",e,t,n),R("filter",e,t,n),s,[a[1],a[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let s=R("strides",e,t,n),a=V2(e,t,n),i=R("dilations",e,t,n),o=R("dataFormat",e,t,n).toUpperCase();return[r.depthwiseConv2d(R("input",e,t,n),R("filter",e,t,n),[s[1],s[2]],a,o,[i[1],i[2]])]}case"Conv3D":{let s=R("strides",e,t,n),a=R("pad",e,t,n),i=R("dataFormat",e,t,n).toUpperCase(),o=R("dilations",e,t,n);return[r.conv3d(R("x",e,t,n),R("filter",e,t,n),[s[1],s[2],s[3]],a,i,[o[1],o[2],o[3]])]}case"AvgPool":{let s=R("strides",e,t,n),a=R("pad",e,t,n),i=R("kernelSize",e,t,n);return[r.avgPool(R("x",e,t,n),[i[1],i[2]],[s[1],s[2]],a)]}case"MaxPool":{let s=R("strides",e,t,n),a=R("pad",e,t,n),i=R("kernelSize",e,t,n);return[r.maxPool(R("x",e,t,n),[i[1],i[2]],[s[1],s[2]],a)]}case"MaxPoolWithArgmax":{let s=R("strides",e,t,n),a=R("pad",e,t,n),i=R("kernelSize",e,t,n),o=R("includeBatchInIndex",e,t,n),{result:u,indexes:c}=r.maxPoolWithArgmax(R("x",e,t,n),[i[1],i[2]],[s[1],s[2]],a,o);return[u,c]}case"AvgPool3D":{let s=R("strides",e,t,n),a=R("pad",e,t,n),i=R("kernelSize",e,t,n);return[r.avgPool3d(R("x",e,t,n),[i[1],i[2],i[3]],[s[1],s[2],s[3]],a)]}case"MaxPool3D":{let s=R("strides",e,t,n),a=R("pad",e,t,n),i=R("kernelSize",e,t,n);return[r.maxPool3d(R("x",e,t,n),[i[1],i[2],i[3]],[s[1],s[2],s[3]],a)]}case"Dilation2D":{let s=R("strides",e,t,n),a=R("pad",e,t,n),i=R("dilations",e,t,n),o=s[1],u=s[2],c=i[1],l=i[2];return[r.dilation2d(R("x",e,t,n),R("filter",e,t,n),[o,u],a,[c,l],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},xce=(e,t,n,r=cs)=>{switch(e.op){case"Fill":{let s=R("shape",e,t,n),a=R("dtype",e,t,n),i=R("value",e,t,n);return[r.fill(s,i,a)]}case"LinSpace":{let s=R("start",e,t,n),a=R("stop",e,t,n),i=R("num",e,t,n);return[r.linspace(s,a,i)]}case"Multinomial":{let s=R("logits",e,t,n),a=R("numSamples",e,t,n),i=R("seed",e,t,n);return[r.multinomial(s,a,i)]}case"OneHot":{let s=R("indices",e,t,n),a=R("depth",e,t,n),i=R("onValue",e,t,n),o=R("offValue",e,t,n),u=R("dtype",e,t,n);return[r.oneHot(s,a,i,o,u)]}case"Ones":return[r.ones(R("shape",e,t,n),R("dtype",e,t,n))];case"OnesLike":return[r.onesLike(R("x",e,t,n))];case"RandomStandardNormal":return[r.randomStandardNormal(R("shape",e,t,n),R("dtype",e,t,n),R("seed",e,t,n))];case"RandomUniform":return[r.randomUniform(R("shape",e,t,n),R("minval",e,t,n),R("maxval",e,t,n),R("dtype",e,t,n))];case"RandomUniformInt":return[r.randomUniformInt(R("shape",e,t,n),R("minval",e,t,n),R("maxval",e,t,n),R("seed",e,t,n))];case"Range":{let s=R("start",e,t,n),a=R("stop",e,t,n),i=R("step",e,t,n);return[r.range(s,a,i,R("dtype",e,t,n))]}case"TruncatedNormal":{let s=R("shape",e,t,n),a=R("mean",e,t,n),i=R("stdDev",e,t,n),o=R("seed",e,t,n);return[r.truncatedNormal(s,a,i,R("dtype",e,t,n),o)]}case"Zeros":return[r.zeros(R("shape",e,t,n),R("dtype",e,t,n))];case"ZerosLike":return[r.zerosLike(R("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function ck(e,t,n){let r=R("boxes",e,t,n),s=R("scores",e,t,n),a=R("maxOutputSize",e,t,n),i=R("iouThreshold",e,t,n),o=R("scoreThreshold",e,t,n),u=R("softNmsSigma",e,t,n);return{boxes:r,scores:s,maxOutputSize:a,iouThreshold:i,scoreThreshold:o,softNmsSigma:u}}var wce=async(e,t,n,r,s=cs)=>{switch(e.op){case"NonMaxSuppressionV5":{let{boxes:a,scores:i,maxOutputSize:o,iouThreshold:u,scoreThreshold:c,softNmsSigma:l}=ck(e,t,n),d=await s.image.nonMaxSuppressionWithScoreAsync(a,i,o,u,c,l);return[d.selectedIndices,d.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:a,scores:i,maxOutputSize:o,iouThreshold:u,scoreThreshold:c}=ck(e,t,n),l=R("padToMaxOutputSize",e,t,n),d=await s.image.nonMaxSuppressionPaddedAsync(a,i,o,u,c,l);return[d.selectedIndices,d.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:a,scores:i,maxOutputSize:o,iouThreshold:u,scoreThreshold:c}=ck(e,t,n);return[await s.image.nonMaxSuppressionAsync(a,i,o,u,c)]}case"Where":{let a=s.cast(R("condition",e,t,n),"bool"),i=[await s.whereAsync(a)];return a.dispose(),i}case"ListDiff":return s.setdiff1dAsync(R("x",e,t,n),R("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}},vce=(e,t,n,r=cs)=>{switch(e.op){case"LowerBound":{let s=R("sortedSequence",e,t,n),a=R("values",e,t,n);return[r.lowerBound(s,a)]}case"TopKV2":{let s=R("x",e,t,n),a=R("k",e,t,n),i=R("sorted",e,t,n),o=r.topk(s,a,i);return[o.values,o.indices]}case"UpperBound":{let s=R("sortedSequence",e,t,n),a=R("values",e,t,n);return[r.upperBound(s,a)]}case"Unique":{let s=R("x",e,t,n),a=r.unique(s);return[a.values,a.indices]}case"UniqueV2":{let s=R("x",e,t,n),a=R("axis",e,t,n),i=r.unique(s,a);return[i.values,i.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},Ice=(e,t,n,r=cs)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":let s=R("default",e,t,n);return[ds(e.name,t,n)||s];case"Placeholder":return[ds(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let l=R("x",e,t,n);return[Yo(l)]}case"IdentityN":return R("x",e,t,n).map(l=>Yo(l));case"Snapshot":let a=R("x",e,t,n);return[Yo(a)];case"Shape":return[r.tensor1d(R("x",e,t,n).shape,"int32")];case"ShapeN":return R("x",e,t,n).map(l=>r.tensor1d(l.shape));case"Size":return[r.scalar(R("x",e,t,n).size,"int32")];case"Rank":return[r.scalar(R("x",e,t,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":let i=R("x",e,t,n),o=R("data",e,t,n),u=R("message",e,t,n),c=R("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(u);for(let l=0;l<o.length;l++)console.log(Array.prototype.slice.call(o[l].dataSync()).slice(0,c));return[i];default:throw TypeError(`Node type ${e.op} is not implemented`)}},kce=class{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=vt(0),this.tensorMap=new Map,zr(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return vt(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return this.tensorMap.forEach(r=>r.dispose()),this.tensorMap.clear(),ie(()=>{let r=br(t),s=n.length,a=r.length;$.assert(s===a,()=>`The number of elements doesn't match, keys has ${s} elements, the values has ${a} elements.`);for(let i=0;i<s;i++){let o=n[i],u=r[i];zr(u),this.tensorMap.set(o,u)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return ie(()=>{let r=[];for(let s=0;s<n.length;s++){let a=n[s],i=this.findWithDefault(a,t);r.push(i)}return Dr(r)})}findWithDefault(e,t){let n=this.tensorMap.get(e);return n??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}},Cce=async(e,t,n,r)=>{switch(e.op){case"HashTable":case"HashTableV2":{let s=r.getHashTableHandleByName(e.name);if(s!=null)return[s];{let a=R("keyDType",e,t,n),i=R("valueDType",e,t,n),o=new kce(a,i);return r.addHashTable(e.name,o),[o.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{let s=R("tableHandle",e,t,n,r),a=R("keys",e,t,n),i=R("values",e,t,n);return[await r.getHashTableById(s.id).import(a,i)]}case"LookupTableFind":case"LookupTableFindV2":{let s=R("tableHandle",e,t,n,r),a=R("keys",e,t,n),i=R("defaultValue",e,t,n);return[await r.getHashTableById(s.id).find(a,i)]}case"LookupTableSize":case"LookupTableSizeV2":{let s=R("tableHandle",e,t,n,r);return[r.getHashTableById(s.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},Sce=(e,t,n,r=cs)=>{switch(e.op){case"ResizeBilinear":{let s=R("images",e,t,n),a=R("size",e,t,n),i=R("alignCorners",e,t,n),o=R("halfPixelCenters",e,t,n);return[r.image.resizeBilinear(s,[a[0],a[1]],i,o)]}case"ResizeNearestNeighbor":{let s=R("images",e,t,n),a=R("size",e,t,n),i=R("alignCorners",e,t,n),o=R("halfPixelCenters",e,t,n);return[r.image.resizeNearestNeighbor(s,[a[0],a[1]],i,o)]}case"CropAndResize":{let s=R("image",e,t,n),a=R("boxes",e,t,n),i=R("boxInd",e,t,n),o=R("cropSize",e,t,n),u=R("method",e,t,n),c=R("extrapolationValue",e,t,n);return[r.image.cropAndResize(s,a,i,o,u,c)]}case"ImageProjectiveTransformV3":{let s=R("images",e,t,n),a=R("transforms",e,t,n),i=R("outputShape",e,t,n),o=R("fillValue",e,t,n),u=R("interpolation",e,t,n),c=R("fillMode",e,t,n);return[r.image.transform(s,a,u.toLowerCase(),c.toLowerCase(),o,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},Nce=(e,t,n,r=cs)=>{switch(e.op){case"Equal":return[r.equal(R("a",e,t,n),R("b",e,t,n))];case"NotEqual":return[r.notEqual(R("a",e,t,n),R("b",e,t,n))];case"Greater":return[r.greater(R("a",e,t,n),R("b",e,t,n))];case"GreaterEqual":return[r.greaterEqual(R("a",e,t,n),R("b",e,t,n))];case"Less":return[r.less(R("a",e,t,n),R("b",e,t,n))];case"LessEqual":return[r.lessEqual(R("a",e,t,n),R("b",e,t,n))];case"LogicalAnd":return[r.logicalAnd(R("a",e,t,n),R("b",e,t,n))];case"LogicalNot":return[r.logicalNot(R("a",e,t,n))];case"LogicalOr":return[r.logicalOr(R("a",e,t,n),R("b",e,t,n))];case"Select":case"SelectV2":return[r.where(R("condition",e,t,n),R("a",e,t,n),R("b",e,t,n))];case"BitwiseAnd":return[r.bitwiseAnd(R("a",e,t,n),R("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},Tce=(e,t,n,r=cs)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(R("a",e,t,n),R("b",e,t,n),R("transposeA",e,t,n),R("transposeB",e,t,n))];case"Einsum":return[r.einsum(R("equation",e,t,n),...R("tensors",e,t,n))];case"Transpose":return[r.transpose(R("x",e,t,n),R("perm",e,t,n))];case"_FusedMatMul":let[s,a]=R("fusedOps",e,t,n),i=s==="biasadd",o=a==="prelu",u=R("numArgs",e,t,n),c=R("leakyreluAlpha",e,t,n);if(i){if(o&&u!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&u!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[l,d]=R("args",e,t,n);return[r.fused.matMul({a:R("a",e,t,n),b:R("b",e,t,n),transposeA:R("transposeA",e,t,n),transposeB:R("transposeB",e,t,n),bias:l,activation:a,preluActivationWeights:d,leakyreluAlpha:c})];case"MatrixBandPart":return[r.linalg.bandPart(R("a",e,t,n),R("numLower",e,t,n),R("numUpper",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},Ece=(e,t,n,r=cs)=>{switch(e.op){case"EuclideanNorm":return[r.euclideanNorm(R("x",e,t,n),R("axis",e,t,n),R("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":return[r.batchNorm(R("x",e,t,n),R("mean",e,t,n),R("variance",e,t,n),R("offset",e,t,n),R("scale",e,t,n),R("epsilon",e,t,n))];case"FusedBatchNormV3":return[r.batchNorm(R("x",e,t,n),R("mean",e,t,n),R("variance",e,t,n),R("offset",e,t,n),R("scale",e,t,n),R("epsilon",e,t,n))];case"LRN":return[r.localResponseNormalization(R("x",e,t,n),R("radius",e,t,n),R("bias",e,t,n),R("alpha",e,t,n),R("beta",e,t,n))];case"Softmax":return[r.softmax(R("x",e,t,n))];case"LogSoftmax":return[r.logSoftmax(R("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},Ace=(e,t,n,r=cs)=>{switch(e.op){case"RaggedGather":{let{outputNestedSplits:s,outputDenseValues:a}=r.raggedGather(R("paramsNestedSplits",e,t,n),R("paramsDenseValues",e,t,n),R("indices",e,t,n),R("outputRaggedRank",e,t,n));return s.concat(a)}case"RaggedRange":{let{rtNestedSplits:s,rtDenseValues:a}=r.raggedRange(R("starts",e,t,n),R("limits",e,t,n),R("splits",e,t,n));return[s,a]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(R("shape",e,t,n),R("values",e,t,n),R("defaultValue",e,t,n),R("rowPartitionTensors",e,t,n),R("rowPartitionTypes",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},$ce=(e,t,n,r=cs)=>{switch(e.op){case"Max":{let o=R("axis",e,t,n),u=R("keepDims",e,t,n);return[r.max(R("x",e,t,n),o,u)]}case"Mean":{let o=R("axis",e,t,n),u=R("keepDims",e,t,n);return[r.mean(R("x",e,t,n),o,u)]}case"Min":{let o=R("axis",e,t,n),u=R("keepDims",e,t,n);return[r.min(R("x",e,t,n),o,u)]}case"Sum":{let o=R("axis",e,t,n),u=R("keepDims",e,t,n);return[r.sum(R("x",e,t,n),o,u)]}case"All":{let o=R("axis",e,t,n),u=R("keepDims",e,t,n);return[r.all(R("x",e,t,n),o,u)]}case"Any":{let o=R("axis",e,t,n),u=R("keepDims",e,t,n);return[r.any(R("x",e,t,n),o,u)]}case"ArgMax":{let o=R("axis",e,t,n);return[r.argMax(R("x",e,t,n),o)]}case"ArgMin":{let o=R("axis",e,t,n);return[r.argMin(R("x",e,t,n),o)]}case"Prod":{let o=R("axis",e,t,n),u=R("keepDims",e,t,n);return[r.prod(R("x",e,t,n),o,u)]}case"Cumprod":{let o=R("axis",e,t,n),u=R("exclusive",e,t,n),c=R("reverse",e,t,n);return[r.cumprod(R("x",e,t,n),o,u,c)]}case"Cumsum":{let o=R("axis",e,t,n),u=R("exclusive",e,t,n),c=R("reverse",e,t,n);return[r.cumsum(R("x",e,t,n),o,u,c)]}case"Bincount":let s=R("x",e,t,n),a=R("weights",e,t,n),i=R("size",e,t,n);return[r.bincount(s,a,i)];case"DenseBincount":{let o=R("x",e,t,n),u=R("weights",e,t,n),c=R("size",e,t,n),l=R("binaryOutput",e,t,n);return[r.denseBincount(o,u,c,l)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},Rce=(e,t,n,r=cs)=>{switch(e.op){case"ConcatV2":case"Concat":{let s=R("n",e,t,n),a=R("axis",e,t,n),i=R("tensors",e,t,n);return i=i.slice(0,s),[r.concat(i,a)]}case"Gather":{let s=R("x",e,t,n),a=R("indices",e,t,n);return[r.gather(s,r.cast(a,"int32"),0)]}case"GatherV2":{let s=R("axis",e,t,n),a=R("batchDims",e,t,n),i=R("x",e,t,n),o=R("indices",e,t,n);return[r.gather(i,r.cast(o,"int32"),s,a)]}case"Reverse":{let s=R("dims",e,t,n),a=[];for(let o=0;o<s.length;o++)s[o]&&a.push(o);let i=R("x",e,t,n);return[r.reverse(i,a)]}case"ReverseV2":{let s=R("axis",e,t,n),a=R("x",e,t,n);return[r.reverse(a,s)]}case"Slice":{let s=R("begin",e,t,n),a=R("size",e,t,n);return[r.slice(R("x",e,t,n),s,a)]}case"StridedSlice":{let s=R("begin",e,t,n),a=R("end",e,t,n),i=R("strides",e,t,n),o=R("beginMask",e,t,n),u=R("endMask",e,t,n),c=R("ellipsisMask",e,t,n),l=R("newAxisMask",e,t,n),d=R("shrinkAxisMask",e,t,n),h=R("x",e,t,n);return[r.stridedSlice(h,s,a,i,o,u,c,l,d)]}case"Pack":return ie(()=>{let s=R("axis",e,t,n),a=R("tensors",e,t,n),i=a[0].shape,o=r.squeeze(a[0]).shape,u=a.map(c=>{let l=$.arraysEqual(c.shape,i);if(!l&&!$.arraysEqual(r.squeeze(c).shape,o))throw new Error("the input tensors shape does not match");return l?c:r.reshape(c,i)});return[r.stack(u,s)]});case"Unpack":{let s=R("axis",e,t,n),a=R("tensor",e,t,n);return r.unstack(a,s)}case"Tile":{let s=R("reps",e,t,n);return[r.tile(R("x",e,t,n),s)]}case"Split":case"SplitV":{let s=R("axis",e,t,n),a=R("numOrSizeSplits",e,t,n),i=R("x",e,t,n);return r.split(i,a,s)}case"ScatterNd":{let s=R("indices",e,t,n),a=R("values",e,t,n),i=R("shape",e,t,n);return[r.scatterND(s,a,i)]}case"GatherNd":{let s=R("x",e,t,n),a=R("indices",e,t,n);return[r.gatherND(s,a)]}case"SparseToDense":{let s=R("sparseIndices",e,t,n),a=R("outputShape",e,t,n),i=R("sparseValues",e,t,n),o=R("defaultValue",e,t,n);return[r.sparseToDense(s,i,a,i.dtype===o.dtype?o:r.cast(o,i.dtype))]}case"TensorScatterUpdate":{let s=R("indices",e,t,n),a=R("values",e,t,n),i=R("tensor",e,t,n);return[r.tensorScatterUpdate(i,s,a)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},_ce=(e,t,n,r=cs)=>{switch(e.op){case"SparseFillEmptyRows":{let{outputIndices:s,outputValues:a,emptyRowIndicator:i,reverseIndexMap:o}=r.sparse.sparseFillEmptyRows(R("indices",e,t,n),R("values",e,t,n),R("denseShape",e,t,n),R("defaultValue",e,t,n));return[s,a,i,o]}case"SparseReshape":{let{outputIndices:s,outputShape:a}=r.sparse.sparseReshape(R("inputIndices",e,t,n),R("inputShape",e,t,n),R("newShape",e,t,n));return[s,a]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(R("data",e,t,n),R("indices",e,t,n),R("segmentIds",e,t,n))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(R("data",e,t,n),R("indices",e,t,n),R("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},Dce=(e,t,n,r=cs)=>{switch(e.op){case"FFT":return[r.fft(R("x",e,t,n))];case"IFFT":return[r.ifft(R("x",e,t,n))];case"RFFT":return[r.rfft(R("x",e,t,n))];case"IRFFT":return[r.irfft(R("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},Fce=(e,t,n,r=cs)=>{switch(e.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(R("input",e,t,n),R("pattern",e,t,n),R("rewrite",e,t,n),R("replaceGlobal",e,t,n))];case"StringNGrams":{let{nGrams:s,nGramsSplits:a}=r.string.stringNGrams(R("data",e,t,n),R("dataSplits",e,t,n),R("separator",e,t,n),R("nGramWidths",e,t,n),R("leftPad",e,t,n),R("rightPad",e,t,n),R("padWidth",e,t,n),R("preserveShortSequences",e,t,n));return[s,a]}case"StringSplit":{let{indices:s,values:a,shape:i}=r.string.stringSplit(R("input",e,t,n),R("delimiter",e,t,n),R("skipEmpty",e,t,n));return[s,a,i]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(R("input",e,t,n),R("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},Mce=(e,t,n,r=cs)=>{switch(e.op){case"Cast":return[r.cast(R("x",e,t,n),R("dtype",e,t,n))];case"ExpandDims":{let s=R("axis",e,t,n);return[r.expandDims(R("x",e,t,n),s)]}case"Squeeze":{let s=R("axis",e,t,n);return[r.squeeze(R("x",e,t,n),s)]}case"Reshape":return[r.reshape(R("x",e,t,n),R("shape",e,t,n))];case"EnsureShape":return[r.ensureShape(R("x",e,t,n),R("shape",e,t,n))];case"MirrorPad":return[r.mirrorPad(R("x",e,t,n),R("padding",e,t,n),R("mode",e,t,n))];case"PadV2":case"Pad":return[r.pad(R("x",e,t,n),R("padding",e,t,n),R("constantValue",e,t,n))];case"SpaceToBatchND":{let s=R("blockShape",e,t,n),a=R("paddings",e,t,n);return[r.spaceToBatchND(R("x",e,t,n),s,a)]}case"BatchToSpaceND":{let s=R("blockShape",e,t,n),a=R("crops",e,t,n);return[r.batchToSpaceND(R("x",e,t,n),s,a)]}case"DepthToSpace":{let s=R("blockSize",e,t,n),a=R("dataFormat",e,t,n).toUpperCase();return[r.depthToSpace(R("x",e,t,n),s,a)]}case"BroadcastTo":return[r.broadcastTo(R("x",e,t,n),R("shape",e,t,n))];case"BroadcastArgs":return[r.broadcastArgs(R("s0",e,t,n),R("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function UR(e,t,n,r,s=ie){let a=((i,o,u)=>{switch(i.category){case"arithmetic":return s(()=>cce(i,o,u));case"basic_math":return s(()=>dce(i,o,u));case"control":return bce(i,o,u);case"convolution":return s(()=>yce(i,o,u));case"creation":return s(()=>xce(i,o,u));case"dynamic":return wce(i,o,u);case"evaluation":return s(()=>vce(i,o,u));case"image":return s(()=>Sce(i,o,u));case"graph":return s(()=>Ice(i,o,u));case"logical":return s(()=>Nce(i,o,u));case"matrices":return s(()=>Tce(i,o,u));case"normalization":return s(()=>Ece(i,o,u));case"ragged":return s(()=>Ace(i,o,u));case"reduction":return s(()=>$ce(i,o,u));case"slice_join":return s(()=>Rce(i,o,u));case"sparse":return s(()=>_ce(i,o,u));case"spectral":return s(()=>Dce(i,o,u));case"string":return s(()=>Fce(i,o,u));case"transformation":return s(()=>Mce(i,o,u));case"hash_table":return Cce(i,o,u,r);case"custom":let c=P8(i.op);if(c&&c.customExecutor)return c.customExecutor(new uce(i,o,u));throw TypeError(`Custom op ${i.op} is not registered.`);default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return $.isPromise(a)?a.then(i=>[].concat(i)):[].concat(a)}var GR=class{constructor(e={},t={},n={},r={},s){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=r,this.parseNodeNameCache=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let e=[];for(let t=0;t<this.contexts.length-1;t++){let n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(let t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(let t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}};function HR(e,t,n,r){let s=new Set,a=[],i=null,o=null,u=new Set,c=new Set(Object.keys(e).map(h=>xa(h)[0]));r=r||[];let l=new Set(r.map(h=>xa(h.name)[0])),d=[...t];for(;d.length>0;){let h=d.pop();if((xc(h)||Uce(h)||Gce(h))&&i==null&&(i=h,o=i.children.map(p=>p.name).filter(p=>s.has(p))),s.add(h.name),n[h.name]==null&&!c.has(h.name)&&!l.has(h.name)){if(h.inputs.length===0){a.push(h.name);continue}h.inputs.forEach(p=>{u.has(p.name)||(u.add(p.name),d.push(p))})}}return{inputs:e,outputs:t,usedNodes:s,missingInputs:a,dynamicNode:i,syncInputs:o}}function Oce(e,t){let{usedNodes:n,inputs:r}=t,s=Object.keys(r).map(g=>xa(g)[0]).map(g=>e.nodes[g]),a=e.initNodes||[],i=g=>n.has(typeof g=="string"?g:g.name);function o(g){return[...new Map(g.map(b=>[b.name,b])).values()]}let u=o([...s,...e.weights,...a]).filter(i),c=o([...u,...Object.values(e.nodes)]).filter(i),l=new Map(c.map(g=>[g.name,g])),d={};for(let g of c){d[g.name]=d[g.name]||0;for(let b of g.children)i(b)||(d[b.name]=Number.POSITIVE_INFINITY),d[b.name]=(d[b.name]||0)+1}let h=Object.entries(d).filter(([,g])=>g===0).map(([g])=>g),p=[...h];for(;h.length>0;){let g=h.pop(),b=l.get(g);for(let y of b.children.filter(i))--d[y.name]===0&&(p.push(y.name),h.push(y.name))}let f=p.map(g=>l.get(g)),m=Lce(f,u);return Pce(m,u),m}function Lce(e,t){let n=new Map(e.map(a=>[a.name,a])),r=t.map(a=>a.name),s=new Set(r);for(;r.length>0;){let a=r.pop(),i=n.get(a);for(let o of i.children)!n.has(o.name)||s.has(o.name)||(s.add(o.name),r.push(o.name))}return e.filter(a=>s.has(a.name))}var b2=class extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}};function Pce(e,t){let n=new Map(e.map((o,u)=>[o.name,u])),r=new Set(t.map(o=>o.name)),s=o=>r.has(typeof o=="string"?o:o.name),a=new Set(e.map(o=>o.name)),i=o=>a.has(typeof o=="string"?o:o.name);for(let o of e){for(let u of o.children.filter(i)){if(!n.has(u.name))throw new b2(`Child ${u.name} of node ${o.name} is unreachable.`);if(n.get(o.name)>n.get(u.name))throw new b2(`Node ${o.name} is scheduled to run after its child ${u.name}.`)}if(!s(o))for(let u of o.inputs){if(!n.has(u.name))throw new b2(`Input ${u.name} of node ${o.name} is unreachable.`);if(n.get(u.name)>n.get(o.name))throw new b2(`Node ${o.name} is scheduled to run before its input ${u.name}.`)}}}function Bce(e){let t=new Map(e.map((o,u)=>[o.name,u])),n=Number.MAX_SAFE_INTEGER,r=e.map((o,u)=>xc(o)?n:u),s=o=>{let u=r[t.get(o.name)];return u??-1},a=e.map((o,u)=>o.children.map(s).reduce((c,l)=>Math.max(c,l),r[u])),i=new Map;for(let o=0;o<e.length;++o){let u=a[o];if(u===n)continue;let c=e[o],l=e[u];i.has(l.name)||i.set(l.name,[]),i.get(l.name).push(c)}return i}var zce=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),Wce=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),Vce=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function xc(e){return zce.has(e.op)}function Uce(e){return Wce.has(e.op)}function Gce(e){return Vce.has(e.op)}var jR=class iO{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){let n=Object.keys(t).map(r=>t[r].map(s=>s.id));this._weightIds=[].concat(...n),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{let n=t.signatureKey||t.name;return t.defaultOutput?`${n}:${t.defaultOutput}`:n})}get functions(){return Object.keys(this._functions).reduce((t,n)=>(t[n]=this._functions[n].signature,t),{})}constructor(t,n){this.graph=t,this.parent=n,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,t.functions!=null&&Object.keys(t.functions).forEach(r=>{this._functionExecutorMap[r]=new iO(t.functions[r],this)})}getCompilationKey(t,n){let r=t.map(a=>a.name).sort(),s=n.map(a=>a.name).sort();return r.join(this.SEPARATOR)+"--"+s.join(this.SEPARATOR)}compile(t,n){let r=HR(t,n,this.weightMap,this._initNodes),{missingInputs:s,dynamicNode:a,syncInputs:i}=r;if(a!=null)throw new Error(`This execution contains the node '${a.name}', which has the dynamic op '${a.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(s.length>0){let c=n.map(d=>d.name),l=Object.keys(t);throw new Error(`Cannot compute the outputs [${c}] from the provided inputs [${l}]. Missing the following inputs: [${s}]`)}let o=Oce(this.graph,r),u=Bce(o);return{orderedNodes:o,nodeLiveUntilMap:u}}cloneAndKeepTensor(t){if(t==null)return null;let n=t.clone();return zr(n),n}cloneTensorList(t){return t?t.map(n=>this.cloneAndKeepTensor(n)):null}cloneTensorMap(t){return Object.fromEntries(Object.entries(t).map(([n,r])=>[n,this.cloneTensorList(r)]))}execute(t,n){this.disposeIntermediateTensors(),t=this.mapInputs(t);let r=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),n=this.mapOutputs(n),this.checkOutputs(n);let s=r.map(h=>this.graph.nodes[xa(h)[0]]),a=n.map(h=>xa(h)[0]),i=new Set(a),o=a.map(h=>this.graph.nodes[h]);o.length===0&&(o=this._outputs);let u=this.getCompilationKey(s,o),c=this.compiledMap.get(u);c==null&&(c=this.compile(t,o),this.compiledMap.set(u,c));try{this.keepIntermediateTensors=ge().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(h){this.keepIntermediateTensors=!1,console.warn(h.message)}let l={},d={};return ie(()=>{let h=new GR(this.weightMap,l,d,this.functionExecutorMap,this.parseNodeNameCache),p=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(t).forEach(b=>{let[y,x]=xa(b,h),w=[];w[x]=t[b],p[y]=w,this.keepIntermediateTensors&&(this.clonedTensorsMap[y]=this.cloneTensorList(w))});let f=this.getFrozenTensorIds(p),{orderedNodes:m,nodeLiveUntilMap:g}=c;for(let b of m){if(p[b.name])continue;let y=UR(b,p,h,this._resourceManager);if($.isPromise(y))throw new Error(`The execution of the op '${b.op}' returned a promise. Please use model.executeAsync() instead.`);p[b.name]=y,this.keepIntermediateTensors&&(this.clonedTensorsMap[b.name]=this.cloneTensorList(y)),this.checkTensorForDisposalWithNodeLiveUntilInfo(b,p,h,f,i,g.get(b.name))}return this.parent==null&&h.dispose(f),n.map(b=>ds(b,p,h))})}getFrozenTensorIds(t){let n=[].concat.apply([],Object.keys(t).map(r=>t[r]).map(r=>r.map(s=>s.id)));return new Set(n)}checkTensorForDisposal(t,n,r,s,a,i,o){if(!(xc(n)||i.has(t))){for(let u of r[t])u!=null&&(o[u.id]=(o[u.id]||0)+n.children.length);for(let u of n.inputs){if(xc(u))continue;let c=PR(u.name,r,s);if(c!=null)for(let l of c){if(!l||l.kept||a.has(l.id))continue;let d=o[l.id];d===1?(l.dispose(),delete o[l.id]):d!=null&&o[l.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(t,n,r,s,a,i){function o(u){return xc(u)||a.has(u.name)}if(!(xc(t)||i==null))for(let u of i){if(o(u))continue;let c=PR(u.name,n,r);for(let l of c)!l||l.kept||s.has(l.id)||l.dispose()}}async executeAsync(t,n){return this._executeAsync(t,n)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(t=>{for(let n of t)n&&!n.isDisposed&&n.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(t,n,r=!1,s={},a={}){this.disposeIntermediateTensors(),r||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),n=this.mapOutputs(n),this.checkOutputs(n));try{this.keepIntermediateTensors=ge().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(h){this.keepIntermediateTensors=!1,console.warn(h.message)}let i=new GR(this.weightMap,s,a,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));let o=await this.executeWithControlFlow(t,i,n,r),u=n.map(h=>ds(h,o,i)),c=u.map(h=>h.id),l=Object.keys(t).map(h=>t[h].id),d=new Set([...c,...l,...this.weightIds]);return Object.values(o).forEach(h=>{h.forEach(p=>{p&&!p.isDisposed&&!d.has(p.id)&&p.dispose()})}),this.parent==null&&i.dispose(d),u}async executeFunctionAsync(t,n,r){let s=t.reduce((a,i,o)=>(a[this.inputs[o].name]=i,a),{});return this._executeAsync(s,this.outputNodes,!0,n,r)}async executeWithControlFlow(t,n,r,s){let a=Object.keys(t),i=a.map(w=>this.graph.nodes[xa(w)[0]]),o=r.map(w=>xa(w)[0]),u=new Set(o),c=o.map(w=>this.graph.nodes[w]);c.length===0&&(c=this._outputs);let{usedNodes:l,missingInputs:d,dynamicNode:h,syncInputs:p}=HR(t,c,this.weightMap,this._initNodes),f=[...i,...this.graph.weights,...this._initNodes||[]].map(w=>({node:w,contexts:n.currentContext})),m=Object.assign({},this.weightMap);Object.keys(t).forEach(w=>{let[v,I]=xa(w),N=[];N[I]=t[w],m[v]=N});let g={},b=this.getFrozenTensorIds(m),y={};for(;f.length>0;){let w=this.processStack(i,f,n,m,y,b,u,g,l);await Promise.all(w)}h==null&&!s&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let x=c.filter(w=>!xc(w)&&!ds(w.name,m,n)).map(w=>w.name);if(x.length>0){let w="";throw h!=null&&(w=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${p}]`),new Error(`Cannot compute the outputs [${x}] from the provided inputs [${a}]. Consider providing the following inputs: [${d}]. ${w}`)}return m}processStack(t,n,r,s,a,i,o,u,c){let l=[];for(;n.length>0;){let d=n.pop();r.currentContext=d.contexts;let h="";if(d.node.op==="Enter"&&R("isConstant",d.node,s,r)&&([h]=Qo(d.node.name,r)),s[d.node.name]==null){let p=UR(d.node,s,r,this._resourceManager);h||([h]=Qo(d.node.name,r));let f=r.currentContext;$.isPromise(p)?l.push(p.then(m=>(s[h]=m,this.keepIntermediateTensors&&(this.clonedTensorsMap[h]=this.cloneTensorList(m)),r.currentContext=f,this.checkTensorForDisposal(h,d.node,s,r,i,o,u),this.processChildNodes(d.node,n,r,s,a,c),m))):(s[h]=p,this.keepIntermediateTensors&&(this.clonedTensorsMap[h]=this.cloneTensorList(p)),this.checkTensorForDisposal(h,d.node,s,r,i,o,u),this.processChildNodes(d.node,n,r,s,a,c))}else this.processChildNodes(d.node,n,r,s,a,c)}return l}processChildNodes(t,n,r,s,a,i){t.children.forEach(o=>{let[u]=Qo(o.name,r);a[u]||!i.has(o.name)||(o.op==="Merge"?o.inputNames.some(c=>!!ds(c,s,r))&&(a[u]=!0,n.push({contexts:r.currentContext,node:o})):o.inputNames.every(c=>!!ds(c,s,r))&&(a[u]=!0,n.push({contexts:r.currentContext,node:o})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(n=>n.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(n=>{let r=t[n],[s]=xa(n),a=this.graph.nodes[s];if(a.attrParams.shape&&a.attrParams.shape.value){let i=a.attrParams.shape.value,o=i.length===r.shape.length&&r.shape.every((u,c)=>i[c]===-1||i[c]===u);$.assert(o,()=>`The shape of dict['${a.name}'] provided in model.execute(dict) must be [${i}], but was [${r.shape}]`)}a.attrParams.dtype&&a.attrParams.dtype.value&&$.assert(r.dtype===a.attrParams.dtype.value,()=>`The dtype of dict['${a.name}'] provided in model.execute(dict) must be ${a.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(t){var n,r;let s={};for(let a in t){let i=(r=(n=this._signature)===null||n===void 0?void 0:n.inputs)===null||r===void 0?void 0:r[a];i!=null?s[i.name]=t[a]:s[a]=t[a]}return s}checkInputs(t){let n=Object.keys(t).filter(r=>{let[s]=xa(r);return this.graph.nodes[s]==null});if(n.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${n}] that are not part of graph`)}mapOutputs(t){return t.map(n=>{var r,s;let a=(s=(r=this._signature)===null||r===void 0?void 0:r.outputs)===null||s===void 0?void 0:s[n];return a!=null?a.name:n},{})}checkOutputs(t){t.forEach(n=>{let[r]=xa(n);if(!this.graph.nodes[r])throw new Error(`The output '${n}' is not found in the graph`)})}},Hce=class{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(let e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(let e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}},jce="?tfjs-format=file",qce="model.json",jT=class{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},n=fs){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=n,t==null&&(this.loadOptions={}),this.resourceManager=new Hce}findIOHandler(){let e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{let t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let e=this.handler.load();return $.isPromise(e)?e.then(t=>t.getWeightStream==null?this.loadSync(t):this.loadStreaming(t)):this.loadSync(e)}loadSync(e){let t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");let t=await u6(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;let n=this.artifacts.modelTopology,r=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){let s=this.artifacts.userDefinedMetadata;s.signature!=null&&(r=s.signature),s.structuredOutputKeys!=null&&(this.structuredOutputKeys=s.structuredOutputKeys)}if(this.signature=r,this.version=`${n.versions.producer}.${n.versions.minConsumer}`,this.executor=new jR(BR.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){let s=BR.Instance.transformGraph(e.modelInitializer);this.initializer=new jR(s),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){let n=this.io.getSaveHandlers(e);if(n.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(n.length>1)throw new Error(`Found more than one (${n.length}) save handlers for URL '${e}'`);e=n[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){let t=e instanceof Wt?[e]:e,n={};return t.forEach((r,s)=>n[this.structuredOutputKeys[s]]=r),n}return e}predict(e,t){let n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){let n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){var t;if(!(e instanceof Wt)&&!Array.isArray(e)){let s=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(s!=null)for(let a in s){let i=s[a];i.resourceId!=null&&(e[a]=this.resourceIdToCapturedInput[i.resourceId])}return e}e=Array.isArray(e)?e:[e];let n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce((s,a)=>{var i,o,u;let c=(u=(o=(i=this.signature)===null||i===void 0?void 0:i.inputs)===null||o===void 0?void 0:o[a])===null||u===void 0?void 0:u.resourceId;return c!=null?s[a]=this.resourceIdToCapturedInput[c]:s[a]=e[r++],s},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){let t=this.initializerSignature.outputs,n=Object.keys(t);for(let r=0;r<n.length;r++){let s=n[r],a=t[s];this.resourceIdToCapturedInput[a.resourceId]=e[r]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,n)=>(t[n]=[e[n]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Lt(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}};async function Kce(e,t={},n=fs){if(e==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");t==null&&(t={}),t.fromTFHub&&typeof e=="string"&&(e=Qce(e));let r=new jT(e,t,n);return await r.load(),r}function Xce(e){if(e==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let t;if(e instanceof Array){let[r,s]=e;if(!r)throw new Error("modelJSON must be the first element of the array");if(!s||!(s instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in r))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in r))throw new Error("Model JSON is missing 'weightsManifest'");let a=fs.getWeightSpecs(r.weightsManifest),i=fs.getModelArtifactsForJSONSync(r,a,s);t=fs.fromMemorySync(i)}else if("load"in e)t=e;else if("modelTopology"in e&&"weightSpecs"in e&&"weightData"in e)t=fs.fromMemorySync(e);else throw new Error("Unknown model format");let n=new jT(t);return n.load(),n}function Qce(e){return e.endsWith("/")||(e=e+"/"),`${e}${qce}${jce}`}var Yce="4.22.0",oO={};Pt(oO,{CSVDataset:()=>yO,Dataset:()=>Sm,FileDataSource:()=>SO,TextLineDataset:()=>bO,URLDataSource:()=>NO,array:()=>wde,csv:()=>Dde,func:()=>Fde,generator:()=>Mde,microphone:()=>Lde,version_data:()=>Pde,webcam:()=>Ode,zip:()=>vde});var Jce=bu(lw()),Zce=bu(lw());function ede(e,t){return Ix(e,t)}function Ix(e,t,n=new Map,r=new Set){if(e==null)return null;if(typeof Blob=="function"&&e instanceof Blob)return e.slice();if(r.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);let s=t(e);if(s.recurse&&s.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(s.recurse)if(jp(e)){let a=Array.isArray(e)?[]:{};r.add(e);for(let i in e){let o=e[i],u=Ix(o,t,n,r);a[i]=u}return r.delete(e),e.__proto__&&(a.__proto__=e.__proto__),a}else throw new Error(`Can't recurse into non-iterable type: ${e}`);else return n.set(e,s.value),s.value}function tde(e,t=uO){return lO(e,t)}function lO(e,t,n=new Set){let r=e[0];if(n.has(r))throw new Error("Circular references are not supported.");let s=t(e);if(s.recurse&&s.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(s.recurse)if(jp(r)){let a=Array.isArray(r)?[]:{};n.add(r);for(let i in r){let o=e.map(c=>c[i]),u=lO(o,t,n);a[i]=u}return n.delete(r),a}else throw new Error(`Can't recurse into non-iterable type: ${r}`);else return s.value}function uO(e){return e===null?null:jp(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}async function cO(e,t){let n=new Map;Ix(e,t,n);for(let r of Array.from(n.keys())){let s=n.get(r);if($.isPromise(s)){let a=await s;n.set(r,a)}}return Ix(e,t,n)}function jp(e){let t=!1;if(ge().get("IS_BROWSER"))t=e instanceof TextDecoder;else{let{StringDecoder:n}=AF();t=e instanceof n}return e!=null&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||typeof e=="object"&&!(e instanceof Wt)&&!(e instanceof Promise)&&!t)}function nde(e){return e==null||rde(e)||Array.isArray(e)||typeof e=="object"&&e instanceof Wt||$.isTypedArray(e)}function rde(e){return e===null||typeof e!="object"&&typeof e!="function"}function sde(e){return ede(e,ade)}function ade(e){return e instanceof Wt?{value:e.clone(),recurse:!1}:jp(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}var dO=class{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,e==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(let t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}},hO=class pO extends dO{constructor(){super(pO.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){let t=this.capacity*2,n=new Array(t),r=this.length();for(let s=0;s<r;s++)n[s]=this.get(this.wrap(this.begin+s));this.data=n,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=r}};hO.INITIAL_CAPACITY=32;function fO(e){return new lde(e)}function qT(e){return new ude(e)}function ide(e,t){return new mO(e,t)}function ode(e,t=Ol.FAIL){return new yde(e,t)}var us=class{async toArray(){let e=[],t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){let e=this.prefetch(100),t=[],n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new gde(this,e)}filter(e){return new fde(this,e)}map(e){return new mde(this,e)}mapAsync(e){return new qR(this,e)}serialMapAsync(e){return new qR(this,e).serial()}flatmap(e){return new bde(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(t=>t===!0)}rowMajorBatch(e,t=!0){return new pde(this,e,t)}columnMajorBatch(e,t=!0,n=uO){return this.rowMajorBatch(e,t).map(r=>tde(r,n))}concatenate(e,t){return new mO(fO([this,e]),t)}take(e){return e<0||e==null?this:new hde(this,e)}skip(e){return e<0||e==null?this:new dde(this,e)}prefetch(e){return new gO(this,e)}shuffle(e,t){return new xde(this,e,t)}serial(){return new cde(this)}},lde=class extends us{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let e=this.items[this.trav];return this.trav++,{value:sde(e),done:!1}}},ude=class extends us{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}},cde=class extends us{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}},dde=class extends us{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let e=await this.upstream.next();if(e.done)return e;Lt(e.value)}return this.upstream.next()}},hde=class extends us{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},pde=class extends us{constructor(e,t,n=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){let e=[];for(;e.length<this.batchSize;){let t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}},fde=class extends us{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){let e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;Lt(e.value)}}},mde=class extends us{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=Bi.getTensorsInContainer(e.value),n=this.transform(e.value),r=Bi.getTensorsInContainer(n);for(let s of t)Bi.isTensorInList(s,r)||s.dispose();return{value:n,done:!1}}},gde=class extends us{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}},qR=class extends us{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=Bi.getTensorsInContainer(e.value),n=await this.transform(e.value),r=Bi.getTensorsInContainer(n);for(let s of t)Bi.isTensorInList(s,r)||s.dispose();return{value:n,done:!1}}},KT=class extends us{constructor(){super(),this.outputQueue=new hO,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},bde=class extends KT{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let e=await this.upstream.next();if(e.done)return!1;let t=Bi.getTensorsInContainer(e.value),n=this.transform(e.value),r=Bi.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(let s of t)Bi.isTensorInList(s,r)||s.dispose();return!0}},mO=class extends us{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,this.iterator==null){let n=await this.moreIterators.next();if(n.done)return{value:null,done:!0};this.iterator=n.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}},Ol;(function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"})(Ol||(Ol={}));var yde=class extends us{constructor(e,t=Ol.FAIL){super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,n=0;function r(a){return a instanceof us?{value:a.next().then(i=>(t++,i.done&&n++,i.value)),recurse:!1}:{value:null,recurse:!0}}let s=await cO(this.iterators,r);if(t===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case Ol.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case Ol.SHORTEST:return{value:null,done:!0};case Ol.LONGEST:}return this.count++,{value:s,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}},gO=class extends us{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new dO(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}},xde=class extends gO{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=Zce.alea(n||$.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(t.done)this.upstreamExhausted=!0;else return this.refill(),t}return{value:null,done:!0}}},Sm=class{constructor(){this.size=null}batch(e,t=!0){let n=this;$.assert(e>0,()=>`batchSize needs to be positive, but it is
      ${e}`);let r;return this.size===1/0||this.size==null?r=this.size:t?r=Math.ceil(this.size/e):r=Math.floor(this.size/e),ya(async()=>(await n.iterator()).columnMajorBatch(e,t,Ide),r)}concatenate(e){let t=this,n;return this.size===1/0||e.size===1/0?n=1/0:this.size!=null&&e.size!=null?n=this.size+e.size:n=null,ya(async()=>(await t.iterator()).concatenate(await e.iterator()),n)}filter(e){let t=this,n;return this.size===1/0?n=1/0:n=null,ya(async()=>(await t.iterator()).filter(r=>ie(()=>e(r))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){let t=this;return ya(async()=>(await t.iterator()).map(n=>ie(()=>e(n))),this.size)}mapAsync(e){let t=this;return ya(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(e==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let t=this;return ya(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){let t=this,n;return this.size!=null&&e>0?n=this.size*e:e===0?n=0:this.size!=null&&(e===void 0||e<0)?n=1/0:n=null,ya(async()=>{let r=qT(async()=>({value:await t.iterator(),done:!1}));return ide(r.take(e))},n)}skip(e){let t=this,n;return this.size!=null&&e>=0&&this.size>=e?n=this.size-e:this.size!=null&&(this.size<e||e===void 0||e<0)?n=0:n=null,ya(async()=>(await t.iterator()).skip(e),n)}shuffle(e,t,n=!0){if(e==null||e<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let r=this,s=Jce.alea(t||$.now().toString());return ya(async()=>{let a=s.int32();return n&&(a+=s.int32()),(await r.iterator()).shuffle(e,a.toString())},this.size)}take(e){let t=this,n;return this.size!=null&&this.size>e?n=e:this.size!=null&&this.size<=e?n=this.size:n=null,ya(async()=>(await t.iterator()).take(e),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};Sm.MAX_BUFFER_SIZE=1e4;function ya(e,t=null){return new class extends Sm{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function wde(e){return ya(async()=>fO(e),e.length)}function vde(e){if(!jp(e))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(e))for(let n=0;n<e.length;n++)t=t==null?e[n].size:Math.min(t,e[n].size);else if(e instanceof Object)for(let n in e)t=t==null?e[n].size:Math.min(t,e[n].size);return ya(async()=>{let n=await cO(e,r=>{if(r instanceof Sm)return{value:r.iterator(),recurse:!1};if(jp(r))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return ode(n,Ol.SHORTEST)},t)}function Ide(e){if(e===null)return null;let t=e[0];return nde(t)?{value:kde(e),recurse:!1}:{value:null,recurse:!0}}function kde(e){if(e.length===0)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof Wt?Dr(e):zs(e)}var bO=class extends Sm{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`
`).map(e=>(e.endsWith("\r")&&(e=e.slice(0,-1)),e))}},y2='"',$b=Symbol("out"),KR=Symbol("field"),x2=Symbol("quote"),dk=Symbol("quoteafterquote"),XR=Symbol("quoteinquote"),yO=class extends Sm{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&$.assert(e.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=e);let t=this.fullColumnNames.reduce((r,s)=>(r[s]=r[s]+1||1,r),{}),n=Object.keys(t).filter(r=>t[r]>1);if($.assert(n.length===0,()=>"Duplicate column names found: "+n.toString()),this.columnConfigs){for(let r of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(r)===-1)throw new Error('The key "'+r+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){let e=await(await this.base.iterator()).next();if(e.done)throw new Error("No data was found for CSV parsing.");let t=e.value;return this.parseRow(t,!1)}else return null}constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new bO(e),t||(t={}),this.hasHeader=t.hasHeader!==!1,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?($.assert(t.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map(t=>this.makeDataElement(t))}makeDataElement(e){let t=this.parseRow(e),n={},r={};for(let s=0;s<this.fullColumnNames.length;s++){let a=this.fullColumnNames[s],i=this.columnConfigs?this.columnConfigs[a]:null;if(!(this.configuredColumnsOnly&&!i)){let o=t[s],u=null;if(o==="")if(i&&i.default!==void 0)u=i.default;else{if(i&&(i.required||i.isLabel))throw new Error(`Required column ${a} is empty in this line: ${e}`);u=void 0}else{let c=Number(o);if(isNaN(c))i&&i.dtype==="bool"?u=this.getBoolean(o):u=o;else if(!i||!i.dtype)u=c;else switch(i.dtype){case"float32":u=c;break;case"int32":u=Math.floor(c);break;case"bool":u=this.getBoolean(o);break;default:u=c}}i&&i.isLabel?r[a]=u:n[a]=u}}return Object.keys(r).length===0?n:{xs:n,ys:r}}getBoolean(e){return e==="1"||e.toLowerCase()==="true"?1:0}parseRow(e,t=!0){let n=[],r=0,s=e.length,a=$b;for(let i=0;i<s;i++)switch(a){case $b:switch(e.charAt(i)){case y2:r=i+1,a=x2;break;case this.delimiter:if(r=i+1,this.delimiter===" "&&this.delimWhitespace)break;n.push(""),a=$b;break;default:a=KR,r=i;break}break;case KR:switch(e.charAt(i)){case this.delimiter:n.push(e.substring(r,i)),a=$b,r=i+1;break}break;case x2:switch(e.charAt(i)){case y2:a=dk;break}break;case dk:switch(e.charAt(i)){case this.delimiter:n.push(e.substring(r,i-1)),a=$b,r=i+1;break;case y2:a=x2;break;default:a=XR;break}break;case XR:switch(e.charAt(i)){case y2:a=x2;break}break}if(a===dk?n.push(e.substring(r,s-1)):n.push(e.substring(r)),t&&n.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}},Cde=class xO extends us{constructor(t){super(),this.microphoneConfig=t,this.isClosed=!1,this.fftSize=t.fftSize||1024;let n=Math.log2(this.fftSize);if(this.fftSize<0||n<4||n>14||!Number.isInteger(n))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=t.numFramesPerSpectrogram||43,this.sampleRateHz=t.sampleRateHz,this.columnTruncateLength=t.columnTruncateLength||this.fftSize,this.audioTrackConstraints=t.audioTrackConstraints,this.smoothingTimeConstant=t.smoothingTimeConstant||0,this.includeSpectrogram=t.includeSpectrogram!==!1,this.includeWaveform=t.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(t={}){if(!ge().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");let n=new xO(t);return await n.start(),n}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(r){throw new Error(`Error thrown while initializing video stream: ${r.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");let t=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new t,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);let n=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,n.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let t,n,r=await this.getAudioData();if(this.includeSpectrogram){let s=this.flattenQueue(r.freqDataQueue);t=this.getTensorFromAudioDataArray(s,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let s=this.flattenQueue(r.timeDataQueue);n=this.getTensorFromAudioDataArray(s,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:t,waveform:n},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let t=[],n=[],r=0;return new Promise(s=>{let a=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&s({freqDataQueue:t,timeDataQueue:n}),t.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),n.push(this.timeData.slice())),++r===this.numFrames&&(clearInterval(a),s({freqDataQueue:t,timeDataQueue:n}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(t){let n=t[0].length,r=new Float32Array(t.length*n);return t.forEach((s,a)=>r.set(s,a*n)),r}getTensorFromAudioDataArray(t,n){let r=new Float32Array($.sizeFromShape(n));return r.set(t,r.length-t.length),zs(r,n)}},Sde=class wO extends us{constructor(t,n){if(super(),this.webcamVideoElement=t,this.webcamConfig=n,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=Tn([0],"int32"),this.webcamConfig.centerCrop){let r=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,s=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,a=(1-r)/2,i=(1-s)/2,o=a+r,u=s+i;this.cropBox=wo([i,a,u,o],[1,4])}else this.cropBox=wo([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(t,n={}){if(!ge().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!t){if(t=document.createElement("video"),!n.resizeWidth||!n.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");t.width=n.resizeWidth,t.height=n.resizeHeight}let r=new wO(t,n);return await r.start(),r}async start(){this.webcamConfig.facingMode&&$.assert(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(t){throw t.message=`Error thrown while initializing video stream: ${t.message}`,t}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(t){console.log(t),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(t=>{this.webcamVideoElement.onloadedmetadata=()=>{t()}})}async next(){if(this.isClosed)return{value:null,done:!0};let t;try{t=$0.fromPixels(this.webcamVideoElement)}catch(n){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(n)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(t),done:!1}}catch(n){throw new Error(`Error thrown cropping the video: ${n.message}`)}finally{t.dispose()}else return{value:t,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(t){return ie(()=>{let n=ns(Ve(t,"float32"),0),r;r=La.cropAndResize(n,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");let s=r.shape;return ae(r,s.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(t=>t.stop());try{this.webcamVideoElement.srcObject=null}catch(t){console.log(t),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}},vO=class{},IO=class extends us{split(e){return new Nde(this,e)}},Nde=class extends IO{constructor(e,t){super(),this.upstream=e,this.impl=new Tde(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},Tde=class extends KT{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let e=await this.upstream.next();if(e.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);let t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(let n of t.slice(0,-1))this.outputQueue.push(n);return this.carryover=t[t.length-1],!0}},Ede=class extends us{decodeUTF8(){return new Ade(this)}},Ade=class extends IO{constructor(e){super(),this.upstream=e,this.impl=new $de(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},$de=class extends KT{constructor(e){if(super(),this.upstream=e,ge().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{let{StringDecoder:t}=AF();this.decoder=new t("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let e=await this.upstream.next(),t;if(e.done)return!1;t=e.value;let n;return ge().get("IS_BROWSER")?n=this.decoder.decode(t,{stream:!0}):n=this.decoder.write(Buffer.from(t.buffer)),this.outputQueue.push(n),!0}},kO=class extends Ede{constructor(e,t={}){super(),this.file=e,this.options=t,$.assert(e instanceof Uint8Array||(ge().get("IS_BROWSER")?e instanceof File||e instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((e,t)=>{let n=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)e(new Uint8Array(this.file.slice(this.offset,n)));else{let r=new FileReader;r.onload=a=>{let i=r.result;if(i instanceof ArrayBuffer&&(i=new Uint8Array(i)),!(i instanceof Uint8Array))return t(new TypeError("FileReader returned unknown type."));e(i)},r.onabort=a=>t(new Error("Aborted")),r.onerror=a=>t(new Error(a.type));let s=this.file.slice(this.offset,n);r.readAsArrayBuffer(s)}this.offset=n}),done:!1}}};async function Rde(e,t={},n){let r,s;typeof e=="string"?r=e:(r=e.url,s=_de(e));let a=await(0,$.fetch)(r,s);if(a.ok){let i=new Uint8Array(await a.arrayBuffer());return new kO(i,t)}else throw new Error(a.statusText)}var _de=e=>({method:e.method,headers:e.headers,body:e.body,mode:e.mode,credentials:e.credentials,cache:e.cache,redirect:e.redirect,referrer:e.referrer,integrity:e.integrity});function CO(e){return typeof e=="string"&&e.slice(0,7)==="file://"}var SO=class extends vO{constructor(e,t={}){super(),this.input=e,this.options=t}async iterator(){if(CO(this.input)&&ge().get("IS_NODE")){let e=BS();this.input=e.readFileSync(this.input.slice(7))}return new kO(this.input,this.options)}},NO=class extends vO{constructor(e,t={}){super(),this.url=e,this.fileOptions=t}async iterator(){return CO(this.url)?new SO(this.url,this.fileOptions).iterator():Rde(this.url,this.fileOptions)}};function Dde(e,t={}){return new yO(new NO(e),t)}function Fde(e){let t=qT(e);return ya(async()=>t)}function Mde(e){return ya(async()=>{let t=await e();return qT(()=>t.next())})}async function Ode(e,t){return Sde.create(e,t)}async function Lde(e){return Cde.create(e)}var Pde="4.22.0";function mt(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&$.assert(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}var Bde=Lo.whereImpl,XT=class TO extends Vy{nextDataId(){return TO.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new uw(this,ai())}write(t,n,r){this.firstUse&&(this.firstUse=!1,ge().get("IS_NODE")&&P.warn(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));let s={id:this.nextDataId()};return this.data.set(s,{values:t,dtype:r,refCount:1}),s}makeTensorInfo(t,n,r){let s;if(n==="string"&&r!=null&&r.length>0&&$.isString(r[0])){let a=r.map(i=>$.encodeString(i));s=this.write(a,t,n)}else s=this.write(r,t,n);return{dataId:s,shape:t,dtype:n}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){let n=this.data.get(t);n.refCount++}decRef(t){if(this.data.has(t)){let n=this.data.get(t);n.refCount--}}move(t,n,r,s,a){this.data.set(t,{values:n,dtype:s,refCount:a})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){let{dtype:n,complexTensorInfos:r}=this.data.get(t);if(n==="complex64"){let s=this.readSync(r.real.dataId),a=this.readSync(r.imag.dataId);return P.mergeRealAndImagArrays(s,a)}return $.convertBackendValuesAndArrayBuffer(this.data.get(t).values,n)}bufferSync(t){let n=this.readSync(t.dataId);if(t.dtype==="string")try{let r=n.map(s=>$.decodeString(s));return Ht(t.shape,t.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Ht(t.shape,t.dtype,n)}makeOutput(t,n,r){return ai().makeTensorFromTensorInfo(this.makeTensorInfo(n,r,t),this)}disposeData(t,n=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!n&&this.data.get(t).refCount>0)return!1;let{complexTensorInfos:r}=this.data.get(t);r!=null&&(this.disposeData(r.real.dataId,!0),this.disposeData(r.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){let n=$.now();return t(),{kernelMs:$.now()-n}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){mt([t],"where");let n=this.readSync(t.dataId);return Bde(t.shape,n)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}};XT.nextDataId=0;var QT={};Pt(QT,{addImpl:()=>$O,bincountImpl:()=>JT,bincountReduceImpl:()=>RO,bitwiseAndImpl:()=>_O,castImpl:()=>AO,ceilImpl:()=>DO,concatImpl:()=>ZT,equalImpl:()=>FO,expImpl:()=>OO,expm1Impl:()=>PO,floorDivImpl:()=>zO,floorImpl:()=>BO,gatherNdImpl:()=>WO,gatherV2Impl:()=>VO,greaterEqualImpl:()=>GO,greaterImpl:()=>UO,lessEqualImpl:()=>jO,lessImpl:()=>HO,linSpaceImpl:()=>qO,logImpl:()=>KO,maxImpl:()=>XO,maximumImpl:()=>QO,minimumImpl:()=>YO,multiplyImpl:()=>e4,negImpl:()=>JO,notEqualImpl:()=>ZO,prodImpl:()=>e9,raggedGatherImpl:()=>t9,raggedRangeImpl:()=>n9,raggedTensorToTensorImpl:()=>r9,rangeImpl:()=>n4,rsqrtImpl:()=>s9,scatterImpl:()=>Sc,sigmoidImpl:()=>Phe,simpleAbsImpl:()=>EO,sliceImpl:()=>Cx,sparseFillEmptyRowsImpl:()=>i9,sparseReshapeImpl:()=>o9,sparseSegmentReductionImpl:()=>r4,sqrtImpl:()=>Whe,squaredDifferenceImpl:()=>l9,staticRegexReplaceImpl:()=>u9,stridedSliceImpl:()=>c9,stringNGramsImpl:()=>s4,stringSplitImpl:()=>a4,stringToHashBucketFastImpl:()=>i4,subImpl:()=>d9,tileImpl:()=>h9,topKImpl:()=>f9,transposeImpl:()=>t4,uniqueImpl:()=>l4});function EO(e){let t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}var zde=e=>{let{x:t}=e.inputs,n=e.backend;mt(t,"abs");let r=new Float32Array($.sizeFromShape(t.shape)),s=n.data.get(t.dataId).values;return r=EO(s),n.makeOutput(r,t.shape,t.dtype)},Wde={kernelName:pf,backendName:"cpu",kernelFunc:zde};function Cr(e){return(t,n,r,s,a)=>{let i=P.assertAndGetBroadcastShape(t,n),o=i.length,u=$.computeStrides(i),c=$.sizeFromShape(i),l=$.getTypedArrayFromDType(a,c),d=t.length,h=n.length,p=$.computeStrides(t),f=$.computeStrides(n),m=P.getBroadcastDims(t,i),g=P.getBroadcastDims(n,i);if(m.length+g.length===0)for(let b=0;b<l.length;++b)l[b]=e(r[b%r.length],s[b%s.length]);else for(let b=0;b<l.length;++b){let y=$.indexToLoc(b,o,u),x=y.slice(-d);m.forEach(N=>x[N]=0);let w=$.locToIndex(x,d,p),v=y.slice(-h);g.forEach(N=>v[N]=0);let I=$.locToIndex(v,h,f);l[b]=e(r[w],s[I])}return[l,i]}}function wa(e){let{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,o=n.makeTensorInfo(r.shape,"complex64"),u=n.data.get(o.dataId);return u.complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",a),imag:n.makeTensorInfo(s.shape,"float32",i)},o}var Vde={kernelName:hw,backendName:"cpu",kernelFunc:wa};function kx(e,t,n="float32"){if(n==="complex64"){let s=kx(e,t,"float32"),a=kx(e,t,"float32");return wa({inputs:{real:s,imag:a},backend:e})}let r=$.makeZerosTypedArray($.sizeFromShape(t),n);return e.makeTensorInfo(t,n,r)}function Ao(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var Ude={kernelName:qd,backendName:"cpu",kernelFunc:Ao};function Xc(e){let{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.real,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}var Gde={kernelName:Cw,backendName:"cpu",kernelFunc:Xc};function AO(e,t,n,r){if(r==="int32"){let s=Int32Array.from(e);return[t,"int32",s]}if(r==="bool"){let s=$.toTypedArray([0],n),[a,i]=Cr((o,u)=>o!==u?1:0)(t,[],e,s,"bool");return[i,"bool",a]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}function ou(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dtype:a}=r;if(a==="complex64"){if(s.dtype==="complex64")return Ao({inputs:{x:s},backend:n});let l=kx(n,s.shape,s.dtype),d=ou({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),h=wa({inputs:{real:d,imag:l},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(d),h}if(s.dtype==="complex64"){let l=Xc({inputs:{input:s},backend:n}),d=ou({inputs:{x:l},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(l),d}if(!$.hasEncodingLoss(s.dtype,a)){let l=Ao({inputs:{x:s},backend:n});return{dataId:l.dataId,shape:l.shape,dtype:a}}let i=n.data.get(s.dataId).values,[o,u,c]=AO(i,s.shape,s.dtype,a);return n.makeTensorInfo(o,u,c)}var Hde={kernelName:Ed,backendName:"cpu",kernelFunc:ou};function Qr(e,t,n,r){return n==null?({inputs:s,backend:a})=>{let{a:i,b:o}=s,u=a;mt([i,o],e);let c=u.data.get(i.dataId).values,l=u.data.get(o.dataId).values,d=i.dtype==="string"?P.fromUint8ToStringArray(c):c,h=i.dtype==="string"?P.fromUint8ToStringArray(l):l,p=r||i.dtype,[f,m]=t(i.shape,o.shape,d,h,p);return u.makeTensorInfo(m,p,f)}:({inputs:s,backend:a})=>{let{a:i,b:o}=s,u=a;if(i.dtype==="complex64"||o.dtype==="complex64"){let c=ou({inputs:{x:i},backend:u,attrs:{dtype:"complex64"}}),l=u.data.get(c.dataId),d=l.complexTensorInfos.real,h=l.complexTensorInfos.imag,p=u.data.get(d.dataId).values,f=u.data.get(h.dataId).values,m=ou({inputs:{x:o},backend:u,attrs:{dtype:"complex64"}}),g=u.data.get(m.dataId),b=g.complexTensorInfos.real,y=g.complexTensorInfos.imag,x=u.data.get(b.dataId).values,w=u.data.get(y.dataId).values,[v,I,N]=n(i.shape,o.shape,p,f,x,w),T=u.makeTensorInfo(N,"float32",v),E=u.makeTensorInfo(N,"float32",I),A=wa({inputs:{real:T,imag:E},backend:u});return u.disposeIntermediateTensorInfo(c),u.disposeIntermediateTensorInfo(m),u.disposeIntermediateTensorInfo(T),u.disposeIntermediateTensorInfo(E),A}else{let c=u.data.get(i.dataId).values,l=u.data.get(o.dataId).values,d=r||i.dtype,[h,p]=t(i.shape,o.shape,c,l,d);return u.makeTensorInfo(p,d,h)}}}function YT(e){return(t,n,r,s,a,i)=>{let o=P.assertAndGetBroadcastShape(t,n),u=$.sizeFromShape(o),c=o.length,l=$.computeStrides(o),d=$.getTypedArrayFromDType("float32",u),h=$.getTypedArrayFromDType("float32",u),p=P.getBroadcastDims(t,o),f=P.getBroadcastDims(n,o),m=P.mergeRealAndImagArrays(r,s),g=P.mergeRealAndImagArrays(a,i),b=t.length,y=$.computeStrides(t),x=n.length,w=$.computeStrides(n);if(p.length+f.length===0)for(let v=0;v<d.length;v++){let I=v%m.length,N=v%g.length,T=e(m[I*2],m[I*2+1],g[N*2],g[N*2+1]);d[v]=T.real,h[v]=T.imag}else for(let v=0;v<d.length;v++){let I=$.indexToLoc(v,c,l),N=I.slice(-b);p.forEach(C=>N[C]=0);let T=$.locToIndex(N,b,y),E=I.slice(-x);f.forEach(C=>E[C]=0);let A=$.locToIndex(E,x,w),k=e(m[T*2],m[T*2+1],g[A*2],g[A*2+1]);d[v]=k.real,h[v]=k.imag}return[d,h,o]}}var $O=Cr((e,t)=>e+t),jde=YT((e,t,n,r)=>({real:e+n,imag:t+r})),qp=Qr(yu,$O,jde),qde={kernelName:yu,backendName:"cpu",kernelFunc:qp};function JT(e,t,n,r,s){let a=$.sizeFromShape(r),i=$.makeZerosTypedArray(s,n);for(let o=0;o<e.length;o++){let u=e[o];if(u<0)throw new Error("Input x must be non-negative!");u>=s||(a>0?i[u]+=t[o]:i[u]+=1)}return i}function RO(e,t,n,r=!1){let s=e.shape[0],a=e.shape[1],i=Ht([s,n],t.dtype);for(let o=0;o<s;o++)for(let u=0;u<a;u++){let c=e.get(o,u);if(c<0)throw new Error("Input x must be non-negative!");c>=n||(r?i.set(1,o,c):t.size>0?i.set(i.get(o,c)+t.get(o,u),o,c):i.set(i.get(o,c)+1,o,c))}return i}var _O=Cr((e,t)=>e&t),Kde=Qr(vf,_O),Xde={kernelName:vf,backendName:"cpu",kernelFunc:Kde};function Po(e){return(t,n,r)=>{let s=$.getArrayFromDType(n,t.length);for(let a=0;a<t.length;++a)s[a]=e(t[a],r);return s}}function Dn(e,t,n){let r=Po(t);return Tu(e,r,n)}function Tu(e,t,n){return({inputs:r,attrs:s,backend:a})=>{let{x:i}=r;mt(i,e);let o=a,u=o.data.get(i.dataId).values,c;if(i.dtype==="string"){if(!Array.isArray(u))throw new Error("String tensor's value was not an instance of Array");c=P.fromUint8ToStringArray(u)}else c=u;let l=n||i.dtype,d=t(c,l,s);return o.makeTensorInfo(i.shape,l,d)}}var DO=Po(e=>Math.ceil(e)),Qde=Tu(Ad,DO),Yde={kernelName:Ad,backendName:"cpu",kernelFunc:Qde};function ZT(e,t,n,r){let s=$.getArrayFromDType(n,$.sizeFromShape(t));if(r&&n!=="string"){let a=0;e.forEach(i=>{let o=$.sizeFromShape(i.shape);s.set(i.vals,a),a+=o})}else{let a=0;e.forEach(i=>{let o=n==="string"?P.fromUint8ToStringArray(i.vals):i.vals,u=0;for(let c=0;c<i.shape[0];++c){let l=c*t[1]+a;for(let d=0;d<i.shape[1];++d)s[l+d]=o[u++]}a+=i.shape[1]})}return s}var FO=Cr((e,t)=>e===t?1:0),MO=Qr(Af,FO,null,"bool"),Jde={kernelName:Af,backendName:"cpu",kernelFunc:MO},OO=Po(e=>Math.exp(e)),LO=Tu(Wd,OO,"float32"),Zde={kernelName:Wd,backendName:"cpu",kernelFunc:LO},PO=Po(e=>Math.expm1(e)),ehe=Tu(Vd,PO),the={kernelName:Vd,backendName:"cpu",kernelFunc:ehe},BO=Po(e=>Math.floor(e)),nhe=Tu(Ud,BO),rhe={kernelName:Ud,backendName:"cpu",kernelFunc:nhe},zO=Cr((e,t)=>Math.floor(e/t)),she=Qr(Gd,zO,null,"int32"),ahe={kernelName:Gd,backendName:"cpu",kernelFunc:she};function WO(e,t,n,r,s,a,i,o,u){let c=Ht([r,a],n);for(let l=0;l<r;l++){let d=[],h=0;for(let p=0;p<s;p++){let f=e[l*s+p];h+=f*i[p],d.push(f)}if(h<0||h>=u/a)throw new Error(`Invalid indices: ${d} does not index into ${o}`);for(let p=0;p<a;p++)c.values[l*a+p]=t.get(...t.indexToLoc(h*a+p))}return c}function VO(e,t,n){let r=Ht(n,e.dtype);for(let s=0;s<r.size;++s){let a=r.indexToLoc(s).slice(),i=a[0],o=a[2],u=t.locToIndex([i,o]);a[2]=t.values[u];let c=e.locToIndex(a);0<=c&&c<e.values.length&&(r.values[s]=e.values[c])}return r}var UO=Cr((e,t)=>e>t?1:0),ihe=Qr(Ff,UO,null,"bool"),ohe={kernelName:Ff,backendName:"cpu",kernelFunc:ihe},GO=Cr((e,t)=>e>=t?1:0),lhe=Qr(jd,GO,null,"bool"),uhe={kernelName:jd,backendName:"cpu",kernelFunc:lhe},HO=Cr((e,t)=>e<t?1:0),che=Qr(Mf,HO,null,"bool"),dhe={kernelName:Mf,backendName:"cpu",kernelFunc:che},jO=Cr((e,t)=>e<=t?1:0),hhe=Qr(Of,jO,null,"bool"),phe={kernelName:Of,backendName:"cpu",kernelFunc:hhe};function qO(e,t,n){let r=(t-e)/(n-1),s=$.makeZerosTypedArray(n,"float32");s[0]=e;for(let a=1;a<s.length;a++)s[a]=s[a-1]+r;return s}var KO=Po(e=>Math.log(e)),fhe=Tu(Jd,KO),mhe={kernelName:Jd,backendName:"cpu",kernelFunc:fhe};function XO(e,t,n,r){let s=$.getTypedArrayFromDType(r,$.sizeFromShape(n));for(let a=0;a<s.length;++a){let i=a*t,o=e[i];for(let u=0;u<t;++u){let c=e[i+u];(Number.isNaN(c)||c>o)&&(o=c)}s[a]=o}return s}var QO=Cr((e,t)=>Math.max(e,t)),ghe=Qr(nh,QO),bhe={kernelName:nh,backendName:"cpu",kernelFunc:ghe},YO=Cr((e,t)=>Math.min(e,t)),yhe=Qr(ih,YO),xhe={kernelName:ih,backendName:"cpu",kernelFunc:yhe},e4=Cr((e,t)=>e*t),whe=YT((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n})),$v=Qr(uh,e4,whe),vhe={kernelName:uh,backendName:"cpu",kernelFunc:$v};function JO(e,t,n){let r=$.createScalarValue(-1,n);return e4([],t,r,e,n)}function Ihe(e){let{inputs:t,backend:n}=e,{x:r}=t;mt(r,"neg");let s=n.data.get(r.dataId).values,[a,i]=JO(s,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,a)}var khe={kernelName:Gf,backendName:"cpu",kernelFunc:Ihe},ZO=Cr((e,t)=>e!==t?1:0),Che=Qr(Hf,ZO,null,"bool"),She={kernelName:Hf,backendName:"cpu",kernelFunc:Che};function t4(e,t,n,r,s){let a=t.length,i=$.sizeFromShape(t),o=$.computeStrides(t),u=$.computeStrides(s),c=$.getTypedArrayFromDType(n,$.sizeFromShape(s));for(let l=0;l<i;++l){let d=$.indexToLoc(l,a,o),h=new Array(d.length);for(let f=0;f<h.length;f++)h[f]=d[r[f]];let p=$.locToIndex(h,a,u);c[p]=e[l]}return c}function ca(e){let{inputs:t,attrs:n,backend:r}=e,{x:s}=t,{perm:a}=n;mt(s,"transpose");let i=s.shape.length,o=new Array(i);for(let l=0;l<o.length;l++)o[l]=s.shape[a[l]];let u=r.data.get(s.dataId).values,c=t4(u,s.shape,s.dtype,a,o);return{dataId:r.write(c,o,s.dtype),shape:o,dtype:s.dtype}}var Nhe={kernelName:nl,backendName:"cpu",kernelFunc:ca};function e9(e,t,n,r){let[s,a]=P.computeOutAndReduceShapes(e,r),i=Ha(t,"int32"),o=$.makeZerosTypedArray($.sizeFromShape(s),i),u=$.sizeFromShape(a);for(let c=0;c<o.length;++c){let l=c*u,d=1;for(let h=0;h<u;++h)d*=n[l+h];o[c]=d}return{outVals:o,outShape:s,outDtype:i}}function The(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;mt(s,"prod");let o=s.shape.length,u=$.parseAxisParam(a,s.shape),c=P.getAxesPermutation(u,o),l=u,d=s,h=[];c!=null&&(d=ca({inputs:{x:s},backend:n,attrs:{perm:c}}),h.push(d),l=P.getInnerMostAxes(l.length,o));let p=n.data.get(d.dataId).values,{outVals:f,outShape:m,outDtype:g}=e9(d.shape,d.dtype,p,l),b=m;return i&&(b=P.expandShapeToKeepDim(m,u)),h.forEach(y=>n.disposeIntermediateTensorInfo(y)),n.makeTensorInfo(b,g,f)}var Ehe={kernelName:fh,backendName:"cpu",kernelFunc:The};function Ahe(e,t,n){e.forEach((r,s)=>{if(r<0||r>=n){let a=$.indexToLoc(s,t.length,$.computeStrides(t)).join(",");throw new Error(`indices[${a}] = ${r} is not in [0, ${n})`)}})}function $he(e,t){for(let n=0;n<e.length;++n){let r=e[n],s=n===e.length-1?t:e[n+1].length;if(r.length===0)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let a=1;a<r.length;++a)if(r[a-1]>r[a])throw new Error("Ragged splits must be sorted in ascending order")}}function Rhe(e,t,n,r){let s=[],a=0,i=t.length-1+n.length,o=new Array(i).fill(null).map(()=>[0]);$he(n,r);let u=1;for(let c=0;c<t.length-1;++c){u*=t[c];let l=t[c+1];for(let d=1;d<u+1;++d)o[c].push(d*l)}for(let c=0;c<e.length;++c){let l=e[c],d=e[c]+1;for(let h=0;h<n.length;++h){let p=n[h],f=h+t.length-1;if(f>=0){let m=o[f],g=m[m.length-1]-p[l];for(let b=l;b<d;++b)o[f].push(p[b+1]+g)}l=p[l],d=p[d]}d!==l&&(s.push([l,d]),a+=d-l)}return{outSplits:o,valueSlices:s,numValues:a}}function _he(e){let t=[];for(let n=0;n<e.length;++n){let r=e[n].length,s=$.getArrayFromDType("int32",r);t.push(s),e[n].forEach((a,i)=>s[i]=a)}return t}function QR(e,t){let n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function Dhe(e,t,n,r,s,a){let i=QR(t,2)[1],o=QR(a,2)[1],u=0;for(let c of n)for(let l=c[0];l<c[1];++l){for(let d=0;d<r;++d)s[u*o+d]=e[l*i+d];++u}}function Fhe(e,t,n,r,s){let a=t.slice();a[0]=s;let i=$.getArrayFromDType(n,$.sizeFromShape(a)),o=e.length,u=o===0?0:o/t[0];return Dhe(e,t,r,u,i,a),[i,a]}function t9(e,t,n,r,s,a,i,o){if(e.length===0)throw new Error("paramsNestedSplits must be non empty");if(t[0].length===0)throw new Error("Split tensors must not be scalars");let u=t[0][0]-1;if(Ahe(a,i,u),r.length===0)throw new Error("params.rank must be nonzero");let c=r[0],{outSplits:l,valueSlices:d,numValues:h}=Rhe(a,i,e,c),p=_he(l),f=Fhe(n,r,s,d,h);return[p,f[0],f[1]]}var YR=2147483647;function n9(e,t,n,r,s,a,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(s.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");let o=t.length===0,u=s.length===0,c=i.length===0,l=[];o||l.push(t[0]),u||l.push(s[0]),c||l.push(i[0]);for(let g=1;g<l.length;++g)if(l[g]!==l[g-1])throw new Error("starts, limits, and deltas must have the same shape");let d=l.length===0?1:l[0],h=$.getArrayFromDType("int32",d+1);h[0]=0;for(let g=0;g<d;++g){let b=o?e[0]:e[g],y=u?r[0]:r[g],x=c?a[0]:a[g];if(x===0)throw new Error("Requires delta != 0");let w;if(x>0&&y<b||x<0&&y>b)w=0;else if(w=Math.ceil(Math.abs((y-b)/x)),w>YR)throw new Error(`Requires ((limit - start) / delta) <= ${YR}`);h[g+1]=h[g]+w}let p=h[d],f=$.getArrayFromDType(n,p),m=0;for(let g=0;g<d;++g){let b=h[g+1]-h[g],y=o?e[0]:e[g],x=c?a[0]:a[g];for(let w=0;w<b;++w)f[m++]=y,y+=x}return[h,f]}var ti=P.RowPartitionType,Mhe=class _C{constructor(t,n,r,s,a,i,o,u,c,l){this.shape=t,this.shapeShape=n,this.values=r,this.valuesShape=s,this.valuesDType=a,this.defaultValue=i,this.defaultValueShape=o,this.rowPartitionValues=u,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=P.getRowPartitionTypesHelper(l),this.raggedRank=P.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===ti.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===ti.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){let n=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case ti.VALUE_ROWIDS:return _C.getMaxWidthValueRowID(n);case ti.ROW_SPLITS:return _C.getMaxWidthRowSplit(n);default:throw new Error(`Cannot handle partition type ${ti[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){let n=t.length;if(n===0||n===1)return 0;let r=0;for(let s=0;s<n-1;++s){let a=t[s+1]-t[s];a>r&&(r=a)}return r}static getMaxWidthValueRowID(t){let n=t.length;if(n===0)return 0;let r=0,s=t[0],a=0;for(let i=1;i<n;++i){let o=t[i];o!==s&&(s=o,a=Math.max(i-r,a),r=i)}return Math.max(n-r,a)}tensorShapeFromTensor(t,n,r=!0){if(n.length===0){if(t[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return ZR(t,r)}calculateOutputSize(t){let n=this.valuesShape,r=this.defaultValueShape;P.validateDefaultValueShape(r,n);let s=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=P.combineRaggedTensorToTensorShapes(this.raggedRank,s,n);a[0]<0&&(a[0]=t);for(let i=1;i<=this.raggedRank;++i)a[i]<0&&(a[i]=this.getMaxWidth(i));return a}calculateFirstParentOutputIndex(t,n,r){let s=Math.min(t,r),a=[],i=0;for(let o=0;o<s;++o,i+=n)a.push(i);for(let o=s;o<t;++o)a.push(-1);return $.assert(a.length===t,()=>"Final length of result must be equal to firstDimension."),a}calculateOutputIndexRowSplit(t,n,r,s){let a=t.length,i=[];for(let o=0;o<a-1;++o){let u=t[o+1]-t[o],c=Math.min(s,u),l=n[o];l===-1&&(c=0);for(let d=0;d<c;++d)i.push(l),l+=r;for(let d=0;d<u-c;++d)i.push(-1)}if(a>0&&i.length!==t[a-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(t,n,r,s){let a=t.length,i=[];if(a===0)return[];let o=0,u=t[0];if(u>=n.length)throw new Error(`Got currentValueRowId=${u}, which is not less than ${n.length}`);let c=n[u];i.push(c);for(let l=1;l<a;++l){let d=t[l];if(d===u)c>=0&&(++o,o<s?c+=r:c=-1);else{if(o=0,u=d,d>=n.length)throw new Error(`Got nextValueRowId=${d} which is not less than ${n.length}`);c=n[d]}i.push(c)}if(i.length!==t.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(t,n,r,s){let a=this.getRowPartitionTensor(t),i=this.getRowPartitionTypeByDimension(t);switch(i){case ti.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(a,n,r,s);case ti.ROW_SPLITS:if(a.length-1>n.length)throw new Error(`Row partition size is greater than output size: ${a.length-1} > ${n.length}`);return this.calculateOutputIndexRowSplit(a,n,r,s);default:throw new Error(`Unsupported partition type: ${ti[i]}`)}}getFirstDimensionSize(){let t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");let n=this.rowPartitionTypes[0];switch(n){case ti.FIRST_DIM_SIZE:return t[0];case ti.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case ti.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${ti[n]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");let t=this.getFirstDimensionSize(),n=this.calculateOutputSize(t),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let i=r.length-2;i>=0;--i)r[i]=r[i+1]*n[i+1];let s=ZR(n,!1),a=$.getArrayFromDType(this.valuesDType,$.sizeFromShape(s));if(r[0]*n[0]>0){let i=this.calculateFirstParentOutputIndex(t,r[0],n[0]);for(let o=1;o<=this.raggedRank;++o)i=this.calculateOutputIndex(o-1,i,r[o],n[o]);this.setOutput(this.raggedRank,i,a,s)}return[s,a]}setOutput(t,n,r,s){if(r.length===0)return;let a=this.values,i=r,o=s.slice();o=o.slice(t+1);let u=$.sizeFromShape(o),c=n.length,l=this.defaultValue;if(l.length!==u&&l.length!==1){let f=this.defaultValueShape;ie(()=>{let m=ae(l,f);l=Ec(m,o).dataSync()})}let d=0,h=0,p=0;for(let f=0;f<=c;++f){let m=f<c?n[f]:-1;if(m===p){++p;continue}if(h<p){let g=a.subarray(d*u),b=i.subarray(h*u),y=(p-h)*u;JR(b,g,y)}if(f>=c){let g=r.length;m=Math.floor(g/u)}if(m>p)if(this.defaultValue.length===1)i.subarray(p*u,m*u).fill(this.defaultValue[0]),p=m;else for(;m>p;){let g=i.slice(p*u);JR(g,l,u),++p}m<0?(d=f+1,h=p):(d=f,h=p,p=h+1)}}};function JR(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function ZR(e,t){let n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function r9(e,t,n,r,s,a,i,o,u,c){return new Mhe(e,t,n,r,s,a,i,o,u,c).compute()}function n4(e,t,n,r){let s=e===t,a=e<t&&n<0,i=t<e&&n>1;if(s||a||i)return $.makeZerosTypedArray(0,r);let o=Math.abs(Math.ceil((t-e)/n)),u=$.makeZerosTypedArray(o,r);t<e&&n===1&&(n=-1),u[0]=e;for(let c=1;c<u.length;c++)u[c]=u[c-1]+n;return u}var s9=Po(e=>1/Math.sqrt(e)),Ohe=Tu(Ih,s9),Lhe={kernelName:Ih,backendName:"cpu",kernelFunc:Ohe};function Sc(e,t,n,r,s,a,i,o,u,c){let l=[r/s,s],d=e.values,h=t.values;if(r===0)return Ht(n,t.dtype);let p=u instanceof _r?u:Ht(l,t.dtype);typeof u=="string"||typeof u=="number"?p.values.fill(u):typeof u=="boolean"&&p.values.fill(+u);for(let f=0;f<a;f++){let m=[],g=0;for(let b=0;b<i;b++){let y=d[f*i+b];m.push(y),g+=y*o[b]}if(g<0||g>=r/s)throw new Error(`Invalid indices: ${m} does not index into ${n}`);for(let b=0;b<s;b++)c?p.values[g*s+b]+=h[f*s+b]:p.values[g*s+b]=t.rank===0?h[0]:h[f*s+b]}return p}var Phe=Po(e=>1/(1+Math.exp(-e))),a9=Dn(Th,e=>1/(1+Math.exp(-e))),Bhe={kernelName:Th,backendName:"cpu",kernelFunc:a9};function Cx(e,t,n,r,s){let a=Gr.isSliceContinous(r,t,n),i=$.sizeFromShape(n),o=$.computeStrides(r);if(a){let d=Gr.computeFlatOffset(t,o);return s==="string"?e.slice(d,d+i):e.subarray(d,d+i)}let u=s==="string"?P.fromUint8ToStringArray(e):e,c=Ht(r,s,u),l=Ht(n,s);for(let d=0;d<l.size;++d){let h=l.indexToLoc(d),p=h.map((f,m)=>f+t[m]);l.set(c.get(...p),...h)}return s==="string"?P.fromStringArrayToUint8(l.values):l.values}function Qc(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,size:i}=r;mt(s,"slice");let[o,u]=Gr.parseSliceParams(s,a,i);Gr.assertParamsValid(s,o,u);let c=n.data.get(s.dataId).values,l=Cx(c,o,u,s.shape,s.dtype);return n.makeTensorInfo(u,s.dtype,l)}var zhe={kernelName:sm,backendName:"cpu",kernelFunc:Qc};function i9(e,t,n,r,s,a,i){let o=t[0],u=a[0],c=new Array(u),l=new Array(o),d=t[1];if(u===0){if(o!==0)throw new Error(P.getSparseFillEmptyRowsIndicesDenseShapeMismatch(o));let g=$.getArrayFromDType(n,0),b=$.getArrayFromDType(s,0);return[g,[0,d],b,c,l]}let h=!0,p=0,f=new Array(u).fill(0);for(let g=0;g<o;++g){let b=e[g*d];if(b<0)throw new Error(P.getSparseFillEmptyRowsNegativeIndexErrorMessage(g,b));if(b>=u)throw new Error(P.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(g,b,u));++f[b],h=h&&b>=p,p=b}let m=!0;for(let g=0;g<u;++g){let b=f[g]===0;c[g]=b,m=m&&!b,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&h){let g=e,b=r;for(let y=0;y<o;++y)l[y]=y;return[g,[o,d],b,c,l]}else{let g=f[u-1],b=$.getArrayFromDType(n,g*d),y=$.getArrayFromDType(s,g),x=new Array(u).fill(0);for(let w=0;w<o;++w){let v=e[w*d],I=x[v],N=(v===0?0:f[v-1])+I;x[v]++;for(let T=0;T<d;++T)b[N*d+T]=e[w*d+T];y[N]=r[w],l[w]=N}for(let w=0;w<u;++w)if(x[w]===0){let v=w===0?0:f[w-1];b[v*d+0]=w;for(let I=1;I<d;++I)b[v*d+I]=0;y[v]=i}return[b,[g,d],y,c,l]}}function o9(e,t,n,r,s){let a=$.sizeFromShape(r),i=t[0],o=s.length,u=[],c=1,l=-1;for(let m=0;m<o;++m){let g=s[m];if(g===-1){if(l!==-1)throw new Error(P.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(l,m));l=m,u.push(1)}else{if(g<0)throw new Error(P.getSparseReshapeNegativeOutputDimErrorMessage(m,g));c*=g,u.push(g)}}if(l!==-1){if(c<=0)throw new Error(P.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let m=Math.trunc(a/c);if(c*m!==a)throw new Error(P.getSparseReshapeInputOutputMultipleErrorMessage(r,u));u[l]=m}if($.sizeFromShape(u)!==a)throw new Error(P.getSparseReshapeInputOutputMismatchErrorMessage(r,u));let d=r.length,h=[];if(d>0){h[d-1]=1;for(let m=d-2;m>=0;--m)h[m]=h[m+1]*r[m+1]}let p=[];if(o>0){p[o-1]=1;for(let m=o-2;m>=0;--m)p[m]=p[m+1]*u[m+1]}let f=$.getArrayFromDType(n,i*o);for(let m=0;m<i;++m){let g=0;for(let b=0;b<d;++b)g+=e[m*d+b]*h[b];for(let b=0;b<o;++b)f[m*o+b]=Math.trunc(g/p[b]),g%=p[b]}return[f,[i,o],u]}function r4(e,t,n,r,s,a=!1,i=0){let o=r.length,u=[t[0],e.length/t[0]],c=u[1],l=o>0?s[o-1]+1:0;if(l<0)throw new Error(P.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let d=t.slice();d[0]=l;let h=d.reduce((y,x)=>y*x,1),p=$.getArrayFromDType(n,h);if(o===0)return l>0&&p.fill(i),[p,d];if(l<=0)throw new Error(P.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let f=0,m=1,g=0,b=s[f];for(;;){let y=0;if(m<o){if(y=s[m],b===y){++m;continue}if(b>=y)throw new Error(P.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(b<0||b>=l)throw new Error(P.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(b,l));b>g&&p.fill(i,g*c,b*c);for(let x=f;x<m;++x){let w=r[x];if(w<0||w>=u[0])throw new Error(P.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(x,r[x],u[0]));for(let v=0;v<c;v++)p[b*c+v]+=e[w*c+v]}if(a)for(let x=0;x<c;x++)p[b*c+x]/=m-f;if(f=m,++m,g=b+1,b=y,m>o)break}return g<l&&p.fill(i,g*c,l*c),[p,d]}var Whe=Po(e=>Math.sqrt(e)),Vhe=Dn(Ah,e=>Math.sqrt(e)),Uhe={kernelName:Ah,backendName:"cpu",kernelFunc:Vhe},l9=Cr((e,t)=>{let n=e-t;return n*n}),Ghe=Qr(_h,l9),Hhe={kernelName:_h,backendName:"cpu",kernelFunc:Ghe},u9=Po((e,t)=>{let{pattern:n,replaceGlobal:r,rewrite:s}=t;return e.replace(new RegExp(n,r?"g":""),s)}),jhe=Tu(a0,u9),qhe={kernelName:a0,backendName:"cpu",kernelFunc:jhe};function c9(e,t,n,r){let s=Ht(e,t.dtype);for(let a=0;a<s.size;a++){let i=s.indexToLoc(a),o=new Array(i.length);for(let u=0;u<o.length;u++)o[u]=i[u]*n[u]+r[u];s.set(t.get(...o),...i)}return s}var Khe=class{constructor(e,t,n,r,s,a){this.separator=$.encodeString(e),this.nGramWidths=t,this.leftPad=$.encodeString(n),this.rightPad=$.encodeString(r),this.padWidth=s,this.preserveShort=a}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){let n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,s,a){for(let i=0;i<s;++i){let o=this.getPadWidth(a),u=Math.max(0,o-i),c=Math.max(0,o-(s-(i+1))),l=a-(u+c),d=t+(u>0?0:i-o),h=0;h+=u*this.leftPad.length;for(let b=0;b<l;++b)h+=e[d+b].length;h+=c*this.rightPad.length;let p=u+c+l-1;h+=p*this.separator.length,n[r+i]=new Uint8Array(h);let f=n[r+i],m=0,g=b=>b.forEach(y=>f[m++]=y);for(let b=0;b<u;++b)g(this.leftPad),g(this.separator);for(let b=0;b<l-1;++b)g(e[d+b]),g(this.separator);if(l>0){g(e[d+l-1]);for(let b=0;b<c;++b)g(this.separator),g(this.rightPad)}else{for(let b=0;b<c-1;++b)g(this.rightPad),g(this.separator);g(this.rightPad)}}}compute(e,t){let n=e.length,r=t.length;if(r>0){let o=t[0];if(o!==0)throw new Error(`First split value must be 0, got ${o}`);for(let u=1;u<r;++u){let c=t[u]>=o;if(c=c&&t[u]<=n,!c)throw new Error(`Invalid split value ${t[u]}, must be in [${o}, ${n}]`);o=t[u]}if(o!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${o}`)}let s=r-1,a=$.getArrayFromDType("int32",r);if(n===0||r===0){let o=new Array(n);for(let u=0;u<=s;++u)a[u]=0;return[o,a]}a[0]=0;for(let o=1;o<=s;++o){let u=t[o]-t[o-1],c=0;this.nGramWidths.forEach(l=>{c+=this.getNumNGrams(u,l)}),this.preserveShort&&u>0&&c===0&&(c=1),a[o]=a[o-1]+c}let i=new Array(a[s]);for(let o=0;o<s;++o){let u=t[o],c=a[o];if(this.nGramWidths.forEach(l=>{let d=t[o+1]-t[o],h=this.getNumNGrams(d,l);this.createNGrams(e,u,i,c,h,l),c+=h}),this.preserveShort&&c===a[o]){let l=t[o+1]-t[o];if(l===0)continue;let d=l+2*this.padWidth;this.createNGrams(e,u,i,c,1,d)}}return[i,a]}};function s4(e,t,n,r,s,a,i,o){return new Khe(n,r,s,a,i,o).compute(e,t)}function Xhe(e,t,n,r){if(!e.length)return;if(t.length===0){for(let a=0;a<e.length;++a)r.push(e.subarray(a,a+1));return}if(t.length===1){let a=t[0],i=e.indexOf(a);for(;i!==-1;){let o=e.subarray(0,i);(!n||o.length!==0)&&r.push(o),e=e.subarray(i+1),i=e.indexOf(a)}(!n||e.length!==0)&&r.push(e);return}let s=0;for(let a=0;a<e.length+1;a++)if(a===e.length||t.indexOf(e[a])!==-1){let i=e.subarray(s,a);(!n||i.length!==0)&&r.push(i),s=a+1}}function a4(e,t,n){let r=e.length,s=[],a=0,i=0,o=new Array(r);for(let h=0;h<r;++h){let p=s.length;Xhe(e[h],t,n,s);let f=s.length-p;o[h]=f,a+=f,i=Math.max(i,f)}let u=$.getArrayFromDType("int32",a*2),c=new Array(a),l=[r,i],d=0;for(let h=0;h<r;++h)for(let p=0;p<o[h];++p)u[d*2]=h,u[d*2+1]=p,c[d]=s[d],++d;return[u,c,l]}function i4(e,t){let n=$.getArrayFromDType("int32",e.length);for(let r=0;r<e.length;++r)n[r]=$.fingerPrint64(e[r]).modulo(t).getLowBitsUnsigned();return n}var d9=Cr((e,t)=>e-t),Qhe=YT((e,t,n,r)=>({real:e-n,imag:t-r})),o4=Qr(Dh,d9,Qhe),Yhe={kernelName:Dh,backendName:"cpu",kernelFunc:o4};function h9(e,t){let n=new Array(e.rank);for(let s=0;s<n.length;s++)n[s]=e.shape[s]*t[s];let r=Ht(n,e.dtype);for(let s=0;s<r.values.length;++s){let a=r.indexToLoc(s),i=new Array(e.rank);for(let u=0;u<i.length;u++)i[u]=a[u]%e.shape[u];let o=e.locToIndex(i);r.values[s]=e.values[o]}return r}var Pb=(e,t)=>{let n=t.value-e.value;return n===0?e.index-t.index:n};function p9(e,t,n=0,r=e.length-1){for(;r>n;){if(r-n>600){let o=r-n+1,u=t-n+1,c=Math.log(o),l=.5*Math.exp(2*c/3),d=.5*Math.sqrt(c*l*(o-l)/o)*Math.sign(u-o/2),h=Math.max(n,Math.floor(t-u*l/o+d)),p=Math.min(r,Math.floor(t+(o-u)*l/o+d));p9(e,t,h,p)}let s=e[t],a=n,i=r;for($.swap(e,n,t),Pb(e[r],s)>0&&$.swap(e,n,r);a<i;){for($.swap(e,a,i),a++,i--;Pb(e[a],s)<0;)a=a+1;for(;Pb(e[i],s)>0;)i=i-1}Pb(e[n],s)===0?$.swap(e,n,i):(i=i+1,$.swap(e,i,r)),i<=t&&(n=i+1),t<=i&&(r=i-1)}}function f9(e,t,n,r,s){let a=t[t.length-1],[i,o]=[e.length/a,a],u=$.getTypedArrayFromDType(n,i*r),c=$.getTypedArrayFromDType("int32",i*r);for(let d=0;d<i;d++){let h=d*o,p=e.subarray(h,h+o),f=new Array(p.length);p.forEach((y,x)=>f[x]={value:y,index:x}),r<f.length&&(p9(f,r),f=f.slice(0,r)),s&&f.sort(Pb);let m=d*r,g=u.subarray(m,m+r),b=c.subarray(m,m+r);for(let y=0;y<r;y++)g[y]=f[y].value,b[y]=f[y].index}let l=t.slice();return l[l.length-1]=r,[Ht(l,n,u),Ht(l,"int32",c)]}function l4(e,t,n,r){let s=$.parseAxisParam(t,n)[0],a=[1,n[0],1];for(let f=0;f<s;f++)a[0]*=n[f];a[1]=n[s];for(let f=s+1;f<n.length;f++)a[2]*=n[f];let i=new Map,o=new Int32Array(n[s]),u=new _r(a,r,e),c=[],l=a[0]===1&&a[2]===1;for(let f=0;f<n[s];f++){let m;if(l)m=e[f].toString();else{let b=[];for(let y=0;y<a[0];y++)for(let x=0;x<a[2];x++)b.push(u.get(y,f,x));m=b.join(",")}let g=i.get(m);if(g!=null)o[f]=g;else{let b=i.size;i.set(m,b),o[f]=b,c.push(f)}}let d=a.slice();d[1]=i.size;let h=new _r(d,r);c.forEach((f,m)=>{for(let g=0;g<a[0];g++)for(let b=0;b<a[2];b++)h.set(u.get(g,f,b),g,m,b)});let p=n.slice();return p[s]=d[1],{outputValues:h.values,outputShape:p,indices:o}}var Jhe="4.22.0";Tw("cpu",()=>new XT,1);var m9=Dn(Bd,e=>e>=0?e:Math.exp(e)-1),Zhe={kernelName:Bd,backendName:"cpu",kernelFunc:m9};function g9(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:a}=r;mt([s],"leakyRelu");let i=$.sizeFromShape(s.shape),o=n.data.get(s.dataId).values,u=$.getTypedArrayFromDType("float32",i);for(let c=0;c<o.length;c++)u[c]=o[c]<0?a*o[c]:o[c];return n.makeTensorInfo(s.shape,"float32",u)}var epe={kernelName:Yd,backendName:"cpu",kernelFunc:g9},tpe=Cr((e,t)=>e<0?t*e:e);function b9(e){let{inputs:t,backend:n}=e,{x:r,alpha:s}=t;mt([r,s],"prelu");let a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,[o,u]=tpe(r.shape,s.shape,a,i,"float32");return n.makeTensorInfo(u,"float32",o)}var npe={kernelName:ph,backendName:"cpu",kernelFunc:b9},y9=Dn(gh,e=>Math.max(0,e)),rpe={kernelName:gh,backendName:"cpu",kernelFunc:y9},x9=Dn(xh,e=>Math.min(Math.max(0,e),6)),spe={kernelName:xh,backendName:"cpu",kernelFunc:x9};function Sx(e,t,n,r,s){if(n==="linear")return Ao({inputs:{x:t},backend:e});if(n==="relu")return y9({inputs:{x:t},backend:e});if(n==="elu")return m9({inputs:{x:t},backend:e});if(n==="relu6")return x9({inputs:{x:t},backend:e});if(n==="prelu")return b9({inputs:{x:t,alpha:r},backend:e});if(n==="leakyrelu")return g9({inputs:{x:t},backend:e,attrs:{alpha:s}});if(n==="sigmoid")return a9({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function Zn(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:a}=r,i=$.sizeFromShape(s.shape),o=$.inferFromImplicitShape(a,i),u=$.sizeFromShape(o);$.assert(i===u,()=>`The new shape (${o}) has ${u} elements and the old shape (${s.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),n.incRef(s.dataId);let c=n.data.get(s.dataId);if(c.complexTensorInfos!=null){let l=c.complexTensorInfos.real,d=c.complexTensorInfos.imag;l.shape=o,d.shape=o}return{dataId:s.dataId,shape:o,dtype:s.dtype}}var ape={kernelName:Yf,backendName:"cpu",kernelFunc:Zn};function w9(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:o}=r;mt([s,a],"matMul");let u=s.shape.length,c=a.shape.length,l=i?s.shape[u-2]:s.shape[u-1],d=o?a.shape[c-1]:a.shape[c-2],h=i?s.shape[u-1]:s.shape[u-2],p=o?a.shape[c-2]:a.shape[c-1],f=s.shape.slice(0,-2),m=a.shape.slice(0,-2),g=$.sizeFromShape(f),b=$.sizeFromShape(m),y=mm.assertAndGetBroadcastShape(s.shape.slice(0,-2),a.shape.slice(0,-2)).concat([h,p]);$.assert(l===d,()=>`Error in matMul: inner shapes (${l}) and (${d}) of Tensors with shapes ${s.shape} and ${a.shape} and transposeA=${i} and transposeB=${o} must match.`);let x=i?[g,l,h]:[g,h,l],w=o?[b,p,d]:[b,d,p],v=Zn({inputs:{x:s},backend:n,attrs:{shape:x}}),I=Zn({inputs:{x:a},backend:n,attrs:{shape:w}}),N=i?v.shape[1]:v.shape[2],T=i?v.shape[2]:v.shape[1],E=o?I.shape[1]:I.shape[2],A=Math.max(g,b),k=n.data.get(v.dataId).values,C=n.data.get(I.dataId).values,M=$.computeStrides(v.shape),L=$.computeStrides(I.shape),[O,B,G]=i?[M[0],1,M[1]]:[M[0],M[1],1],[z,q,Q]=o?[1,L[1],L[0]]:[L[1],1,L[0]],K=T*E,ee=Ht([A,T,E],v.dtype),Y=ee.values,de=n.blockSize;for(let ue=0;ue<A;ue++){let Ie=ue%g,Ee=ue%b;for(let ve=0;ve<T;ve+=de){let Ae=Math.min(ve+de,T);for(let Be=0;Be<E;Be+=de){let Ue=Math.min(Be+de,E);for(let qe=0;qe<N;qe+=de){let ut=Math.min(qe+de,N);for(let nt=ve;nt<Ae;nt++)for(let rt=Be;rt<Ue;rt++){let ze=0;for(let ct=qe;ct<ut;ct++){let ht=k[Ie*O+nt*B+ct*G],yn=C[ct*z+rt*q+Ee*Q];ze+=ht*yn}Y[ue*K+(nt*E+rt)]+=ze}}}}}return n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(I),n.makeTensorInfo(y,ee.dtype,ee.values)}var ipe={kernelName:Td,backendName:"cpu",kernelFunc:w9};function ope(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:o}=t,{transposeA:u,transposeB:c,activation:l,leakyreluAlpha:d}=r,h,p,f,m=[];h=w9({inputs:{a:s,b:a},attrs:{transposeA:u,transposeB:c},backend:n}),i&&(p=qp({inputs:{a:h,b:i},backend:n}),m.push(h),h=p),l&&(f=Sx(n,h,l,o,d),m.push(h),h=f);for(let g of m)n.disposeIntermediateTensorInfo(g);return h}var lpe={kernelName:Oc,backendName:"cpu",kernelFunc:ope},upe=Dn(yd,e=>Math.acos(e)),cpe={kernelName:yd,backendName:"cpu",kernelFunc:upe},dpe=Dn(xd,e=>Math.acosh(e)),hpe={kernelName:xd,backendName:"cpu",kernelFunc:dpe};function ppe(e){let{inputs:t,backend:n}=e,r=t;mt(t,"addN");let s=r.map(o=>n.data.get(o.dataId).values),a=Ht(r[0].shape,r[0].dtype),i=a.values;for(let o=0;o<r.length;o++){let u=s[o];for(let c=0;c<i.length;c++)i[c]+=u[c]}return n.makeTensorInfo(a.shape,a.dtype,a.values)}var fpe={kernelName:wd,backendName:"cpu",kernelFunc:ppe};function mpe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;mt(s,"all");let o=$.parseAxisParam(a,s.shape),u=o,c=P.getAxesPermutation(u,s.shape.length),l=s;c!=null&&(l=ca({inputs:{x:s},backend:n,attrs:{perm:c}}),u=P.getInnerMostAxes(u.length,s.shape.length)),P.assertAxesAreInnerMostDims("all",u,l.shape.length);let[d,h]=P.computeOutAndReduceShapes(l.shape,u),p=$.sizeFromShape(h),f=$.makeZerosTypedArray($.sizeFromShape(d),l.dtype),m=n.data.get(l.dataId).values;for(let b=0;b<f.length;++b){let y=b*p,x=m[y];for(let w=0;w<p;++w){let v=m[y+w];x=x&&v}f[b]=x}c!=null&&n.disposeIntermediateTensorInfo(l);let g=n.makeTensorInfo(d,l.dtype,f);if(i){let b=P.expandShapeToKeepDim(d,o),y=Zn({inputs:{x:g},backend:n,attrs:{shape:b}});return n.disposeIntermediateTensorInfo(g),y}return g}var gpe={kernelName:ff,backendName:"cpu",kernelFunc:mpe};function bpe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;mt(s,"any");let o=$.parseAxisParam(a,s.shape),u=o,c=P.getAxesPermutation(u,s.shape.length),l=s;c!=null&&(l=ca({inputs:{x:s},backend:n,attrs:{perm:c}}),u=P.getInnerMostAxes(u.length,s.shape.length)),P.assertAxesAreInnerMostDims("any",u,l.shape.length);let[d,h]=P.computeOutAndReduceShapes(l.shape,u),p=$.sizeFromShape(h),f=$.makeZerosTypedArray($.sizeFromShape(d),l.dtype),m=n.data.get(l.dataId).values;for(let b=0;b<f.length;++b){let y=b*p,x=m[y];for(let w=0;w<p;++w){let v=m[y+w];x=x||v}f[b]=x}c!=null&&n.disposeIntermediateTensorInfo(l);let g=n.makeTensorInfo(d,l.dtype,f);if(i){let b=P.expandShapeToKeepDim(d,o),y=Zn({inputs:{x:g},backend:n,attrs:{shape:b}});return n.disposeIntermediateTensorInfo(g),y}return g}var ype={kernelName:mf,backendName:"cpu",kernelFunc:bpe};function xpe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;mt(s,"argMax");let i=$.parseAxisParam(a,s.shape),o=P.getAxesPermutation(i,s.shape.length),u=s,c=[];o!=null&&(u=ca({inputs:{x:s},backend:n,attrs:{perm:o}}),c.push(u),i=P.getInnerMostAxes(i.length,u.shape.length)),i=[i[0]],P.assertAxesAreInnerMostDims("argMax",i,u.shape.length);let[l,d]=P.computeOutAndReduceShapes(u.shape,i),h=$.sizeFromShape(l),p=$.makeZerosTypedArray(h,"int32"),f=$.sizeFromShape(d),m=n.data.get(u.dataId).values;for(let g=0;g<p.length;++g){let b=g*f,y=m[b],x=0;for(let w=0;w<f;++w){let v=m[b+w];v>y&&(y=v,x=w)}p[g]=x}return c.forEach(g=>n.disposeIntermediateTensorInfo(g)),n.makeTensorInfo(l,"int32",p)}var wpe={kernelName:gf,backendName:"cpu",kernelFunc:xpe};function vpe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;mt(s,"argMin");let i=$.parseAxisParam(a,s.shape),o=P.getAxesPermutation(i,s.shape.length),u=s,c=[];o!=null&&(u=ca({inputs:{x:s},backend:n,attrs:{perm:o}}),c.push(u),i=P.getInnerMostAxes(i.length,u.shape.length)),i=[i[0]],P.assertAxesAreInnerMostDims("argMin",i,u.shape.length);let[l,d]=P.computeOutAndReduceShapes(u.shape,i),h=$.sizeFromShape(l),p=$.makeZerosTypedArray(h,"int32"),f=$.sizeFromShape(d),m=n.data.get(u.dataId).values;for(let g=0;g<p.length;++g){let b=g*f,y=m[b],x=0;for(let w=0;w<f;++w){let v=m[b+w];v<y&&(y=v,x=w)}p[g]=x}return c.forEach(g=>n.disposeIntermediateTensorInfo(g)),n.makeTensorInfo(l,"int32",p)}var Ipe={kernelName:bf,backendName:"cpu",kernelFunc:vpe},kpe=Dn(vd,e=>Math.asin(e)),Cpe={kernelName:vd,backendName:"cpu",kernelFunc:kpe},Spe=Dn(Id,e=>Math.asinh(e)),Npe={kernelName:Id,backendName:"cpu",kernelFunc:Spe},Tpe=Dn(kd,e=>Math.atan(e)),Epe={kernelName:kd,backendName:"cpu",kernelFunc:Tpe},Ape=Cr((e,t)=>Math.atan2(e,t)),$pe=Qr(Sd,Ape),Rpe={kernelName:Sd,backendName:"cpu",kernelFunc:$pe},_pe=Dn(Cd,e=>Math.atanh(e)),Dpe={kernelName:Cd,backendName:"cpu",kernelFunc:_pe};function u4(e,t,n,r,s,a){let i=s.strideHeight,o=s.strideWidth,u=s.dilationHeight,c=s.dilationWidth,l=s.effectiveFilterHeight,d=s.effectiveFilterWidth,h=s.padInfo.top,p=s.padInfo.left,f=a==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=Ht(s.outShape,n),g=m.values,b=s.outShape[1]*s.outShape[2]*s.outShape[3],y=s.outShape[2]*s.outShape[3],x=s.outShape[3];for(let w=0;w<s.batchSize;++w){let v=w*b,I=w*r[0];for(let N=0;N<s.inChannels;++N)for(let T=0;T<s.outHeight;++T){let E=T*i-h,A=Math.max(0,E),k=Math.min(s.inHeight,l+E),C=v+T*y;for(let M=0;M<s.outWidth;++M){let L=M*o-p,O=Math.max(0,L),B=Math.min(s.inWidth,d+L),G=f,z=0,q=0;for(let K=A;K<k;K+=u){let ee=I+K*r[1];for(let Y=O;Y<B;Y+=c){let de=ee+Y*r[2],ue=e[de+N];a==="max"&&ue>G?G=ue:a==="avg"&&(z+=ue,q++)}if(isNaN(G))break}let Q=C+M*x+N;g[Q]=a==="avg"?z/q:G}}}return m}function v9(e,t,n,r,s=!1,a=!1){let i=Ht(r.outShape,"int32"),o=r.strideHeight,u=r.strideWidth,c=r.dilationHeight,l=r.dilationWidth,d=r.effectiveFilterHeight,h=r.effectiveFilterWidth,p=r.padInfo.top,f=r.padInfo.left,m=Ht(t,n,e);for(let g=0;g<r.batchSize;++g)for(let b=0;b<r.inChannels;++b)for(let y=0;y<r.outHeight;++y){let x=y*o-p,w=x;for(;w<0;)w+=c;let v=Math.min(r.inHeight,d+x);for(let I=0;I<r.outWidth;++I){let N=I*u-f,T=N;for(;T<0;)T+=l;let E=Math.min(r.inWidth,h+N),A=Number.NEGATIVE_INFINITY,k=-1;for(let C=w;C<v;C+=c){let M=C-x;for(let L=T;L<E;L+=l){let O=L-N,B=m.get(g,C,L,b);B>A&&(A=B,s?k=a?((g*r.inHeight+C)*r.inWidth+L)*r.inChannels+b:(C*r.inWidth+L)*r.inChannels+b:k=M*h+O)}}i.set(k,g,y,I,b)}}return i}function I9(e,t,n,r,s,a){let i=s.strideDepth,o=s.strideHeight,u=s.strideWidth,c=s.dilationDepth,l=s.dilationHeight,d=s.dilationWidth,h=s.effectiveFilterDepth,p=s.effectiveFilterHeight,f=s.effectiveFilterWidth,m=s.padInfo.front,g=s.padInfo.top,b=s.padInfo.left,y=a==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=Ht(s.outShape,n),w=x.values,v=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],I=s.outShape[2]*s.outShape[3]*s.outShape[4],N=s.outShape[3]*s.outShape[4],T=s.outShape[4];for(let E=0;E<s.batchSize;++E){let A=E*v,k=E*r[0];for(let C=0;C<s.inChannels;++C)for(let M=0;M<s.outDepth;++M){let L=M*i-m,O=L;for(;O<0;)O+=c;let B=Math.min(s.inDepth,h+L),G=A+M*I;for(let z=0;z<s.outHeight;++z){let q=z*o-g,Q=q;for(;Q<0;)Q+=l;let K=Math.min(s.inHeight,p+q),ee=G+z*N;for(let Y=0;Y<s.outWidth;++Y){let de=Y*u-b,ue=de;for(;ue<0;)ue+=d;let Ie=Math.min(s.inWidth,f+de),Ee=ee+Y*T,ve=y,Ae=0,Be=0;for(let qe=O;qe<B;qe+=c){let ut=k+qe*r[1];for(let nt=Q;nt<K;nt+=l){let rt=ut+nt*r[2];for(let ze=ue;ze<Ie;ze+=d){let ct=rt+ze*r[3],ht=e[ct+C];if(a==="max"&&ht>ve?ve=ht:a==="avg"&&(Ae+=ht,Be++),isNaN(ve))break}if(isNaN(ve))break}if(isNaN(ve))break}let Ue=Ee+C;w[Ue]=a==="avg"?Ae/Math.max(Be,1):ve}}}}return x}function Fpe(e,t){let n=Ht(t.outShape,"int32"),r=t.strideDepth,s=t.strideHeight,a=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,u=t.dilationWidth,c=t.effectiveFilterDepth,l=t.effectiveFilterHeight,d=t.effectiveFilterWidth,h=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let b=0;b<t.outDepth;++b){let y=b*r-h,x=y;for(;x<0;)x+=i;let w=Math.min(t.inDepth,c+y);for(let v=0;v<t.outHeight;++v){let I=v*s-p,N=I;for(;N<0;)N+=o;let T=Math.min(t.inHeight,l+I);for(let E=0;E<t.outWidth;++E){let A=E*a-f,k=A;for(;k<0;)k+=u;let C=Math.min(t.inWidth,d+A),M=Number.NEGATIVE_INFINITY,L=-1;for(let O=x;O<w;O+=i){let B=O-y;for(let G=N;G<T;G+=o){let z=G-I;for(let q=k;q<C;q+=u){let Q=q-A,K=e.get(m,O,G,q,g);K>=M&&(M=K,L=B*l*d+z*l+Q)}}}n.set(L,m,b,v,E,g)}}}return n}function Mpe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t;mt(s,"avgPool");let{filterSize:a,strides:i,pad:o,dimRoundingMode:u}=r,c=1;$.assert(P.eitherStridesOrDilationsAreOne(i,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);let l=P.computePool2DInfo(s.shape,a,i,c,o,u),d;if(l.filterWidth===1&&l.filterHeight===1&&$.arraysEqual(l.inShape,l.outShape))d=Ao({inputs:{x:s},backend:n});else{let h=n.data.get(s.dataId).values,p=$.computeStrides(s.shape),f=u4(h,s.shape,s.dtype,p,l,"avg");d=n.makeTensorInfo(l.outShape,s.dtype,f.values)}return d}var Ope={kernelName:Nd,backendName:"cpu",kernelFunc:Mpe};function Lpe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:u,dataFormat:c}=r;mt(s,"avgPool3d");let l=P.computePool3DInfo(s.shape,a,i,1,o,u,c),d=n.data.get(s.dataId).values,h=I9(d,s.shape,s.dtype,$.computeStrides(s.shape),l,"avg");return n.makeTensorInfo(h.shape,"float32",h.values)}var Ppe={kernelName:yf,backendName:"cpu",kernelFunc:Lpe};function Bpe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:u,dimRoundingMode:c}=r;mt([s,a],"avgPool3DGrad");let l=P.computePool3DInfo(a.shape,i,o,1,u,c),d=l.strideDepth,h=l.strideHeight,p=l.strideWidth,f=l.filterDepth,m=l.filterHeight,g=l.filterWidth,b=l.dilationDepth,y=l.dilationHeight,x=l.dilationWidth,w=l.effectiveFilterDepth,v=l.effectiveFilterHeight,I=l.effectiveFilterWidth,N=w-1-l.padInfo.front,T=I-1-l.padInfo.left,E=v-1-l.padInfo.top,A=Ht(a.shape,"float32"),k=1/(f*m*g),C=n.bufferSync(s);for(let M=0;M<l.batchSize;++M)for(let L=0;L<l.inChannels;++L)for(let O=0;O<l.inDepth;++O)for(let B=0;B<l.inHeight;++B)for(let G=0;G<l.inWidth;++G){let z=O-N,q=B-E,Q=G-T,K=0;for(let ee=0;ee<w;ee+=b){let Y=(z+ee)/d;if(!(Y<0||Y>=l.outDepth||Math.floor(Y)!==Y))for(let de=0;de<v;de+=y){let ue=(q+de)/h;if(!(ue<0||ue>=l.outHeight||Math.floor(ue)!==ue))for(let Ie=0;Ie<I;Ie+=x){let Ee=(Q+Ie)/p;if(Ee<0||Ee>=l.outWidth||Math.floor(Ee)!==Ee)continue;let ve=C.get(M,Y,ue,Ee,L);K+=ve}}}A.set(K*k,M,O,B,G,L)}return n.makeTensorInfo(A.shape,A.dtype,A.values)}var zpe={kernelName:Hy,backendName:"cpu",kernelFunc:Bpe};function Wpe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a;mt([s,a],"avgPoolGrad");let{filterSize:o,strides:u,pad:c}=r,l=P.computePool2DInfo(i.shape,o,u,1,c),d=l.strideHeight,h=l.strideWidth,p=l.filterHeight,f=l.filterWidth,m=l.dilationHeight,g=l.dilationWidth,b=l.effectiveFilterHeight,y=l.effectiveFilterWidth,x=y-1-l.padInfo.left,w=b-1-l.padInfo.top,v=Ht(i.shape,"float32"),I=1/(p*f),N=n.data.get(s.dataId).values,T=Ht(s.shape,"float32",N);for(let E=0;E<l.batchSize;++E)for(let A=0;A<l.inChannels;++A)for(let k=0;k<l.inHeight;++k)for(let C=0;C<l.inWidth;++C){let M=k-w,L=C-x,O=0;for(let B=0;B<b;B+=m){let G=(M+B)/d;if(!(G<0||G>=l.outHeight||Math.floor(G)!==G))for(let z=0;z<y;z+=g){let q=(L+z)/h;if(q<0||q>=l.outWidth||Math.floor(q)!==q)continue;let Q=T.get(E,G,q,A);O+=Q}}v.set(O*I,E,k,C,A)}return n.makeTensorInfo(v.shape,v.dtype,v.values)}var Vpe={kernelName:Gy,backendName:"cpu",kernelFunc:Wpe};function Upe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,scale:a,offset:i,mean:o,variance:u}=t;$.assert(o.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),$.assert(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),$.assert(a==null||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),mt([s,o,u,a,i],"batchNorm");let{varianceEpsilon:c}=r;c==null&&(c=.001);let l=n.data.get(s.dataId).values,d=n.data.get(o.dataId).values,h=n.data.get(u.dataId).values,p=a?n.data.get(a.dataId).values:new Float32Array([1]),f=i?n.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(l.length),g=f.length,b=p.length,y=h.length,x=d.length,w=0,v=0,I=0,N=0;for(let T=0;T<l.length;++T)m[T]=f[w++]+(l[T]-d[v++])*p[I++]/Math.sqrt(h[N++]+c),w>=g&&(w=0),v>=x&&(v=0),I>=b&&(I=0),N>=y&&(N=0);return n.makeTensorInfo(s.shape,s.dtype,m)}var Gpe={kernelName:Hd,backendName:"cpu",kernelFunc:Upe};function Hpe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:i}=r;mt([s],"batchToSpaceND");let o=a.reduce((b,y)=>b*y),u=P.getReshaped(s.shape,a,o),c=P.getPermuted(u.length,a.length),l=P.getReshapedPermuted(s.shape,a,o),d=P.getSliceBeginCoords(i,a.length),h=P.getSliceSize(l,i,a.length),p=Zn({inputs:{x:s},backend:n,attrs:{shape:u}}),f=ca({inputs:{x:p},backend:n,attrs:{perm:c}}),m=Zn({inputs:{x:f},backend:n,attrs:{shape:l}}),g=Qc({inputs:{x:m},backend:n,attrs:{begin:d,size:h}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}var jpe={kernelName:xf,backendName:"cpu",kernelFunc:Hpe};function qpe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i}=r,o=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,c=JT(o,u,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,c)}var Kpe={kernelName:wf,backendName:"cpu",kernelFunc:qpe};function Xpe(e){let{inputs:t,backend:n}=e,{s0:r,s1:s}=t,a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,o=P.assertAndGetBroadcastShape(Array.from(a),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}var Qpe={kernelName:jy,backendName:"cpu",kernelFunc:Xpe},Ype=Dn(xu,(e,t)=>{let n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e}),Jpe={kernelName:xu,backendName:"cpu",kernelFunc:Ype},Zpe=e=>{let{x:t}=e.inputs,n=e.backend,r=new Float32Array($.sizeFromShape(t.shape)),s=n.data.get(t.dataId),a=s.complexTensorInfos.real,i=s.complexTensorInfos.imag,o=n.data.get(a.dataId).values,u=n.data.get(i.dataId).values;for(let c=0;c<o.length;c++){let l=o[c],d=u[c];r[c]=Math.hypot(l,d)}return n.makeOutput(r,t.shape,"float32")},efe={kernelName:qy,backendName:"cpu",kernelFunc:Zpe};function Kp(e){let{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.imag,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}var tfe={kernelName:ww,backendName:"cpu",kernelFunc:Kp};function Xp(e){let{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,a=$.parseAxisParam(s,t[0].shape)[0],i=t.map(m=>m.shape);P.assertParamsConsistent(i,a);let o=P.computeOutShape(t.map(m=>m.shape),a);if($.sizeFromShape(o)===0)return n.makeTensorInfo(o,t[0].dtype,[]);let u=t.filter(m=>$.sizeFromShape(m.shape)>0);if(u.length===1)return Ao({inputs:{x:u[0]},backend:n});if(u[0].dtype==="complex64"){let m=u.map(w=>Xc({inputs:{input:w},backend:n})),g=u.map(w=>Kp({inputs:{input:w},backend:n})),b=Xp({inputs:m,backend:n,attrs:{axis:a}}),y=Xp({inputs:g,backend:n,attrs:{axis:a}}),x=wa({inputs:{real:b,imag:y},backend:n});return m.forEach(w=>n.disposeIntermediateTensorInfo(w)),g.forEach(w=>n.disposeIntermediateTensorInfo(w)),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(y),x}let c=u.map(m=>{let g=[-1,$.sizeFromShape(m.shape.slice(a))];return Zn({inputs:{x:m},backend:n,attrs:{shape:g}})}),l=c.map(m=>({vals:n.data.get(m.dataId).values,shape:m.shape}));o=P.computeOutShape(c.map(m=>m.shape),1);let d=c[0].shape[0]===1,h=ZT(l,o,t[0].dtype,d),p=P.computeOutShape(u.map(m=>m.shape),a),f=n.makeTensorInfo(p,t[0].dtype,h);return c.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}var nfe={kernelName:If,backendName:"cpu",kernelFunc:Xp};function k9(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dataFormat:u,dilations:c,dimRoundingMode:l}=r;mt([s,a],"conv2d");let d=P.convertConv2DDataFormat(u),h=P.computeConv2DInfo(s.shape,a.shape,i,c,o,l,!1,d),p=h.filterHeight,f=h.filterWidth,m=h.dilationHeight,g=h.dilationWidth,b=h.padInfo.left,y=h.padInfo.top,x=h.dataFormat==="channelsLast",w=new _r(h.outShape,s.dtype),v=$.computeStrides(s.shape),I=$.computeStrides(a.shape),N=v[0],T=x?v[1]:v[2],E=x?v[2]:1,A=x?1:v[1],k=w.strides[0],C=x?w.strides[1]:w.strides[2],M=x?w.strides[2]:1,L=x?1:w.strides[1],O=n.data.get(s.dataId).values,B=n.data.get(a.dataId).values,G=w.values;for(let z=0;z<h.batchSize;++z){let q=z*N,Q=z*k;for(let K=0;K<h.outHeight;++K){let ee=Q+K*C,Y=K*h.strideHeight-y;for(let de=0;de<p;++de){let ue=Y+de*m;if(ue<0||ue>=h.inHeight)continue;let Ie=de*I[0],Ee=q+ue*T;for(let ve=0;ve<h.outWidth;++ve){let Ae=ee+ve*M,Be=ve*h.strideWidth-b;for(let Ue=0;Ue<f;++Ue){let qe=Be+Ue*g;if(qe<0||qe>=h.inWidth)continue;let ut=Ie+Ue*I[1],nt=Ee+qe*E,rt=ut;for(let ze=0;ze<h.inChannels;++ze){let ct=O[nt+ze*A];for(let ht=0;ht<h.outChannels;++ht)G[Ae+ht*L]+=ct*B[rt+ht];rt+=h.outChannels}}}}}}return n.makeTensorInfo(w.shape,w.dtype,G)}var rfe={kernelName:$d,backendName:"cpu",kernelFunc:k9};function sfe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,dataFormat:u,dimRoundingMode:c,filterShape:l}=r;mt([s,a],"conv2dBackpropFilter");let d=P.convertConv2DDataFormat(u),h=P.computeConv2DInfo(s.shape,l,i,1,o,c,!1,d),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=h,b=h.dataFormat==="channelsLast",y=new _r(h.filterShape,"float32"),x=h.padInfo.left,w=h.padInfo.top,v=n.data.get(s.dataId).values,I=n.data.get(a.dataId).values,N=new _r(s.shape,s.dtype,v),T=new _r(a.shape,a.dtype,I);for(let E=0;E<m;++E){let A=Math.max(0,Math.ceil((w-E)/p)),k=Math.min(h.outHeight,(h.inHeight+w-E)/p);for(let C=0;C<g;++C){let M=Math.max(0,Math.ceil((x-C)/f)),L=Math.min(h.outWidth,(h.inWidth+x-C)/f);for(let O=0;O<h.inChannels;++O)for(let B=0;B<h.outChannels;++B){let G=0;for(let z=0;z<h.batchSize;++z)for(let q=A;q<k;++q){let Q=E+q*p-w;for(let K=M;K<L;++K){let ee=C+K*f-x;b?G+=N.get(z,Q,ee,O)*T.get(z,q,K,B):G+=N.get(z,O,Q,ee)*T.get(z,B,q,K)}}y.set(G,E,C,O,B)}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}var afe={kernelName:pw,backendName:"cpu",kernelFunc:sfe};function ife(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{inputShape:i,strides:o,pad:u,dataFormat:c,dimRoundingMode:l}=r;mt([s,a],"conv2dBackpropInput");let d=$.computeStrides(a.shape),h=$.computeStrides(s.shape),p=P.convertConv2DDataFormat(c),f=P.computeConv2DInfo(i,a.shape,o,1,u,l,!1,p),m=new _r(f.inShape,"float32"),g=m.values,b=n.data.get(s.dataId).values,y=n.data.get(a.dataId).values,[x,w,v]=d,{batchSize:I,filterHeight:N,filterWidth:T,inChannels:E,inHeight:A,inWidth:k,outChannels:C,outHeight:M,outWidth:L,strideHeight:O,strideWidth:B}=f;p=f.dataFormat;let G=N-1-f.padInfo.top,z=T-1-f.padInfo.left,q=p==="channelsLast",Q=m.strides[0],K=q?m.strides[1]:m.strides[2],ee=q?m.strides[2]:1,Y=q?1:m.strides[1],de=h[0],ue=q?h[1]:h[2],Ie=q?h[2]:1,Ee=q?1:h[1];for(let ve=0;ve<I;++ve)for(let Ae=0;Ae<E;++Ae)for(let Be=0;Be<A;++Be){let Ue=Be-G,qe=Math.max(0,Math.ceil(Ue/O)),ut=Math.min(M,(N+Ue)/O);for(let nt=0;nt<k;++nt){let rt=nt-z,ze=Math.max(0,Math.ceil(rt/B)),ct=Math.min(L,(T+rt)/B),ht=0;for(let St=qe;St<ut;++St){let pn=St*O-Ue;for(let jt=ze;jt<ct;++jt){let nn=jt*B-rt,wn=de*ve+ue*St+Ie*jt,Tt=x*(N-1-pn)+w*(T-1-nn)+v*Ae;for(let vn=0;vn<C;++vn){let Kt=b[wn+Ee*vn],an=y[Tt+vn];ht+=Kt*an}}}let yn=Q*ve+K*Be+ee*nt+Y*Ae;g[yn]=ht}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}var ofe={kernelName:Rd,backendName:"cpu",kernelFunc:ife};function lfe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:u}=r;mt([s,a],"conv3d");let c=P.computeConv3DInfo(s.shape,a.shape,i,u,o),{filterDepth:l,filterHeight:d,filterWidth:h,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=c,b=g.front,y=g.left,x=g.top,w=new _r(c.outShape,s.dtype),v=n.data.get(s.dataId).values,I=n.data.get(a.dataId).values,N=w.values,T=$.computeStrides(s.shape),E=$.computeStrides(a.shape);for(let A=0;A<c.batchSize;++A){let k=A*T[0],C=A*w.strides[0];for(let M=0;M<c.outDepth;++M){let L=C+M*w.strides[1],O=M*c.strideDepth-b;for(let B=0;B<l;++B){let G=O+B*p;if(G<0||G>=c.inDepth)continue;let z=B*E[0],q=k+G*T[1];for(let Q=0;Q<c.outHeight;++Q){let K=L+Q*w.strides[2],ee=Q*c.strideHeight-x;for(let Y=0;Y<d;++Y){let de=ee+Y*f;if(de<0||de>=c.inHeight)continue;let ue=z+Y*E[1],Ie=q+de*T[2];for(let Ee=0;Ee<c.outWidth;++Ee){let ve=K+Ee*c.outChannels,Ae=Ee*c.strideWidth-y;for(let Be=0;Be<h;++Be){let Ue=Ae+Be*m;if(Ue<0||Ue>=c.inWidth)continue;let qe=ue+Be*E[2],ut=Ie+Ue*c.inChannels,nt=qe;for(let rt=0;rt<c.inChannels;++rt){let ze=v[ut+rt];for(let ct=0;ct<c.outChannels;++ct)N[ve+ct]+=ze*I[nt+ct];nt+=c.outChannels}}}}}}}}return n.makeTensorInfo(w.shape,w.dtype,w.values)}var ufe={kernelName:_d,backendName:"cpu",kernelFunc:lfe};function cfe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,filterShape:u}=r;mt([s,a],"conv3dBackpropFilterV2");let c=$.computeStrides(s.shape),l=$.computeStrides(a.shape),d=P.computeConv3DInfo(s.shape,u,i,1,o),h=d.strideDepth,p=d.strideHeight,f=d.strideWidth,m=d.filterDepth,g=d.filterHeight,b=d.filterWidth,y=new _r(d.filterShape,"float32"),x=y.values,[w,v,I,N]=y.strides,T=n.data.get(a.dataId).values,[E,A,k,C]=l,M=n.data.get(s.dataId).values,[L,O,B,G]=c,z=d.padInfo.front,q=d.padInfo.left,Q=d.padInfo.top;for(let K=0;K<m;++K){let ee=Math.max(0,Math.ceil((z-K)/h)),Y=Math.min(d.outDepth,(d.inDepth+z-K)/h),de=K*w;for(let ue=0;ue<g;++ue){let Ie=Math.max(0,Math.ceil((Q-ue)/p)),Ee=Math.min(d.outHeight,(d.inHeight+Q-ue)/p),ve=ue*v+de;for(let Ae=0;Ae<b;++Ae){let Be=Math.max(0,Math.ceil((q-Ae)/f)),Ue=Math.min(d.outWidth,(d.inWidth+q-Ae)/f),qe=Ae*I+ve;for(let ut=0;ut<d.inChannels;++ut){let nt=ut*N+qe;for(let rt=0;rt<d.outChannels;++rt){let ze=0;for(let ct=0;ct<d.batchSize;++ct){let ht=ct*L,yn=ct*E;for(let St=ee;St<Y;++St){let pn=(K+St*h-z)*O+ht,jt=St*A+yn;for(let nn=Ie;nn<Ee;++nn){let wn=(ue+nn*p-Q)*B+pn,Tt=nn*k+jt;for(let vn=Be;vn<Ue;++vn){let Kt=(Ae+vn*f-q)*G+wn,an=vn*C+Tt;ze+=M[Kt+ut]*T[an+rt]}}}}x[nt+rt]=ze}}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}var dfe={kernelName:kf,backendName:"cpu",kernelFunc:cfe};function hfe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:i,strides:o,inputShape:u}=r;mt([s],"conv3dBackpropInputV2");let c=$.computeStrides(s.shape),l=$.computeStrides(a.shape),d=P.computeConv3DInfo(u,a.shape,o,1,i),h=new _r(d.inShape,"float32"),p=h.values,[f,m,g,b]=h.strides,y=n.data.get(s.dataId).values,[x,w,v,I]=c,N=n.data.get(a.dataId).values,[T,E,A,k]=l,{batchSize:C,filterDepth:M,filterHeight:L,filterWidth:O,inChannels:B,inDepth:G,inHeight:z,inWidth:q,outChannels:Q,outDepth:K,outHeight:ee,outWidth:Y,strideDepth:de,strideHeight:ue,strideWidth:Ie}=d,Ee=M-1-d.padInfo.front,ve=L-1-d.padInfo.top,Ae=O-1-d.padInfo.left;for(let Be=0;Be<C;++Be)for(let Ue=0;Ue<B;++Ue)for(let qe=0;qe<G;++qe){let ut=qe-Ee,nt=Math.max(0,Math.ceil(ut/de)),rt=Math.min(K,(M+ut)/de);for(let ze=0;ze<z;++ze){let ct=ze-ve,ht=Math.max(0,Math.ceil(ct/ue)),yn=Math.min(ee,(L+ct)/ue);for(let St=0;St<q;++St){let pn=St-Ae,jt=Math.max(0,Math.ceil(pn/Ie)),nn=Math.min(Y,(O+pn)/Ie),wn=0;for(let Tt=nt;Tt<rt;++Tt){let vn=Tt*de-ut;for(let Kt=ht;Kt<yn;++Kt){let an=Kt*ue-ct;for(let xr=jt;xr<nn;++xr){let Re=xr*Ie-pn,re=x*Be+w*Tt+v*Kt+I*xr,$e=T*(M-1-vn)+E*(L-1-an)+A*(O-1-Re)+k*Ue;for(let Oe=0;Oe<Q;++Oe){let tt=y[re+Oe],Ke=N[$e+Oe];wn+=tt*Ke}}}}p[f*Be+m*qe+g*ze+b*St+Ue]=wn}}}return n.makeTensorInfo(h.shape,h.dtype,h.values)}var pfe={kernelName:Cf,backendName:"cpu",kernelFunc:hfe},ffe=Dn(Dd,e=>Math.cos(e)),mfe={kernelName:Dd,backendName:"cpu",kernelFunc:ffe},gfe=Dn(Fd,e=>Math.cosh(e)),bfe={kernelName:Fd,backendName:"cpu",kernelFunc:gfe};function yfe(e){let{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:i}=t,{cropSize:o,method:u,extrapolationValue:c}=r,[l,d,h,p]=s.shape,f=a.shape[0],[m,g]=o,b=Ht([f,m,g,p],"float32"),y=n.data.get(a.dataId).values,x=n.data.get(i.dataId).values,w=n.data.get(s.dataId).values,v=$.computeStrides(s.shape),I=$.computeStrides(b.shape);for(let N=0;N<f;N++){let T=N*4,E=y[T],A=y[T+1],k=y[T+2],C=y[T+3],M=x[N];if(M>=l)continue;let L=m>1?(k-E)*(d-1)/(m-1):0,O=g>1?(C-A)*(h-1)/(g-1):0;for(let B=0;B<m;B++){let G=m>1?E*(d-1)+B*L:.5*(E+k)*(d-1);if(G<0||G>d-1){for(let z=0;z<g;z++)for(let q=0;q<p;q++){let Q=q+z*I[2]+B*I[1]+N*I[0];b.values[Q]=c}continue}if(u==="bilinear"){let z=Math.floor(G),q=Math.ceil(G),Q=G-z;for(let K=0;K<g;K++){let ee=g>1?A*(h-1)+K*O:.5*(A+C)*(h-1);if(ee<0||ee>h-1){for(let Ie=0;Ie<p;Ie++){let Ee=Ie+K*I[2]+B*I[1]+N*I[0];b.values[Ee]=c}continue}let Y=Math.floor(ee),de=Math.ceil(ee),ue=ee-Y;for(let Ie=0;Ie<p;Ie++){let Ee=Ie+Y*v[2]+z*v[1]+M*v[0],ve=w[Ee];Ee=Ie+de*v[2]+z*v[1]+M*v[0];let Ae=w[Ee];Ee=Ie+Y*v[2]+q*v[1]+M*v[0];let Be=w[Ee];Ee=Ie+de*v[2]+q*v[1]+M*v[0];let Ue=w[Ee],qe=ve+(Ae-ve)*ue,ut=Be+(Ue-Be)*ue;Ee=Ie+K*I[2]+B*I[1]+N*I[0],b.values[Ee]=qe+(ut-qe)*Q}}}else for(let z=0;z<g;++z){let q=g>1?A*(h-1)+z*O:.5*(A+C)*(h-1);if(q<0||q>h-1){for(let ee=0;ee<p;ee++){let Y=ee+z*I[2]+B*I[1]+N*I[0];b.values[Y]=c}continue}let Q=Math.round(q),K=Math.round(G);for(let ee=0;ee<p;ee++){let Y=ee+Q*v[2]+K*v[1]+M*v[0],de=ee+z*I[2]+B*I[1]+N*I[0];b.values[de]=w[Y]}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}var xfe={kernelName:Nf,backendName:"cpu",kernelFunc:yfe};function wfe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;mt(s,"cumprod");let u=P.getAxesPermutation([a],s.shape.length),c=s;u!=null&&(c=ca({inputs:{x:s},backend:n,attrs:{perm:u}}));let l=P.getInnerMostAxes(1,s.shape.length)[0];if(l!==c.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${l}`);let d=Ha(c.dtype,"int32"),h=$.makeOnesTypedArray($.sizeFromShape(c.shape),d),p=n.data.get(c.dataId).values,f=c.shape[c.shape.length-1],m=o?(b,y)=>b+f-y-1:(b,y)=>b+y;for(let b=0;b<p.length;b+=f)for(let y=0;y<f;y++){let x=m(b,y);if(y===0)h[x]=i?1:p[x];else{let w=m(b,y-1);h[x]=i?p[w]*h[w]:p[x]*h[w]}}let g=n.makeTensorInfo(c.shape,d,h);if(u!=null){let b=P.getUndoAxesPermutation(u),y=ca({inputs:{x:g},backend:n,attrs:{perm:b}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(c),y}return g}var vfe={kernelName:Sf,backendName:"cpu",kernelFunc:wfe};function Ife(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;mt(s,"cumsum");let u=P.getAxesPermutation([a],s.shape.length),c=s;u!=null&&(c=ca({inputs:{x:s},backend:n,attrs:{perm:u}}));let l=P.getInnerMostAxes(1,s.shape.length)[0];if(l!==c.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${l}`);let d=Ha(c.dtype,"int32"),h=$.makeZerosTypedArray($.sizeFromShape(c.shape),d),p=n.data.get(c.dataId).values,f=c.shape[c.shape.length-1],m=o?(b,y)=>b+f-y-1:(b,y)=>b+y;for(let b=0;b<p.length;b+=f)for(let y=0;y<f;y++){let x=m(b,y);if(y===0)h[x]=i?0:p[x];else{let w=m(b,y-1);h[x]=i?p[w]+h[w]:p[x]+h[w]}}let g=n.makeTensorInfo(c.shape,d,h);if(u!=null){let b=P.getUndoAxesPermutation(u),y=ca({inputs:{x:g},backend:n,attrs:{perm:b}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(c),y}return g}var kfe={kernelName:Md,backendName:"cpu",kernelFunc:Ife};function Cfe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i,binaryOutput:o}=r;if(s.shape.length===1){let u=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,l=JT(u,c,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,l)}else if(s.shape.length===2){let u=n.bufferSync(s),c=n.bufferSync(a),l=RO(u,c,i,o);return n.makeTensorInfo(l.shape,a.dtype,l.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}var Sfe={kernelName:Ky,backendName:"cpu",kernelFunc:Cfe};function Nfe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:i}=r;$.assert(i==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);let o=s.shape[0],u=s.shape[1],c=s.shape[2],l=s.shape[3],d=u*a,h=c*a,p=l/(a*a),f=n.data.get(s.dataId).values,m=new Float32Array(o*d*h*p),g=0;for(let b=0;b<o;++b)for(let y=0;y<d;++y){let x=Math.floor(y/a),w=y%a;for(let v=0;v<h;++v){let I=Math.floor(v/a),N=v%a,T=(w*a+N)*p;for(let E=0;E<p;++E){let A=E+T+l*(I+c*(x+u*b));m[g++]=f[A]}}}return n.makeTensorInfo([o,d,h,p],s.dtype,m)}var Tfe={kernelName:Tf,backendName:"cpu",kernelFunc:Nfe};function C9(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:u,dimRoundingMode:c}=r;mt([s,a],"depthwiseConv2DNative");let l=$.computeStrides(s.shape),d=$.computeStrides(a.shape),h=u;h==null&&(h=[1,1]),$.assert(P.eitherStridesOrDilationsAreOne(i,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${h}'`);let p=P.computeConv2DInfo(s.shape,a.shape,i,h,o,c,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:b,padInfo:y}=p,x=y.left,w=y.top,v=p.outChannels/p.inChannels,I=new _r(p.outShape,s.dtype),N=n.data.get(s.dataId).values,T=n.data.get(a.dataId).values,E=I.values;for(let A=0;A<p.batchSize;++A){let k=A*l[0],C=A*I.strides[0];for(let M=0;M<p.outHeight;++M){let L=C+M*I.strides[1],O=M*p.strideHeight-w;for(let B=0;B<f;++B){let G=O+B*g;if(G<0||G>=p.inHeight)continue;let z=B*d[0],q=k+G*l[1];for(let Q=0;Q<p.outWidth;++Q){let K=L+Q*I.strides[2],ee=Q*p.strideWidth-x;for(let Y=0;Y<m;++Y){let de=ee+Y*b;if(de<0||de>=p.inWidth)continue;let ue=z+Y*d[1],Ie=q+de*p.inChannels,Ee=K,ve=ue;for(let Ae=0;Ae<p.inChannels;++Ae){let Be=N[Ie+Ae];for(let Ue=0;Ue<v;++Ue)E[Ee+Ue]+=Be*T[ve+Ue];Ee+=v,ve+=v}}}}}}return n.makeTensorInfo(I.shape,I.dtype,I.values)}var Efe={kernelName:Od,backendName:"cpu",kernelFunc:C9};function Afe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,dilations:o,pad:u,dimRoundingMode:c,filterShape:l}=r;mt([s,a],"depthwiseConv2dNativeBackpropFilter");let d=P.computeConv2DInfo(s.shape,l,i,o,u,c,!0),{strideHeight:h,strideWidth:p,filterHeight:f,filterWidth:m}=d,g=new _r(d.filterShape,"float32"),b=d.padInfo.left,y=d.padInfo.top,x=d.outChannels/d.inChannels,w=n.data.get(s.dataId).values,v=new _r(s.shape,s.dtype,w),I=n.data.get(a.dataId).values,N=new _r(a.shape,a.dtype,I);for(let T=0;T<f;++T){let E=Math.max(0,Math.ceil((y-T)/h)),A=Math.min(d.outHeight,(d.inHeight+y-T)/h);for(let k=0;k<m;++k){let C=Math.max(0,Math.ceil((b-k)/p)),M=Math.min(d.outWidth,(d.inWidth+b-k)/p);for(let L=0;L<d.outChannels;++L){let O=Math.trunc(L/x),B=L%x,G=0;for(let z=0;z<d.batchSize;++z)for(let q=E;q<A;++q){let Q=T+q*h-y;for(let K=C;K<M;++K){let ee=k+K*p-b;G+=v.get(z,Q,ee,O)*N.get(z,q,K,L)}}g.set(G,T,k,O,B)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}var $fe={kernelName:fw,backendName:"cpu",kernelFunc:Afe};function Rfe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{strides:i,dilations:o,pad:u,dimRoundingMode:c,inputShape:l}=r;mt([s,a],"depthwiseConv2DNativeBackpropInput");let d=$.computeStrides(s.shape),h=$.computeStrides(a.shape),p=P.computeConv2DInfo(l,a.shape,i,o,u,c,!0),f=new _r(p.inShape,"float32"),m=f.values,[g,b,y]=f.strides,x=n.data.get(s.dataId).values,[w,v,I]=d,N=n.data.get(a.dataId).values,[T,E,A]=h,{batchSize:k,filterHeight:C,filterWidth:M,inChannels:L,inHeight:O,inWidth:B,outChannels:G,outHeight:z,outWidth:q,strideHeight:Q,strideWidth:K}=p,ee=C-1-p.padInfo.top,Y=M-1-p.padInfo.left,de=G/L;for(let ue=0;ue<k;++ue)for(let Ie=0;Ie<L;++Ie)for(let Ee=0;Ee<O;++Ee){let ve=Ee-ee,Ae=Math.max(0,Math.ceil(ve/Q)),Be=Math.min(z,(C+ve)/Q);for(let Ue=0;Ue<B;++Ue){let qe=Ue-Y,ut=Math.max(0,Math.ceil(qe/K)),nt=Math.min(q,(M+qe)/K),rt=0;for(let ze=Ae;ze<Be;++ze){let ct=ze*Q-ve;for(let ht=ut;ht<nt;++ht){let yn=ht*K-qe,St=w*ue+v*ze+I*ht,pn=T*(C-1-ct)+E*(M-1-yn)+A*Ie;for(let jt=0;jt<de;++jt){let nn=Ie*de+jt,wn=x[St+nn],Tt=N[pn+jt];rt+=wn*Tt}}}m[g*ue+b*Ee+y*Ue+Ie]=rt}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}var _fe={kernelName:mw,backendName:"cpu",kernelFunc:Rfe};function Dfe(e){let{inputs:t,backend:n}=e,{x:r}=t,s=$.sizeFromShape(r.shape),a=n.data.get(r.dataId).values,i=Ht([s,s],r.dtype),o=i.values;for(let c=0;c<a.length;c++)o[c*s+c]=a[c];let u=[...r.shape,...r.shape];return n.makeTensorInfo(u,i.dtype,i.values)}var Ffe={kernelName:Xy,backendName:"cpu",kernelFunc:Dfe},Mfe={kernelName:Ld,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:s}=e,{strides:a,pad:i,dilations:o}=n,u=t,c=u.data.get(r.dataId).values,l=r.shape.length,d=u.data.get(s.dataId).values,h=s.shape.length,{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:b,outWidth:y,padInfo:x,strideHeight:w,strideWidth:v,filterHeight:I,filterWidth:N,dilationHeight:T,dilationWidth:E,outShape:A}=P.computeDilation2DInfo(r.shape,s.shape,a,i,"NHWC",o),k=$.sizeFromShape(A),C=A.length,M=$.getArrayFromDType(r.dtype,k);for(let L=0;L<p;++L)for(let O=0;O<b;++O){let B=O*w-x.top;for(let G=0;G<y;++G){let z=G*v-x.left;for(let q=0;q<g;++q){let Q=Number.MIN_SAFE_INTEGER;for(let ee=0;ee<I;++ee){let Y=B+ee*T;if(Y>=0&&Y<f)for(let de=0;de<N;++de){let ue=z+de*E;if(ue>=0&&ue<m){let Ie=$.locToIndex([L,Y,ue,q],l,$.computeStrides(r.shape)),Ee=$.locToIndex([ee,de,q],h,$.computeStrides(s.shape)),ve=c[Ie]+d[Ee];ve>Q&&(Q=ve)}}}let K=$.locToIndex([L,O,G,q],C,$.computeStrides(A));M[K]=Q}}}return{dataId:u.write($.toTypedArray(M,r.dtype),A,r.dtype),shape:A,dtype:r.dtype}}},Ofe={kernelName:Mp,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:s,dy:a}=e,{strides:i,pad:o,dilations:u}=n,c=t,l=$.toNestedArray(r.shape,c.data.get(r.dataId).values),d=$.toNestedArray(s.shape,c.data.get(s.dataId).values),{batchSize:h,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:b,padInfo:y,strideHeight:x,strideWidth:w,filterHeight:v,filterWidth:I,dilationHeight:N,dilationWidth:T,outShape:E}=P.computeDilation2DInfo(r.shape,s.shape,i,o,"NHWC",u);$.assert(a.rank===E.length,()=>`Error in ${Mp}, dy must have the same rank as output ${E.length}, but got ${a.rank}`);let A=$.toNestedArray(E,c.data.get(a.dataId).values),k=$.makeZerosNestedTypedArray(s.shape,s.dtype);for(let C=0;C<h;++C)for(let M=0;M<g;++M){let L=M*x-y.top;for(let O=0;O<b;++O){let B=O*w-y.left;for(let G=0;G<m;++G){let z=Number.MIN_SAFE_INTEGER,q=0,Q=0;for(let K=0;K<v;++K){let ee=L+K*N;if(ee>=0&&ee<p)for(let Y=0;Y<I;++Y){let de=B+Y*T;if(de>=0&&de<f){let ue=l[C][ee][de][G]+d[K][Y][G];ue>z&&(z=ue,q=K,Q=Y)}}}k[q][Q][G]+=A[C][M][O][G]}}}return{dataId:c.write($.toTypedArray(k,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},Lfe={kernelName:Fp,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:s,dy:a}=e,{strides:i,pad:o,dilations:u}=n,c=t,l=$.toNestedArray(r.shape,c.data.get(r.dataId).values),d=$.toNestedArray(s.shape,c.data.get(s.dataId).values),{batchSize:h,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:b,padInfo:y,strideHeight:x,strideWidth:w,filterHeight:v,filterWidth:I,dilationHeight:N,dilationWidth:T,outShape:E}=P.computeDilation2DInfo(r.shape,s.shape,i,o,"NHWC",u);$.assert(a.rank===E.length,()=>`Error in ${Fp}, dy must have the same rank as output ${E.length}, but got ${a.rank}`);let A=$.toNestedArray(E,c.data.get(a.dataId).values),k=$.makeZerosNestedTypedArray(r.shape,r.dtype);for(let C=0;C<h;++C)for(let M=0;M<g;++M){let L=M*x-y.top;for(let O=0;O<b;++O){let B=O*w-y.left;for(let G=0;G<m;++G){let z=Number.MIN_SAFE_INTEGER,q=L<0?0:L,Q=B<0?0:B;for(let K=0;K<v;++K){let ee=L+K*N;if(ee>=0&&ee<p)for(let Y=0;Y<I;++Y){let de=B+Y*T;if(de>=0&&de<f){let ue=l[C][ee][de][G]+d[K][Y][G];ue>z&&(z=ue,q=ee,Q=de)}}}k[C][q][Q][G]+=A[C][M][O][G]}}}return{dataId:c.write($.toTypedArray(k,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};function Pfe(e){let{inputs:t,backend:n,attrs:r}=e,{image:s}=t,{canvas:a,options:i}=r,{contextOptions:o,imageOptions:u}=i||{},c=u?.alpha||1,l=o?.contextType||"2d";if(l!=="2d")throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);let d=a.getContext(l,o?.contextAttributes||{});if(d==null)throw new Error(`Could not get the context with ${l} type.`);let[h,p]=s.shape.slice(0,2),f=s.shape.length===2?1:s.shape[2],m=n.data.get(s.dataId).values,g=s.dtype==="float32"?255:1,b=new Uint8ClampedArray(p*h*4);for(let x=0;x<h*p;++x){let w=[0,0,0,255*c];for(let I=0;I<f;I++){let N=m[x*f+I];if(s.dtype==="float32"){if(N<0||N>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${N}.`)}else if(s.dtype==="int32"&&(N<0||N>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${N}.`);f===1?(w[0]=N*g,w[1]=N*g,w[2]=N*g):w[I]=N*g}let v=x*4;b[v+0]=Math.round(w[0]),b[v+1]=Math.round(w[1]),b[v+2]=Math.round(w[2]),b[v+3]=Math.round(w[3])}a.width=p,a.height=h;let y=new ImageData(b,p,h);return d.putImageData(y,0,0),s}var Bfe={kernelName:gw,backendName:"cpu",kernelFunc:Pfe};function B0(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;mt(s,"sum");let o;s.dtype==="bool"?o=ou({inputs:{x:s},backend:n,attrs:{dtype:"int32"}}):o=Ao({inputs:{x:s},backend:n});let u=o.shape.length,c=$.parseAxisParam(a,o.shape),l=P.getAxesPermutation(c,u),d=c,h=o;l!=null&&(h=ca({inputs:{x:o},backend:n,attrs:{perm:l}}),d=P.getInnerMostAxes(d.length,u)),P.assertAxesAreInnerMostDims("sum",d,h.shape.length);let[p,f]=P.computeOutAndReduceShapes(h.shape,d),m=P.upcastType(h.dtype,"int32"),g=kx(n,p,m),b=$.sizeFromShape(f),y=n.data.get(g.dataId).values,x=n.data.get(h.dataId).values;for(let w=0;w<y.length;++w){let v=w*b,I=0;for(let N=0;N<b;++N)I+=x[v+N];y[w]=I}if(i){let w=P.expandShapeToKeepDim(g.shape,c),v=g;g=Zn({inputs:{x:g},backend:n,attrs:{shape:w}}),n.disposeIntermediateTensorInfo(v)}return n.disposeIntermediateTensorInfo(o),l!=null&&n.disposeIntermediateTensorInfo(h),g}var zfe={kernelName:$h,backendName:"cpu",kernelFunc:B0};function Wfe(e){let{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,a=t,{allDims:i,summedDims:o,idDims:u}=P.decodeEinsumEquation(s,a.length);P.checkEinsumDimSizes(i.length,u,a);let{path:c,steps:l}=P.getEinsumComputePath(o,u),d=l.length,h=null,p=i.length,f=[];for(let m=0;m<d;++m){for(let g of l[m]){let{permutationIndices:b,expandDims:y}=P.getEinsumPermutation(p,u[g]),x;P.isIdentityPermutation(b)?x=a[g]:(x=ca({inputs:{x:a[g]},backend:n,attrs:{perm:b}}),f.push(x));let w=x.shape.slice();for(let v=0;v<y.length;++v)w.splice(y[v],0,1);$.arraysEqual(x.shape,w)||(x=Zn({inputs:{x},backend:n,attrs:{shape:w}}),f.push(x)),h===null?h=x:(h=$v({inputs:{a:x,b:h},backend:n}),f.push(h))}m<d-1&&(c[m]>=0&&(h=B0({inputs:{x:h},backend:n,attrs:{axis:c[m]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(let m of f)m!==h&&n.disposeIntermediateTensorInfo(m);return h}var Vfe={kernelName:bw,backendName:"cpu",kernelFunc:Wfe};function Ufe(e){let{inputs:t,backend:n}=e,{dy:r,y:s}=t;mt([r,s],"eluGrad");let a=new Float32Array($.sizeFromShape(s.shape)),i=n.data.get(s.dataId).values,o=n.data.get(r.dataId).values;for(let u=0;u<i.length;++u){let c=i[u];c>=0?a[u]=o[u]:a[u]=o[u]*(c+1)}return n.makeTensorInfo(s.shape,"float32",a)}var Gfe={kernelName:Ef,backendName:"cpu",kernelFunc:Ufe},Hfe=P.ERF_P,jfe=P.ERF_A1,qfe=P.ERF_A2,Kfe=P.ERF_A3,Xfe=P.ERF_A4,Qfe=P.ERF_A5,Yfe=Dn(zd,e=>{let t=Math.sign(e),n=Math.abs(e),r=1/(1+Hfe*n);return t*(1-((((Qfe*r+Xfe)*r+Kfe)*r+qfe)*r+jfe)*r*Math.exp(-n*n))}),Jfe={kernelName:zd,backendName:"cpu",kernelFunc:Yfe};function Nx(e){let{inputs:t,backend:n,attrs:r}=e,{input:s}=t,{dim:a}=r,i=s.shape.length,o=s.shape.slice(),u=a;return a<0&&($.assert(-(i+1)<=a,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+a+1),o.splice(u,0,1),Zn({inputs:{x:s},backend:n,attrs:{shape:o}})}var Zfe={kernelName:$f,backendName:"cpu",kernelFunc:Nx},eme=Cr((e,t)=>e/t),c4=Qr(Pd,eme),DC={kernelName:Pd,backendName:"cpu",kernelFunc:c4};function S9(e,t,n){let r=e.shape,s=r[0],a=r[1],i=n.data.get(e.dataId),o=i.complexTensorInfos.real,u=i.complexTensorInfos.imag,c=[s,a],l=$.sizeFromShape(c),d=$.getTypedArrayFromDType("float32",l),h=$.getTypedArrayFromDType("float32",l);for(let g=0;g<s;g++){let b=Qc({inputs:{x:o},backend:n,attrs:{begin:[g,0],size:[1,a]}}),y=Qc({inputs:{x:u},backend:n,attrs:{begin:[g,0],size:[1,a]}}),x=wa({inputs:{real:b,imag:y},backend:n}),{real:w,imag:v}=tme(x,t,n),I=P.mergeRealAndImagArrays(w,v);for(let N=0;N<a;N++){let T=P.getComplexWithIndex(I,N);d[g*a+N]=T.real,h[g*a+N]=T.imag}n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(x)}let p=n.makeTensorInfo(c,"float32",d),f=n.makeTensorInfo(c,"float32",h),m=wa({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}function tme(e,t,n){let r=$.sizeFromShape(e.shape),s=n.data.get(e.dataId),a=n.data.get(s.complexTensorInfos.real.dataId).values,i=n.data.get(s.complexTensorInfos.imag.dataId).values;if(nme(r)){let o=FC(a,i,r,t,n),u=[e.shape[0],e.shape[1]];if(t){let c=n.makeTensorInfo(u,"float32",o.real),l=n.makeTensorInfo(u,"float32",o.imag),d=n.makeTensorInfo([],"float32",$.createScalarValue(r,"float32")),h=Ao({inputs:{x:d},backend:n}),p=DC.kernelFunc({inputs:{a:c,b:d},backend:n}),f=DC.kernelFunc({inputs:{a:l,b:h},backend:n}),m=n.data.get(p.dataId).values,g=n.data.get(f.dataId).values;return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),{real:m,imag:g}}return o}else{let o=P.mergeRealAndImagArrays(a,i),u=rme(o,r,t);return P.splitRealAndImagArrays(u)}}function nme(e){return(e&e-1)===0}function FC(e,t,n,r,s){if(n===1)return{real:e,imag:t};let a=P.mergeRealAndImagArrays(e,t),i=n/2,o=P.complexWithEvenIndex(a),u=o.real,c=o.imag,l=[u.length],d=s.makeTensorInfo(l,"float32",u),h=s.makeTensorInfo(l,"float32",c),p=wa({inputs:{real:d,imag:h},backend:s}),f=P.complexWithOddIndex(a),m=f.real,g=f.imag,b=[m.length],y=s.makeTensorInfo(b,"float32",m),x=s.makeTensorInfo(b,"float32",g),w=wa({inputs:{real:y,imag:x},backend:s}),v=FC(u,c,i,r,s),I=v.real,N=v.imag,T=[I.length],E=s.makeTensorInfo(T,"float32",I),A=s.makeTensorInfo(T,"float32",N),k=wa({inputs:{real:E,imag:A},backend:s}),C=FC(m,g,i,r,s),M=C.real,L=C.imag,O=[M.length],B=s.makeTensorInfo(O,"float32",M),G=s.makeTensorInfo(O,"float32",L),z=wa({inputs:{real:B,imag:G},backend:s}),q=P.exponents(n,r),Q=[q.real.length],K=s.makeTensorInfo(Q,"float32",q.real),ee=s.makeTensorInfo(Q,"float32",q.imag),Y=wa({inputs:{real:K,imag:ee},backend:s}),de=$v({inputs:{a:Y,b:z},backend:s}),ue=qp({inputs:{a:k,b:de},backend:s}),Ie=o4({inputs:{a:k,b:de},backend:s}),Ee=Xc({inputs:{input:ue},backend:s}),ve=Xc({inputs:{input:Ie},backend:s}),Ae=Kp({inputs:{input:ue},backend:s}),Be=Kp({inputs:{input:Ie},backend:s}),Ue=Xp({inputs:[Ee,ve],backend:s,attrs:{axis:0}}),qe=Xp({inputs:[Ae,Be],backend:s,attrs:{axis:0}}),ut=s.data.get(Ue.dataId).values,nt=s.data.get(qe.dataId).values;return s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(p),s.disposeIntermediateTensorInfo(y),s.disposeIntermediateTensorInfo(x),s.disposeIntermediateTensorInfo(w),s.disposeIntermediateTensorInfo(E),s.disposeIntermediateTensorInfo(A),s.disposeIntermediateTensorInfo(k),s.disposeIntermediateTensorInfo(B),s.disposeIntermediateTensorInfo(G),s.disposeIntermediateTensorInfo(z),s.disposeIntermediateTensorInfo(K),s.disposeIntermediateTensorInfo(ee),s.disposeIntermediateTensorInfo(Y),s.disposeIntermediateTensorInfo(de),s.disposeIntermediateTensorInfo(ue),s.disposeIntermediateTensorInfo(Ie),s.disposeIntermediateTensorInfo(Ee),s.disposeIntermediateTensorInfo(Ae),s.disposeIntermediateTensorInfo(ve),s.disposeIntermediateTensorInfo(Be),s.disposeIntermediateTensorInfo(Ue),s.disposeIntermediateTensorInfo(qe),{real:ut,imag:nt}}function rme(e,t,n){let r=new Float32Array(t*2);for(let s=0;s<t;s++){let a=0,i=0;for(let o=0;o<t;o++){let u=P.exponent(s*o,t,n),c=P.getComplexWithIndex(e,o);a+=c.real*u.real-c.imag*u.imag,i+=c.real*u.imag+c.imag*u.real}n&&(a/=t,i/=t),P.assignToTypedArray(r,a,i,s)}return r}function sme(e){let{inputs:t,backend:n}=e,{input:r}=t,s=$.sizeFromShape(r.shape),a=r.shape[r.shape.length-1],i=s/a,o=Zn({inputs:{x:r},backend:n,attrs:{shape:[i,a]}}),u=S9(o,!1,n),c=Zn({inputs:{x:u},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),c}var ame={kernelName:yw,backendName:"cpu",kernelFunc:sme};function d4(e){let{backend:t,attrs:n}=e,{shape:r,value:s,dtype:a}=n,i=a||$.inferDtype(s),o=$.getArrayFromDType(i,$.sizeFromShape(r));return ome(o,s),t.makeTensorInfo(r,i,o)}var ime={kernelName:Qy,backendName:"cpu",kernelFunc:d4};function ome(e,t,n){e.fill(t)}var lme={kernelName:Rf,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,s=n,a=$.getTypedArrayFromDType(r.dtype,$.sizeFromShape(r.shape)),[i,o,u,c]=r.shape,l=s.data.get(r.dataId).values;for(let d=0;d<i;d++){let h=d*u*o*c;for(let p=0;p<o;p++){let f=p*(u*c);for(let m=0;m<u;m++){let g=m*c;for(let b=0;b<c;b++){let y=Math.round(u-m-1),x=h+f+g+b,w=l[x];if(y>=0&&y<u){let v=y*c,I=h+f+v+b;w=l[I]}a[x]=w}}}}return{dataId:s.write(a,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};function ume(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:u,pad:c,dataFormat:l,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r,m=k9({inputs:{x:s,filter:a},backend:n,attrs:{strides:u,pad:c,dataFormat:l,dilations:d,dimRoundingMode:h}});if(i){let g=m;if(l==="NCHW"&&i.shape.length===1&&i.shape[0]!==1){let b=Zn({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=qp({inputs:{a:m,b},backend:n}),n.disposeIntermediateTensorInfo(b)}else m=qp({inputs:{a:m,b:i},backend:n});n.disposeIntermediateTensorInfo(g)}if(p){let g=m;if(l==="NCHW"&&p==="prelu"&&o.shape.length===1&&o.shape[0]!==1){let b=Zn({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=Sx(n,m,p,b,f),n.disposeIntermediateTensorInfo(b)}else m=Sx(n,m,p,o,f);n.disposeIntermediateTensorInfo(g)}return m}var cme={kernelName:Lc,backendName:"cpu",kernelFunc:ume};function dme(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:u,pad:c,dataFormat:l,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r,m=C9({inputs:{x:s,filter:a},backend:n,attrs:{strides:u,pad:c,dataFormat:l,dilations:d,dimRoundingMode:h}});if(i){let g=m;m=qp({inputs:{a:m,b:i},backend:n}),n.disposeIntermediateTensorInfo(g)}if(p){let g=m;m=Sx(n,m,p,o,f),n.disposeIntermediateTensorInfo(g)}return m}var hme={kernelName:Pc,backendName:"cpu",kernelFunc:dme};function pme(e){let{inputs:t,backend:n}=e,{params:r,indices:s}=t,a=$.sizeFromShape(r.shape),i=s.shape,o=i[i.length-1],[u,c,l,d]=P.prepareAndValidate(r,s);if(c===0)return n.makeTensorInfo(u,r.dtype,[]);let h=n.data.get(s.dataId).values,p=n.bufferSync(r),f=WO(h,p,r.dtype,c,o,l,d,r.shape,a);return n.makeTensorInfo(u,r.dtype,f.values)}var fme={kernelName:Df,backendName:"cpu",kernelFunc:pme};function mme(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,indices:a}=t,{axis:i,batchDims:o}=r;mt([s,a],"gatherV2");let u=$.parseAxisParam(i,s.shape)[0],c=n.data.get(a.dataId).values,l=s.shape[u];for(let w=0;w<c.length;++w){let v=c[w];$.assert(v<=l-1&&v>=0,()=>`GatherV2: the index value ${v} is not in [0, ${l-1}]`)}let d=o;o==null&&(d=0);let h=$.sizeFromShape(a.shape),p=P.segment_util.collectGatherOpShapeInfo(s,a,u,d),f=Zn({inputs:{x:s},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=Zn({inputs:{x:a},backend:n,attrs:{shape:[p.batchSize,h/p.batchSize]}}),g=[p.batchSize,p.outerSize,h/p.batchSize,p.sliceSize],b=n.bufferSync(m),y=n.bufferSync(f),x=VO(y,b,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(p.outputShape,x.dtype,x.values)}var gme={kernelName:_f,backendName:"cpu",kernelFunc:mme};function bme(e){let{inputs:t,backend:n}=e,{input:r}=t,s=$.sizeFromShape(r.shape),a=r.shape[r.shape.length-1],i=s/a,o=Zn({inputs:{x:r},backend:n,attrs:{shape:[i,a]}}),u=S9(o,!0,n),c=Zn({inputs:{x:u},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),c}var yme={kernelName:xw,backendName:"cpu",kernelFunc:bme},xme=Dn(Kd,e=>Number.isFinite(e)?1:0,"bool"),wme={kernelName:Kd,backendName:"cpu",kernelFunc:xme},vme=Dn(Xd,e=>Math.abs(e)===1/0?1:0,"bool"),Ime={kernelName:Xd,backendName:"cpu",kernelFunc:vme},kme=Dn(Qd,e=>Number.isNaN(e)?1:0,"bool"),Cme={kernelName:Qd,backendName:"cpu",kernelFunc:kme};function Sme(e){let{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,i=qO(r,s,a);return t.makeTensorInfo([i.length],"float32",i)}var Nme={kernelName:Lf,backendName:"cpu",kernelFunc:Sme},Tme=Dn(Zd,e=>Math.log1p(e)),Eme={kernelName:Zd,backendName:"cpu",kernelFunc:Tme},Ame=Cr((e,t)=>e&&t),$me=Qr(Pf,Ame,null,"bool"),Rme={kernelName:Pf,backendName:"cpu",kernelFunc:$me},_me=Dn(Bf,e=>e?0:1,"bool"),Dme={kernelName:Bf,backendName:"cpu",kernelFunc:_me},Fme=Cr((e,t)=>e||t),Mme=Qr(zf,Fme,null,"bool"),Ome={kernelName:zf,backendName:"cpu",kernelFunc:Mme};function Lme(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:i,alpha:o,beta:u}=r;mt(s,"LRN");let c=s.shape[3],l=c-1,d=n.data.get(s.dataId).values,h=$.sizeFromShape(s.shape),p=new Float32Array(h);function f(m){let g=m%c,b=m-g+Math.max(0,g-a),y=m-g+Math.min(g+a,l),x=0;for(;b<=y;b++){let w=d[b];x+=w*w}return x}for(let m=0;m<h;m++){let g=f(m),b=d[m]*Math.pow(i+o*g,-u);p[m]=b}return n.makeTensorInfo(s.shape,s.dtype,p)}var Pme={kernelName:eh,backendName:"cpu",kernelFunc:Lme};function Bme(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:i}=t,{depthRadius:o,bias:u,alpha:c,beta:l}=r;mt(i,"LRNGrad");let d=$.sizeFromShape(i.shape),h=i.shape[3],p=n.data.get(i.dataId).values,f=n.data.get(s.dataId).values,m=n.data.get(a.dataId).values,g=new Float32Array(d),b=d;for(let y=0;y<b;y++){let x=y%h,w=y-x+Math.max(0,x-o),v=y-x+Math.min(h,x+o+1),I=0;for(let N=w;N<v;N++)I+=Math.pow(f[N],2);I=c*I+u;for(let N=w;N<v;N++){let T=-2*c*l*f[N]*m[y]/I;y===N&&(T+=Math.pow(I,-l)),T*=p[y],g[N]+=T}}return n.makeTensorInfo(i.shape,s.dtype,g)}var zme={kernelName:Wf,backendName:"cpu",kernelFunc:Bme};function N9(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:a,keepDims:i}=r,o=n,u=s.shape,c=u.length,l=$.parseAxisParam(a,u),d=l,h=P.getAxesPermutation(d,c),p=o.data.get(s.dataId).values;if(h!=null){let w=new Array(c);for(let v=0;v<w.length;v++)w[v]=u[h[v]];p=t4(p,u,s.dtype,h,w),d=P.getInnerMostAxes(d.length,c),u=w}mt(s,"max"),P.assertAxesAreInnerMostDims("max",d,c);let[f,m]=P.computeOutAndReduceShapes(u,d),g=$.sizeFromShape(m),b=XO(p,g,f,s.dtype),y=o.write(b,f,s.dtype),x=f;return i&&(x=P.expandShapeToKeepDim(f,l)),{dataId:y,shape:x,dtype:s.dtype}}var Wme={kernelName:th,backendName:"cpu",kernelFunc:N9};function Vme(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t;mt(s,"maxPool");let{filterSize:a,strides:i,pad:o,dimRoundingMode:u}=r,c=1;$.assert(P.eitherStridesOrDilationsAreOne(i,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);let l=P.computePool2DInfo(s.shape,a,i,c,o,u),d;if(l.filterWidth===1&&l.filterHeight===1&&$.arraysEqual(l.inShape,l.outShape))d=Ao({inputs:{x:s},backend:n});else{let h=n.data.get(s.dataId).values,p=$.computeStrides(s.shape),f=u4(h,s.shape,s.dtype,p,l,"max");d=n.makeTensorInfo(l.outShape,s.dtype,f.values)}return d}var Ume={kernelName:rh,backendName:"cpu",kernelFunc:Vme};function Gme(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:u,dataFormat:c}=r;mt(s,"maxPool3d");let l=P.computePool3DInfo(s.shape,a,i,1,o,u,c),d=n.data.get(s.dataId).values,h=I9(d,s.shape,s.dtype,$.computeStrides(s.shape),l,"max");return n.makeTensorInfo(h.shape,"float32",h.values)}var Hme={kernelName:Vf,backendName:"cpu",kernelFunc:Gme};function jme(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:u,dimRoundingMode:c}=r;mt([s,a],"maxPool3DGrad");let l=P.computePool3DInfo(a.shape,i,o,1,u,c),d=n.bufferSync(a),h=Fpe(d,l),p=l.strideDepth,f=l.strideHeight,m=l.strideWidth,g=l.dilationDepth,b=l.dilationHeight,y=l.dilationWidth,x=l.effectiveFilterDepth,w=l.effectiveFilterHeight,v=l.effectiveFilterWidth,I=x-1-l.padInfo.front,N=v-1-l.padInfo.left,T=w-1-l.padInfo.top,E=Ht(a.shape,"float32"),A=n.bufferSync(s);for(let k=0;k<l.batchSize;++k)for(let C=0;C<l.inChannels;++C)for(let M=0;M<l.inDepth;++M)for(let L=0;L<l.inHeight;++L)for(let O=0;O<l.inWidth;++O){let B=M-I,G=L-T,z=O-N,q=0;for(let Q=0;Q<x;Q+=g){let K=(B+Q)/p;if(!(K<0||K>=l.outDepth||Math.floor(K)!==K))for(let ee=0;ee<w;ee+=b){let Y=(G+ee)/f;if(!(Y<0||Y>=l.outHeight||Math.floor(Y)!==Y))for(let de=0;de<v;de+=y){let ue=(z+de)/m;if(ue<0||ue>=l.outWidth||Math.floor(ue)!==ue)continue;let Ie=x*w*v-1-h.get(k,K,Y,ue,C),Ee=Q*w*v+ee*v+de,ve=Ie===Ee?1:0;if(ve===0)continue;let Ae=A.get(k,K,Y,ue,C);q+=Ae*ve}}}E.set(q,k,M,L,O,C)}return n.makeTensorInfo(E.shape,E.dtype,E.values)}var qme={kernelName:Jy,backendName:"cpu",kernelFunc:jme};function Kme(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a,output:i}=t,o=a;mt([a,i],"maxPoolGrad");let{filterSize:u,strides:c,pad:l,dimRoundingMode:d}=r,h=P.computePool2DInfo(o.shape,u,c,1,l,d),p=n.data.get(o.dataId).values,f=Ht(h.outShape,o.dtype,v9(p,o.shape,o.dtype,h).values),m=h.strideHeight,g=h.strideWidth,b=h.dilationHeight,y=h.dilationWidth,x=h.effectiveFilterHeight,w=h.effectiveFilterWidth,v=w-1-h.padInfo.left,I=x-1-h.padInfo.top,N=Ht(o.shape,"float32"),T=n.data.get(s.dataId).values,E=Ht(s.shape,"float32",T);for(let A=0;A<h.batchSize;++A)for(let k=0;k<h.inChannels;++k)for(let C=0;C<h.inHeight;++C)for(let M=0;M<h.inWidth;++M){let L=C-I,O=M-v,B=0;for(let G=0;G<x;G+=b){let z=(L+G)/m;if(!(z<0||z>=h.outHeight||Math.floor(z)!==z))for(let q=0;q<w;q+=y){let Q=(O+q)/g;if(Q<0||Q>=h.outWidth||Math.floor(Q)!==Q)continue;let K=x*w-1-f.get(A,z,Q,k),ee=G*w+q,Y=K===ee?1:0;if(Y===0)continue;let de=E.get(A,z,Q,k);B+=de*Y}}N.set(B,A,C,M,k)}return n.makeTensorInfo(N.shape,N.dtype,N.values)}var Xme={kernelName:Yy,backendName:"cpu",kernelFunc:Kme};function Qme(e,t,n,r,s){let a=$.computeStrides(t),i=u4(e,t,n,a,s,"max"),o=v9(e,t,n,s,!0,r);return[i.values,o.values]}var Yme={kernelName:Zy,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{filterSize:s,strides:a,pad:i,includeBatchInIndex:o}=t,u=n;mt(r,"MaxPoolWithArgmax");let c=u.data.get(r.dataId).values,l=P.computePool2DInfo(r.shape,s,a,[1,1],i),[d,h]=Qme(c,r.shape,r.dtype,o,l),p=u.write(d,l.outShape,r.dtype),f=u.write(h,l.outShape,r.dtype);return[{dataId:p,shape:l.outShape,dtype:r.dtype},{dataId:f,shape:l.outShape,dtype:"int32"}]}};function Jme(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=$.parseAxisParam(a,s.shape),u=P.computeOutAndReduceShapes(s.shape,o)[1],c=$.sizeFromShape(u),l=[],d=n.makeTensorInfo([],"float32",new Float32Array([c]));l.push(d);let h=ou({inputs:{x:s},backend:n,attrs:{dtype:"float32"}});l.push(h);let p=c4({inputs:{a:h,b:d},backend:n});l.push(p);let f=B0({inputs:{x:p},backend:n,attrs:{axis:a,keepDims:i}});return l.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}var Zme={kernelName:sh,backendName:"cpu",kernelFunc:Jme};function ege(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;mt(s,"min");let o=$.parseAxisParam(a,s.shape),u=o,c=P.getAxesPermutation(u,s.shape.length),l=s;c!=null&&(l=ca({inputs:{x:s},backend:n,attrs:{perm:c}}),u=P.getInnerMostAxes(u.length,s.shape.length)),P.assertAxesAreInnerMostDims("min",u,l.shape.length);let[d,h]=P.computeOutAndReduceShapes(l.shape,u),p=$.sizeFromShape(h),f=$.makeZerosTypedArray($.sizeFromShape(d),l.dtype),m=n.data.get(l.dataId).values;for(let b=0;b<f.length;++b){let y=b*p,x=m[y];for(let w=0;w<p;++w){let v=m[y+w];(Number.isNaN(v)||v<x)&&(x=v)}f[b]=x}c!=null&&n.disposeIntermediateTensorInfo(l);let g=n.makeTensorInfo(d,l.dtype,f);if(i){let b=P.expandShapeToKeepDim(d,o),y=Zn({inputs:{x:g},backend:n,attrs:{shape:b}});return n.disposeIntermediateTensorInfo(g),y}return g}var tge={kernelName:ah,backendName:"cpu",kernelFunc:ege};function nge(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,mode:i}=r;mt(s,"mirrorPad");let o=a.map((y,x)=>y[0]+s.shape[x]+y[1]),u=a.map(y=>y[0]),c=a.map((y,x)=>y[0]+s.shape[x]),l=i==="reflect"?0:1,d=n.data.get(s.dataId).values,h=s.shape.length,p=$.computeStrides(s.shape),f=$.sizeFromShape(o),m=o.length,g=$.computeStrides(o),b=$.getTypedArrayFromDType(s.dtype,f);for(let y=0;y<f;y++){let x=$.indexToLoc(y,m,g);for(let v=0;v<m;v++)x[v]<u[v]?x[v]=u[v]*2-x[v]-l:x[v]>=c[v]&&(x[v]=(c[v]-1)*2-x[v]+l);x=x.map((v,I)=>v-u[I]);let w=$.locToIndex(x,h,p);b[y]=d[w]}return{dataId:n.write(b,o,s.dtype),shape:o,dtype:s.dtype}}var rge={kernelName:oh,backendName:"cpu",kernelFunc:nge},sge=Cr((e,t)=>{let n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t}),age=Qr(lh,sge),ige={kernelName:lh,backendName:"cpu",kernelFunc:age},oge=bu(lw());function T9(e){let{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:a}=r,i=s.shape.length,o=a;if(o===-1&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);let u=$.parseAxisParam([o],s.shape),c=N9({inputs:{x:s},backend:n,attrs:{reductionIndices:u,keepDims:!1}}),l=P.expandShapeToKeepDim(c.shape,u),d=Zn({inputs:{x:c},backend:n,attrs:{shape:l}}),h=o4({inputs:{a:s,b:d},backend:n}),p=LO({inputs:{x:h},backend:n}),f=B0({inputs:{x:p},backend:n,attrs:{axis:u,keepDims:!1}}),m=Zn({inputs:{x:f},backend:n,attrs:{shape:l}}),g=c4({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}var lge={kernelName:Rh,backendName:"cpu",kernelFunc:T9};function uge(e){let{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:i,normalized:o}=r;mt(s,"multinomial");let u=o?s:T9({inputs:{logits:s},backend:n,attrs:{dim:-1}}),c=u.shape[0],l=u.shape[1],d=n.data.get(u.dataId).values,h=[c,a],p=$.makeZerosTypedArray($.sizeFromShape(h),"int32");for(let f=0;f<c;++f){let m=f*l,g=new Float32Array(l-1);g[0]=d[m];for(let x=1;x<g.length;++x)g[x]=g[x-1]+d[m+x];let b=oge.alea(i.toString()),y=f*a;for(let x=0;x<a;++x){let w=b();p[y+x]=g.length;for(let v=0;v<g.length;v++)if(w<g[v]){p[y+x]=v;break}}}return o||n.disposeIntermediateTensorInfo(u),n.makeTensorInfo(h,"int32",p)}var cge={kernelName:Uf,backendName:"cpu",kernelFunc:uge},dge=Lo.nonMaxSuppressionV3Impl;function hge(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u}=r;mt(s,"NonMaxSuppression");let c=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,{selectedIndices:d}=dge(c,l,i,o,u);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}var pge={kernelName:jf,backendName:"cpu",kernelFunc:hge},fge=Lo.nonMaxSuppressionV4Impl;function mge(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u,padToMaxOutputSize:c}=r;mt(s,"NonMaxSuppressionPadded");let l=n.data.get(s.dataId).values,d=n.data.get(a.dataId).values,{selectedIndices:h,validOutputs:p}=fge(l,d,i,o,u,c);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}var gge={kernelName:qf,backendName:"cpu",kernelFunc:mge},bge=Lo.nonMaxSuppressionV5Impl;function yge(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u,softNmsSigma:c}=r;mt(s,"NonMaxSuppressionWithScore");let l=n.data.get(s.dataId).values,d=n.data.get(a.dataId).values,h=i,p=o,f=u,m=c,{selectedIndices:g,selectedScores:b}=bge(l,d,h,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}var xge={kernelName:Kf,backendName:"cpu",kernelFunc:yge};function wge(e){let{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{dtype:a,depth:i,onValue:o,offValue:u}=r;mt(s,"oneHot");let c=$.sizeFromShape(s.shape),l=new Float32Array(c*i);l.fill(u);let d=n.data.get(s.dataId).values;for(let h=0;h<c;++h)d[h]>=0&&d[h]<i&&(l[h*i+d[h]]=o);return n.makeTensorInfo([...s.shape,i],a,l)}var vge={kernelName:ch,backendName:"cpu",kernelFunc:wge};function Tx(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(r.dtype==="complex64"){let s=Xc({inputs:{input:r},backend:n}),a=Tx({inputs:{x:s},backend:n}),i=Kp({inputs:{input:r},backend:n}),o=Tx({inputs:{x:i},backend:n}),u=wa({inputs:{real:a,imag:o},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),u}else return d4({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}var Ige={kernelName:pm,backendName:"cpu",kernelFunc:Tx};function E9(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(r.dtype==="complex64"){let s=Xc({inputs:{input:r},backend:n}),a=E9({inputs:{x:s},backend:n}),i=Kp({inputs:{input:r},backend:n}),o=Tx({inputs:{x:i},backend:n}),u=wa({inputs:{real:a,imag:o},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),u}else return d4({backend:n,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}var kge={kernelName:Xf,backendName:"cpu",kernelFunc:E9};function A9(e){let{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(t.length===1)return Nx({inputs:{input:t[0]},backend:n,attrs:{dim:s}});let a=t[0].shape,i=t[0].dtype;t.forEach(l=>{$.assertShapesMatch(a,l.shape,"All tensors passed to stack must have matching shapes"),$.assert(i===l.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],u=t.map(l=>{let d=Nx({inputs:{input:l},backend:n,attrs:{dim:s}});return o.push(d),d}),c=Xp({inputs:u,backend:n,attrs:{axis:s}});return o.forEach(l=>n.disposeIntermediateTensorInfo(l)),c}var Cge={kernelName:Qf,backendName:"cpu",kernelFunc:A9};function Sge(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,constantValue:i}=r;mt(s,"pad");let o=a.map((b,y)=>b[0]+s.shape[y]+b[1]),u=a.map(b=>b[0]),c=n.data.get(s.dataId).values,l=$.sizeFromShape(s.shape),d=s.shape.length,h=$.computeStrides(s.shape),p=$.sizeFromShape(o),f=o.length,m=$.computeStrides(o),g=$.getTypedArrayFromDType(s.dtype,p);i!==0&&g.fill(i);for(let b=0;b<l;b++){let y=$.indexToLoc(b,d,h).map((w,v)=>w+u[v]),x=$.locToIndex(y,f,m);g[x]=c[b]}return{dataId:n.write(g,o,s.dtype),shape:o,dtype:s.dtype}}var $9={kernelName:dh,backendName:"cpu",kernelFunc:Sge},Nge=Cr((e,t)=>Math.pow(e,t)),Tge=Qr(hh,Nge),Ege={kernelName:hh,backendName:"cpu",kernelFunc:Tge};function Age(e){let{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:s,paramsDenseValues:a,indices:i}=t,{outputRaggedRank:o}=r,u=s.map(b=>n.data.get(b.dataId).values),c=s.map(b=>b.shape),l=n.data.get(a.dataId).values,d=n.data.get(i.dataId).values,[h,p,f]=t9(u,c,l,a.shape,a.dtype,d,i.shape),m=h.map(b=>n.makeTensorInfo([b.length],"int32",b)),g=n.makeTensorInfo(f,a.dtype,p);return m.concat([g])}var $ge={kernelName:vw,backendName:"cpu",kernelFunc:Age};function Rge(e){let{inputs:t,backend:n}=e,{starts:r,limits:s,deltas:a}=t,i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,[c,l]=n9(i,r.shape,r.dtype,o,s.shape,u,a.shape),d=n.makeTensorInfo([c.length],"int32",c),h=n.makeTensorInfo([l.length],r.dtype,l);return[d,h]}var _ge={kernelName:Iw,backendName:"cpu",kernelFunc:Rge};function Dge(e){let{inputs:t,backend:n,attrs:r}=e,{shape:s,values:a,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:u}=r,c=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,d=n.data.get(i.dataId).values,h=o.map(g=>n.data.get(g.dataId).values),p=o.map(g=>g.shape),[f,m]=r9(c,s.shape,l,a.shape,a.dtype,d,i.shape,h,p,u);return n.makeTensorInfo(f,a.dtype,m)}var Fge={kernelName:kw,backendName:"cpu",kernelFunc:Dge};function Mge(e){let{backend:t,attrs:n}=e,{start:r,stop:s,dtype:a,step:i}=n,o=n4(r,s,i,a);return t.makeTensorInfo([o.length],a,o)}var Oge={kernelName:e0,backendName:"cpu",kernelFunc:Mge},Lge=Dn(mh,e=>1/e),Pge={kernelName:mh,backendName:"cpu",kernelFunc:Lge};function Bge(e){let{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r;mt(s,"resizeBilinear");let u=$.computeStrides(s.shape),[c,l]=o,[d,h,p,f]=s.shape,m=n.data.get(s.dataId).values,g=new Float32Array($.sizeFromShape([d,c,l,f])),b=[a&&c>1?h-1:h,a&&l>1?p-1:p],y=[a&&c>1?c-1:c,a&&l>1?l-1:l],x=0,w=b[0]/y[0],v=b[1]/y[1];for(let I=0;I<d;I++)for(let N=0;N<c;N++){let T;i?T=w*(N+.5)-.5:T=w*N;let E=Math.max(0,Math.floor(T)),A=T-E,k=Math.min(h-1,Math.ceil(T)),C=I*u[0]+E*u[1],M=I*u[0]+k*u[1];for(let L=0;L<l;L++){let O;i?O=v*(L+.5)-.5:O=v*L;let B=Math.max(0,Math.floor(O)),G=O-B,z=Math.min(p-1,Math.ceil(O)),q=C+B*u[2],Q=M+B*u[2],K=C+z*u[2],ee=M+z*u[2];for(let Y=0;Y<f;Y++){let de=m[q+Y],ue=m[Q+Y],Ie=m[K+Y],Ee=m[ee+Y],ve=de+(Ie-de)*G,Ae=ue+(Ee-ue)*G,Be=ve+(Ae-ve)*A;g[x++]=Be}}}return n.makeTensorInfo([d,c,l,f],"float32",g)}var zge={kernelName:yh,backendName:"cpu",kernelFunc:Bge};function Wge(e){let{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r;mt([a,s],"resizeBilinearGrad");let o=$.computeStrides(s.shape),[u,c,l,d]=s.shape,[,h,p]=a.shape,f=new Float32Array(u*c*l*d),m=[i&&h>1?c-1:c,i&&p>1?l-1:l],g=[i&&h>1?h-1:h,i&&p>1?p-1:p],b=m[0]/g[0],y=m[1]/g[1],x=n.data.get(a.dataId).values,w=0;for(let v=0;v<u;v++){let I=v*o[0];for(let N=0;N<h;N++){let T=N*b,E=Math.floor(T),A=Math.min(Math.ceil(T),c-1),k=I+E*o[1],C=I+A*o[1],M=T-E,L=1-M;for(let O=0;O<p;O++){let B=O*y,G=Math.floor(B),z=Math.min(Math.ceil(B),l-1),q=B-G,Q=1-q,K=k+G*o[2],ee=k+z*o[2],Y=C+G*o[2],de=C+z*o[2],ue=L*Q,Ie=L*q,Ee=M*Q,ve=M*q;for(let Ae=0;Ae<d;Ae++){let Be=x[w++];f[K+Ae]+=Be*ue,f[ee+Ae]+=Be*Ie,f[Y+Ae]+=Be*Ee,f[de+Ae]+=Be*ve}}}}return n.makeTensorInfo([u,l,c,d],"float32",f)}var Vge={kernelName:Zf,backendName:"cpu",kernelFunc:Wge};function Uge(e){let{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r;mt(s,"resizeNearestNeighbor");let u=$.computeStrides(s.shape),[c,l]=o,[d,h,p,f]=s.shape,m=n.data.get(s.dataId).values,g=new Float32Array(d*c*l*f),b=[a&&c>1?h-1:h,a&&l>1?p-1:p],y=[a&&c>1?c-1:c,a&&l>1?l-1:l],x=b[0]/y[0],w=b[1]/y[1],v=0;for(let I=0;I<d;I++){let N=I*u[0];for(let T=0;T<c;T++){let E=i?x*(T+.5):x*T,A=Math.min(h-1,a?Math.round(E):Math.floor(E));i&&(A=Math.max(0,A));let k=N+A*u[1];for(let C=0;C<l;C++){let M=i?w*(C+.5):w*C,L=Math.min(p-1,a?Math.round(M):Math.floor(M));i&&(L=Math.max(0,L));let O=k+L*u[2];for(let B=0;B<f;B++){let G=m[O+B];g[v++]=G}}}}return n.makeTensorInfo([d,c,l,f],s.dtype,g)}var Gge={kernelName:bh,backendName:"cpu",kernelFunc:Uge};function Hge(e){let{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r;mt([a,s],"resizeNearestNeighborGrad");let o=$.computeStrides(s.shape),u=$.computeStrides(a.shape),[c,l,d,h]=s.shape,[,p,f]=a.shape,m=new Float32Array(c*l*d*h),g=n.data.get(a.dataId).values,b=[i&&p>1?l-1:l,i&&f>1?d-1:d],y=[i&&p>1?p-1:p,i&&f>1?f-1:f],x=b[0]/y[0],w=b[1]/y[1],v=1/x,I=1/w,N=Math.ceil(v)*2+2,T=Math.ceil(I)*2+2;for(let E=0;E<c;E++){let A=E*o[0];for(let k=0;k<l;k++){let C=A+k*o[1],M=Math.floor(k*v),L=Math.floor(M-N/2);for(let O=0;O<d;O++){let B=C+O*o[2],G=Math.floor(O*I),z=Math.floor(G-T/2);for(let q=0;q<h;q++){let Q=0;for(let K=0;K<N;K++){let ee=K+L;if(ee<0||ee>=p)continue;let Y=A+ee*u[1],de=ee*x,ue=Math.min(l-1,i?Math.round(de):Math.floor(de));if(k===ue)for(let Ie=0;Ie<T;Ie++){let Ee=Ie+z;if(Ee<0||Ee>=f)continue;let ve=Y+Ee*u[2],Ae=Ee*w,Be=Math.min(d-1,i?Math.round(Ae):Math.floor(Ae));O===Be&&(Q+=g[ve+q])}}m[B+q]=Q}}}}return n.makeTensorInfo(s.shape,s.dtype,m)}var jge={kernelName:Jf,backendName:"cpu",kernelFunc:Hge};function qge(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r;mt(s,"reverse");let i=s.shape.length,o=$.parseAxisParam(a,s.shape);if(i===0)return Ao({inputs:{x:s},backend:n});let u=new _r(s.shape,s.dtype),c=n.bufferSync(s);for(let l=0;l<u.size;l++){let d=u.indexToLoc(l),h=d.slice();o.forEach(p=>h[p]=s.shape[p]-1-h[p]),u.set(c.get(...h),...d)}return n.makeTensorInfo(u.shape,u.dtype,u.values)}var Kge={kernelName:wh,backendName:"cpu",kernelFunc:qge},Xge={kernelName:fm,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,{radians:s,fillValue:a,center:i}=t,o=n,u=$.getTypedArrayFromDType(r.dtype,$.sizeFromShape(r.shape)),[c,l,d,h]=r.shape,[p,f]=P.getImageCenter(i,l,d),m=255,g=Math.sin(s),b=Math.cos(s),y=o.data.get(r.dataId).values;for(let x=0;x<c;x++){let w=x*d*l*h;for(let v=0;v<l;v++){let I=v*(d*h);for(let N=0;N<d;N++){let T=N*h;for(let E=0;E<h;E++){let A=[c,v,N,E],k=A[2],C=A[1],M=(k-p)*b-(C-f)*g,L=(k-p)*g+(C-f)*b;M=Math.round(M+p),L=Math.round(L+f);let O=a;if(typeof a!="number"&&(E===3?O=m:O=a[E]),M>=0&&M<d&&L>=0&&L<l){let G=L*(d*h),z=M*h,q=w+G+z+E;O=y[q]}let B=w+I+T+E;u[B]=O}}}}return{dataId:o.write(u,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},Qge=Dn(vh,e=>{let t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1}),Yge={kernelName:vh,backendName:"cpu",kernelFunc:Qge};function Jge(e){let{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:a}=t,{shape:i}=r,{sliceRank:o,numUpdates:u,sliceSize:c,strides:l,outputSize:d}=P.calculateShapes(a,s,i),h=!0,p=n.bufferSync(s),f=n.bufferSync(a),m=Sc(p,f,i,d,c,u,o,l,0,h);return n.makeTensorInfo(i,m.dtype,m.values)}var Zge={kernelName:em,backendName:"cpu",kernelFunc:Jge};function ebe(e,t){let n=0,r=e.length,s=0;for(;n<r;)s=Math.floor((n+r)/2),e[s]<t?n=s+1:r=s;return r}function tbe(e,t){let n=0,r=e.length,s=0;for(;n<r;)s=Math.floor((n+r)/2),e[s]<=t?n=s+1:r=s;return r}function nbe(e,t,n,r,s,a){let i=$.getArrayFromDType("int32",n*s);for(let o=0;o<n;++o){let u=e.slice(o*r,(o+1)*r),c=o*s;for(let l=0;l<s;++l)i[c+l]=a==="left"?ebe(u,t[l+c]):tbe(u,t[l+c])}return i}function rbe(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:s,values:a}=t,{side:i}=r,o=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,c=nbe(o,u,s.shape[0],s.shape[1],a.shape[1],i);return n.makeTensorInfo(a.shape,"int32",c)}var sbe={kernelName:nm,backendName:"cpu",kernelFunc:rbe};function abe(e){let{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t;mt([r,s,a],"select");let i=r.shape.length,o=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,l=Ha(s.dtype,a.dtype),d=$.makeZerosTypedArray($.sizeFromShape(s.shape),l),h=0,p=i===0||i>1||s.shape.length===1?1:$.sizeFromShape(s.shape.slice(1));for(let f=0;f<o.length;f++)for(let m=0;m<p;m++)o[f]===1?d[h++]=u[f]:d[h++]=c[f];return n.makeTensorInfo(s.shape,l,d)}var ibe={kernelName:rm,backendName:"cpu",kernelFunc:abe},obe=P.SELU_SCALEALPHA,lbe=P.SELU_SCALE,ube=Dn(kh,e=>e>=0?lbe*e:obe*(Math.exp(e)-1)),cbe={kernelName:kh,backendName:"cpu",kernelFunc:ube},dbe=Dn(Nh,e=>e<0?-1:e>0?1:0),hbe={kernelName:Nh,backendName:"cpu",kernelFunc:dbe},pbe=Dn(Ch,e=>Math.sin(e)),fbe={kernelName:Ch,backendName:"cpu",kernelFunc:pbe},mbe=Dn(Sh,e=>Math.sinh(e)),gbe={kernelName:Sh,backendName:"cpu",kernelFunc:mbe},bbe=11920928955078125e-23,e_=Math.log(bbe)+2,ybe=Dn(Eh,e=>{let t=e>-e_,n=e<e_,r=Math.exp(e),s;return n?s=r:t?s=e:s=Math.log(1+r),s}),xbe={kernelName:Eh,backendName:"cpu",kernelFunc:ybe};function wbe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:i}=r;mt([s],"spaceToBatchND");let o=$.sizeFromShape(a),u=[[0,0]];u.push(...i);for(let g=1+a.length;g<s.shape.length;++g)u.push([0,0]);let c=$9.kernelFunc({inputs:{x:s},backend:n,attrs:{paddings:u,constantValue:0}}),l=P.getReshaped(c.shape,a,o,!1),d=P.getPermuted(l.length,a.length,!1),h=P.getReshapedPermuted(c.shape,a,o,!1),p=Zn({inputs:{x:c},backend:n,attrs:{shape:l}}),f=ca({inputs:{x:p},backend:n,attrs:{perm:d}}),m=Zn({inputs:{x:f},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}var vbe={kernelName:am,backendName:"cpu",kernelFunc:wbe};function Ibe(e){let{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:a,defaultValue:i}=t;if(a.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${a.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${s.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let o=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,l=n.data.get(i.dataId).values[0],[d,h,p,f,m]=i9(o,r.shape,r.dtype,u,s.dtype,c,l);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([h[0]],s.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}var kbe={kernelName:t0,backendName:"cpu",kernelFunc:Ibe};function Cbe(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:a}=t;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${s.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);let i=Array.from(n.data.get(s.dataId).values),o=n.data.get(r.dataId).values,u=Array.from(n.data.get(a.dataId).values),[c,l,d]=o9(o,r.shape,r.dtype,i,u);return[n.makeTensorInfo(l,r.dtype,c),n.makeTensorInfo([d.length],a.dtype,new Int32Array(d))]}var Sbe={kernelName:om,backendName:"cpu",kernelFunc:Cbe};function Nbe(e){let{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${a.shape}`);if(s.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");let i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,[c,l]=r4(i,r.shape,r.dtype,o,u,!0);return n.makeTensorInfo(l,r.dtype,c)}var Tbe={kernelName:n0,backendName:"cpu",kernelFunc:Nbe};function Ebe(e){let{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${a.shape}`);if(s.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");let i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,[c,l]=r4(i,r.shape,r.dtype,o,u);return n.makeTensorInfo(l,r.dtype,c)}var Abe={kernelName:r0,backendName:"cpu",kernelFunc:Ebe};function $be(e){let{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:u,numUpdates:c,sliceSize:l,strides:d,outputSize:h}=P.calculateShapes(a,s,o),p=!1,f=n.bufferSync(s),m;switch(a.dtype){case"bool":{let g=n.bufferSync(a),b=!!n.data.get(i.dataId).values[0];m=Sc(f,g,o,h,l,c,u,d,b,p);break}case"float32":{let g=n.bufferSync(a),b=n.data.get(i.dataId).values[0];m=Sc(f,g,o,h,l,c,u,d,b,p);break}case"int32":{let g=n.bufferSync(a),b=n.data.get(i.dataId).values[0];m=Sc(f,g,o,h,l,c,u,d,b,p);break}case"string":{let g=n.bufferSync(a),b=$.decodeString(n.data.get(i.dataId).values[0]);m=Sc(f,g,o,h,l,c,u,d,b,p);break}default:throw new Error(`Unsupported type ${a.dtype}`)}return n.makeTensorInfo(o,m.dtype,m.values)}var Rbe={kernelName:lm,backendName:"cpu",kernelFunc:$be};function _be(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:i}=r,o=$.parseAxisParam(i,s.shape)[0],u=P.prepareSplitSize(s,a,o),c=new Array(s.shape.length).fill(0),l=s.shape.slice();return u.map(d=>{let h=[...l];h[o]=d;let p=Qc({inputs:{x:s},backend:n,attrs:{begin:c,size:h}});return c[o]+=d,p})}var Dbe={kernelName:im,backendName:"cpu",kernelFunc:_be},Fbe={kernelName:s0,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{let{x:n}=e,r=t;mt(n,"square");let s=r.data.get(n.dataId).values,a=new Float32Array(s.length);for(let i=0;i<s.length;++i){let o=s[i];a[i]=o*o}return{dataId:r.write(a,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},Mbe=Dn(vu,(e,t)=>{let n=t;return isNaN(e)?NaN:e>0?1:n.alpha}),Obe={kernelName:vu,backendName:"cpu",kernelFunc:Mbe};function Lbe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,end:i,strides:o,beginMask:u,endMask:c,ellipsisMask:l,newAxisMask:d,shrinkAxisMask:h}=r;mt(s,"stridedSlice");let{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:b,begin:y,end:x,strides:w}=Gr.sliceInfo(s.shape,a,i,o,u,c,l,d,h),v;if(m)v=Zn({inputs:{x:s},backend:n,attrs:{shape:f}});else if(g||b){$.assert(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);let I=Gr.computeOutShape(y,x,w),N=Qc({inputs:{x:s},backend:n,attrs:{begin:y,size:I}});v=Zn({inputs:{x:N},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(N)}else{let I=n.bufferSync(s),N=c9(p,I,w,y);v=n.makeTensorInfo(f,N.dtype,N.values)}return v}var Pbe={kernelName:um,backendName:"cpu",kernelFunc:Lbe};function Bbe(e){let{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:a,leftPad:i,rightPad:o,padWidth:u,preserveShortSequences:c}=r,{data:l,dataSplits:d}=t,h=n.data.get(l.dataId).values,p=n.data.get(d.dataId).values,[f,m]=s4(h,p,s,a,i,o,u,c);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}var zbe={kernelName:i0,backendName:"cpu",kernelFunc:Bbe};function Wbe(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:a,delimiter:i}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(a.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let o=n.data.get(a.dataId).values,u=n.data.get(i.dataId).values[0],[c,l,d]=a4(o,u,s),h=l.length;return[n.makeTensorInfo([h,2],"int32",c),n.makeTensorInfo([h],"string",l),n.makeTensorInfo([2],"int32",new Int32Array(d))]}var Vbe={kernelName:o0,backendName:"cpu",kernelFunc:Wbe};function Ube(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:a}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");let i=n.data.get(a.dataId).values,o=i4(i,s);return n.makeTensorInfo(a.shape,"int32",o)}var Gbe={kernelName:l0,backendName:"cpu",kernelFunc:Ube},Hbe=Dn(Fh,e=>Math.tan(e)),jbe={kernelName:Fh,backendName:"cpu",kernelFunc:Hbe},qbe=Dn(Mh,e=>Math.tanh(e)),Kbe={kernelName:Mh,backendName:"cpu",kernelFunc:qbe};function Xbe(e){let{inputs:t,backend:n}=e,{tensor:r,indices:s,updates:a}=t,{sliceRank:i,numUpdates:o,sliceSize:u,strides:c,outputSize:l}=P.calculateShapes(a,s,r.shape),d=!1,h=n.bufferSync(s),p=n.bufferSync(a),f=n.bufferSync(r),m=Sc(h,p,r.shape,l,u,o,i,c,f,d);return n.makeTensorInfo(r.shape,m.dtype,m.values)}var Qbe={kernelName:tm,backendName:"cpu",kernelFunc:Xbe};function Ybe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:a}=r;mt(s,"tile");let i=h9(n.bufferSync(s),a);return n.makeTensorInfo(i.shape,i.dtype,i.values)}var Jbe={kernelName:wu,backendName:"cpu",kernelFunc:Ybe};function Zbe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:a,sorted:i}=r;mt(s,"topk");let o=n.data.get(s.dataId).values,[u,c]=f9(o,s.shape,s.dtype,a,i);return[n.makeTensorInfo(u.shape,u.dtype,u.values),n.makeTensorInfo(c.shape,c.dtype,c.values)]}var eye={kernelName:cm,backendName:"cpu",kernelFunc:Zbe};function tye(e){let{inputs:t,attrs:n,backend:r}=e,{image:s,transforms:a}=t,{interpolation:i,fillMode:o,fillValue:u,outputShape:c}=n,[l,d,h,p]=s.shape,[f,m]=c??[d,h],g=[l,f,m,p],b=$.computeStrides(s.shape),y=b[0],x=b[1],w=b[2],v=$.computeStrides(g),I=v[0],N=v[1],T=v[2],E=$.getTypedArrayFromDType(s.dtype,$.sizeFromShape(g));E.fill(u);let A=r.data.get(s.dataId).values,k=r.data.get(a.dataId).values;for(let C=0;C<l;++C){let M=a.shape[0]===1?k:k.subarray(C*8,C*8+8);for(let L=0;L<f;++L)for(let O=0;O<m;++O)for(let B=0;B<p;++B){let G,z=M[6]*O+M[7]*L+1;if(z===0)continue;let q=(M[0]*O+M[1]*L+M[2])/z,Q=(M[3]*O+M[4]*L+M[5])/z,K=t_(q,h,o),ee=t_(Q,d,o);switch(i){case"nearest":G=oye(A,d,h,y,x,w,C,ee,K,B,u);break;case"bilinear":G=lye(A,d,h,y,x,w,C,ee,K,B,u);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}let Y=C*I+L*N+O*T+B;E[Y]=G}return r.makeTensorInfo(g,s.dtype,E)}return{dataId:r.write(E,g,s.dtype),shape:s.shape,dtype:s.dtype}}var nye={kernelName:dm,backendName:"cpu",kernelFunc:tye};function t_(e,t,n){switch(n){case"reflect":return rye(e,t);case"wrap":return sye(e,t);case"nearest":return iye(e,t);case"constant":default:return aye(e)}}function rye(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let r=2*t;n<r&&(n=r*Math.trunc(-n/r)+n),n=n<-t?n+r:-n-1}else if(n>t-1)if(t<=1)n=0;else{let r=2*t;n-=r*Math.trunc(n/r),n>=t&&(n=r-n-1)}return $.clamp(0,n,t-1)}function sye(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let r=t-1;n+=t*(Math.trunc(-n/r)+1)}else if(n>t-1)if(t<=1)n=0;else{let r=t-1;n-=t*Math.trunc(n/r)}return $.clamp(0,n,t-1)}function aye(e,t){return e}function iye(e,t){return $.clamp(0,e,t-1)}function Bb(e,t,n,r,s,a,i,o,u,c,l){let d=i*r+o*s+u*a+c;return 0<=o&&o<t&&0<=u&&u<n?e[d]:l}function oye(e,t,n,r,s,a,i,o,u,c,l){let d=Math.round(o),h=Math.round(u);return Bb(e,t,n,r,s,a,i,d,h,c,l)}function lye(e,t,n,r,s,a,i,o,u,c,l){let d=Math.floor(o),h=Math.floor(u),p=d+1,f=h+1,m=(f-u)*Bb(e,t,n,r,s,a,i,d,h,c,l)+(u-h)*Bb(e,t,n,r,s,a,i,d,f,c,l),g=(f-u)*Bb(e,t,n,r,s,a,i,p,h,c,l)+(u-h)*Bb(e,t,n,r,s,a,i,p,f,c,l);return(p-o)*m+(o-d)*g}function uye(e){let{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t;mt(a,"unique");let i=r.data.get(a.dataId).values,{outputValues:o,outputShape:u,indices:c}=l4(i,s,a.shape,a.dtype);return[r.makeTensorInfo(u,a.dtype,o),r.makeTensorInfo([c.length],"int32",c)]}var cye={kernelName:u0,backendName:"cpu",kernelFunc:uye};function dye(e){let{inputs:t,backend:n,attrs:r}=e,{value:s}=t,{axis:a}=r;a<0&&(a+=s.shape.length);let i=s.shape.length,o=s.shape[a],u=new Array(i-1),c=0;for(let p=0;p<i;p++)p!==a&&(u[c++]=s.shape[p]);let l=new Array(i).fill(0),d=s.shape.slice();d[a]=1;let h=new Array(o);for(let p=0;p<h.length;p++){l[a]=p;let f=Qc({inputs:{x:s},backend:n,attrs:{begin:l,size:d}});h[p]=Zn({inputs:{x:f},backend:n,attrs:{shape:u}}),n.disposeIntermediateTensorInfo(f)}return h}var hye={kernelName:hm,backendName:"cpu",kernelFunc:dye};function pye(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:a}=t,{numSegments:i}=r;mt(s,"unsortedSegmentSum");let o=s.shape.length,u=a.shape.length,c=[],l=[],d=o-u,h=a;for(let f=0;f<d;++f){let m=Nx({inputs:{input:h},backend:n,attrs:{dim:f+1}});h=m,l.push(m)}for(let f=0;f<i;++f){let m=$.createScalarValue(f,"int32"),g=n.makeTensorInfo([],"int32",m),b=MO({inputs:{a:g,b:h},backend:n}),y=ou({inputs:{x:b},backend:n,attrs:{dtype:"float32"}}),x=$v({inputs:{a:y,b:s},backend:n}),w=B0({inputs:{x},backend:n,attrs:{axis:0,keepDims:!1}});c.push(w),l.push(g),l.push(b),l.push(y),l.push(x),l.push(w)}let p=A9({inputs:c,backend:n,attrs:{axis:0}});return l.forEach(f=>n.disposeIntermediateTensorInfo(f)),p}var fye={kernelName:c0,backendName:"cpu",kernelFunc:pye},mye=[lpe,Wde,cpe,hpe,qde,fpe,gpe,ype,wpe,Ipe,Cpe,Npe,Epe,Rpe,Dpe,Ope,Ppe,zpe,Vpe,ipe,Gpe,jpe,Kpe,Xde,Qpe,Hde,Yde,Jpe,Vde,efe,nfe,rfe,afe,ofe,ufe,dfe,pfe,mfe,bfe,xfe,vfe,kfe,Sfe,Tfe,Efe,$fe,_fe,Ffe,Mfe,Ofe,Lfe,Bfe,Vfe,Zhe,Gfe,Jde,Jfe,Zde,Zfe,the,ame,ime,lme,rhe,ahe,cme,hme,fme,gme,ohe,uhe,Ude,yme,tfe,wme,Ime,Cme,epe,dhe,phe,Nme,mhe,Eme,Rme,Dme,Ome,Pme,zme,Wme,bhe,Ume,Hme,qme,Xme,Yme,Zme,tge,xhe,rge,ige,cge,vhe,khe,pge,gge,xge,She,vge,kge,Cge,$9,Ege,npe,Ehe,$ge,_ge,Fge,Oge,Gde,DC,Pge,rpe,spe,ape,zge,Vge,Gge,jge,Kge,Xge,Yge,Lhe,Zge,sbe,ibe,cbe,Bhe,hbe,fbe,gbe,zhe,lge,xbe,vbe,kbe,Sbe,Tbe,Abe,Rbe,Dbe,Uhe,Fbe,Hhe,qhe,Obe,Pbe,zbe,Vbe,Gbe,Yhe,zfe,jbe,Kbe,Qbe,Jbe,eye,nye,Nhe,cye,hye,fye,Ige];for(let e of mye)d0(e);var R9={};Pt(R9,{assertNotComplex:()=>Tm,bindCanvasToFramebuffer:()=>Nye,bindColorTextureToFramebuffer:()=>G2,bindTextureToProgramUniformSampler:()=>q9,bindTextureUnit:()=>G9,bindVertexBufferToProgramAttribute:()=>MC,callAndCheck:()=>Ze,canBeRepresented:()=>D9,createFragmentShader:()=>O9,createFramebuffer:()=>U9,createProgram:()=>L9,createStaticIndexBuffer:()=>z9,createStaticVertexBuffer:()=>B9,createTexture:()=>W9,createVertexShader:()=>M9,getBatchDim:()=>Yc,getExtensionOrThrow:()=>zb,getFramebufferErrorMessage:()=>K9,getMaxTexturesInShader:()=>J9,getNumChannels:()=>Cye,getProgramUniformLocation:()=>j9,getProgramUniformLocationOrThrow:()=>H9,getRowsCols:()=>Jc,getShapeAs3D:()=>Vb,getTextureShapeFromLogicalShape:()=>Q9,getWebGLDisjointQueryTimerVersion:()=>Z9,getWebGLErrorMessage:()=>F9,getWebGLMaxTextureSize:()=>Y9,hasExtension:()=>Ba,isCapableOfRenderingToFloatTexture:()=>eL,isDownloadFloatTextureEnabled:()=>tL,isReshapeFree:()=>yy,isWebGLFenceEnabled:()=>nL,isWebGLVersionEnabled:()=>LC,linkProgram:()=>P9,logShaderSourceAndInfoLog:()=>p4,resetMaxTextureSize:()=>Tye,resetMaxTexturesInShader:()=>Eye,unbindColorTextureFromFramebuffer:()=>OC,unbindTextureUnit:()=>Sye,validateFramebuffer:()=>Wb,validateProgram:()=>U2,validateTextureSize:()=>V9});var wc={},w2={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function _9(e,t){wc[e]=t}function Ki(e,t){if(!(e in wc)||t!=null){let r=bye(e,t);if(r!==null)wc[e]=r;else return console.log("Could not get context for WebGL version",e),null}let n=wc[e];return n==null||n.isContextLost()?(delete wc[e],Ki(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),wc[e])}function gye(e){if(!ge().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&e===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function bye(e,t){if(e!==1&&e!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let n=t??gye(e);return n.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete wc[e]},!1),ge().getBool("SOFTWARE_WEBGL_ENABLED")&&(w2.failIfMajorPerformanceCaveat=!1),e===1?n.getContext("webgl",w2)||n.getContext("experimental-webgl",w2):n.getContext("webgl2",w2)}var by;(function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"})(by||(by={}));var Pa;(function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"})(Pa||(Pa={}));var hs;(function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(hs||(hs={}));function z0(e,t){return[t,e]}function yye(e,t){return e*t}function v2(e){let t=$.sizeFromShape(e),n=Math.ceil(t/4);return $.sizeToSquarishShape(n)}function Nm(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function xye(e,t){let[n,r]=Nm(e,t);return n*r*4}function h4(e,t){let n=e,r,s,a,i,o,u,c,l,d,h;return ge().getNumber("WEBGL_VERSION")===2?(r=n.R32F,s=n.R16F,a=n.RGBA16F,i=n.RGBA32F,o=n.RED,c=4,l=1,d=n.HALF_FLOAT,h=n.FLOAT,u=n.RGBA8):(r=e.RGBA,s=e.RGBA,a=e.RGBA,i=n.RGBA,o=e.RGBA,c=4,l=4,d=t!=null?t.HALF_FLOAT_OES:null,h=e.FLOAT,u=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:i,textureFormatFloat:o,downloadTextureFormat:u,downloadUnpackNumChannels:c,defaultNumChannels:l,textureTypeHalfFloat:d,textureTypeFloat:h}}function Ze(e,t){let n=t();return ge().getBool("DEBUG")&&wye(e),n}function wye(e){let t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+F9(e,t))}var vye=596e-10,Iye=65504;function D9(e){return!!(ge().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||e===0||vye<Math.abs(e)&&Math.abs(e)<Iye)}function F9(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function zb(e,t){return xl(e,()=>e.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function M9(e,t){let n=xl(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Ze(e,()=>e.shaderSource(n,t)),Ze(e,()=>e.compileShader(n)),e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function O9(e,t){let n=xl(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Ze(e,()=>e.shaderSource(n,t)),Ze(e,()=>e.compileShader(n)),ge().get("ENGINE_COMPILE_ONLY"))return n;if(e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw p4(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}var kye=/ERROR: [0-9]+:([0-9]+):/g;function p4(e,t){let n=kye.exec(t);if(n==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(e);return}let r=+n[1],s=e.split(`
`),a=s.length.toString().length+2,i=s.map((d,h)=>$.rightPad((h+1).toString(),a)+d),o=0;for(let d=0;d<i.length;d++)o=Math.max(i[d].length,o);let u=i.slice(0,r-1),c=i.slice(r-1,r),l=i.slice(r);console.log(u.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${$.rightPad(c[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(l.join(`
`))}function L9(e){return xl(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}function P9(e,t){if(Ze(e,()=>e.linkProgram(t)),!ge().get("ENGINE_COMPILE_ONLY")&&e.getProgramParameter(t,e.LINK_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function U2(e,t){if(Ze(e,()=>e.validateProgram(t)),e.getProgramParameter(t,e.VALIDATE_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function B9(e,t){let n=xl(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return Ze(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),Ze(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function z9(e,t){let n=xl(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return Ze(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)),Ze(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function Cye(){return ge().getNumber("WEBGL_VERSION")===2?1:4}function W9(e){return xl(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}function V9(e,t){let n=ge().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){let r=`[${e}x${t}]`;throw new Error("Requested texture size "+r+" is invalid.")}if(e>n||t>n){let r=`[${e}x${t}]`,s=`[${n}x${n}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+s+".")}}function U9(e){return xl(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function MC(e,t,n,r,s,a,i){let o=e.getAttribLocation(t,n);return o===-1?!1:(Ze(e,()=>e.bindBuffer(e.ARRAY_BUFFER,r)),Ze(e,()=>e.vertexAttribPointer(o,s,e.FLOAT,!1,a,i)),Ze(e,()=>e.enableVertexAttribArray(o)),!0)}function G9(e,t,n){X9(e,n),Ze(e,()=>e.activeTexture(e.TEXTURE0+n)),Ze(e,()=>e.bindTexture(e.TEXTURE_2D,t))}function Sye(e,t){X9(e,t),Ze(e,()=>e.activeTexture(e.TEXTURE0+t)),Ze(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function H9(e,t,n){return xl(e,()=>e.getUniformLocation(t,n),'uniform "'+n+'" not present in program.')}function j9(e,t,n){return e.getUniformLocation(t,n)}function q9(e,t,n,r){Ze(e,()=>G9(e,t,r)),Ze(e,()=>e.uniform1i(n,r))}function Nye(e){Ze(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),Ze(e,()=>e.viewport(0,0,e.canvas.width,e.canvas.height)),Ze(e,()=>e.scissor(0,0,e.canvas.width,e.canvas.height))}function G2(e,t,n){Ze(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),Ze(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function OC(e,t){Ze(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),Ze(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function Wb(e){let t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+K9(e,t))}function K9(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function xl(e,t,n){let r=Ze(e,()=>t());if(r==null)throw new Error(n);return r}function X9(e,t){let n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){let s=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${s}.`)}}function Yc(e,t=2){return $.sizeFromShape(e.slice(0,e.length-t))}function Jc(e){if(e.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function Vb(e){let t=[1,1,1];return e.length===0||e.length===1&&e[0]===1||(t=[Yc(e),...Jc(e)]),t}function Q9(e,t=!1){let n=ge().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=ge().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&ge().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),t&&(n=n*2,r=r*2,e=e.map((o,u)=>u>=e.length-2?$.nearestLargerEven(e[u]):e[u]),e.length===1&&(e=[2,e[0]])),e.length!==2&&(e=$.squeezeShape(e).newShape);let s=$.sizeFromShape(e),a=null;e.length<=1&&s<=n?a=[1,s]:e.length===2&&e[0]<=n&&e[1]<=n?a=e:e.length===3&&e[0]*e[1]<=n&&e[2]<=n?a=[e[0]*e[1],e[2]]:e.length===3&&e[0]<=n&&e[1]*e[2]<=n?a=[e[0],e[1]*e[2]]:e.length===4&&e[0]*e[1]*e[2]<=n&&e[3]<=n?a=[e[0]*e[1]*e[2],e[3]]:e.length===4&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(a=[e[0],e[1]*e[2]*e[3]]);let i=a!=null&&Math.max(...a)>r&&Math.min(...a)<=(t?2:1)&&Math.min(...a)>0;if(a==null||i)if(t){let o=Yc(e),u=2,c=2;e.length&&([u,c]=Jc(e)),s=o*(u/2)*(c/2),a=$.sizeToSquarishShape(s).map(l=>l*2)}else a=$.sizeToSquarishShape(s);return a}function I2(e){return e%2===0}function yy(e,t){if(e=e.slice(-2),t=t.slice(-2),$.arraysEqual(e,t)||!e.length||!t.length||e[0]===0||e[1]===0||t[0]===0||t[1]===0)return!0;if(e.length!==t.length){let n=e[e.length-1],r=t[t.length-1];if(n===r||I2(n)&&I2(r)&&(e[0]===1||t[0]===1))return!0}return e[1]===t[1]&&I2(e[0])&&I2(t[0])}var H2,j2;function Y9(e){if(H2==null){let t=Ki(e);H2=t.getParameter(t.MAX_TEXTURE_SIZE)}return H2}function Tye(){H2=null}function Eye(){j2=null}function J9(e){if(j2==null){let t=Ki(e);j2=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,j2)}function Z9(e){if(e===0)return 0;let t,n=Ki(e);return Ba(n,"EXT_disjoint_timer_query_webgl2")&&e===2?t=2:Ba(n,"EXT_disjoint_timer_query")?t=1:t=0,t}function Ba(e,t){return e.getExtension(t)!=null}function LC(e){try{if(Ki(e)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function eL(e){if(e===0)return!1;let t=Ki(e);if(e===1){if(!Ba(t,"OES_texture_float"))return!1}else if(!Ba(t,"EXT_color_buffer_float"))return!1;return PC(t)}function tL(e){if(e===0)return!1;let t=Ki(e);if(e===1){if(!Ba(t,"OES_texture_float")||!Ba(t,"WEBGL_color_buffer_float"))return!1}else{if(Ba(t,"EXT_color_buffer_float"))return PC(t);let n="EXT_color_buffer_half_float";if(Ba(t,n)){let r=t.getExtension(n);return Aye(t,r)}return!1}return PC(t)}function PC(e){let t=h4(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);let r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);let s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),s}function Aye(e,t){let n=h4(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r),e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);let s=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,s),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);let a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(s),a}function nL(e){return e!==2?!1:Ki(e).fenceSync!=null}function Tm(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&$.assert(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}var yt=ge();yt.registerFlag("HAS_WEBGL",()=>yt.getNumber("WEBGL_VERSION")>0);yt.registerFlag("WEBGL_VERSION",()=>LC(2)?2:LC(1)?1:0);yt.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);yt.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>yt.get("WEBGL_VERSION")===2);yt.registerFlag("WEBGL_CPU_FORWARD",()=>!0);yt.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);yt.registerFlag("WEBGL_PACK",()=>yt.getBool("HAS_WEBGL"));yt.registerFlag("WEBGL_PACK_NORMALIZATION",()=>yt.getBool("WEBGL_PACK"));yt.registerFlag("WEBGL_PACK_CLIP",()=>yt.getBool("WEBGL_PACK"));yt.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>yt.getBool("WEBGL_PACK"));yt.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>yt.getBool("WEBGL_PACK"));yt.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>yt.getBool("WEBGL_PACK"));yt.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>yt.getBool("WEBGL_PACK"));yt.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>yt.getBool("WEBGL_PACK"));yt.registerFlag("WEBGL_PACK_REDUCE",()=>yt.getBool("WEBGL_PACK"));yt.registerFlag("WEBGL_LAZILY_UNPACK",()=>yt.getBool("WEBGL_PACK"));yt.registerFlag("WEBGL_CONV_IM2COL",()=>yt.getBool("WEBGL_PACK"));yt.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>yt.getBool("WEBGL_PACK"));yt.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>Y9(yt.getNumber("WEBGL_VERSION")));yt.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>J9(yt.getNumber("WEBGL_VERSION")));yt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let e=yt.getNumber("WEBGL_VERSION");return e===0?0:Z9(e)});yt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>yt.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!f0.isMobile());yt.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>eL(yt.getNumber("WEBGL_VERSION")));yt.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>yt.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:yt.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));yt.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>tL(yt.getNumber("WEBGL_VERSION")));yt.registerFlag("WEBGL_FENCE_API_ENABLED",()=>nL(yt.getNumber("WEBGL_VERSION")));yt.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>yt.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);yt.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,e=>{if(typeof e!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&e!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)});yt.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>f0.isMobile()?1:-1,e=>{if(typeof e!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);if(e<0&&e!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)});yt.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);yt.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);yt.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);yt.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);yt.registerFlag("WEBGL_EXP_CONV",()=>!1);yt.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>yt.getBool("IS_TEST"));yt.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);yt.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);yt.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);yt.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function Qs(){let e,t,n,r,s,a,i,o,u,c;return ge().getNumber("WEBGL_VERSION")===2?(e="#version 300 es",t="in",n="out",r="in",s="texture",a="outputColor",i="out vec4 outputColor;",o=ge().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",u="",c=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(e="",t="attribute",n="varying",r="varying",s="texture2D",a="gl_FragColor",i="",o=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,u=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,c=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:s,output:a,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:u,defineRound:c}}function Uh(e,t,n="index"){let r=$.computeStrides(t);return r.map((s,a)=>{let i=`int ${e[a]} = ${n} / ${s}`,o=a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * ${s}`:`index -= ${e[a]} * ${s}`;return`${i}; ${o};`}).join("")}function Rv(e,t,n="index"){let r=$.computeStrides(t);return r.map((s,a)=>{let i=`int ${e[a]} = ${n} / outShapeStrides[${a}]`,o=a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * outShapeStrides[${a}]`:`index -= ${e[a]} * outShapeStrides[${a}]`;return`${i}; ${o};`}).join("")}function $ye(e,t){let n=e.length,r=e.map(a=>`${t}[${a}]`),s=new Array(n-1);s[n-2]=r[n-1];for(let a=n-3;a>=0;--a)s[a]=`(${s[a+1]} * ${r[a+1]})`;return s}function Rye(e,t,n="index"){let r=e.map((a,i)=>i),s=$ye(r,t);return s.map((a,i)=>{let o=`int ${e[i]} = ${n} / ${s[i]}`,u=i===s.length-1?`int ${e[i+1]} = ${n} - ${e[i]} * ${s[i]}`:`index -= ${e[i]} * ${s[i]}`;return`${o}; ${u};`}).join("")}function f4(e){let t=$.computeStrides(e).map(n=>n.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function m4(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}var rL=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`,{getBroadcastDims:sL}=P;function _ye(e,t,n){let r=[];if(e.forEach(h=>{let p=$.sizeFromShape(h.shapeInfo.logicalShape);if(h.shapeInfo.isUniform?r.push(`uniform float ${h.name}${p>1?`[${p}]`:""};`):(r.push(`uniform sampler2D ${h.name};`),r.push(`uniform int offset${h.name};`)),n.enableShapeUniforms){let{uniformShape:f}=g4(n.packedInputs,h.shapeInfo.logicalShape,h.shapeInfo.texShape);switch(f.length){case 1:r.push(`uniform int ${h.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${h.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${h.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${h.name}Shape;`);break}r.push(`uniform ivec2 ${h.name}TexShape;`)}}),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(h=>{r.push(`uniform ${h.type} ${h.name}${h.arrayIndex?`[${h.arrayIndex}]`:""};`)});let s=r.join(`
`),a=e.map(h=>Dye(h,t,n.packedInputs,n.enableShapeUniforms)).join(`
`),i=t.texShape,o=Qs(),u=Oye(o),c,l,d=Bye(o);return t.isPacked?(c=Fye(t.logicalShape,i,n.enableShapeUniforms),l=Pye(o)):(c=Mye(t.logicalShape,i,n.enableShapeUniforms),l=Lye(o)),n.packedInputs&&(d+=Uye),[d,u,l,s,c,a,n.userCode].join(`
`)}function Em(e,t=!1){let n=e.shapeInfo.logicalShape;switch(n.length){case 0:return t0e(e,t);case 1:return r0e(e,t);case 2:return a0e(e,t);case 3:return o0e(e,t);case 4:return u0e(e,t);case 5:return c0e(e);case 6:return d0e(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function aL(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return e0e(e);case 1:return n0e(e,t);case 2:return s0e(e,t);case 3:return i0e(e,t);default:return l0e(e,t)}}function Dye(e,t,n=!1,r){let s="";n?s+=aL(e,r):s+=Em(e,r);let a=e.shapeInfo.logicalShape,i=t.logicalShape;return a.length<=i.length&&(n?s+=h0e(e,t):s+=p0e(e,t)),s}function Fye(e,t,n){switch(e.length){case 0:return iL();case 1:return Gye(e,t,n);case 2:return Jye(e,t,n);case 3:return jye(e,t,n);default:return Kye(e,t,n)}}function Mye(e,t,n){switch(e.length){case 0:return iL();case 1:return Hye(e,t,n);case 2:return Zye(e,t,n);case 3:return qye(e,t,n);case 4:return Xye(e,t,n);case 5:return Qye(e,t);case 6:return Yye(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}function Oye(e){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${e.texture2D}(textureSampler, uv).r;
    }
  `}function Lye(e){return`
    void setOutput(float val) {
      ${e.output} = vec4(val, 0, 0, 0);
    }
  `}function Pye(e){return`
    void setOutput(vec4 val) {
      ${e.output} = val;
    }
  `}function Bye(e){return`${e.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${e.varyingFs} vec2 resultUV;
    ${e.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${e.defineSpecialNaN}
    ${e.defineSpecialInf}
    ${e.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${zye}
    ${Wye}
    ${Vye}
  `}var zye=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Wye=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Vye=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Uye=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function iL(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function Gye(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return r[0]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `}function Hye(e,t,n){return t[0]===1?n?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?n?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function jye(e,t,n){if(n)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[2]/2),a=s*Math.ceil(e[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec3(b, r, c);
    }
  `}function qye(e,t,n){if(n)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Rv(["r","c","d"],e)}
    return ivec3(r, c, d);
  }
`;let r=Uh(["r","c","d"],e);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `}function Kye(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[e.length-1]/2),a=s*Math.ceil(e[e.length-2]/2),i=a,o="",u="b, r, c";for(let c=2;c<e.length-1;c++)i*=e[e.length-c-1],o=`
      int b${c} = index / ${i};
      index -= b${c} * ${i};
    `+o,u=`b${c}, `+u;return`
    ivec${e.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${o}

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec${e.length}(${u});
    }
  `}function Xye(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Rv(["r","c","d","d2"],e)}
      return ivec4(r, c, d, d2);
    }
  `;let r=Uh(["r","c","d","d2"],e);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `}function Qye(e,t){let n=Uh(["r","c","d","d2","d3"],e);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function Yye(e,t){let n=Uh(["r","c","d","d2","d3","d4"],e);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function Jye(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if($.arraysEqual(e,t))return n?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;let s=Math.ceil(e[1]/2);return n?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec2(r, c);
    }
  `}function Zye(e,t,n){return $.arraysEqual(e,t)?n?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:e[1]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:e[0]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:n?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${e[1]};
      int c = index - r * ${e[1]};
      return ivec2(r, c);
    }
  `}function Gh(e){return`offset${e}`}function e0e(e){let t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=Qs();return`
    vec4 ${n}() {
      return ${r.texture2D}(${t}, halfCR);
    }
  `}function t0e(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;let[s,a]=e.shapeInfo.texShape;if(s===1&&a===1)return`
      float ${r}() {
        return sampleTexture(${n}, halfCR);
      }
    `;let i=Gh(n);if(t)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});
      return sampleTexture(${n}, uv);
    }
  `;let[o,u]=e.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${o}, ${u}, ${i});
      return sampleTexture(${n}, uv);
    }
  `}function n0e(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape,a=Qs();if(t)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${a.texture2D}(${n}, uv);
    }
  `;let i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${a.texture2D}(${n}, uv);
    }
  `}function r0e(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${Am(e)}
      }
    `;let s=e.shapeInfo.texShape,a=s[0],i=s[1];if(i===1&&a===1)return`
      float ${r}(int index) {
        return sampleTexture(${n}, halfCR);
      }
    `;let o=Gh(n);return i===1?t?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${a}.0);
        return sampleTexture(${n}, uv);
      }
    `:a===1?t?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${n}, uv);
      }
    `:t?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${a}, ${i}, index + ${o});
      return sampleTexture(${n}, uv);
    }
  `}function s0e(e,t){let n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,i=a[0],o=a[1],u=Qs();if(a!=null&&$.arraysEqual(n,a))return t?`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${u.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);

        return ${u.texture2D}(${r}, uv);
      }
    `;if(t)return`
    vec4 ${s}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${u.texture2D}(${r}, uv);
    }
  `;let c=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],l=Math.ceil(n[1]/2);return`
    vec4 ${s}(int row, int col) {
      vec2 uv = packedUVfrom2D(${l}, ${c[0]}, ${c[1]}, row, col);
      return ${u.texture2D}(${r}, uv);
    }
  `}function a0e(e,t){let n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape;if(a!=null&&$.arraysEqual(n,a)){if(t)return`
      float ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;let h=a[0],p=a[1];return`
    float ${s}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${p}.0, ${h}.0);
      return sampleTexture(${r}, uv);
    }
  `}let{newShape:i,keptDims:o}=$.squeezeShape(n),u=i;if(u.length<n.length){let h=$m(e,u),p=["row","col"];return`
      ${Em(h,t)}
      float ${s}(int row, int col) {
        return ${s}(${Rm(p,o)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${s}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));
        ${Am(e)}
      }
    `;let c=a[0],l=a[1],d=Gh(r);return l===1?t?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);
      return sampleTexture(${r}, uv);
    }
  `:c===1?t?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${l}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `:t?`
      float ${s}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${d};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `:`
  float ${s}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n[1]} + col + ${d};
    vec2 uv = uvFromFlat(${c}, ${l}, index);
    return sampleTexture(${r}, uv);
  }
`}function i0e(e,t){let n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];if(n[0]===1){let h=n.slice(1),p=[1,2],f=$m(e,h),m=["b","row","col"];return`
        ${aL(f,t)}
        vec4 ${s}(int b, int row, int col) {
          return ${s}(${Rm(m,p)});
        }
      `}let o=Qs();if(t)return`
    vec4 ${s}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${o.texture2D}(${r}, uv);
    }
  `;let u=i[0],c=i[1],l=Math.ceil(n[2]/2),d=l*Math.ceil(n[1]/2);return`
    vec4 ${s}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${u}, ${c}, ${d}, ${l}, b, row, col);
      return ${o.texture2D}(${r}, uv);
    }
  `}function o0e(e,t){let n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=n[1]*n[2],i=n[2],{newShape:o,keptDims:u}=$.squeezeShape(n),c=o;if(c.length<n.length){let m=$m(e,c),g=["row","col","depth"];return`
        ${Em(m,t)}
        float ${s}(int row, int col, int depth) {
          return ${s}(${Rm(g,u)});
        }
      `}if(e.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${a}, ${i}, 1)));
        ${Am(e)}
      }
    `;let l=e.shapeInfo.texShape,d=l[0],h=l[1],p=e.shapeInfo.flatOffset;if(h===a&&p==null)return t?`
      float ${s}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
        float ${s}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${h}.0, ${d}.0);
          return sampleTexture(${r}, uv);
        }
      `;if(h===i&&p==null)return t?`
      float ${s}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${d}.0);
      return sampleTexture(${r}, uv);
    }
  `;let f=Gh(r);return t?`
    float ${s}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${f};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `:`
      float ${s}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${a} + col * ${i} + depth + ${f};
        vec2 uv = uvFromFlat(${d}, ${h}, index);
        return sampleTexture(${r}, uv);
      }
  `}function l0e(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=Qs();if(t)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${n}, uv);
    }
  `;let a=e.shapeInfo.logicalShape,i=a.length,o=e.shapeInfo.texShape,u=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],c=u[0],l=u[1],d=Math.ceil(a[i-1]/2),h=d*Math.ceil(a[i-2]/2),p="int b, int row, int col",f=`b * ${h} + (row / 2) * ${d} + (col / 2)`;for(let m=2;m<i-1;m++)p=`int b${m}, `+p,h*=a[i-m-1],f=`b${m} * ${h} + `+f;return`
    vec4 ${r}(${p}) {
      int index = ${f};
      int texR = index / ${l};
      int texC = index - texR * ${l};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${l}, ${c});
      return ${s.texture2D}(${n}, uv);
    }
  `}function u0e(e,t){let n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=n[3],i=n[2]*a,o=n[1]*i,{newShape:u,keptDims:c}=$.squeezeShape(n);if(u.length<n.length){let y=$m(e,u),x=["row","col","depth","depth2"];return`
      ${Em(y,t)}
      float ${s}(int row, int col, int depth, int depth2) {
        return ${s}(${Rm(x,c)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${o}, ${i}, ${a}, 1)));
        ${Am(e)}
      }
    `;let l=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1],f=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(p===o&&l==null)return t?`
      float ${s}(int row, int col, int depth, int depth2) {
        ${f}
        ${m}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${a}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${h}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(p===a&&l==null)return t?`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n[1]*n[2]}, ${n[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${h}.0);
        return sampleTexture(${r}, uv);
      }
    `;let b=Gh(r);return t?`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${f}
      ${m}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${b});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${i} +
          depth * ${a} + depth2;
      vec2 uv = uvFromFlat(${h}, ${p}, index + ${b});
      return sampleTexture(${r}, uv);
    }
  `}function c0e(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[4],a=t[3]*s,i=t[2]*a,o=t[1]*i,{newShape:u,keptDims:c}=$.squeezeShape(t);if(u.length<t.length){let m=$m(e,u),g=["row","col","depth","depth2","depth3"];return`
      ${Em(m)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${Rm(g,c)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${o}, ${i}, ${a}, ${s})) +
          depth3;
        ${Am(e)}
      }
    `;let l=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1];if(p===o&&l==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${a}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${h}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(p===s&&l==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${h}.0);
        return sampleTexture(${n}, uv);
      }
    `;let f=Gh(n);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${i} + depth * ${a} +
          depth2 * ${s} + depth3 + ${f};
      vec2 uv = uvFromFlat(${h}, ${p}, index);
      return sampleTexture(${n}, uv);
    }
  `}function d0e(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:s,keptDims:a}=$.squeezeShape(t);if(s.length<t.length){let g=$m(e,s),b=["row","col","depth","depth2","depth3","depth4"];return`
      ${Em(g)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${Rm(b,a)});
      }
    `}let i=t[5],o=t[4]*i,u=t[3]*o,c=t[2]*u,l=t[1]*c;if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${l}, ${c}, ${u}, ${o})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${Am(e)}
      }
    `;let d=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,p=h[0],f=h[1];if(f===l&&d==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${c}, ${u}, ${o}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(f===i&&d==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;let m=Gh(n);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${l} + col * ${c} + depth * ${u} +
          depth2 * ${o} + depth3 * ${i} + depth4 + ${m};
      vec2 uv = uvFromFlat(${p}, ${f}, index);
      return sampleTexture(${n}, uv);
    }
  `}function Am(e){let t=e.name,n=$.sizeFromShape(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`
    for (int i = 0; i < ${n}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function h0e(e,t){let n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,o=sL(e.shapeInfo.logicalShape,t.logicalShape),u=Wn(i),c=i-a,l,d=["x","y","z","w","u","v"];a===0?l="":i<2&&o.length>=1?l="coords = 0;":l=o.map(g=>`coords.${d[g+c]} = 0;`).join(`
`);let h="";i<2&&a>0?h="coords":h=e.shapeInfo.logicalShape.map((g,b)=>`coords.${d[b+c]}`).join(", ");let p="return outputValue;",f=$.sizeFromShape(e.shapeInfo.logicalShape)===1,m=$.sizeFromShape(t.logicalShape)===1;if(a===1&&!f&&!m)p=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(f&&!m)i===1?p=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:p=`
        return vec4(outputValue.x);
      `;else if(o.length){let g=a-2,b=a-1;o.indexOf(g)>-1&&o.indexOf(b)>-1?p="return vec4(outputValue.x);":o.indexOf(g)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(b)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${s}() {
      ${u} coords = getOutputCoords();
      ${l}
      vec4 outputValue = get${r}(${h});
      ${p}
    }
  `}function p0e(e,t){let n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=t.texShape,i=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,u=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===u&&e.shapeInfo.flatOffset==null&&$.arraysEqual(i,a))return`
      float ${s}() {
        return sampleTexture(${n}, resultUV);
      }
    `;let c=Wn(u),l=sL(e.shapeInfo.logicalShape,t.logicalShape),d=u-o,h,p=["x","y","z","w","u","v"];o===0?h="":u<2&&l.length>=1?h="coords = 0;":h=l.map(m=>`coords.${p[m+d]} = 0;`).join(`
`);let f="";return u<2&&o>0?f="coords":f=e.shapeInfo.logicalShape.map((m,g)=>`coords.${p[g+d]}`).join(", "),`
    float ${s}() {
      ${c} coords = getOutputCoords();
      ${h}
      return get${r}(${f});
    }
  `}function Wn(e){if(e<=1)return"int";if(e===2)return"ivec2";if(e===3)return"ivec3";if(e===4)return"ivec4";if(e===5)return"ivec5";if(e===6)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function g4(e,t,n){let{newShape:r,keptDims:s}=$.squeezeShape(t),a=t.length,i=e&&a===3&&t[0]===1,o=i?t.slice(1):r,u=!e&&a>1&&!$.arraysEqual(t,n)&&r.length<a||i;return{useSqueezeShape:u,uniformShape:u?o:t,keptDims:s}}function $m(e,t){let n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function Rm(e,t){return t.map(n=>e[n]).join(", ")}function f0e(e,t,n,r){let s=n.map((l,d)=>{let h={logicalShape:l.shape,texShape:l.isUniform?null:l.texData.texShape,isUniform:l.isUniform,isPacked:l.isUniform?!1:l.texData.isPacked,flatOffset:null};return l.texData!=null&&l.texData.slice!=null&&l.texData.slice.flatOffset>0&&(h.flatOffset=l.texData.slice.flatOffset),{name:t.variableNames[d],shapeInfo:h}}),a=s.map(l=>l.shapeInfo),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},o=_ye(s,i,t),u=O9(e.gl,o),c=e.createProgram(u);return ge().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:u,source:o,webGLProgram:c,inShapeInfos:a,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(c),Object.assign({program:t,fragmentShader:u,source:o,webGLProgram:c,inShapeInfos:a,outShapeInfo:i},oL(e,t,c)))}function oL(e,t,n){let r=[],s=[],a,i,o,u=null,c=null;c=e.getUniformLocation(n,"NAN",!1),ge().getNumber("WEBGL_VERSION")===1&&(u=e.getUniformLocation(n,"INFINITY",!1));let l=!1;for(let d of t.variableNames){let h={name:d,uniform:e.getUniformLocation(n,d,l),offset:e.getUniformLocation(n,`offset${d}`,l)};t.enableShapeUniforms&&(h.shape=e.getUniformLocation(n,`${d}Shape`,l),h.texShape=e.getUniformLocation(n,`${d}TexShape`,l)),r.push(h)}if(t.enableShapeUniforms&&(a=e.getUniformLocation(n,"outShape",l),o=e.getUniformLocation(n,"outShapeStrides",l),i=e.getUniformLocation(n,"outTexShape",l)),t.customUniforms)for(let d of t.customUniforms)s.push(e.getUniformLocation(n,d.name,l));return{variablesLocations:r,customUniformLocations:s,infLoc:u,nanLoc:c,outShapeLocation:a,outShapeStridesLocation:o,outTexShapeLocation:i}}function n_(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach((n,r)=>{let s=n.logicalShape,a=t[r],i=a.shape;if(!$.arraysEqual(s,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${i} must match`);if(n.isUniform&&a.isUniform)return;let o=n.texShape,u=a.isUniform?null:a.texData.texShape;if(!$.arraysEqual(o,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${u} must match`)})}function m0e(e,t,n,r,s){t.program.enableShapeUniforms||(n_(t.inShapeInfos,n),n_([t.outShapeInfo],[r]));let a=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(a.texture,i[0],i[1]):e.setOutputMatrixTexture(a.texture,i[0],i[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),ge().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&e.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&e.gl.uniform1f(t.nanLoc,NaN);for(let u=0;u<n.length;++u){let c=n[u],{uniform:l,offset:d,shape:h,texShape:p}=t.variablesLocations[u];if(h){let{uniformShape:f}=g4(t.program.packedInputs,c.shape,c.texData.texShape);switch(f.length){case 1:e.gl.uniform1iv(h,new Int32Array(f));break;case 2:e.gl.uniform2iv(h,new Int32Array(f));break;case 3:e.gl.uniform3iv(h,new Int32Array(f));break;case 4:e.gl.uniform4iv(h,new Int32Array(f));break}}if(p&&e.gl.uniform2i(p,c.texData.texShape[0],c.texData.texShape[1]),l!=null){if(c.isUniform){if($.sizeFromShape(c.shape)<2)e.gl.uniform1f(l,c.uniformValues[0]);else{let f=c.uniformValues;f instanceof Float32Array||(f=new Float32Array(f)),e.gl.uniform1fv(l,f)}continue}c.texData.slice!=null&&d!=null&&e.gl.uniform1i(d,c.texData.slice.flatOffset),e.setInputMatrixTexture(c.texData.texture.texture,l,u)}}let o=t.outShapeLocation;if(o)switch(r.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(r.shape));break}if(t.outShapeStridesLocation){let u=$.computeStrides(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(u));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(u));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(u));break}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&s)for(let u=0;u<t.program.customUniforms.length;++u){let c=t.program.customUniforms[u],l=t.customUniformLocations[u],d=s[u];if(c.type==="float")e.gl.uniform1fv(l,d);else if(c.type==="vec2")e.gl.uniform2fv(l,d);else if(c.type==="vec3")e.gl.uniform3fv(l,d);else if(c.type==="vec4")e.gl.uniform4fv(l,d);else if(c.type==="int")e.gl.uniform1iv(l,d);else if(c.type==="ivec2")e.gl.uniform2iv(l,d);else if(c.type==="ivec3")e.gl.uniform3iv(l,d);else if(c.type==="ivec4")e.gl.uniform4iv(l,d);else throw Error(`uniform type ${c.type} is not supported yet.`)}e.executeProgram()}function g0e(e,t,n){let r="";t.concat(n).forEach(i=>{let o=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!i.isUniform){let u=i.texData.texShape,{useSqueezeShape:c,uniformShape:l,keptDims:d}=g4(e.packedInputs,i.shape,u),h="",p="",f="";if(l.length===1&&e.packedInputs){let v=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)];h=`${v[0]>1}_${v[1]>1}`}else if(l.length===2&&!e.packedInputs)p=`${l[0]>1}_${l[1]>1}`;else if(l.length>2&&!e.packedInputs){let v=$.computeStrides(l);f=`${v[0]===u[1]}_${v[v.length-1]===u[1]}`}let m=i.shape.length,g=l.length===2&&$.arraysEqual(i.shape,u),b=$.sizeFromShape(i.shape)===1,y=P.getBroadcastDims(i.shape,n.shape),x=!e.packedInputs&&m===n.shape.length&&$.arraysEqual(u,n.texData.texShape),w=e.packedInputs||l.length>2?"":`${u[0]>1}_${u[1]>1}`;r+=`${m}_${x}_${c?d:""}_${l.length}_${b}_${y}_${g}_${h}_${p}_${f}_${w}_${o}`}else{let u=i.isUniform?"uniform":i.texData.texShape;r+=`${i.shape}_${u}_${o}`}});let s=e.userCode,a=e.constructor.name;return a+="_"+r+"_"+s+`${ge().getNumber("WEBGL_VERSION")}`,a}function Ts(e){return ge().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}var b0e=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=by.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=Qs();this.outputShape=e,this.enableShapeUniforms=Ts(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Rv(["r","c","d"],e):Uh(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}},y0e=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=by.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=Qs();this.outputShape=e,this.enableShapeUniforms=Ts(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Rv(["r","c","d"],e):Uh(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}},x0e=class{constructor(e){this.variableNames=["A"],this.outTexUsage=Pa.DOWNLOAD;let t=Qs();this.outputShape=e,this.userCode=`
      ${rL}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}},w0e=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Pa.DOWNLOAD;let t=Qs();this.outputShape=e,this.userCode=`
      ${rL}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}},v0e={R:0,G:1,B:2,A:3},r_=class{constructor(e,t=!1,n="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let r=Qs();this.outputShape=e,this.enableShapeUniforms=Ts(this.outputShape.length);let s="result";t&&(s="floor(result * 255. + 0.5)");let a="";for(let i=0;i<n.length;i++){let o=n[i];a+=`
          if(offset == ${i}) {
            result = values[${v0e[o]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?m4():f4(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${n.length});

        flatIndex = idiv(flatIndex, ${n.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${r.texture2D}(A, uv);
          ${a}
        }
        ${r.output} = vec4(${s}, 0., 0., 0.);
      }
    `}},I0e=class{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=Qs();this.outputShape=e,this.enableShapeUniforms=Ts(this.outputShape.length);let r="",s="result";t&&(s="floor(result * 255. + 0.5)");for(let a=0;a<=1;a++)for(let i=0;i<=1;i++){let o=a*2+i;r+=`
          localCoords = coords;
          if(localCoords[2] + ${i} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${i};
          if (localCoords[1] + ${a} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${a};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${n.texture2D}(A, uv);

            if (offset == 0) {
              result[${o}] = values[0];
            } else if (offset == 1) {
              result[${o}] = values[1];
            } else if (offset == 2) {
              result[${o}] = values[2];
            } else {
              result[${o}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?m4():f4(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${n.output} = ${s};
        }
    `}},lL={};Pt(lL,{bindVertexProgramAttributeStreams:()=>bL,createBufferFromOutputTexture:()=>wL,createFloat16MatrixTexture:()=>pL,createFloat16PackedMatrixTexture:()=>gL,createFloat32MatrixTexture:()=>hL,createIndexBuffer:()=>dL,createPackedMatrixTexture:()=>mL,createUnsignedBytesMatrixTexture:()=>fL,createVertexBuffer:()=>cL,createVertexShader:()=>uL,downloadByteEncodedFloatMatrixFromOutputTexture:()=>IL,downloadFloat32MatrixFromBuffer:()=>vL,downloadMatrixFromPackedOutputTexture:()=>CL,downloadPackedMatrixFromBuffer:()=>kL,getInternalFormatForFloat16MatrixTexture:()=>y4,getInternalFormatForFloat16PackedMatrixTexture:()=>v4,getInternalFormatForFloat32MatrixTexture:()=>b4,getInternalFormatForPackedMatrixTexture:()=>w4,getInternalFormatForUnsignedBytesMatrixTexture:()=>x4,uploadDenseMatrixToTexture:()=>yL,uploadPixelDataToTexture:()=>xL});function uL(e){let t=Qs(),n=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return M9(e,n)}function cL(e){let t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return B9(e,t)}function dL(e){let t=new Uint16Array([0,1,2,2,1,3]);return z9(e,t)}function W0(e,t,n,r,s,a){V9(t,n);let i=W9(e),o=e.TEXTURE_2D;return Ze(e,()=>e.bindTexture(o,i)),Ze(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),Ze(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),Ze(e,()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST)),Ze(e,()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST)),ge().getNumber("WEBGL_VERSION")===1?Ze(e,()=>e.texImage2D(o,0,r,t,n,0,s,a,null)):Ze(e,()=>e.texStorage2D(o,1,r,t,n)),Ze(e,()=>e.bindTexture(e.TEXTURE_2D,null)),{texture:i,texShape:[n,t]}}function b4(e){return e.internalFormatFloat}function hL(e,t,n,r){let[s,a]=z0(t,n);return W0(e,s,a,b4(r),r.textureFormatFloat,e.FLOAT)}function y4(e){return e.internalFormatHalfFloat}function pL(e,t,n,r){let[s,a]=z0(t,n);return W0(e,s,a,y4(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function x4(e){return e.downloadTextureFormat}function fL(e,t,n,r){let[s,a]=z0(t,n);return W0(e,s,a,x4(r),e.RGBA,e.UNSIGNED_BYTE)}function w4(e){return e.internalFormatPackedFloat}function mL(e,t,n,r){let[s,a]=Nm(t,n);return W0(e,s,a,w4(r),e.RGBA,e.FLOAT)}function v4(e){return e.internalFormatPackedHalfFloat}function gL(e,t,n,r){let[s,a]=Nm(t,n);return W0(e,s,a,v4(r),e.RGBA,r.textureTypeHalfFloat)}function bL(e,t,n){return Ze(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),MC(e,t,"clipSpacePos",n,3,20,0)&&MC(e,t,"uv",n,2,20,12)}function yL(e,t,n,r,s,a){Ze(e,()=>e.bindTexture(e.TEXTURE_2D,t));let i,o,u;s instanceof Uint8Array?(i=new Uint8Array(n*r*4),o=e.UNSIGNED_BYTE,u=e.RGBA):(i=new Float32Array(n*r*4),o=e.FLOAT,u=a.internalFormatPackedFloat),i.set(s),ge().getNumber("WEBGL_VERSION")===2?Ze(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,o,i)):Ze(e,()=>e.texImage2D(e.TEXTURE_2D,0,u,n,r,0,e.RGBA,o,i)),Ze(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function xL(e,t,n){Ze(e,()=>e.bindTexture(e.TEXTURE_2D,t)),n.data instanceof Uint8Array?ge().getNumber("WEBGL_VERSION")===2?Ze(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data)):Ze(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data)):ge().getNumber("WEBGL_VERSION")===2?Ze(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n)):Ze(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)),Ze(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function wL(e,t,n,r){let s=e.createBuffer();Ze(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,s));let a=16*t*n;return Ze(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,a,e.STREAM_READ)),Ze(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)),Ze(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),s}function vL(e,t,n){let r=e,s=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}function IL(e,t,n,r){let[s,a]=z0(t,n),i=4,o=new Uint8Array(yye(t*n,i));return Ze(e,()=>e.readPixels(0,0,s,a,r.downloadTextureFormat,e.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}function kL(e,t,n,r,s,a,i,o){let u=e,c=new Float32Array(xye(a,i));return u.bindBuffer(u.PIXEL_PACK_BUFFER,t),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,c),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),c}function CL(e,t,n){let r=new Float32Array(t*n*4);return Ze(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r)),r}var q2=class{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];let t=ge().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,_9(t,e)):this.gl=Ki(t),e=this.gl,ge().getNumber("WEBGL_VERSION")===2){let s=e;this.createVertexArray=()=>Ze(s,()=>s.createVertexArray()),this.bindVertexArray=a=>Ze(s,()=>s.bindVertexArray(a)),this.deleteVertexArray=a=>Ze(s,()=>s.deleteVertexArray(a)),this.getVertexArray=()=>Ze(s,()=>s.getParameter(s.VERTEX_ARRAY_BINDING))}else if(e!=null){let s=e.getExtension("OES_vertex_array_object");if(s==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>Ze(e,()=>s.createVertexArrayOES()),this.bindVertexArray=a=>Ze(e,()=>s.bindVertexArrayOES(a)),this.deleteVertexArray=a=>Ze(e,()=>s.deleteVertexArrayOES(a)),this.getVertexArray=()=>Ze(e,()=>e.getParameter(s.VERTEX_ARRAY_BINDING_OES))}let n="WEBGL_color_buffer_float",r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),ge().getNumber("WEBGL_VERSION")===1){let s="OES_texture_float",a="OES_texture_half_float";if(this.textureFloatExtension=zb(this.gl,s),Ba(this.gl,a))this.textureHalfFloatExtension=zb(this.gl,a);else if(ge().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),Ba(this.gl,r))this.colorBufferHalfFloatExtension=zb(this.gl,r);else if(ge().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",Ba(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else if(Ba(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=cL(this.gl),this.indexBuffer=dL(this.gl),this.framebuffer=U9(this.gl),this.textureConfig=h4(this.gl,this.textureHalfFloatExtension)}get debug(){return ge().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let e=this.gl;Ze(e,()=>e.finish()),Ze(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),Ze(e,()=>e.deleteFramebuffer(this.framebuffer)),Ze(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),Ze(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),Ze(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),hL(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),pL(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),fL(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),xL(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),yL(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),gL(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),mL(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(OC(this.gl,this.framebuffer),this.outputTexture=null),Ze(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>IL(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,r,s,a){return kL(this.gl,e,t,n,r,s,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return vL(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);let r=wL(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(ge().getBool("WEBGL_FENCE_API_ENABLED")){let r=e,s=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{let a=r.clientWaitSync(s,0,0);return a===r.ALREADY_SIGNALED||a===r.CONDITION_SATISFIED},t=s}else ge().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,ge().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>CL(this.gl,t,n))}createProgram(e){this.throwIfDisposed();let t=this.gl;this.vertexShader==null&&(this.vertexShader=uL(t));let n=L9(t);Ze(t,()=>t.attachShader(n,this.vertexShader)),Ze(t,()=>t.attachShader(n,e)),P9(t,n);let r=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&U2(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);let t=this.gl;Ze(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),bL(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(Ze(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&U2(this.gl,this.program),Ze(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?H9(this.gl,e,t):j9(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),Ze(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),q9(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();let[r,s]=Nm(t,n);this.setOutputMatrixTextureDriver(e,r,s)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&U2(this.gl,this.program),Wb(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let e=this.gl;if(this.debug){let t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}Ze(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Ze(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=zb(this.gl,ge().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(ge().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let n=this.gl,r=this.getQueryTimerExtensionWebGL2(),s=n.createQuery();return n.beginQuery(r.TIME_ELAPSED_EXT,s),s}let e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(ge().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let t=this.gl,n=this.getQueryTimerExtensionWebGL2();t.endQuery(n.TIME_ELAPSED_EXT);return}let e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await $.repeatedTry(()=>this.disposed||this.isQueryAvailable(e,ge().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,ge().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){let n=this.gl;return n.getQueryParameter(e,n.QUERY_RESULT)/1e6}else{let n=this.getQueryTimerExtensionWebGL1();return n.getQueryObjectEXT(e,n.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){let n=this.gl,r=this.getQueryTimerExtensionWebGL2(),s=n.getQueryParameter(e,n.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}else{let n=this.getQueryTimerExtensionWebGL1(),r=n.getQueryObjectEXT(e,n.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){let e=k0e(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){let{resolveFn:n}=this.itemsToPoll[t];n()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in ge().platform&&(n=ge().platform.setTimeoutCustom.bind(ge().platform)),$.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),G2(this.gl,e,this.framebuffer),this.debug&&Wb(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(G2(this.gl,this.outputTexture,this.framebuffer),this.debug&&Wb(this.gl)):OC(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);let n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();let r=this.gl;G2(r,e,this.framebuffer),this.debug&&Wb(r),this.outputTexture=e,Ze(r,()=>r.viewport(0,0,t,n)),Ze(r,()=>r.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),Ze(this.gl,()=>this.gl.scissor(e,t,n,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}};function k0e(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}var{addImpl:C0e,bincountImpl:SL,bincountReduceImpl:S0e,bitwiseAndImpl:N0e,castImpl:T0e,ceilImpl:E0e,concatImpl:A0e,equalImpl:$0e,expImpl:R0e,expm1Impl:_0e,floorImpl:D0e,gatherNdImpl:F0e,gatherV2Impl:M0e,greaterImpl:O0e,greaterEqualImpl:L0e,lessImpl:P0e,lessEqualImpl:B0e,linSpaceImpl:z0e,logImpl:W0e,maxImpl:V0e,maximumImpl:U0e,minimumImpl:G0e,multiplyImpl:H0e,negImpl:j0e,notEqualImpl:q0e,prodImpl:K0e,raggedGatherImpl:X0e,raggedRangeImpl:Q0e,raggedTensorToTensorImpl:Y0e,rangeImpl:J0e,rsqrtImpl:Z0e,scatterImpl:e1e,sigmoidImpl:t1e,simpleAbsImpl:NL,sliceImpl:n1e,sparseFillEmptyRowsImpl:r1e,sparseReshapeImpl:s1e,sparseSegmentReductionImpl:TL,sqrtImpl:a1e,staticRegexReplaceImpl:i1e,stridedSliceImpl:o1e,stringNGramsImpl:l1e,stringSplitImpl:u1e,stringToHashBucketFastImpl:c1e,subImpl:d1e,tileImpl:h1e,topKImpl:p1e,transposeImpl:I4,uniqueImpl:f1e}=QT;function EL(e,t){return["x","y","z","w","u","v"].slice(0,t).map(n=>`${e}.${n}`)}function Ps(e,t){return t===1?[e]:EL(e,t)}function m1e(e,t){if(e===1)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}var g1e=class{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=Ts(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let t=Ps("rc",this.rank),n=Wn(this.rank),r=this.getOutOfBoundsCondition(t),s=this.getSetup(t),a=this.getOutput(t);this.userCode=`
        void main() {
          ${n} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${s}

            setOutput(vec4(${a}));
          }
        }
      `}}getSourceCoordsArr(e){let t=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let s=`${n===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let a=2;a<this.rank;a++)s=`${e[e.length-1-a]},`+s;t.push(s)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";let t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${n};
      bool rEdge = rp1 >= ${r};
    `}getOutput(e){let t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}},AL=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=Ts(this.outputShape.length);let n="";for(let r=0;r<4;r++){let s="thisRC = rc;";r%2===1&&(s+="thisRC.z += 1;"),r>1&&(s+="thisRC.y += 1;"),n+=`
        ${s}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${b1e(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?m4():f4(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${n}

        setOutput(result);
      }
    `}};function b1e(e,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?Rye(["r","c","d"],"inputShape"):Uh(["r","c","d"],e)}
      return ivec3(r, c, d);
    }
  `}var y1e=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){let r=a_(t,n),s=i_(e,r,n);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);let a=s_(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();let o=this.freeTextures[s].pop();return this.usedTextures[s].push(o),o}let i;return r===hs.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===hs.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===hs.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===hs.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===hs.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[s].push(i),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),i}releaseTexture(e,t,n,r){if(this.freeTextures==null)return;let s=a_(n,r),a=i_(t,s,r);a in this.freeTextures||(this.freeTextures[a]=[]);let i=s_(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,r),o=ge().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");o!==-1&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;let u=this.usedTextures[a],c=u&&u.indexOf(e);if(c==null||c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u[c]=u[u.length-1],u.pop(),this.log()}log(){if(!this.logEnabled)return;let e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);let t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(let e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function x1e(e,t){let n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F||t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function s_(e,t,n,r,s){let a=w1e(t,r),i;if(s){let[u,c]=Nm(e[0],e[1]);i=u*c}else{let[u,c]=z0(e[0],e[1]);i=u*c}let o=x1e(n,a);return i*o}function w1e(e,t){switch(e){case hs.PACKED_2X2_FLOAT32:return w4(t);case hs.PACKED_2X2_FLOAT16:return v4(t);case hs.UNPACKED_FLOAT32:return b4(t);case hs.UNPACKED_FLOAT16:return y4(t);case hs.PACKED_4X1_UNSIGNED_BYTE:return x4(t);default:throw new Error(`Unknown physical texture type ${e}`)}}function v1e(e){return ge().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?hs.PACKED_2X2_FLOAT32:hs.UNPACKED_FLOAT32:e?hs.PACKED_2X2_FLOAT16:hs.UNPACKED_FLOAT16}function a_(e,t){if(e===Pa.UPLOAD)return hs.PACKED_2X2_FLOAT32;if(e===Pa.RENDER||e==null)return v1e(t);if(e===Pa.DOWNLOAD||e===Pa.PIXELS)return hs.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function i_(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}var bo=class{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=Ts(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}},bi="if (isnan(x)) return x;",I1e="return x;",o_="return abs(x);",k1e="return (x >= 0.0) ? x : (exp(x) - 1.0);",C1e=bi+`
  return (x < 0.0) ? 0.0 : x;
`,S1e=bi+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,$l="return x;",N1e="return 1.0 / (1.0 + exp(-1.0 * x));",T1e="return x;",E1e=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,A1e=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,$1e=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,R1e="return 1.0 / (1.0 + exp(-1.0 * x));",Ll=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=Ts(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}},_1e=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=Ts(this.outputShape.length);let t=e.length,n=Ps("rc",t),r=Wn(t),s=m1e(t,n),a=n.slice(-2),i=t<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${s});

        setOutput(getChannel(packedInput, ${i}));
      }
    `}},D1e=Lo.whereImpl,F1e=1e-7,M1e=1e-4,hk={};function O1e(e){return e in hk||(hk[e]={}),hk[e]}var L1e=ge().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),P1e=600;function B1e(){return ge().global.screen==null?1024:ge().global.screen.height*ge().global.screen.width*window.devicePixelRatio*P1e/1024/1024}var k4=class $L extends Vy{nextDataId(){return $L.nextDataId++}constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!ge().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let n;if(t!=null){if(t instanceof q2)n=t;else{let r=Ki(ge().getNumber("WEBGL_VERSION"),t);n=new q2(r)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let r=Ki(ge().getNumber("WEBGL_VERSION"));n=new q2(r),this.binaryCache=O1e(ge().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=n,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new y1e(this.gpgpu),this.numMBBeforeWarning=B1e(),this.texData=new uw(this,ai())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(t,n,r,s,a,i){let o=this.makeTensorInfo(n,r),u=this.texData.get(o.dataId);u.isPacked=!1,u.texture={texture:t,texShape:[s,a]},u.texShape=[s,a];let c=Vb(n),l=new r_(c,!1,i),d=this.runWebGLProgram(l,[o],r,[[s,a]]);return d.shape=n,u.texture=null,this.disposeIntermediateTensorInfo(o),d.dataId}write(t,n,r){if((ge().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||ge().getBool("DEBUG"))&&this.checkNumericalProblems(t),r==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let s={id:this.nextDataId()};return this.texData.set(s,{shape:n,dtype:r,values:t,usage:Pa.UPLOAD,refCount:1}),s}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){let n=this.texData.get(t);n.refCount++}decRef(t){if(this.texData.has(t)){let n=this.texData.get(t);n.refCount--}}move(t,n,r,s,a){if(ge().getBool("DEBUG")&&this.checkNumericalProblems(n),s==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:r,dtype:s,values:n,usage:Pa.UPLOAD,refCount:a})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){let n=this.texData.get(t),{values:r,dtype:s,complexTensorInfos:a,slice:i,shape:o,isPacked:u}=n;if(i!=null){let h;u?h=new Ll(o,$l):h=new bo(o,$l);let p=this.runWebGLProgram(h,[{dataId:t,shape:o,dtype:s}],s),f=this.readSync(p.dataId);return this.disposeIntermediateTensorInfo(p),f}if(r!=null)return this.convertAndCacheOnCPU(t);if(s==="string")return r;let c=this.activeTimers!=null,l;c&&(l=$.now());let d;if(s==="complex64"){let h=this.readSync(a.real.dataId),p=this.readSync(a.imag.dataId);d=P.mergeRealAndImagArrays(h,p)}else d=this.getValuesFromTexture(t);return c&&(this.downloadWaitMs+=$.now()-l),this.convertAndCacheOnCPU(t,d)}async read(t){if(this.pendingRead.has(t)){let f=this.pendingRead.get(t);return new Promise(m=>f.push(m))}let n=this.texData.get(t),{values:r,shape:s,slice:a,dtype:i,complexTensorInfos:o,isPacked:u}=n;if(a!=null){let f;u?f=new Ll(s,$l):f=new bo(s,$l);let m=this.runWebGLProgram(f,[{dataId:t,shape:s,dtype:i}],i),g=this.read(m.dataId);return this.disposeIntermediateTensorInfo(m),g}if(r!=null)return this.convertAndCacheOnCPU(t);if(ge().getBool("DEBUG")&&!ge().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&ge().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c=null,l;if(i!=="complex64"&&ge().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(t);let f=this.texData.get(l.dataId);c=this.gpgpu.createBufferFromTexture(f.texture.texture,...v2(s))}this.pendingRead.set(t,[]),i!=="complex64"&&await this.gpgpu.createAndWaitForFence();let d;if(i==="complex64"){let f=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),m=f[0],g=f[1];d=P.mergeRealAndImagArrays(m,g)}else if(c==null)d=this.getValuesFromTexture(t);else{let f=$.sizeFromShape(s);d=this.gpgpu.downloadFloat32MatrixFromBuffer(c,f)}if(l!=null&&this.disposeIntermediateTensorInfo(l),c!=null){let f=this.gpgpu.gl;Ze(f,()=>f.deleteBuffer(c))}let h=this.convertAndCacheOnCPU(t,d),p=this.pendingRead.get(t);return this.pendingRead.delete(t),p.forEach(f=>f(h)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&ai().removeDataId(t,this),this.pendingDeletes--),h}readToGPU(t,n={}){let r=this.texData.get(t),{values:s,shape:a,slice:i,dtype:o,isPacked:u,texture:c}=r;if(o==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(i!=null){let p;u?p=new Ll(a,$l):p=new bo(a,$l);let f=this.runWebGLProgram(p,[{dataId:t,shape:a,dtype:o}],o),m=this.readToGPU(f,n);return this.disposeIntermediateTensorInfo(f),m}if(c==null)throw s!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let l=this.decode(t,n.customTexShape),d=ai().makeTensorFromTensorInfo(l),h=this.texData.get(l.dataId);return Object.assign({tensorRef:d},h.texture)}bufferSync(t){let n=this.readSync(t.dataId);if(t.dtype==="string")try{let r=n.map(s=>$.decodeString(s));return Ht(t.shape,t.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Ht(t.shape,t.dtype,n)}checkNumericalProblems(t){if(t!=null)for(let n=0;n<t.length;n++){let r=t[n];if(!D9(r))throw ge().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${r} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${r} cannot be represented on this device.`)}}getValuesFromTexture(t){let{shape:n,dtype:r,isPacked:s}=this.texData.get(t),a=$.sizeFromShape(n);if(ge().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let h=this.decode(t),p=this.texData.get(h.dataId),f=this.gpgpu.downloadMatrixFromPackedTexture(p.texture.texture,...v2(n)).subarray(0,a);return this.disposeIntermediateTensorInfo(h),f}let i=ge().getBool("WEBGL_PACK")&&s===!0,o=i?Vb(n):n,u=i?new w0e(o):new x0e(o),c=this.runWebGLProgram(u,[{shape:o,dtype:r,dataId:t}],"float32"),l=this.texData.get(c.dataId),d=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(l.texture.texture,l.texShape[0],l.texShape[1]).subarray(0,a);return this.disposeIntermediateTensorInfo(c),d}timerAvailable(){return ge().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){let n=this.activeTimers,r=[],s=!1;this.programTimersStack==null?(this.programTimersStack=r,s=!0):this.activeTimers.push(r),this.activeTimers=r,t();let a=$.flatten(this.activeTimers.map(u=>u.query)).filter(u=>u!=null),i=$.flatten(this.activeTimers.map(u=>u.name)).filter(u=>u!=null);this.activeTimers=n,s&&(this.programTimersStack=null);let o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(ge().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let u=await Promise.all(a);o.kernelMs=$.sum(u),o.getExtraProfileInfo=()=>u.map((c,l)=>({name:i[l],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return ge().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:$.now(),endMs:null}}endTimer(t){return ge().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=$.now(),t)}async getQueryTime(t){if(ge().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);let n=t;return n.endMs-n.startMs}disposeData(t,n=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(n?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!n&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);let{complexTensorInfos:r}=this.texData.get(t);return r!=null&&(this.disposeData(r.real.dataId,n),this.disposeData(r.imag.dataId,n)),this.texData.delete(t),!0}releaseGPUData(t){let{texture:n,dtype:r,texShape:s,usage:a,isPacked:i,slice:o}=this.texData.get(t),u=o&&o.origDataId||t,c=this.dataRefCount.get(u);c>1?this.dataRefCount.set(u,c-1):(this.dataRefCount.delete(u),n!=null&&(this.numBytesInGPU-=this.computeBytes(s,r),this.textureManager.releaseTexture(n,s,a,i)));let l=this.texData.get(t);l.texture=null,l.texShape=null,l.isPacked=!1,l.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,n=L1e){return ge().getBool("WEBGL_CPU_FORWARD")&&t.every(r=>this.texData.get(r.dataId).texture==null&&$.sizeFromShape(r.shape)<n)}getGPGPUContext(){return this.gpgpu}where(t){P.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let n=t.dataSync();return D1e(t.shape,n)}packedUnaryOp(t,n,r){let s=new Ll(t.shape,n),a=this.compileAndRun(s,[t],r);return ai().makeTensorFromTensorInfo(a)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){let s=NL(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,s)}if(ge().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,o_,t.dtype);let n=new bo(t.shape,o_),r=this.compileAndRun(n,[t]);return ai().makeTensorFromTensorInfo(r)}makeTensorInfo(t,n,r){let s;if(n==="string"&&r!=null&&r.length>0&&$.isString(r[0])){let a=r.map(i=>$.encodeString(i));s=this.write(a,t,n)}else s=this.write(r,t,n);return this.texData.get(s).usage=null,{dataId:s,shape:t,dtype:n}}makeOutput(t,n,r){return ai().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,r),this)}unpackTensor(t){let n=new _1e(t.shape);return this.runWebGLProgram(n,[t],t.dtype)}packTensor(t){let n=new g1e(t.shape);return this.runWebGLProgram(n,[t],t.dtype,null,!0)}packedReshape(t,n){let r=[Yc(t.shape),...Jc(t.shape)],s={dtype:t.dtype,shape:r,dataId:t.dataId},a=[Yc(n),...Jc(n)],i=new AL(a,r),o=!0,u=[r],c=this.runWebGLProgram(i,[s],t.dtype,u,o);return{dataId:c.dataId,shape:n,dtype:c.dtype}}decode(t,n){let r=this.texData.get(t),{isPacked:s,shape:a,dtype:i}=r;if(n!=null){let h=$.sizeFromShape(a),p=n[0]*n[1]*4;$.assert(h<=p,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}let o=Vb(a),u;s?u=new y0e(o):u=new b0e(o);let c=!0,l=[n??v2(o)],d=this.runWebGLProgram(u,[{shape:o,dtype:i,dataId:t}],i,l,c,n);return{dtype:i,shape:a,dataId:d.dataId}}runWebGLProgram(t,n,r,s,a=!1,i){let o=this.makeTensorInfo(t.outputShape,r),u=this.texData.get(o.dataId);if(t.packedOutput&&(u.isPacked=!0),t.outPackingScheme===by.DENSE){let b=i??v2(t.outputShape);u.texShape=b.map(y=>y*2)}if(t.outTexUsage!=null&&(u.usage=t.outTexUsage),$.sizeFromShape(o.shape)===0)return u.values=$.getTypedArrayFromDType(o.dtype,0),o;let c=[],l=n.map(b=>{if(b.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let y=this.texData.get(b.dataId);if(y.texture==null){if(!t.packedInputs&&$.sizeFromShape(b.shape)<=ge().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:b.shape,texData:null,isUniform:!0,uniformValues:y.values};t.packedInputs&&(y.isPacked=!0,y.shape=b.shape)}if(this.uploadToGPU(b.dataId),!!y.isPacked!=!!t.packedInputs)b=y.isPacked?this.unpackTensor(b):this.packTensor(b),c.push(b),y=this.texData.get(b.dataId);else if(y.isPacked&&!yy(y.shape,b.shape)){let x=b,w=b.shape;b.shape=y.shape,b=this.packedReshape(b,w),c.push(b),y=this.texData.get(b.dataId),x.shape=w}return{shape:b.shape,texData:y,isUniform:!1}});this.uploadToGPU(o.dataId);let d={shape:o.shape,texData:u,isUniform:!1},h=g0e(t,l,d),p=this.getAndSaveBinary(h,()=>f0e(this.gpgpu,t,l,d)),f=this.activeTimers!=null,m;f&&(m=this.startTimer()),ge().get("ENGINE_COMPILE_ONLY")||m0e(this.gpgpu,p,l,d,s),c.forEach(b=>this.disposeIntermediateTensorInfo(b)),f&&(m=this.endTimer(m),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(m)}));let g=ge().getNumber("WEBGL_FLUSH_THRESHOLD");if(g>0){let b=$.now();b-this.lastGlFlushTime>g&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=b)}if(!ge().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&a===!1){let b=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),b}return o}compileAndRun(t,n,r,s,a=!1){return r=r||n[0].dtype,this.runWebGLProgram(t,n,r,s,a)}getAndSaveBinary(t,n){return t in this.binaryCache||(this.binaryCache[t]=n()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(ge().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=ie(()=>{if(!ge().get("WEBGL_RENDER_FLOAT32_ENABLED")){let t=ge().getBool("DEBUG");ge().set("DEBUG",!1);let n=this.abs(vt(1e-8)).dataSync()[0];if(ge().set("DEBUG",t),n>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?F1e:M1e}uploadToGPU(t){let n=this.texData.get(t),{shape:r,dtype:s,values:a,texture:i,usage:o,isPacked:u}=n;if(i!=null)return;let c=this.activeTimers!=null,l;c&&(l=$.now());let d=n.texShape;if(d==null&&(d=Q9(r,u),n.texShape=d),a!=null){let h=Vb(r),p,f=d[1],m=d[0],g=a instanceof Uint8Array||a instanceof Uint8ClampedArray;(u||!g)&&([f,m]=Nm(d[0],d[1])),u?p=new I0e(h,g):p=new r_(h,g);let b=g?[m,f]:d,y=this.makeTensorInfo(b,s),x=this.texData.get(y.dataId);g?x.usage=Pa.PIXELS:x.usage=Pa.UPLOAD,x.texShape=b,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(y.dataId),f,m,a);let w=[[m,f]],v=this.runWebGLProgram(p,[y],s,w,!0),I=this.texData.get(v.dataId);n.texShape=I.texShape,n.isPacked=I.isPacked,n.usage=I.usage,ge().get("ENGINE_COMPILE_ONLY")?this.disposeData(v.dataId):(n.texture=I.texture,n.values=null,this.texData.delete(v.dataId)),this.disposeIntermediateTensorInfo(y),c&&(this.uploadWaitMs+=$.now()-l)}else{let h=this.acquireTexture(d,o,s,u);n.texture=h}}convertAndCacheOnCPU(t,n){let r=this.texData.get(t),{dtype:s}=r;return n!=null&&(r.values=z1e(n,s)),r.values}acquireTexture(t,n,r,s){if(this.numBytesInGPU+=this.computeBytes(t,r),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let a=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${a} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,n,s)}computeBytes(t,n){return t[0]*t[1]*$.bytesPerElement(n)}checkCompileCompletion(){for(let[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){let t=[];if(this.gpgpu.parallelCompilationExtension){for(let[,n]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(n));return Promise.all(t)}else{for(let[,n]of Object.entries(this.binaryCache)){let r=new Promise(s=>{try{this.checkCompletion_(n),s(!0)}catch(a){throw a}});t.push(r)}return Promise.all(t)}}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await hN(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(p4(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let t of Object.values(this.binaryCache)){this.gpgpu.buildVao(t.webGLProgram);let{variablesLocations:n,customUniformLocations:r,infLoc:s,nanLoc:a,outShapeLocation:i,outShapeStridesLocation:o,outTexShapeLocation:u}=oL(this.gpgpu,t.program,t.webGLProgram);t.variablesLocations=n,t.customUniformLocations=r,t.infLoc=s,t.nanLoc=a,t.outShapeLocation=i,t.outShapeStridesLocation=o,t.outTexShapeLocation=u}}createTensorFromGPUData(t,n,r){t.channels=t.channels||"RGBA";let{texture:s,height:a,width:i,channels:o}=t,u=ai().backend;if(!u.gpgpu.gl.isTexture(s))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");let c=u.writeTexture(s,n,r,a,i,o);return ai().makeTensorFromDataId(c,n,r,u)}};k4.nextDataId=0;function z1e(e,t){if(t==="float32"||t==="complex64")return e;if(t==="int32"||t==="bool"){let n=t==="int32"?new Int32Array(e.length):new Uint8Array(e.length);for(let r=0;r<n.length;++r)n[r]=Math.round(e[r]);return n}else throw new Error(`Unknown dtype ${t}`)}var W1e="4.22.0";function RL(){ge().set("WEBGL_FORCE_F16_TEXTURES",!0)}f0.isBrowser()&&Tw("webgl",()=>new k4,2);var V1e={forceHalfFloat:RL},C4=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,Zc=class{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=P.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=Ts(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}},Hh=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`,_m=class{constructor(e,t,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=P.assertAndGetBroadcastShape(t,n);let s=this.outputShape.length;this.enableShapeUniforms=Ts(s);let a="";if(r)if(s===0||$.sizeFromShape(this.outputShape)===1)a=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(a=`
          ${Wn(s)} coords = getOutputCoords();
        `,s===1)this.enableShapeUniforms?a+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:a+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let i=Ps("coords",s);this.enableShapeUniforms?a+=`
            bool nextRowOutOfBounds =
              (${i[s-2]} + 1) >= outShape[${s} - 2];
            bool nextColOutOfBounds =
              (${i[s-1]} + 1) >= outShape[${s} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:a+=`
            bool nextRowOutOfBounds =
              (${i[s-2]} + 1) >= ${this.outputShape[s-2]};
            bool nextColOutOfBounds =
              (${i[s-1]} + 1) >= ${this.outputShape[s-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${a}

        setOutput(result);
      }
    `}};function Aa(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var U1e={kernelName:qd,backendName:"webgl",kernelFunc:Aa};function Eu(e){let{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.makeTensorInfo(r.shape,"complex64"),i=n.texData.get(a.dataId),o=Aa({inputs:{x:r},backend:n}),u=Aa({inputs:{x:s},backend:n});return i.complexTensorInfos={real:o,imag:u},a}var G1e={kernelName:hw,backendName:"webgl",kernelFunc:Eu},_L="return (a < 0.) ? b * a : a;",DL=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function H1e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:a}=r,i=n.makeTensorInfo([],"float32",$.createScalarValue(a,"float32")),o=ge().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new _m(DL,s.shape,i.shape):new Zc(_L,s.shape,i.shape),u=n.runWebGLProgram(o,[s,i],"float32");return n.disposeIntermediateTensorInfo(i),u}var j1e={kernelName:Yd,backendName:"webgl",kernelFunc:H1e},FL="return (a < 0.) ? b * a : a;",ML=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function q1e(e){let{inputs:t,backend:n}=e,{x:r,alpha:s}=t,a=ge().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new _m(ML,r.shape,s.shape):new Zc(FL,r.shape,s.shape);return n.runWebGLProgram(a,[r,s],"float32")}var K1e={kernelName:ph,backendName:"webgl",kernelFunc:q1e},Dm="if (isnan(x)) return x;";function dn({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return({inputs:s,backend:a})=>{let{x:i}=s,o=a,u=r||i.dtype;if(o.shouldExecuteOnCPU([i])&&n!=null){let d=o.texData.get(i.dataId),h=n(d.values,u);return o.makeTensorInfo(i.shape,u,h)}let c=ge().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null,l;return c?l=new Ll(i.shape,t):l=new bo(i.shape,e),o.runWebGLProgram(l,[i],u)}}function gs({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:a}){return({inputs:i,backend:o})=>{let{a:u,b:c}=i,l=o;if(r&&u.dtype==="complex64"){let f=l.texData.get(u.dataId),m=l.texData.get(c.dataId),[g,b]=[[f.complexTensorInfos.real,m.complexTensorInfos.real],[f.complexTensorInfos.imag,m.complexTensorInfos.imag]].map(x=>{let[w,v]=x,I={dataId:w.dataId,dtype:w.dtype,shape:u.shape},N={dataId:v.dataId,dtype:v.dtype,shape:c.shape},T=new Zc(e,u.shape,c.shape);return l.runWebGLProgram(T,[I,N],Ha(w.dtype,v.dtype))}),y=Eu({inputs:{real:g,imag:b},backend:l});return l.disposeIntermediateTensorInfo(g),l.disposeIntermediateTensorInfo(b),y}let d=a||Ha(u.dtype,c.dtype);if((u.dtype==="string"||c.dtype==="string"||l.shouldExecuteOnCPU([u,c]))&&s!=null){let f=l.texData.get(u.dataId).values,m=l.texData.get(c.dataId).values,g=u.dtype==="string"?P.fromUint8ToStringArray(f):f,b=u.dtype==="string"?P.fromUint8ToStringArray(m):m,[y,x]=s(u.shape,c.shape,g,b,d),w=l.makeTensorInfo(x,d),v=l.texData.get(w.dataId);return v.values=y,w}let h=ge().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null,p;return h?p=new _m(t,u.shape,c.shape,n):p=new Zc(e,u.shape,c.shape),l.runWebGLProgram(p,[u,c],d)}}function xy(e,t=!1){if(e==="linear")return t?T1e:I1e;if(e==="relu")return t?A1e:C1e;if(e==="elu")return t?E1e:k1e;if(e==="relu6")return t?$1e:S1e;if(e==="prelu")return t?ML:FL;if(e==="leakyrelu")return t?DL:_L;if(e==="sigmoid")return t?R1e:N1e;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}var OL=class{constructor(e,t,n,r=!1,s=!1,a=!1,i=null,o=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=Ts(this.outputShape.length);let c=r?e[1]:e[2],l=Math.ceil(c/2),d=r?"i * 2, rc.y":"rc.y, i * 2",h=s?"rc.z, i * 2":"i * 2, rc.z",p=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],m="",g="";i&&(o?m=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${i}
        }`:u?m=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${i}
        }`:m=`vec4 activation(vec4 x) {
          ${i}
        }`,g="result = activation(result);");let b=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let y="rc.x",x="rc.x";e[0]<t[0]?y=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(x=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${m}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${l}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${y};
        int batchB = ${x};
        for (int i = 0; i < ${l}; i++) {
          vec4 a = getMatrixA(batchA, ${d});
          vec4 b = getMatrixB(batchB, ${h});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${p[0]} * ${f[0]});
          result += (${p[1]} * ${f[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${b}

        ${g}

        setOutput(result);
      }
    `}},l_={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},u_=class{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=P.assertAndGetBroadcastShape(t,n),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}},c_="return a * b;";function S4(e){let{inputs:t,backend:n}=e,{a:r,b:s}=t,a=P.upcastType(r.dtype,s.dtype);if(r.dtype==="complex64"){let o=n.texData.get(r.dataId),u=n.texData.get(s.dataId),c=new u_(l_.REAL,r.shape,s.shape),l=new u_(l_.IMAG,r.shape,s.shape),d=[{dataId:o.complexTensorInfos.real.dataId,dtype:o.complexTensorInfos.real.dtype,shape:r.shape},{dataId:o.complexTensorInfos.imag.dataId,dtype:o.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:s.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:s.shape}],h=n.runWebGLProgram(c,d,"float32"),p=n.runWebGLProgram(l,d,"float32"),f=Eu({inputs:{real:h,imag:p},backend:n});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),f}if(n.shouldExecuteOnCPU([r,s])){let o=n.texData.get(r.dataId),u=n.texData.get(s.dataId),[c,l]=H0e(r.shape,s.shape,o.values,u.values,a),d=n.makeTensorInfo(l,a),h=n.texData.get(d.dataId);return h.values=c,d}let i;return ge().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new _m(c_,r.shape,s.shape):i=new Zc(c_,r.shape,s.shape),n.runWebGLProgram(i,[r,s],a)}var X1e={kernelName:uh,backendName:"webgl",kernelFunc:S4};function Q1e(e,t,n){let r=[Yc(e.shape),...Jc(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},a=[Yc(t),...Jc(t)],i=new AL(a,r),o=!0,u=[r],c=n.runWebGLProgram(i,[s],e.dtype,u,o);return{dataId:c.dataId,shape:t,dtype:c.dtype}}function Ye(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:a}=r,i=n,o=$.sizeFromShape(s.shape),u=$.inferFromImplicitShape(a,o),c=$.sizeFromShape(u);$.assert(o===c,()=>`The new shape (${u}) has ${c} elements and the old shape (${s.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);let l=i.texData.get(s.dataId);return l.isPacked&&!yy(s.shape,u)&&!(l.texture!==null&&yy(l.shape,u))?Q1e(s,u,i):(i.incRef(s.dataId),{dataId:s.dataId,shape:u,dtype:s.dtype})}var Y1e={kernelName:Yf,backendName:"webgl",kernelFunc:Ye},d_=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:s,outSize:a}=e;this.outputShape=[r,a];let i=Math.floor(n/4)*4,o=n%4,u="sumValue += dot(values, ones);";if(t!=null){let l=1/t;u=`sumValue += dot(values * ${$.isInt(l)?l.toPrecision(2):l}, ones);`}let c="";s%n>0&&(c=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        float sumValue = 0.0;

        for (int i = 0; i < ${i}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${u}
        }

        int inIdx = inOffset + ${i};
        if (${o===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${u}
        } else if (${o===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${u}
        } else if (${o===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${u}
        }
        setOutput(sumValue);
      }
    `}},J1e=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:s,outSize:a}=e;this.outputShape=[r,a];let i="0.0",o="";t==="prod"?i="1.0":t==="min"?(i="1.0 / 1e-20",o="min"):t==="max"&&(i="-1.0 / 1e-20",o="max");let u=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?u="sumValue":t==="prod"?u="prodValue":t==="all"?u="allValue":t==="any"&&(u="anyValue");let c=Math.floor(n/4)*4,l=n%4,d=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${o}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${o}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,h="vec4";t==="all"?(i="1.0",d=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,h="bvec4"):t==="any"&&(i="0.0",d=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,h="bvec4");let p="";s%n>0&&(p=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${i};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        vec4 minMaxValue = vec4(${i});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          ${h} values = ${h}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${d}
        }

        int inIdx = inOffset + ${c};
        if (${l===1}) {
          ${h} values = ${h}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${l===2}) {
          ${h} values = ${h}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${l===3}) {
          ${h} values = ${h}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${d}
        }
        setOutput(${u});
      }
    `}};function Z1e(e){let t=[];for(;t.length===0||t[t.length-1].outSize!==1;){let n=t.length?t[t.length-1].outSize:e[1],r=P.computeOptimalWindowSize(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}function jh(e,t,n,r){let s=Z1e(e.shape),a=e;for(let i=0;i<s.length;i++){let{inSize:o,windowSize:u,outSize:c}=s[i],l,d;n==="mean"?l=i===0?new d_({windowSize:u,inSize:o,batchSize:e.shape[0],outSize:c},o):new d_({windowSize:u,inSize:o,batchSize:e.shape[0],outSize:c}):l=new J1e({windowSize:u,inSize:o,batchSize:e.shape[0],outSize:c},n),d=a,a=r.runWebGLProgram(l,[a],t),d.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(d)}return a}var e2e=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[t[a]];this.outputShape=n,this.rank=n.length;let r=Wn(this.rank),s=t2e(t);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${s}));
    }
    `}};function t2e(e){let t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let s=0;s<e.length;s++)r[e[s]]=n[s];return r.join()}var n2e=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let n=new Array(e.length);for(let c=0;c<n.length;c++)n[c]=e[t[c]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let r=Wn(this.rank),s=EL("rc",this.rank),a=new Array(this.rank);for(let c=0;c<t.length;c++)a[t[c]]=s[c];let i=`vec2(${a.slice(-2).join()})`,o=`++${s[this.rank-1]} < ${n[this.rank-1]}`,u=`getChannel(getA(${a.join()}), ${i})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${u};
      if(${o}) {
        result[1] = ${u};
      }
      --${s[this.rank-1]};
      if(++${s[this.rank-2]} < ${n[this.rank-2]}) {
        result[2] = ${u};
        if(${o}) {
          result[3] = ${u};
        }
      }
      setOutput(result);
    }
    `}};function _v(e,t,n){let r=ge().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new n2e(e.shape,t):new e2e(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function r2e(e,t,n,r){let s=t,a=e.shape.length,i=$.parseAxisParam(s,e.shape),o=i,u=P.getAxesPermutation(o,a),c=u!=null,l=e;c&&(l=_v(e,u,r),o=P.getInnerMostAxes(o.length,a)),P.assertAxesAreInnerMostDims("sum",o,a);let[d,h]=P.computeOutAndReduceShapes(l.shape,o),p=d;n&&(p=P.expandShapeToKeepDim(d,i));let f=$.sizeFromShape(h),m=$.sizeFromShape(e.shape)/f,g=Ye({inputs:{x:l},attrs:{shape:[m,f]},backend:r}),b=Nw(e.dtype),y=jh(g,b,"sum",r),x=Ye({inputs:{x:y},attrs:{shape:p},backend:r});return r.disposeIntermediateTensorInfo(g),r.disposeIntermediateTensorInfo(y),c&&r.disposeIntermediateTensorInfo(l),x}function Dv(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;return r2e(s,a,i,n)}var s2e={kernelName:$h,backendName:"webgl",kernelFunc:Dv};function Us(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{perm:a}=r,i=n,o=s.shape.length,u=new Array(o);for(let l=0;l<u.length;l++)u[l]=s.shape[a[l]];let c;if(i.shouldExecuteOnCPU([s])){let l=i.texData.get(s.dataId).values,d=I4(l,s.shape,s.dtype,a,u);c=i.makeTensorInfo(u,s.dtype);let h=i.texData.get(c.dataId);h.values=d}else c=_v(s,a,i);return c}var a2e={kernelName:nl,backendName:"webgl",kernelFunc:Us},LL=1e3;function Ex({a:e,b:t,transposeA:n,transposeB:r,backend:s,bias:a=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:u=null}){let c=e.shape.length,l=t.shape.length,d=n?e.shape[c-2]:e.shape[c-1],h=r?t.shape[l-1]:t.shape[l-2],p=n?e.shape[c-1]:e.shape[c-2],f=r?t.shape[l-2]:t.shape[l-1],m=e.shape.slice(0,-2),g=t.shape.slice(0,-2),b=$.sizeFromShape(m),y=$.sizeFromShape(g),x=mm.assertAndGetBroadcastShape(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([p,f]);$.assert(d===h,()=>`Error in matMul: inner shapes (${d}) and (${h}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`);let w=n?[b,d,p]:[b,p,d],v=r?[y,f,h]:[y,h,f],I=Ye({inputs:{x:e},backend:s,attrs:{shape:w}}),N=Ye({inputs:{x:t},backend:s,attrs:{shape:v}}),T=[I,N],E=Math.max(b,y),A=n?I.shape[1]:I.shape[2],k=a!=null,C=i!=null,M=u==="leakyrelu",L=u!=null?xy(u,!0):null,O=k||C||M||L!=null,B;if((p===1||f===1)&&A>LL&&O===!1){let z=I,q=N;n&&(z=Us({inputs:{x:I},backend:s,attrs:{perm:[0,2,1]}}),T.push(z)),r&&(q=Us({inputs:{x:N},backend:s,attrs:{perm:[0,2,1]}}),T.push(q));let Q=f!==1,K=f===1,ee=z;Q&&(ee=Ye({inputs:{x:z},backend:s,attrs:{shape:[E,A,1]}}),T.push(ee));let Y=f===1?2:1,de=q;K&&(de=Ye({inputs:{x:q},backend:s,attrs:{shape:[E,1,A]}}),T.push(de));let ue=S4({inputs:{a:ee,b:de},backend:s});B=Dv({inputs:{x:ue},backend:s,attrs:{axis:Y,keepDims:!0}}),T.push(ue)}else{let z=Ha(e.dtype,t.dtype),q=new OL(w,v,[E,p,f],n,r,k,L,C,M),Q=[I,N];if(a!=null&&Q.push(a),C&&Q.push(i),M){let K=s.makeTensorInfo([],"float32",$.createScalarValue(o,"float32"));Q.push(K),T.push(K)}B=s.runWebGLProgram(q,Q,z)}let G=Ye({inputs:{x:B},backend:s,attrs:{shape:x}});T.push(B);for(let z of T)s.disposeIntermediateTensorInfo(z);return G}function i2e(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:o}=t,{transposeA:u,transposeB:c,activation:l,leakyreluAlpha:d}=r;return Ex({a:s,b:a,transposeA:u,transposeB:c,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:d,activation:l})}var o2e={kernelName:Oc,backendName:"webgl",kernelFunc:i2e},h_="return abs(x);";function l2e(e){let{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){let a=n.texData.get(r.dataId),i=NL(a.values);return n.makeTensorInfo(r.shape,r.dtype,i)}let s;return ge().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new Ll(r.shape,h_):s=new bo(r.shape,h_),n.runWebGLProgram(s,[r],r.dtype)}var u2e={kernelName:pf,backendName:"webgl",kernelFunc:l2e},c2e=bi+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,d2e=dn({opSnippet:c2e}),h2e={kernelName:yd,backendName:"webgl",kernelFunc:d2e},p2e=bi+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,f2e=dn({opSnippet:p2e}),m2e={kernelName:xd,backendName:"webgl",kernelFunc:f2e},p_="return a + b;",g2e=gs({opSnippet:p_,packedOpSnippet:p_,supportsComplex:!0,cpuKernelImpl:C0e}),b2e={kernelName:yu,backendName:"webgl",kernelFunc:g2e},y2e=class{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((s,a)=>`T${a}`);let n=[];this.variableNames.forEach(s=>{n.push(`float v${s} = get${s}AtOutCoords();`)});let r=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}},x2e=class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((s,a)=>`T${a}`);let n=[];this.variableNames.forEach(s=>{n.push(`vec4 v${s} = get${s}AtOutCoords();`)});let r=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}};function K2(e){let{inputs:t,backend:n}=e,r=t;if(r.length===1)return Aa({inputs:{x:r[0]},backend:n});if(r.length>ge().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let o=Math.floor(r.length/2),u=K2({inputs:r.slice(0,o),backend:n}),c=K2({inputs:r.slice(o),backend:n});return K2({inputs:[u,c],backend:n})}let s=r.map(o=>o.dtype).reduce((o,u)=>Ha(o,u)),a=r.map(o=>o.shape),i=ge().getBool("WEBGL_PACK")?new x2e(r[0].shape,a):new y2e(r[0].shape,a);return n.runWebGLProgram(i,r,s)}var w2e={kernelName:wd,backendName:"webgl",kernelFunc:K2};function v2e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,u=$.parseAxisParam(a,s.shape),c=u,l=P.getAxesPermutation(c,o),d=s;l!=null&&(d=Us({inputs:{x:s},backend:n,attrs:{perm:l}}),c=P.getInnerMostAxes(c.length,o)),P.assertAxesAreInnerMostDims("all",c,o);let[h,p]=P.computeOutAndReduceShapes(d.shape,c),f=$.sizeFromShape(p),m=Ye({inputs:{x:d},backend:n,attrs:{shape:[-1,f]}}),g=jh(m,m.dtype,"all",n),b;if(i){let y=P.expandShapeToKeepDim(h,u);b=Ye({inputs:{x:g},backend:n,attrs:{shape:y}})}else b=Ye({inputs:{x:g},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),l!=null&&n.disposeIntermediateTensorInfo(d),b}var I2e={kernelName:ff,backendName:"webgl",kernelFunc:v2e};function k2e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,u=$.parseAxisParam(a,s.shape),c=u,l=P.getAxesPermutation(c,o),d=s;l!=null&&(d=Us({inputs:{x:s},backend:n,attrs:{perm:l}}),c=P.getInnerMostAxes(c.length,o)),P.assertAxesAreInnerMostDims("any",c,o);let[h,p]=P.computeOutAndReduceShapes(d.shape,c),f=$.sizeFromShape(p),m=Ye({inputs:{x:d},backend:n,attrs:{shape:[-1,f]}}),g=jh(m,m.dtype,"any",n),b;if(i){let y=P.expandShapeToKeepDim(h,u);b=Ye({inputs:{x:g},backend:n,attrs:{shape:y}})}else b=Ye({inputs:{x:g},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),l!=null&&n.disposeIntermediateTensorInfo(d),b}var C2e={kernelName:mf,backendName:"webgl",kernelFunc:k2e},S2e=class{constructor(e,t,n){this.variableNames=["A"];let{windowSize:r,batchSize:s,outSize:a}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,a];let i=t==="max"?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${o};
          float candidate = getA(batch, inIdx);
          if (candidate ${i} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}},N2e=class{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,$.assert(e.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);let s=e[e.length-1],a=Math.ceil(s/t);this.outputShape=e.slice(0,-1),a>1&&this.outputShape.push(a),r||this.variableNames.push("bestIndicesA");let i=this.outputShape,o=i.length,u=Wn(o),c=Ps("coords",o),l,d;if(a===1){d=o+1;let N=Wn(d);l=`
        ${N} sourceLocR = ${N}(${c.join()}, 0);
        ++${c[o-1]};
        ${N} sourceLocG = ${N}(${c.join()}, 0);
        ++${c[o-2]};
        ${N} sourceLocA = ${N}(${c.join()}, 0);
        --${c[o-1]};
        ${N} sourceLocB = ${N}(${c.join()}, 0);
        --${c[o-2]};`}else d=o,l=`
        ${u} sourceLocR = coords;
        ++${c[o-1]};
        ${u} sourceLocG = coords;
        ++${c[o-2]};
        ${u} sourceLocA = coords;
        --${c[o-1]};
        ${u} sourceLocB = coords;
        --${c[o-2]};`;let h=["x","y","z","w","u","v"].slice(0,d),p="."+h[d-1],f=h.map(N=>"int "+N),m=Ps("sourceLocR",d-1).concat("inIdx.r"),g=Ps("sourceLocG",d-1).concat("inIdx.g"),b=Ps("sourceLocB",d-1).concat("inIdx.b"),y=Ps("sourceLocA",d-1).concat("inIdx.a"),x=n==="max"?"greaterThan":"lessThan",w=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),
                             getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${y.join()})));`,v=`vec4(
            getAChannel(${m.join()}),
            hasNextCol ? getAChannel(${g.join()}) : 0.,
            hasNextRow ? getAChannel(${b.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${y.join()}) : 0.)`,I=r?"":`
      float getBestIndicesAChannel(${f.join()}) {
        return getChannel(getBestIndicesA(${h.join()}),
                                          vec2(${h.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${f.join()}) {
        return getChannel(getA(${h.join()}),
                               vec2(${h.slice(-2).join()}));
      }
      ${I}
      void main() {
        ${u} coords = getOutputCoords();
        bool hasNextCol = ${c[o-1]} < ${i[o-1]-1};
        bool hasNextRow = ${c[o-2]} < ${i[o-2]-1};
        ${l}
        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},
          sourceLocB${p}, sourceLocA${p}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${v};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${w}
          vec4 candidate = ${v};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${x}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}};function PL(e,t,n,r=null){let s=t.shape[0],a=t.shape[1];r!=null&&(s=r.shape[0],a=r.shape[1]);let i=P.computeOptimalWindowSize(a),o={windowSize:i,inSize:a,batchSize:s,outSize:Math.ceil(a/i)},u=new S2e(o,n,r==null),c=[t];r!=null&&c.push(r);let l=e.runWebGLProgram(u,c,"int32");if(l.shape[1]===1)return l;let d=PL(e,t,n,l);return e.disposeIntermediateTensorInfo(l),d}function BL(e,t,n,r=null){let s=r!=null?r.shape:t.shape,a=s[s.length-1],i=P.computeOptimalWindowSize(a),o=new N2e(s,i,n,r==null),u=r==null?[t]:[t,r],c=e.runWebGLProgram(o,u,"int32");if(c.shape.length===t.shape.length){let l=BL(e,t,n,c);return e.disposeIntermediateTensorInfo(c),l}return c}function zL(e,t,n,r){let s=[n];if(P.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,t.shape.length),!ge().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){let a=[],i=e.texData.get(t.dataId),o=i!==null&&i.isPacked,u=t;o&&(u=e.unpackTensor(t),a.push(u));let[c,l]=P.computeOutAndReduceShapes(u.shape,s),d=$.sizeFromShape(l),h=Ye({inputs:{x:u},backend:e,attrs:{shape:[-1,d]}});a.push(h);let p=PL(e,h,r);a.push(p);let f=Ye({inputs:{x:p},backend:e,attrs:{shape:c}});return a.forEach(m=>e.disposeIntermediateTensorInfo(m)),f}return BL(e,t,r)}function T2e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r,i=$.parseAxisParam(a,s.shape),o=P.getAxesPermutation(i,s.shape.length),u=s,c=[];o!=null&&(u=Us({inputs:{x:s},backend:n,attrs:{perm:o}}),c.push(u),i=P.getInnerMostAxes(i.length,u.shape.length)),P.assertAxesAreInnerMostDims("argMax",[i[0]],u.shape.length);let l=zL(n,u,i[0],"max");return c.forEach(d=>n.disposeIntermediateTensorInfo(d)),l}var E2e={kernelName:gf,backendName:"webgl",kernelFunc:T2e};function A2e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r,i=$.parseAxisParam(a,s.shape),o=P.getAxesPermutation(i,s.shape.length),u=s,c=[];o!=null&&(u=Us({inputs:{x:s},backend:n,attrs:{perm:o}}),c.push(u),i=P.getInnerMostAxes(i.length,u.shape.length)),P.assertAxesAreInnerMostDims("argMin",[i[0]],u.shape.length);let l=zL(n,u,i[0],"min");return c.forEach(d=>n.disposeIntermediateTensorInfo(d)),l}var $2e={kernelName:bf,backendName:"webgl",kernelFunc:A2e},R2e=bi+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,_2e=dn({opSnippet:R2e}),D2e={kernelName:vd,backendName:"webgl",kernelFunc:_2e},F2e=bi+"return log(x + sqrt(x * x + 1.0));",M2e=dn({opSnippet:F2e}),O2e={kernelName:Id,backendName:"webgl",kernelFunc:M2e},L2e=bi+`
  return atan(x);
`,P2e=dn({opSnippet:L2e}),B2e={kernelName:kd,backendName:"webgl",kernelFunc:P2e},z2e=C4+`
  return atan(a, b);
`,W2e=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Hh+`
  return result;
`,V2e=gs({opSnippet:z2e,packedOpSnippet:W2e}),U2e={kernelName:Sd,backendName:"webgl",kernelFunc:V2e},G2e=bi+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,H2e=dn({opSnippet:G2e}),j2e={kernelName:Cd,backendName:"webgl",kernelFunc:H2e},wy=class{constructor(e,t,n,r=!1,s=!1){if(this.variableNames=["x"],t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let a=e.filterWidth,i=e.strideHeight,o=e.strideWidth,u=e.dilationHeight,c=e.dilationWidth,l=e.effectiveFilterHeight,d=e.effectiveFilterWidth,h=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;let f=t==="avg",m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`,b="0.0";if(f||(b="-1.0 / 1e-20"),n){let N=">=";this.userCode=`
        const ivec2 strides = ivec2(${i}, ${o});
        const ivec2 pads = ivec2(${h}, ${p});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${l};
              wR += ${u}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d};
                wC += ${c}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${N} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?s?m:g:`wR * ${d} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let y="max",x=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(x="avgValue / max(count, 1.0)");let w=Math.floor(a/4)*4,v=a%4,I=`
      if (${f}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${y}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${o});
      const ivec2 pads = ivec2(${h}, ${p});
      const float initializationValue = ${b};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${b});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${l};
            wR += ${u}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${w}; wC += 4) {
            int xC = xCCorner + wC * ${c};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              getValue(batch, xR, xC + 3 * ${c}, d)
            );

            ${I}
          }

          int xC = xCCorner + ${w};
          if (${v===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${I}
          } else if (${v===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              initializationValue,
              initializationValue
            );

            ${I}
          } else if (${v===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              initializationValue
            );

            ${I}
          }
        }
        setOutput(${x});
      }
    `}},N4=class{constructor(e,t,n,r=!1,s=!1){if(this.variableNames=["x"],t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let a=e.filterWidth,i=e.strideDepth,o=e.strideHeight,u=e.strideWidth,c=e.dilationDepth,l=e.dilationHeight,d=e.dilationWidth,h=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,b=e.padInfo.left;this.outputShape=e.outShape;let y=t==="avg",x="0.0";if(y||(x="-1.0 / 1e-20"),n){let E=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${i}, ${o}, ${u});
        const ivec3 pads = ivec3(${m}, ${g}, ${b});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${h};
              wD += ${c}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${p};
                wR += ${l}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${f};
                  wC += ${d}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${E} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?s?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${p} * ${f} +
                      wR * ${f} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let w="max",v=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(v="avgValue / max(count, 1.0)");let I=Math.floor(a/4)*4,N=a%4,T=`
      if (${y}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${w}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${i}, ${o}, ${u});
      const ivec3 pads = ivec3(${m}, ${g}, ${b});
      const float initializationValue = ${x};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${x});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${h};
            wD += ${c}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${p};
            wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${I}; wC += 4) {
              int xC = xCCorner + wC * ${d};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                getValue(batch, xD, xR, xC + 3 * ${d}, ch)
              );

              ${T}
            }

            int xC = xCCorner + ${I};
            if (${N===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${T}
            } else if (${N===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                initializationValue,
                initializationValue
              );

              ${T}
            } else if (${N===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                initializationValue
              );

              ${T}
            }
          }
        }
        setOutput(${v});
      }
    `}};function q2e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t;Tm(s,"avgPool");let{filterSize:a,strides:i,pad:o,dimRoundingMode:u}=r,c=1;$.assert(P.eitherStridesOrDilationsAreOne(i,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);let l=P.computePool2DInfo(s.shape,a,i,c,o,u);if(l.filterWidth===1&&l.filterHeight===1&&$.arraysEqual(l.inShape,l.outShape))return Aa({inputs:{x:s},backend:n});let d=new wy(l,"avg",!1);return n.runWebGLProgram(d,[s],"float32")}var K2e={kernelName:Nd,backendName:"webgl",kernelFunc:q2e};function X2e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:u,dataFormat:c}=r,l=[1,1,1],d=P.computePool3DInfo(s.shape,a,i,l,o,u,c),h=new N4(d,"avg",!1);return n.runWebGLProgram(h,[s],"float32")}var Q2e={kernelName:yf,backendName:"webgl",kernelFunc:X2e},Y2e=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterHeight,u=e.effectiveFilterWidth,c=o-1-e.padInfo.top,l=u-1-e.padInfo.left,d=1/(t*n);this.userCode=`
      const ivec2 pads = ivec2(${c}, ${l});
      const float avgMultiplier = float(${d});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${o};
            wR += ${a}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${u};
            wC+= ${i}) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},J2e=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,u=e.dilationHeight,c=e.dilationWidth,l=e.effectiveFilterDepth,d=e.effectiveFilterHeight,h=e.effectiveFilterWidth,p=l-1-e.padInfo.front,f=d-1-e.padInfo.top,m=h-1-e.padInfo.left,g=1/(t*n*r);this.userCode=`
      const ivec3 pads = ivec3(${p}, ${f}, ${m});
      const float avgMultiplier = float(${g});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
            wD += ${o}) {
          float dyD = float(dyDCorner + wD) / ${s}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${d};
              wR += ${u}) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${h};
                wC += ${c}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Z2e(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a,{filterSize:o,strides:u,pad:c,dimRoundingMode:l}=r,d=[1,1,1],h=P.computePool3DInfo(i.shape,o,u,d,c,l),p=new J2e(h);return n.runWebGLProgram(p,[s],i.dtype)}var exe={kernelName:Hy,backendName:"webgl",kernelFunc:Z2e};function txe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a;Tm([s,a],"avgPoolGrad");let{filterSize:o,strides:u,pad:c}=r,l=P.computePool2DInfo(i.shape,o,u,1,c),d=new Y2e(l);return n.runWebGLProgram(d,[s],i.dtype)}var nxe={kernelName:Gy,backendName:"webgl",kernelFunc:txe};function rxe(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:o}=r;return Ex({a:s,b:a,transposeA:i,transposeB:o,backend:n})}var sxe={kernelName:Td,backendName:"webgl",kernelFunc:rxe},axe=class{constructor(e,t,n,r,s,a){this.outputShape=[],this.variableNames=["x","mean","variance"],P.assertAndGetBroadcastShape(e,t),P.assertAndGetBroadcastShape(e,n);let i="0.0";r!=null&&(P.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="1.0";s!=null&&(P.assertAndGetBroadcastShape(e,s),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${i};
        float scale = ${o};
        float inv = scale * inversesqrt(variance + float(${a}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}},ixe=class{constructor(e,t,n,r,s,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],P.assertAndGetBroadcastShape(e,t),P.assertAndGetBroadcastShape(e,n);let i="vec4(0.0)";r!=null&&(P.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="vec4(1.0)";s!=null&&(P.assertAndGetBroadcastShape(e,s),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${i};
        vec4 scale = ${o};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${a}));

        setOutput((x - mean) * inv + offset);
      }
    `}},oxe=({inputs:e,backend:t,attrs:n})=>{let{x:r,mean:s,variance:a,offset:i,scale:o}=e;$.assert(s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),$.assert(i==null||s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),$.assert(o==null||s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=n;u==null&&(u=.001);let c=[r,s,a],l=null;i!=null&&(l=i.shape,c.push(i));let d=null;o!=null&&(d=o.shape,c.push(o));let h=ge().getBool("WEBGL_PACK_NORMALIZATION")?new ixe(r.shape,s.shape,a.shape,l,d,u):new axe(r.shape,s.shape,a.shape,l,d,u);return t.runWebGLProgram(h,c,c[0].dtype)},lxe={kernelName:Hd,backendName:"webgl",kernelFunc:oxe},uxe=class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;let t=Wn(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let n=cxe(this.rank),r,s=e.map((a,i)=>`sourceLoc.${BC[i]} = start[${i}] + coords.${BC[i]};`);r=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${s.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${n}));
      }
    `}},BC=["x","y","z","w","u","v"];function cxe(e){if(e===1)return"sourceLoc";if(e<=6)return BC.slice(0,e).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}var dxe=class{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let t=Wn(this.rank),n=Ps("coords",this.rank),r=Ps("sourceLoc",this.rank),s=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,a=`getChannel(getSource(${r.join()}), ${s})`,i=`
      result.x = ${a};
      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${a};
        --${r[this.rank-1]};
      }
    `,o=this.rank===1?"":`
      --${n[this.rank-1]};
      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${a};
        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${a};
        }
      }
    `,u=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((c,l)=>`start[${l}]`).join()});`:e.map((c,l)=>`${r[l]} = ${n[l]} + start[${l}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${u}
        vec4 result = vec4(0.);
        ${i}
        ${o}
        setOutput(result);
      }
    `}};function hxe(e,t,n,r){let s=r.texData.get(e.dataId),a=r.makeTensorInfo(n,e.dtype),i=r.texData.get(a.dataId);Object.assign(i,s),i.refCount=1,i.shape=n,i.dtype=e.dtype;let o=Gr.computeFlatOffset(t,$.computeStrides(e.shape));s.slice&&(o+=s.slice.flatOffset),i.slice={flatOffset:o,origDataId:s.slice&&s.slice.origDataId||e.dataId};let u=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,u+1),a}function Fm(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,size:i}=r,[o,u]=Gr.parseSliceParams(s,a,i);if(Gr.assertParamsValid(s,o,u),$.sizeFromShape(u)===0)return n.makeTensorInfo(u,s.dtype,[]);if(n.shouldExecuteOnCPU([s])||s.dtype==="string"){let d=n.texData.get(s.dataId),h=n1e(d.values,o,u,s.shape,s.dtype);return n.makeTensorInfo(u,s.dtype,h)}let{isPacked:c}=n.texData.get(s.dataId),l=Gr.isSliceContinous(s.shape,o,u);if(c||!l){let d=ge().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new dxe(u):new uxe(u),h=[o];return n.runWebGLProgram(d,[s],s.dtype,h)}return n.uploadToGPU(s.dataId),hxe(s,o,u,n)}var pxe={kernelName:sm,backendName:"webgl",kernelFunc:Fm},fxe=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:i}=r;$.assert(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let o=a.reduce((y,x)=>y*x),u=P.getReshaped(s.shape,a,o),c=P.getPermuted(u.length,a.length),l=P.getReshapedPermuted(s.shape,a,o),d=P.getSliceBeginCoords(i,a.length),h=P.getSliceSize(l,i,a.length),p=[],f=Ye({inputs:{x:s},backend:n,attrs:{shape:u}}),m=Us({inputs:{x:f},backend:n,attrs:{perm:c}}),g=Ye({inputs:{x:m},backend:n,attrs:{shape:l}}),b=Fm({inputs:{x:g},backend:n,attrs:{begin:d,size:h}});return p.push(f),p.push(m),p.push(g),p.forEach(y=>n.disposeIntermediateTensorInfo(y)),b},mxe={kernelName:xf,backendName:"webgl",kernelFunc:fxe};function gxe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i}=r,o=n.readSync(s.dataId),u=n.readSync(a.dataId),c=SL(o,u,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,c)}var bxe={kernelName:wf,backendName:"webgl",kernelFunc:gxe},yxe=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,xxe=`
  return float(int(a.r) & int(b.r));
`;function wxe(e){let{inputs:t,backend:n}=e,{a:r,b:s}=t,a=ge().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=ge().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([r,s])||i===1){let u=n.texData.get(r.dataId).values,c=n.texData.get(s.dataId).values,[l,d]=N0e(r.shape,s.shape,u,c,r.dtype),h=n.makeTensorInfo(d,r.dtype),p=n.texData.get(h.dataId);return p.values=l,h}let o;return a?o=new _m(yxe,r.shape,s.shape,!1):o=new Zc(xxe,r.shape,s.shape),n.runWebGLProgram(o,[r,s],r.dtype)}var vxe={kernelName:vf,backendName:"webgl",kernelFunc:wxe};function Ixe(e){let{inputs:t,backend:n}=e,{s0:r,s1:s}=t,a=n.readSync(r.dataId),i=n.readSync(s.dataId),o=P.assertAndGetBroadcastShape(Array.from(a),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}var kxe={kernelName:jy,backendName:"webgl",kernelFunc:Ixe},Cxe="return float(a != b);",WL=gs({opSnippet:Cxe,cpuKernelImpl:q0e,dtype:"bool"}),Sxe={kernelName:Hf,backendName:"webgl",kernelFunc:WL};function V0(e){let{inputs:t,backend:n}=e,{input:r}=t,s=n.texData.get(r.dataId);return Aa({inputs:{x:s.complexTensorInfos.real},backend:n})}var Nxe={kernelName:Cw,backendName:"webgl",kernelFunc:V0},Txe="return float(int(x));";function Exe(e,t){let n=new bo(e.shape,Txe),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}function zC(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dtype:a}=r;if(a==="complex64"){if(s.dtype==="complex64")return Aa({inputs:{x:s},backend:n});let i=dr(s.shape),o=zC({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),u=Eu({inputs:{real:o,imag:i},backend:n});return i.dispose(),n.disposeIntermediateTensorInfo(o),u}if(s.dtype==="complex64"){let i=V0({inputs:{input:s},backend:n}),o=zC({inputs:{x:i},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(i),o}if(!$.hasEncodingLoss(s.dtype,a)){let i=Aa({inputs:{x:s},backend:n});return{dataId:i.dataId,shape:i.shape,dtype:a}}if(n.shouldExecuteOnCPU([s])){let i=n.texData.get(s.dataId).values,[o,u,c]=T0e(i,s.shape,s.dtype,a);return n.makeTensorInfo(o,u,c)}if(a==="int32")return Exe(s,n);if(a==="bool"){let i=n.makeTensorInfo([],"bool",$.getTypedArrayFromDType("bool",1)),o=WL({inputs:{a:s,b:i},backend:n});return n.disposeIntermediateTensorInfo(i),o}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${a}`)}var Axe={kernelName:Ed,backendName:"webgl",kernelFunc:zC},f_="return ceil(x);",$xe=dn({opSnippet:f_,packedOpSnippet:f_,cpuKernelImpl:E0e}),Rxe={kernelName:Ad,backendName:"webgl",kernelFunc:$xe},_xe=class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}},Dxe=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}};function Fxe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{clipValueMin:a,clipValueMax:i}=r,o;ge().getBool("WEBGL_PACK_CLIP")?o=new Dxe(s.shape):o=new _xe(s.shape);let u=[[a],[i]];return n.runWebGLProgram(o,[s],s.dtype,u)}var Mxe={kernelName:xu,backendName:"webgl",kernelFunc:Fxe},Oxe=class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};function m_(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}function Lxe(e){let{inputs:t,backend:n}=e,{x:r}=t,s=n.texData.get(r.dataId),a=new Oxe(r.shape),i=[m_(r,s.complexTensorInfos.real),m_(r,s.complexTensorInfos.imag)];return n.runWebGLProgram(a,i,i[0].dtype)}var Pxe={kernelName:qy,backendName:"webgl",kernelFunc:Lxe},Bxe=class{constructor(e){this.outputShape=[],this.outputShape=P.computeOutShape(e,1),this.variableNames=e.map((a,i)=>`T${i}`);let t=new Array(e.length-1);t[0]=e[0][1];for(let a=1;a<t.length;a++)t[a]=t[a-1]+e[a][1];let n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let a=1;a<t.length;a++){let i=t[a-1];n.push(`else if (yC < ${t[a]}) setOutput(getT${a}(yR, yC-${i}));`)}let r=t.length,s=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${s}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${n.join(`
        `)}
      }
    `}},zxe=class{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=P.computeOutShape(e,t);let n=this.outputShape,r=n.length,s=Wn(r),a=Ps("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((f,m)=>`T${m}`);let o=new Array(e.length-1);o[0]=e[0][t];for(let f=1;f<o.length;f++)o[f]=o[f-1]+e[f][t];let u=i[t],c=i.slice(-2),l=i.join(),d=`if (${u} < ${o[0]}) {
        return getChannel(
            getT0(${l}), vec2(${c.join()}));
        }`;for(let f=1;f<o.length;f++){let m=o[f-1];d+=`
        if (${u} < ${o[f]}  && ${u} >= ${o[f-1]}) {
          return getChannel(
            getT${f}(${k2(i,u,m)}),
            vec2(${k2(c,u,m)}));
        }`}let h=o.length,p=o[o.length-1];d+=`
        return getChannel(
          getT${h}(${k2(i,u,p)}),
          vec2(${k2(c,u,p)}));`,this.userCode=`
      float getValue(${i.map(f=>"int "+f)}) {
        ${d}
      }

      void main() {
        ${s} coords = getOutputCoords();
        vec4 result = vec4(getValue(${a}), 0., 0., 0.);

        ${a[r-1]} = ${a[r-1]} + 1;
        if (${a[r-1]} < ${n[r-1]}) {
          result.g = getValue(${a});
        }

        ${a[r-2]} = ${a[r-2]} + 1;
        if (${a[r-2]} < ${n[r-2]}) {
          result.a = getValue(${a});
        }

        ${a[r-1]} = ${a[r-1]} - 1;
        if (${a[r-2]} < ${n[r-2]} &&
            ${a[r-1]} < ${n[r-1]}) {
          result.b = getValue(${a});
        }
        setOutput(result);
      }
    `}};function k2(e,t,n){let r=e.indexOf(t);return e.map((s,a)=>a===r?`${s} - ${n}`:s).join()}function Fv(e){let{inputs:t,backend:n}=e,{input:r}=t,s=n.texData.get(r.dataId);return Aa({inputs:{x:s.complexTensorInfos.imag},backend:n})}var Wxe={kernelName:ww,backendName:"webgl",kernelFunc:Fv};function Ub(e,t,n){let r=e[0].dtype;if(r==="complex64"){let p=e.map(y=>V0({inputs:{input:y},backend:n})),f=e.map(y=>Fv({inputs:{input:y},backend:n})),m=Ub(p,t,n),g=Ub(f,t,n),b=Eu({inputs:{real:m,imag:g},backend:n});return p.forEach(y=>n.disposeIntermediateTensorInfo(y)),f.forEach(y=>n.disposeIntermediateTensorInfo(y)),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),b}let s=n.shouldExecuteOnCPU(e);if(r==="string"&&(s=!0),s){let p=e.map(w=>{let v=[-1,$.sizeFromShape(w.shape.slice(t))];return Ye({inputs:{x:w},backend:n,attrs:{shape:v}})}),f=p.map(w=>({vals:n.readSync(w.dataId),shape:w.shape})),m=P.computeOutShape(p.map(w=>w.shape),1),g=p[0].shape[0]===1,b=A0e(f,m,r,g),y=P.computeOutShape(e.map(w=>w.shape),t),x=n.makeTensorInfo(y,r,b);return p.forEach(w=>n.disposeIntermediateTensorInfo(w)),x}let a=e.filter(p=>$.sizeFromShape(p.shape)>0),i=ge().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&a[0].shape.length>1;if(a.length===1){let p=i?new bo(e[0].shape,$l):new Ll(e[0].shape,$l);return n.runWebGLProgram(p,e,r)}let o=ge().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(a.length>o){let p=[];for(let m=0;m<a.length;m+=o){let g=a.slice(m,m+o);p.push(Ub(g,t,n))}let f=Ub(p,t,n);for(let m of p)n.disposeIntermediateTensorInfo(m);return f}if(i){let p=new zxe(a.map(f=>f.shape),t);return n.runWebGLProgram(p,a,r)}let{tensors2D:u,outShape:c}=Vxe(a,t,n),l=new Bxe(u.map(p=>p.shape)),d=n.runWebGLProgram(l,u,r);u.forEach(p=>n.disposeIntermediateTensorInfo(p));let h=Ye({inputs:{x:d},attrs:{shape:c},backend:n});return n.disposeIntermediateTensorInfo(d),h}function Vxe(e,t,n){let r=P.computeOutShape(e.map(s=>s.shape),t);return{tensors2D:e.map(s=>Ye({inputs:{x:s},attrs:{shape:[-1,$.sizeFromShape(s.shape.slice(t))]},backend:n})),outShape:r}}function VL(e){let{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,a=$.parseAxisParam(s,t[0].shape)[0],i=t.map(c=>c.shape);P.assertParamsConsistent(i,a);let o=P.computeOutShape(t.map(c=>c.shape),a);if($.sizeFromShape(o)===0)return n.makeTensorInfo(o,t[0].dtype,[]);let u=t.filter(c=>$.sizeFromShape(c.shape)>0);return u.length===1?Aa({inputs:{x:u[0]},backend:n}):Ub(u,a,n)}var Uxe={kernelName:If,backendName:"webgl",kernelFunc:VL},UL=class{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;let a=e.padInfo.top,i=e.padInfo.left,o=e.strideHeight,u=e.strideWidth,c=e.dilationHeight,l=e.dilationWidth,d=e.filterHeight,h=e.filterWidth,p=Math.floor(e.inChannels/4)*4,f=e.inChannels%4,m=e.dataFormat==="channelsLast",g=m?1:2,b=m?2:3,y=m?3:1,x="",w="";n&&(r?x=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?x=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:x=`
          float activation(float x) {
            ${n}
          }
        `,w="result = activation(result);");let v=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${x}

      const ivec2 strides = ivec2(${o}, ${u});
      const ivec2 pads = ivec2(${a}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${y}];

        ivec2 xRCCorner =
            ivec2(coords[${g}], coords[${b}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${d}; wR++) {
          int xR = xRCorner + wR * ${c};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${h}; wC++) {
            int xC = xCCorner + wC * ${l};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${p}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${m}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${f===1}) {

              if (${m}) {
                dotProd +=
                    getX(batch, xR, xC, ${p}) *
                    getW(wR, wC, ${p}, d2);
              } else {
                dotProd +=
                    getX(batch, ${p}, xR, xC) *
                    getW(wR, wC, ${p}, d2);
              }

            } else if (${f===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${p}, d2),
                getW(wR, wC, ${p} + 1, d2)
              );

              if (${m}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${p}),
                  getX(batch, xR, xC, ${p} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${p}, xR, xC),
                  getX(batch, ${p} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${f===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${p}, d2),
                getW(wR, wC, ${p} + 1, d2),
                getW(wR, wC, ${p} + 2, d2)
              );

              if (${m}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${p}),
                  getX(batch, xR, xC, ${p} + 1),
                  getX(batch, xR, xC, ${p} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${p}, xR, xC),
                  getX(batch, ${p} + 1, xR, xC),
                  getX(batch, ${p} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${v}
        ${w}
        setOutput(result);
      }
    `}},Gxe=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,u=e.dilationHeight,c=e.dilationWidth,l=e.filterDepth,d=e.filterHeight,h=e.filterWidth,p=Math.floor(e.inChannels/4)*4,f=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${s}, ${a}, ${i});
      const ivec3 pads = ivec3(${t}, ${n}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${l}; wF++) {
          int xF = xFCorner + wF * ${o};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d}; wR++) {
            int xR = xRCorner + wR * ${u};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${h}; wC++) {
              int xC = xCCorner + wC * ${c};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${p}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${f===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${p}) *
                  getW(wF, wR, wC, ${p}, d2);
              } else if (${f===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${p}),
                  getX(batch, xF, xR, xC, ${p} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${p}, d2),
                  getW(wF, wR, wC, ${p} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${f===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${p}),
                  getX(batch, xF, xR, xC, ${p} + 1),
                  getX(batch, xF, xR, xC, ${p} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${p}, d2),
                  getW(wF, wR, wC, ${p} + 1, d2),
                  getW(wF, wR, wC, ${p} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},GL=class{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Ts(this.outputShape.length);let a=e.padInfo.left,i=e.strideWidth,o=e.dilationWidth,u=e.filterHeight,c=e.filterWidth,l=c,d=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let m=0;m<c;m++)d+=`
           vec4 xTexelC${m*2};
           int xTexelC${m*2}Ready;
           vec4 xTexelC${m*2+1};
           int xTexelC${m*2+1}Ready;
           vec4 xC${m};`;d+=`
     for (int r = 0; r < ${u}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let m=0;m<c;m++)d+=`
           xTexelC${m*2} = vec4(0.0);
           xTexelC${m*2}Ready = 0;
           xTexelC${m*2+1} = vec4(0.0);
           xTexelC${m*2+1}Ready = 0;
           xC${m} = vec4(0.0);`;d+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let m=0;m<(l+1)/2;m++){let g=m*2;if(d+=`
           xC = xCCorner + ${g*o};
           `,i===1){if(g<c&&(a%2===1?(d+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }
               `,o===1&&g>0?d+=`
                 xC${g} = vec4(xTexelC${g-2}.zw, xTexelC${g}.xy);
                 `:d+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${g} = vec4(previous.zw, xTexelC${g}.xy);
                   } else {
                     xC${g} = vec4(0.0, 0.0, xTexelC${g}.xy);
                   }
                   `):d+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }

                 xC${g} = xTexelC${g};
                 `,g+1<c)){let b=a%2===0?$.nearestLargerEven(o):o;o%2===0&&a%2===1||o%2!==0&&a%2!==1?(d+=`
                   xCOffset = xC + imod(pads[1], 2) + ${b};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {
                     xTexelC${g+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${g+1}.zw = vec2(0.0);
                     }
                     xTexelC${g+1}Ready = 1;
                   }
                   `,o>1?d+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${g+1} = vec4(previous.zw, xTexelC${g+1}.xy);
                     } else {
                      xC${g+1} = vec4(0.0, 0.0, xTexelC${g+1}.xy);
                     }
                     `:d+=`
                     xC${g+1} = vec4(xTexelC${g}.zw, xTexelC${g+1}.xy);
                     `):b===1?d+=`
                     xC${g+1} = xTexelC${g};
                     `:d+=`
                     xCOffset = xC + ${b};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {
                       xTexelC${g+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${g+1}.zw = vec2(0.0);
                       }
                       xTexelC${g+1}Ready = 1;
                     }

                     xC${g+1} = xTexelC${g+1};
                     `}}else g<c&&(a%2===1?(d+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${g+1}Ready == 0) {
                   xTexelC${g+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${g+1}.zw = vec2(0.0);
                   }
                   xTexelC${g+1}Ready = 1;
                 }

                 xC${g} = vec4(xTexelC${g}.zw, xTexelC${g+1}.zw);
               `,g+1<c&&(d+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${g+1} = vec4(xTexelC${g+1}.xy, final.xy);
                 `)):(d+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {
                   xTexelC${g+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${g+1}.zw = vec2(0.);
                   }
                   xTexelC${g+1}Ready = 1;
                 }

                 xC${g} = vec4(
                   xTexelC${g}.xy, xTexelC${g+1}.xy);
               `,g+1<c&&(d+=`
                   xC${g+1} = vec4(xTexelC${g}.zw, xTexelC${g+1}.zw);
                 `)));g<c&&(d+=`
             wTexel = getW(r, ${g}, d1, d2);
             dotProd += xC${g}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${g}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,g+1<c&&(d+=`
               wTexel = getW(r, ${g+1}, d1, d2);
               dotProd += xC${g+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${g+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}d+=`
     }
   `,d+=`
     }
   `,d+=`
     }
   `;let h="",p="";n&&(r?h=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${n}
         }`:s?h=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${n}
         }`:h=`vec4 activation(vec4 x) {
           ${n}
         }`,p="result = activation(result);");let f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${h}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${d}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${f}
         ${p}
         setOutput(result);
       }
     `}},Hxe=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=Ts(this.outputShape.length);let{dataFormat:n}=t,r=Qs(),s=n==="channelsLast",a=s?1:2,i=s?2:3,o=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`,u="";for(let c=0;c<=1;c++)for(let l=0;l<=1;l++)u+=`
          blockIndex = rc.z + ${l};
          pos = rc.y + ${c};

          ${o}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${a}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${i}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${s}) {
                  innerDims = vec2(d1, ch);
                  result[${c*2+l}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${c*2+l}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${u}

        ${r.output} = result;
      }
    `}};function Ax(e,t){let n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&n===1&&e[0]>1?[e[0],1]:null}function HL({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){let u=e.shape,c=r.texData.get(e.dataId),l=n.inChannels,d=u[0]*u[1]*u[2],h=n.outChannels,p=n.dataFormat==="channelsLast",f=!1,m=!1,g,b=[];if(a!=null){let y=Ax(a.shape,p);y!=null&&(a=Ye({inputs:{x:a},backend:r,attrs:{shape:y}}),b.push(a))}if(s!=null){let y=Ax(s.shape,p);y!=null&&(s=Ye({inputs:{x:s},backend:r,attrs:{shape:y}}),b.push(s))}if(!((d===1||h===1)&&l>LL)&&c.isPacked&&p&&c.texture!=null&&u[2]%2!==0&&$.arraysEqual(c.shape.slice(-3),u.slice(-3))){let y=u[0]*u[1]*(u[2]+1),x={dataId:e.dataId,shape:[1,y,n.inChannels],dtype:e.dtype},w=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,$.assert(yy(c.shape,x.shape),()=>`packed reshape ${c.shape} to ${x.shape} isn't free`);let v=Ye({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});b.push(v);let I=Ex({a:x,b:v,backend:r,transposeA:f,transposeB:m,bias:s,activation:o,preluActivationWeights:a,leakyreluAlpha:i}),N=r.texData.get(I.dataId);$.assert(N.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=w,N.shape=n.outShape,g=Aa({inputs:{x:I},backend:r}),g.shape=n.outShape,b.push(I)}else{let y=n.outHeight*n.outWidth,x=Ye({inputs:{x:e},backend:r,attrs:{shape:p?[n.batchSize,y,n.inChannels]:[n.batchSize,n.inChannels,y]}}),w=Ye({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),v=Ex({a:p?x:w,b:p?w:x,transposeA:!p,transposeB:m,backend:r,bias:s,activation:o,preluActivationWeights:a,leakyreluAlpha:i});g=Ye({inputs:{x:v},backend:r,attrs:{shape:n.outShape}}),b.push(x),b.push(w),b.push(v)}for(let y of b)r.disposeIntermediateTensorInfo(y);return g}function jL({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){let{filterWidth:u,filterHeight:c,inChannels:l,outWidth:d,outHeight:h,dataFormat:p}=n,f=p==="channelsLast",m=u*c*l,g=h*d,b=[n.batchSize,m,g],y=!0,x=!1,w=[];if(a!=null){let z=Ax(a.shape,f);z!=null&&(a=Ye({inputs:{x:a},backend:r,attrs:{shape:z}}),w.push(a))}if(s!=null){let z=Ax(s.shape,f);z!=null&&(s=Ye({inputs:{x:s},backend:r,attrs:{shape:z}}),w.push(s))}let v=Ye({inputs:{x:t},backend:r,attrs:{shape:[1,m,$.sizeFromShape(t.shape)/m]}});w.push(v);let I=new Hxe(b,n),N=[e.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],T=r.runWebGLProgram(I,[e],"float32",N),E=Ye({inputs:{x:T},backend:r,attrs:{shape:b}});w.push(T),w.push(E);let A=s!=null,k=a!=null,C=o==="leakyrelu",M=o?xy(o,!0):null,L=new OL(f?E.shape:v.shape,f?v.shape:E.shape,f?[n.batchSize,g,n.outChannels]:[n.batchSize,n.outChannels,g],y,x,A,M,k,C),O=f?[E,v]:[v,E];if(s&&O.push(s),k&&O.push(a),C){let z=r.makeTensorInfo([],"float32",$.createScalarValue(i,"float32"));O.push(z),w.push(z)}let B=r.runWebGLProgram(L,O,"float32"),G=Ye({inputs:{x:B},backend:r,attrs:{shape:n.outShape}});w.push(B);for(let z of w)r.disposeIntermediateTensorInfo(z);return G}function jxe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dataFormat:u,dilations:c,dimRoundingMode:l}=r,d=P.convertConv2DDataFormat(u),h=P.computeConv2DInfo(s.shape,a.shape,i,c,o,l,!1,d),p;if(h.filterHeight===1&&h.filterWidth===1&&h.dilationHeight===1&&h.dilationWidth===1&&h.strideHeight===1&&h.strideWidth===1&&(h.padInfo.type==="SAME"||h.padInfo.type==="VALID"))p=HL({x:s,filter:a,convInfo:h,backend:n});else if(h.strideWidth<=2&&d==="channelsLast"&&ge().getBool("WEBGL_EXP_CONV")){let m=new GL(h),g=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];p=n.runWebGLProgram(m,[s,a],"float32",g)}else if(ge().getBool("WEBGL_CONV_IM2COL"))p=jL({x:s,filter:a,convInfo:h,backend:n});else{let m=new UL(h);p=n.runWebGLProgram(m,[s,a],"float32")}let f=Ye({inputs:{x:p},backend:n,attrs:{shape:h.outShape}});return n.disposeIntermediateTensorInfo(p),f}var qxe={kernelName:$d,backendName:"webgl",kernelFunc:jxe},Kxe=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,s=e.padInfo.left,a=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${s};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${a?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Xxe=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a=e.dataFormat==="channelsLast",i=t-1-e.padInfo.top,o=n-1-e.padInfo.left,u=a?1:2,c=a?2:3,l=a?3:1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${l}];

        ivec2 dyCorner = ivec2(coords[${u}], coords[${c}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${a}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},Qxe=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,s=e.padInfo.front,a=e.padInfo.top,i=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${s};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${n} - ${a};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${i};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Yxe=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.front,u=n-1-e.padInfo.top,c=r-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${o}, ${u}, ${c});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${s}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${n}; wR++) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${n} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Jxe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,dataFormat:u,dimRoundingMode:c,filterShape:l}=r,d=P.convertConv2DDataFormat(u),h=P.computeConv2DInfo(s.shape,l,i,1,o,c,!1,d),p=new Kxe(h);return n.runWebGLProgram(p,[s,a],"float32")}var Zxe={kernelName:pw,backendName:"webgl",kernelFunc:Jxe},ewe=class{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=Ts(this.outputShape.length);let t=e.filterHeight,n=e.filterWidth,r=t-1-e.padInfo.top,s=n-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${r}, ${s});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            int wCPerm = ${n} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}};function twe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{inputShape:i,strides:o,pad:u,dataFormat:c,dimRoundingMode:l}=r,d=P.convertConv2DDataFormat(c),h=P.computeConv2DInfo(i,a.shape,o,1,u,l,!1,d);if(ge().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&d==="channelsLast"){let p=[[h.strideHeight,h.strideWidth]],f=new ewe(h);return n.runWebGLProgram(f,[s,a],"float32",p)}else{let p=new Xxe(h);return n.runWebGLProgram(p,[s,a],"float32")}}var nwe={kernelName:Rd,backendName:"webgl",kernelFunc:twe};function rwe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:u}=r,c=P.computeConv3DInfo(s.shape,a.shape,i,u,o),l=new Gxe(c);return n.runWebGLProgram(l,[s,a],"float32")}var swe={kernelName:_d,backendName:"webgl",kernelFunc:rwe};function awe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,filterShape:u}=r,c=P.computeConv3DInfo(s.shape,u,i,1,o),l=new Qxe(c);return n.runWebGLProgram(l,[s,a],"float32")}var iwe={kernelName:kf,backendName:"webgl",kernelFunc:awe};function owe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:i,strides:o,inputShape:u}=r,c=P.computeConv3DInfo(u,a.shape,o,1,i),l=new Yxe(c);return n.runWebGLProgram(l,[s,a],"float32")}var lwe={kernelName:Cf,backendName:"webgl",kernelFunc:owe},uwe=Dm+`
  return cos(x);
`,cwe=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Hh}
  return result;
`,dwe=dn({opSnippet:uwe,packedOpSnippet:cwe}),hwe={kernelName:Dd,backendName:"webgl",kernelFunc:dwe},pwe=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,fwe=dn({opSnippet:pwe}),mwe={kernelName:Fd,backendName:"webgl",kernelFunc:fwe},gwe=class{constructor(e,t,n,r,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[a,i,o,u]=e,[c]=t,[l,d]=n;this.outputShape=[c,l,d,u];let h=r==="bilinear"?1:0,[p,f]=[`${i-1}.0`,`${o-1}.0`],[m,g,b]=l>1?[`${(i-1)/(l-1)}`,"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[y,x,w]=d>1?[`${(o-1)/(d-1)}`,"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`
      const float height_ratio = float(${m});
      const float width_ratio = float(${y});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${a}) {
          return;
        }

        float height_scale = ${g};
        float width_scale = ${x};

        float in_y = ${b};
        if( in_y < 0.0 || in_y > ${p} ) {
          setOutput(float(${s}));
          return;
        }
        float in_x = ${w};
        if( in_x < 0.0 || in_x > ${f} ) {
          setOutput(float(${s}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${h} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}},bwe=e=>{let{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:i}=t,{cropSize:o,method:u,extrapolationValue:c}=r,l=new gwe(s.shape,a.shape,o,u,c);return n.runWebGLProgram(l,[s,a,i],"float32")},ywe={kernelName:Nf,backendName:"webgl",kernelFunc:bwe},vy;(function(e){e.Prod="*",e.Sum="+"})(vy||(vy={}));var g_=class{constructor(e,t,n,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];let s=this.outputShape.length,a=this.op===vy.Prod?"1.0":"0.0",i=n?a:`getX(${b_(s,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1],u="",c="";n?(u=r?`end != ${o-1}`:"end != 0",c=r?"end + 1":"end - 1"):(u=r?`end + pow2 < ${o}`:"end >= pow2",c=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Wn(s)} coords = getOutputCoords();
        int end = ${y_(s,"coords",this.op)};
        float val = ${i};
        int pow2 = int(pow(2.0, index));
        if (${u}) {
          int idx = ${c};
          ${y_(s,"coords",this.op)} = idx;
          val ${this.op}= getX(${b_(s,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function b_(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.x, ${t}.y`;if(e===3)return`${t}.x, ${t}.y, ${t}.z`;if(e===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function y_(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.y`;if(e===3)return`${t}.z`;if(e===4)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function qL(e,t,n,r,s,a){let i=t.shape.length,o=P.getAxesPermutation([r],i),u=t;o!=null&&(u=Us({inputs:{x:t},backend:n,attrs:{perm:o}}));let c=P.getInnerMostAxes(1,i)[0];if(c!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);let l=u.shape[c],d=Aa({inputs:{x:u},backend:n});for(let h=0;h<=Math.ceil(Math.log2(l))-1;h++){let p=new g_(e,u.shape,!1,a),f=[[h]],m=d;d=n.runWebGLProgram(p,[d],d.dtype,f),n.disposeIntermediateTensorInfo(m)}if(s){let h=new g_(e,u.shape,s,a),p=d;d=n.runWebGLProgram(h,[d],d.dtype),n.disposeIntermediateTensorInfo(p)}if(o!=null){let h=P.getUndoAxesPermutation(o),p=Us({inputs:{x:d},backend:n,attrs:{perm:h}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(u),p}return d}function xwe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;return qL(vy.Prod,s,n,a,i,o)}var wwe={kernelName:Sf,backendName:"webgl",kernelFunc:xwe};function vwe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;return qL(vy.Sum,s,n,a,i,o)}var Iwe={kernelName:Md,backendName:"webgl",kernelFunc:vwe};function kwe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i,binaryOutput:o}=r;if(s.shape.length===1){let u=n.readSync(s.dataId),c=n.readSync(a.dataId),l=SL(u,c,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,l)}else if(s.shape.length===2){let u=n.bufferSync(s),c=n.bufferSync(a),l=S0e(u,c,i,o);return n.makeTensorInfo(l.shape,a.dtype,l.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}var Cwe={kernelName:Ky,backendName:"webgl",kernelFunc:kwe},Swe=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function Nwe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:i}=r,o=s.shape[0],u=i==="NHWC"?s.shape[1]:s.shape[2],c=i==="NHWC"?s.shape[2]:s.shape[3],l=i==="NHWC"?s.shape[3]:s.shape[1],d=u*a,h=c*a,p=l/(a*a),f=i==="NHWC"?[o,d,h,p]:[o,p,d,h],m=new Swe(f,a,i);return n.runWebGLProgram(m,[s],s.dtype)}var Twe={kernelName:Tf,backendName:"webgl",kernelFunc:Nwe},KL=class{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Ts(this.outputShape.length);let a=e.filterHeight,i=e.filterWidth,o=e.outChannels/e.inChannels,u="",c="";n&&(r?u=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?u=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:u=`
          float activation(float x) {
            ${n}
          }
        `,c="result = activation(result);");let l=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${u}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${a}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${i}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${l}
        ${c}
        setOutput(result);
      }
    `}},XL=class{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Ts(this.outputShape.length);let a=e.outChannels/e.inChannels,i=e.padInfo.left,o=e.strideWidth,u=e.dilationWidth,c=e.filterHeight,l=e.filterWidth,d=l,h=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<l;g++)h+=`
          vec4 xTexelC${g*2};
          int xTexelC${g*2}Ready;
          vec4 xTexelC${g*2+1};
          int xTexelC${g*2+1}Ready;
          vec4 xC${g};`;h+=`
    for (int r = 0; r < ${c}; r++) {
      `;for(let g=0;g<l;g++)h+=`
          xTexelC${g*2} = vec4(0.0);
          xTexelC${g*2}Ready = 0;
          xTexelC${g*2+1} = vec4(0.0);
          xTexelC${g*2+1}Ready = 0;
          xC${g} = vec4(0.0);`;h+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let g=0;g<(d+1)/2;g++){let b=g*2;if(h+=`
          xC = xCCorner + ${b*u};
          `,o===1){if(b<l&&(i%2===1?(h+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }
              `,u===1&&b>0?h+=`
                xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);
                `:h+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${b} = vec4(previous.zw, xTexelC${b}.xy);
                  } else {
                    xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);
                  }
                  `):h+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xC${b} = xTexelC${b};
                `,b+1<l)){let y=i%2===0?$.nearestLargerEven(u):u;u%2===0&&i%2===1||u%2!==0&&i%2!==1?(h+=`
                  xCOffset = xC + imod(pads[1], 2) + ${y};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                    xTexelC${b+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${b+1}.zw = vec2(0.0);
                    }
                    xTexelC${b+1}Ready = 1;
                  }
                  `,u>1?h+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);
                    } else {
                     xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);
                    }
                    `:h+=`
                    xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);
                    `):y===1?h+=`
                    xC${b+1} = xTexelC${b};
                    `:h+=`
                    xCOffset = xC + ${y};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                      xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${b+1}.zw = vec2(0.0);
                      }
                      xTexelC${b+1}Ready = 1;
                    }

                    xC${b+1} = xTexelC${b+1};
                    `}}else b<l&&(i%2===1?(h+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.0);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
              `,b+1<l&&(h+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);
                `)):(h+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(
                  xTexelC${b}.xy, xTexelC${b+1}.xy);
              `,b+1<l&&(h+=`
                  xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
                `)));b<l&&(h+=`
            wTexel = getW(r, ${b}, d1, q);
            dotProd += xC${b} * vec4(wTexel.xz, wTexel.xz);
          `,b+1<l&&(h+=`
              wTexel = getW(r, ${b+1}, d1, q);
              dotProd += xC${b+1} * vec4(wTexel.xz, wTexel.xz);
            `))}h+=`
    }
  `,h+=`
      }
    `;let p="",f="";n&&(r?p=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?p=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:p=`vec4 activation(vec4 x) {
          ${n}
        }`,f="result = activation(result);");let m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${p}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${a};
        int q = d2 - d1 * ${a};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${h}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${m}
        ${f}
        setOutput(result);
      }
    `}};function Ewe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:u,dimRoundingMode:c}=r,l=u;l==null&&(l=[1,1]),$.assert(P.eitherStridesOrDilationsAreOne(i,l),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);let d=P.computeConv2DInfo(s.shape,a.shape,i,l,o,c,!0),h;ge().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels===1?h=new XL(d):h=new KL(d);let p=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return n.runWebGLProgram(h,[s,a],"float32",p)}var Awe={kernelName:Od,backendName:"webgl",kernelFunc:Ewe},$we=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,s=e.padInfo.left,a=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${a} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${s};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Rwe=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a=t-1-e.padInfo.top,i=n-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${o}; dm++) {
              int d2 = d1 * ${o} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function _we(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,dilations:o,pad:u,dimRoundingMode:c,filterShape:l}=r,d=P.computeConv2DInfo(s.shape,l,i,o,u,c,!0),h=new $we(d);return n.runWebGLProgram(h,[s,a],"float32")}var Dwe={kernelName:fw,backendName:"webgl",kernelFunc:_we};function Fwe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{strides:i,dilations:o,pad:u,dimRoundingMode:c,inputShape:l}=r,d=P.computeConv2DInfo(l,a.shape,i,o,u,c,!0),h=new Rwe(d);return n.runWebGLProgram(h,[s,a],"float32")}var Mwe={kernelName:mw,backendName:"webgl",kernelFunc:Fwe},Owe=class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};function Lwe(e){let{inputs:t,backend:n}=e,{x:r}=t,s=[...r.shape,...r.shape],a=$.sizeFromShape(r.shape),i=Ye({inputs:{x:r},backend:n,attrs:{shape:[a]}}),o=new Owe(a),u=n.runWebGLProgram(o,[i],i.dtype),c=Ye({inputs:{x:u},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(u),c}var Pwe={kernelName:Xy,backendName:"webgl",kernelFunc:Lwe},Bwe=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let{inHeight:t,inWidth:n,padInfo:r,strideHeight:s,strideWidth:a,filterHeight:i,filterWidth:o,dilationHeight:u,dilationWidth:c}=e,{top:l,left:d}=r;this.userCode=`
      const ivec2 strides = ivec2(${s}, ${a});
      const ivec2 pads = ivec2(${l}, ${d});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${i}; h++) {
          int hIn = hBeg + h * ${u};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${o}; w++) {
              int wIn = wBeg + w * ${c};

              if (wIn >= 0 && wIn < ${n}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};function zwe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:u}=r,c=P.computeDilation2DInfo(s.shape,a.shape,i,o,"NHWC",u),l,d=new Bwe(c);l=n.runWebGLProgram(d,[s,a],"float32");let h=Ye({inputs:{x:l},backend:n,attrs:{shape:c.outShape}});return n.disposeIntermediateTensorInfo(l),h}var Wwe={kernelName:Ld,backendName:"webgl",kernelFunc:zwe};function Vwe(e){let{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,a=t,{allDims:i,summedDims:o,idDims:u}=P.decodeEinsumEquation(s,a.length);P.checkEinsumDimSizes(i.length,u,a);let{path:c,steps:l}=P.getEinsumComputePath(o,u),d=l.length,h=null,p=i.length,f=[];for(let m=0;m<d;++m){for(let g of l[m]){let{permutationIndices:b,expandDims:y}=P.getEinsumPermutation(p,u[g]),x;P.isIdentityPermutation(b)?x=a[g]:(x=Us({inputs:{x:a[g]},backend:n,attrs:{perm:b}}),f.push(x));let w=x.shape.slice();for(let v=0;v<y.length;++v)w.splice(y[v],0,1);$.arraysEqual(x.shape,w)||(x=Ye({inputs:{x},backend:n,attrs:{shape:w}}),f.push(x)),h===null?h=x:(h=S4({inputs:{a:x,b:h},backend:n}),f.push(h))}m<d-1&&(c[m]>=0&&(h=Dv({inputs:{x:h},backend:n,attrs:{axis:c[m]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(let m of f)m!==h&&n.disposeIntermediateTensorInfo(m);return h}var Uwe={kernelName:bw,backendName:"webgl",kernelFunc:Vwe},Gwe="return (x >= 0.0) ? x : (exp(x) - 1.0);",Hwe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,jwe=dn({opSnippet:Gwe,packedOpSnippet:Hwe}),qwe={kernelName:Bd,backendName:"webgl",kernelFunc:jwe},Kwe="return (b >= 0.0) ? a : a * (b + 1.0);",Xwe=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,Qwe=e=>{let{inputs:t,backend:n}=e,{dy:r,y:s}=t,a=ge().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new _m(Xwe,r.shape,s.shape):new Zc(Kwe,r.shape,s.shape);return n.runWebGLProgram(a,[r,s],r.dtype)},Ywe={kernelName:Ef,backendName:"webgl",kernelFunc:Qwe},Jwe=`
  return vec4(equal(a, b));
`,Zwe="return float(a == b);",eve=gs({opSnippet:Zwe,packedOpSnippet:Jwe,dtype:"bool",cpuKernelImpl:$0e}),tve={kernelName:Af,backendName:"webgl",kernelFunc:eve},nve=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${P.ERF_P};
  float a1 = ${P.ERF_A1};
  float a2 = ${P.ERF_A2};
  float a3 = ${P.ERF_A3};
  float a4 = ${P.ERF_A4};
  float a5 = ${P.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,rve=dn({opSnippet:nve}),sve={kernelName:zd,backendName:"webgl",kernelFunc:rve},ave=Dm+`
  return exp(x);
`,ive=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,QL=dn({opSnippet:ave,packedOpSnippet:ive,cpuKernelImpl:R0e,dtype:"float32"}),ove={kernelName:Wd,backendName:"webgl",kernelFunc:QL};function WC(e){let{inputs:t,attrs:n,backend:r}=e,{dim:s}=n,{input:a}=t,i=a.shape.length,o=a.shape.slice(),u=s;return s<0&&($.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+s+1),o.splice(u,0,1),Ye({inputs:{x:a},backend:r,attrs:{shape:o}})}var lve={kernelName:$f,backendName:"webgl",kernelFunc:WC},x_="return exp(x) - 1.0;",uve=dn({opSnippet:x_,packedOpSnippet:x_,cpuKernelImpl:_0e}),cve={kernelName:Vd,backendName:"webgl",kernelFunc:uve},w_=class{constructor(e,t,n){this.variableNames=["real","imag"];let r=t[1];this.outputShape=t;let s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=n?`${r}.0`:"1.0",i;if(e==="real")i="return real * expR - imag * expI;";else if(e==="imag")i="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${s};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${i}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${a};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};function YL(e,t,n){let r=n.texData.get(e.dataId),s=$.sizeFromShape(e.shape),a=e.shape[e.shape.length-1],i=s/a,o=Ye({inputs:{x:e},backend:n,attrs:{shape:[i,a]}}),u=o.shape,c=new w_("real",u,t),l=new w_("imag",u,t),d=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:u},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:u}],h=n.runWebGLProgram(c,d,"float32"),p=n.runWebGLProgram(l,d,"float32"),f=Eu({inputs:{real:h,imag:p},backend:n});n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p);let m=Ye({inputs:{x:f},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(f),m}function dve(e){let{inputs:t,backend:n}=e,{input:r}=t;return YL(r,!1,n)}var hve={kernelName:yw,backendName:"webgl",kernelFunc:dve},pve=class{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};function U0(e){let{backend:t,attrs:n}=e,{shape:r,value:s}=n,{dtype:a}=n;if(a=a||$.inferDtype(s),a==="string"){let i=$.getArrayFromDType(a,$.sizeFromShape(r));return i.fill(s),t.makeTensorInfo(r,a,i)}else{let i=new pve(r,s),o=[[s]];return t.runWebGLProgram(i,[],a,o)}}var fve={kernelName:Qy,backendName:"webgl",kernelFunc:U0},mve=class{constructor(e){this.variableNames=["Image"],this.outputShape=[];let t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}},gve={kernelName:Rf,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{let{image:n}=e,r=t,s=new mve(n.shape);return r.runWebGLProgram(s,[n],n.dtype)}},v_="return floor(x);",bve=dn({opSnippet:v_,packedOpSnippet:v_,cpuKernelImpl:D0e}),yve={kernelName:Ud,backendName:"webgl",kernelFunc:bve},xve=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,wve=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,vve=gs({opSnippet:xve,packedOpSnippet:wve,dtype:"int32"}),Ive={kernelName:Gd,backendName:"webgl",kernelFunc:vve},kve=class{constructor(e){this.variableNames=["A"];let t=Qs(),[n,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}},Cve=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let t=Qs(),[n,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${n}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}},Sve={kernelName:ox,backendName:"webgl",kernelFunc:Nve},pp,pk=ge().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function Nve(e){let{inputs:t,backend:n,attrs:r}=e,{pixels:s}=t,{numChannels:a}=r,i=typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement,o=typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement,[u,c]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],l=[c,u],d=[c,u,a];if(o||i){let m=ge().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(pp==null||m!==pk)&&(pk=m,pp=document.createElement("canvas").getContext("2d",{willReadFrequently:pk})),pp.canvas.width=u,pp.canvas.height=c,pp.drawImage(s,0,0,u,c),s=pp.canvas}let h=n.makeTensorInfo(l,"int32");n.texData.get(h.dataId).usage=Pa.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(h.dataId),s);let p=ge().getBool("WEBGL_PACK")?new Cve(d):new kve(d),f=n.runWebGLProgram(p,[h],"int32");return n.disposeData(h.dataId),f}function Tve(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:u,pad:c,dataFormat:l,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r,m=P.convertConv2DDataFormat(l),g=P.computeConv2DInfo(s.shape,a.shape,u,d,c,h,!1,m),b,y=[],x=i!=null,w=o!=null,v=p==="leakyrelu",I=()=>{let T=[s,a],E=(A,k)=>{if(k==="NCHW"&&A.shape.length===1&&A.shape[0]!==1){let C=Ye({inputs:{x:A},backend:n,attrs:{shape:[A.shape[0],1,1]}});return y.push(C),C}return A};if(x&&T.push(E(i,l)),w&&T.push(E(o,l)),v){let A=n.makeTensorInfo([],"float32",$.createScalarValue(f,"float32"));T.push(A),y.push(A)}return T};if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))b=HL({x:s,filter:a,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else if(g.strideWidth<=2&&m==="channelsLast"&&ge().getBool("WEBGL_EXP_CONV")){let T=p?xy(p,!0):null,E=new GL(g,x,T,w,v),A=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],k=I();b=n.runWebGLProgram(E,k,"float32",A)}else if(ge().getBool("WEBGL_CONV_IM2COL"))b=jL({x:s,filter:a,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else{let T=p?xy(p,!1):null,E=new UL(g,x,T,w,v),A=I();b=n.runWebGLProgram(E,A,"float32")}let N=Ye({inputs:{x:b},backend:n,attrs:{shape:g.outShape}});return y.push(b),y.forEach(T=>n.disposeIntermediateTensorInfo(T)),N}var Eve={kernelName:Lc,backendName:"webgl",kernelFunc:Tve};function Ave(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:u,pad:c,dilations:l,dimRoundingMode:d,activation:h,leakyreluAlpha:p}=r,f=[],m=l;m==null&&(m=[1,1]),$.assert(P.eitherStridesOrDilationsAreOne(u,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${m}'`);let g=P.computeConv2DInfo(s.shape,a.shape,u,m,c,d,!0),b=ge().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,y=h?xy(h,b):null,x=[s,a],w=i!=null,v=o!=null,I=h==="leakyrelu";if(w&&x.push(i),v&&x.push(o),I){let A=n.makeTensorInfo([],"float32",$.createScalarValue(p,"float32"));x.push(A),f.push(A)}let N;b?N=new XL(g,w,y,v,I):N=new KL(g,w,y,v,I);let T=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],E=n.runWebGLProgram(N,x,"float32",T);return f.forEach(A=>n.disposeIntermediateTensorInfo(A)),E}var $ve={kernelName:Pc,backendName:"webgl",kernelFunc:Ave},Rve=class{constructor(e,t,n,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;let s=Wn(n.length),a=`
    int index;`;for(let i=0;i<this.sliceDim;i++)a+=`
          index = round(getIndices(coords[0], ${i}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[i]};
          flattenIndex += index * ${this.strides[i]};`;this.userCode=`
         void main() {
          ${s} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${a}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}};function _ve(e){let{inputs:t,backend:n}=e,{params:r,indices:s}=t,a=s.shape,i=a[a.length-1],o=$.sizeFromShape(r.shape),[u,c,l,d]=P.prepareAndValidate(r,s),h=Ye({inputs:{x:s},backend:n,attrs:{shape:[c,i]}}),p=Ye({inputs:{x:r},backend:n,attrs:{shape:[$.sizeFromShape(r.shape)/l,l]}});if(n.shouldExecuteOnCPU([r,s])||r.dtype==="string"){let b=n.readSync(s.dataId),y=n.bufferSync(r),x=F0e(b,y,r.dtype,c,i,l,d,r.shape,o);return n.makeTensorInfo(u,r.dtype,x.values)}let f=new Rve(i,d,[c,l],r.shape),m=n.runWebGLProgram(f,[p,h],p.dtype),g=Ye({inputs:{x:m},backend:n,attrs:{shape:u}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}var Dve={kernelName:Df,backendName:"webgl",kernelFunc:_ve},Fve=class{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;let n=Wn(this.rank),r=Mve(e);this.userCode=`
      void main() {
        ${n} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}};function Mve(e,t){let n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<e.length;s++)s===2?r.push("index"):r.push(`${n[s]}`);return r.join()}function JL(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,indices:a}=t,{axis:i,batchDims:o}=r,u=$.parseAxisParam(i,s.shape)[0];if(ge().get("DEBUG")){let y=n.readSync(a.dataId),x=s.shape[u];for(let w=0;w<y.length;++w){let v=y[w];$.assert(v<=x-1&&v>=0,()=>`GatherV2: the index value ${v} is not in [0, ${x-1}]`)}}let c=P.segment_util.collectGatherOpShapeInfo(s,a,u,o),l=$.sizeFromShape(a.shape),d=[],h=Ye({inputs:{x:s},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),p=Ye({inputs:{x:a},backend:n,attrs:{shape:[c.batchSize,l/c.batchSize]}});d.push(h),d.push(p);let f=[c.batchSize,c.outerSize,l/c.batchSize,c.sliceSize];if(n.shouldExecuteOnCPU([s,a])||s.dtype==="string"){let y=n.bufferSync(p),x=n.bufferSync(h),w=M0e(x,y,f);return d.forEach(v=>n.disposeIntermediateTensorInfo(v)),n.makeTensorInfo(c.outputShape,w.dtype,w.values)}let m=new Fve(h.shape,f),g=n.runWebGLProgram(m,[h,p],h.dtype);d.push(g);let b=Ye({inputs:{x:g},backend:n,attrs:{shape:c.outputShape}});return d.forEach(y=>n.disposeIntermediateTensorInfo(y)),b}var Ove={kernelName:_f,backendName:"webgl",kernelFunc:JL},Lve="return float(a > b);",Pve=`
  return vec4(greaterThan(a, b));
`,Bve=gs({opSnippet:Lve,packedOpSnippet:Pve,cpuKernelImpl:O0e,dtype:"bool"}),zve={kernelName:Ff,backendName:"webgl",kernelFunc:Bve},Wve="return float(a >= b);",Vve=`
  return vec4(greaterThanEqual(a, b));
`,Uve=gs({opSnippet:Wve,packedOpSnippet:Vve,dtype:"bool",cpuKernelImpl:L0e}),Gve={kernelName:jd,backendName:"webgl",kernelFunc:Uve};function Hve(e){let{inputs:t,backend:n}=e,{input:r}=t;return YL(r,!0,n)}var jve={kernelName:xw,backendName:"webgl",kernelFunc:Hve},qve="return float(!isnan(x) && !isinf(x));",Kve=dn({opSnippet:qve,dtype:"bool"}),Xve={kernelName:Kd,backendName:"webgl",kernelFunc:Kve},Qve="return float(isinf(x));",Yve=dn({opSnippet:Qve,dtype:"bool"}),Jve={kernelName:Xd,backendName:"webgl",kernelFunc:Yve},Zve="return float(isnan(x));",eIe=dn({opSnippet:Zve,dtype:"bool"}),tIe={kernelName:Qd,backendName:"webgl",kernelFunc:eIe},nIe="return float(a < b);",rIe=`
  return vec4(lessThan(a, b));
`,sIe=gs({opSnippet:nIe,packedOpSnippet:rIe,cpuKernelImpl:P0e,dtype:"bool"}),aIe={kernelName:Mf,backendName:"webgl",kernelFunc:sIe},iIe="return float(a <= b);",oIe=`
  return vec4(lessThanEqual(a, b));
`,lIe=gs({opSnippet:iIe,packedOpSnippet:oIe,cpuKernelImpl:B0e,dtype:"bool"}),uIe={kernelName:Of,backendName:"webgl",kernelFunc:lIe};function cIe(e){let{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,i=z0e(r,s,a);return t.makeTensorInfo([i.length],"float32",i)}var dIe={kernelName:Lf,backendName:"webgl",kernelFunc:cIe},hIe=Dm+`
  return x < 0.0 ? 0./0. : log(x);
`,pIe=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,fIe=dn({opSnippet:hIe,packedOpSnippet:pIe,cpuKernelImpl:W0e}),mIe={kernelName:Jd,backendName:"webgl",kernelFunc:fIe},gIe=Dm+`
  return log(1.0 + x);
`,bIe=dn({opSnippet:gIe}),yIe={kernelName:Zd,backendName:"webgl",kernelFunc:bIe},xIe="return float(a >= 1.0 && b >= 1.0);",wIe=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,vIe=gs({opSnippet:xIe,packedOpSnippet:wIe,dtype:"bool"}),IIe={kernelName:Pf,backendName:"webgl",kernelFunc:vIe},kIe="return float(!(x >= 1.0));",CIe=dn({opSnippet:kIe}),SIe={kernelName:Bf,backendName:"webgl",kernelFunc:CIe},NIe="return float(a >= 1.0 || b >= 1.0);",TIe=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,EIe=gs({opSnippet:NIe,packedOpSnippet:TIe,dtype:"bool"}),AIe={kernelName:zf,backendName:"webgl",kernelFunc:EIe},$Ie=class{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[];let a=t,i=e[3]-1;this.outputShape=e;let o,u=`float(${n}) + float(${r}) * sum`;s===.5?o=`inversesqrt(${u})`:s===1?o=`1.0/(${u})`:o=`exp(log(${u}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${a}; j <= ${a}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${i}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${o};
        setOutput(val);
      }
    `}},RIe=class{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let a=t,i=e[3]-1;this.outputShape=e;let o,u=`float(${n}) + float(${r}) * sum`;s===.5?o=`inversesqrt(${u})`:s===1?o=`1.0/(${u})`:o=`exp(log(${u}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${a};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${a}; j <= ${a}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${o};
        setOutput(result);
      }
    `}},_Ie=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:i,alpha:o,beta:u}=r,c=ge().getBool("WEBGL_PACK_NORMALIZATION")?new RIe(s.shape,a,i,o,u):new $Ie(s.shape,a,i,o,u);return n.runWebGLProgram(c,[s],s.dtype)},DIe={kernelName:eh,backendName:"webgl",kernelFunc:_Ie},FIe=class{constructor(e,t,n,r,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=s,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${n});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${s})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${s});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}},MIe=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:i}=t,{depthRadius:o,bias:u,alpha:c,beta:l}=r,d=new FIe(s.shape,o,u,c,l);return n.runWebGLProgram(d,[s,a,i],s.dtype)},OIe={kernelName:Wf,backendName:"webgl",kernelFunc:MIe};function LIe(e,t,n,r){let s=$.sizeFromShape(t),a=$.sizeFromShape(e.shape)/s,i=Ye({inputs:{x:e},attrs:{shape:[a,s]},backend:r}),o=jh(i,e.dtype,"max",r),u=Ye({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(o),u}function ZL(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:a,keepDims:i}=r,o=s.shape.length,u=$.parseAxisParam(a,s.shape),c=u,l=P.getAxesPermutation(c,o),d=l!=null,h=n.shouldExecuteOnCPU([s]),p=s;if(d){if(h){let y=n.texData.get(p.dataId).values,x=new Array(o);for(let I=0;I<x.length;I++)x[I]=s.shape[l[I]];let w=I4(y,s.shape,s.dtype,l,x);p=n.makeTensorInfo(x,s.dtype);let v=n.texData.get(p.dataId);v.values=w}else p=_v(s,l,n);c=P.getInnerMostAxes(c.length,o)}P.assertAxesAreInnerMostDims("max",c,o);let[f,m]=P.computeOutAndReduceShapes(p.shape,c),g=f;i&&(g=P.expandShapeToKeepDim(f,u));let b;if(h){let y=n.texData.get(p.dataId).values,x=V0e(y,$.sizeFromShape(m),g,s.dtype);b=n.makeTensorInfo(g,s.dtype);let w=n.texData.get(b.dataId);w.values=x}else b=LIe(p,m,g,n);return d&&n.disposeIntermediateTensorInfo(p),b}var PIe={kernelName:th,backendName:"webgl",kernelFunc:ZL},BIe=C4+`
  return max(a, b);
`,zIe=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Hh+`
  return result;
`,WIe=gs({opSnippet:BIe,packedOpSnippet:zIe,cpuKernelImpl:U0e}),VIe={kernelName:nh,backendName:"webgl",kernelFunc:WIe};function UIe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t;Tm(s,"maxPool");let{filterSize:a,strides:i,pad:o,dimRoundingMode:u}=r,c=1;$.assert(P.eitherStridesOrDilationsAreOne(i,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);let l=P.computePool2DInfo(s.shape,a,i,c,o,u);if(l.filterWidth===1&&l.filterHeight===1&&$.arraysEqual(l.inShape,l.outShape))return Aa({inputs:{x:s},backend:n});let d=new wy(l,"max",!1);return n.runWebGLProgram(d,[s],s.dtype)}var GIe={kernelName:rh,backendName:"webgl",kernelFunc:UIe};function HIe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dataFormat:u,dimRoundingMode:c}=r,l=[1,1,1],d=P.computePool3DInfo(s.shape,a,i,l,o,c,u),h=new N4(d,"max",!1);return n.runWebGLProgram(h,[s],s.dtype)}var jIe={kernelName:Vf,backendName:"webgl",kernelFunc:HIe},qIe=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,s=e.effectiveFilterHeight,a=e.effectiveFilterWidth,i=s-1-e.padInfo.top,o=a-1-e.padInfo.left,u=s*a-1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${s};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${a}; wC++) {
            float dyC = float(dyCCorner + wC) / ${n}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${a} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},KIe=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,s=e.dilationDepth,a=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterDepth,u=e.effectiveFilterHeight,c=e.effectiveFilterWidth,l=o-1-e.padInfo.front,d=u-1-e.padInfo.top,h=c-1-e.padInfo.left,p=o*u*c-1;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${d}, ${h});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${o};
           wD += ${s}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${u};
              wR += ${a}) {
            float dyR = float(dyRCorner + wR) / ${n}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${c};
                wC += ${i}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${p} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${u} * ${c} +
                  wR * ${c} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function XIe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a,{filterSize:o,strides:u,pad:c,dimRoundingMode:l}=r,d=[1,1,1],h=P.computePool3DInfo(i.shape,o,u,d,c,l),p=new N4(h,"max",!0),f=n.runWebGLProgram(p,[i],i.dtype),m=new KIe(h),g=n.runWebGLProgram(m,[s,f],i.dtype);return n.disposeIntermediateTensorInfo(f),g}var QIe={kernelName:Jy,backendName:"webgl",kernelFunc:XIe};function YIe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a,output:i}=t,o=a;Tm([a,i],"maxPoolGrad");let{filterSize:u,strides:c,pad:l,dimRoundingMode:d}=r,h=P.computePool2DInfo(o.shape,u,c,1,l,d),p=!0,f=new wy(h,"max",p),m=n.runWebGLProgram(f,[o],o.dtype),g=new qIe(h),b=n.runWebGLProgram(g,[s,m],o.dtype);return n.disposeIntermediateTensorInfo(m),b}var JIe={kernelName:Yy,backendName:"webgl",kernelFunc:YIe};function ZIe(e,t,n,r){let s=new wy(n,"max",!1),a=r.runWebGLProgram(s,[e],"float32");s=new wy(n,"max",!0,!0,t);let i=r.runWebGLProgram(s,[e],"float32");return[a,i]}var eke={kernelName:Zy,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{filterSize:s,strides:a,pad:i,includeBatchInIndex:o}=t,u=n;$.assert(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);let c=[1,1];$.assert(P.eitherStridesOrDilationsAreOne(a,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);let l=P.computePool2DInfo(r.shape,s,a,c,i),[d,h]=ZIe(r,o,l,u);return[d,h]}};function tke(e,t,n,r){let s=$.sizeFromShape(t),a=$.sizeFromShape(e.shape)/s,i=Ye({inputs:{x:e},attrs:{shape:[a,s]},backend:r}),o=jh(i,"float32","mean",r),u=Ye({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(o),u}var nke={kernelName:sh,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{keepDims:s,axis:a}=t,i=n,o=r.shape.length,u=$.parseAxisParam(a,r.shape),c=u,l=P.getAxesPermutation(c,o),d=l!=null,h=i.shouldExecuteOnCPU([r]),p=[],f=r;if(d){if(h){let x=i.texData.get(f.dataId).values,w=new Array(o);for(let N=0;N<w.length;N++)w[N]=r.shape[l[N]];let v=I4(x,r.shape,r.dtype,l,w);f=i.makeTensorInfo(w,r.dtype);let I=i.texData.get(f.dataId);I.values=v}else f=_v(r,l,i);p.push(f),c=P.getInnerMostAxes(c.length,o)}P.assertAxesAreInnerMostDims("sum",c,o);let[m,g]=P.computeOutAndReduceShapes(f.shape,c),b=m;s&&(b=P.expandShapeToKeepDim(m,u));let y=tke(f,g,b,i);for(let x of p)i.disposeIntermediateTensorInfo(x);return y}};function rke(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,u=$.parseAxisParam(a,s.shape),c=u,l=P.getAxesPermutation(c,o),d=s;l!=null&&(d=Us({inputs:{x:s},backend:n,attrs:{perm:l}}),c=P.getInnerMostAxes(c.length,s.shape.length)),P.assertAxesAreInnerMostDims("min",c,o);let[h,p]=P.computeOutAndReduceShapes(d.shape,c),f=$.sizeFromShape(p),m=Ye({inputs:{x:d},backend:n,attrs:{shape:[-1,f]}}),g=jh(m,m.dtype,"min",n),b;if(i){let y=P.expandShapeToKeepDim(h,u);b=Ye({inputs:{x:g},backend:n,attrs:{shape:y}})}else b=Ye({inputs:{x:g},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),l!=null&&n.disposeIntermediateTensorInfo(d),b}var ske={kernelName:ah,backendName:"webgl",kernelFunc:rke},ake=C4+`
  return min(a, b);
`,ike=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Hh+`
  return result;
`,oke=gs({opSnippet:ake,packedOpSnippet:ike,cpuKernelImpl:G0e}),lke={kernelName:ih,backendName:"webgl",kernelFunc:oke},uke=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map((c,l)=>c[0]+e[l]+c[1]);let r=e.length,s=Wn(r),a=t.map(c=>c[0]).join(","),i=t.map((c,l)=>c[0]+e[l]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),u=n==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${a};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${u};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${u};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${a});
      ${s} end = ${s}(${i});

      void main() {
        ${s} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${u};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};
          }
        }
        ${s} coords = outC - start;
        setOutput(getX(${o}));
      }
    `}},cke=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((p,f)=>p[0]+e[f]+p[1]);let r=e.length,s=Wn(r),a=t.map(p=>p[0]).join(","),i=t.map((p,f)=>p[0]+e[f]).join(","),o=Ps("rc",r),u=Ps("source",r),c=`${o[r-1]} < ${this.outputShape[r-1]}`,l=r===1?"source":`vec2(${u.slice(-2).join()})`,d=n==="reflect"?0:1,h="";if(r===1){let p=`
        ${s} source = rc;
        if (source < start) {
          source = start * 2 - source - ${d};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${d};
        }
        source -= start;
      `;h=`
        ${s} rc = outputLoc;
        ${p}
        result[0] = getChannel(getX(${u.join()}), ${l});
        ${o[r-1]} += 1;
        if(${c}) {
          ${p}
          result[1] = getChannel(getX(${u.join()}), ${l});
        }
      `}else{let p=`
        ${s} source = rc;
        ${s} lt = ${s}(lessThan(source, start));
        ${s} gte = ${s}(greaterThanEqual(source, end));
        ${s} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${d}) +
                gte * ((end - 1) * 2 - source + ${d});
        source -= start;
      `;h=`
        ${s} rc = outputLoc;
        ${p}
        result[0] = getChannel(getX(${u.join()}), ${l});
        ${o[r-1]} += 1;
        if(${c}) {
          ${p}
          result[1] = getChannel(getX(${u.join()}), ${l});
        }
        rc = outputLoc;
        ${o[r-2]} += 1;
        if(${o[r-2]} < ${this.outputShape[r-2]}) {
          ${p}
          result[2] = getChannel(getX(${u.join()}), ${l});
          ${o[r-1]} += 1;
          if(${c}) {
            ${p}
            result[3] = getChannel(getX(${u.join()}), ${l});
          }
        }
      `}this.userCode=`
      const ${s} start = ${s}(${a});
      const ${s} end = ${s}(${i});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${h}
        setOutput(result);
      }
    `}},dke=({inputs:e,backend:t,attrs:n})=>{let{x:r}=e,{paddings:s,mode:a}=n,i=ge().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new cke(r.shape,s,a):new uke(r.shape,s,a);return t.runWebGLProgram(i,[r],r.dtype)},hke={kernelName:oh,backendName:"webgl",kernelFunc:dke},pke=`if (b == 0.0) return NAN;
  return mod(a, b);`,fke=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Hh+`
  return result;
`,mke=gs({opSnippet:pke,packedOpSnippet:fke}),gke={kernelName:lh,backendName:"webgl",kernelFunc:mke},bke=class{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}},yke=`
if (a == b) {
  return 1.0;
};
return a / b;`,xke=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,eP=gs({opSnippet:yke,packedOpSnippet:xke,checkOutOfBounds:!0}),wke={kernelName:Pd,backendName:"webgl",kernelFunc:eP},I_="return a - b;",tP=gs({opSnippet:I_,packedOpSnippet:I_,supportsComplex:!0,cpuKernelImpl:d1e}),vke={kernelName:Dh,backendName:"webgl",kernelFunc:tP};function nP(e){let{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:a}=r,i=$.parseAxisParam([a],s.shape),o=ZL({inputs:{x:s},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),u=P.expandShapeToKeepDim(o.shape,i),c=Ye({inputs:{x:o},backend:n,attrs:{shape:u}}),l=tP({inputs:{a:s,b:c},backend:n}),d=QL({inputs:{x:l},backend:n}),h=Dv({inputs:{x:d},backend:n,attrs:{axis:i,keepDims:!1}}),p=Ye({inputs:{x:h},backend:n,attrs:{shape:u}}),f=eP({inputs:{a:d,b:p},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),f}var Ike={kernelName:Rh,backendName:"webgl",kernelFunc:nP};function kke(e){let{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:i,normalized:o}=r,u=o?s:nP({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),c=u.shape[0],l=u.shape[1],d=new bke(c,l,a),h=[[i]],p=n.runWebGLProgram(d,[u],"int32",h);return o||n.disposeIntermediateTensorInfo(u),p}var Cke={kernelName:Uf,backendName:"webgl",kernelFunc:kke},Ske=bi+`
  return -x;
`,Nke=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function Tke(e){let{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){let a=n.texData.get(r.dataId),[i,o]=j0e(a.values,r.shape,r.dtype);return n.makeTensorInfo(o,r.dtype,i)}let s;return ge().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new Ll(r.shape,Nke):s=new bo(r.shape,Ske),n.runWebGLProgram(s,[r],r.dtype)}var Eke={kernelName:Gf,backendName:"webgl",kernelFunc:Tke},Ake=Lo.nonMaxSuppressionV3Impl;function $ke(e){P.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u}=r,c=n.readSync(s.dataId),l=n.readSync(a.dataId),{selectedIndices:d}=Ake(c,l,i,o,u);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}var Rke={kernelName:jf,backendName:"webgl",kernelFunc:$ke},_ke=Lo.nonMaxSuppressionV4Impl;function Dke(e){P.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u,padToMaxOutputSize:c}=r,l=n.readSync(s.dataId),d=n.readSync(a.dataId),{selectedIndices:h,validOutputs:p}=_ke(l,d,i,o,u,c);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}var Fke={kernelName:qf,backendName:"webgl",kernelFunc:Dke},Mke=Lo.nonMaxSuppressionV5Impl;function Oke(e){P.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u,softNmsSigma:c}=r,l=n.readSync(s.dataId),d=n.readSync(a.dataId),h=i,p=o,f=u,m=c,{selectedIndices:g,selectedScores:b}=Mke(l,d,h,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}var Lke={kernelName:Kf,backendName:"webgl",kernelFunc:Oke},Pke=class{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${n}),
                      float(index == coords.y)));
      }
    `}},Bke=e=>{let{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{dtype:a,depth:i,onValue:o,offValue:u}=r,c=$.sizeFromShape(s.shape),l=new Pke(c,i,o,u),d=Ye({inputs:{x:s},backend:n,attrs:{shape:[c]}}),h=n.runWebGLProgram(l,[d],a);n.disposeIntermediateTensorInfo(d);let p=[...s.shape,i],f=Ye({inputs:{x:h},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(h),f},zke={kernelName:ch,backendName:"webgl",kernelFunc:Bke};function $x(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="complex64"){let s=V0({inputs:{input:r},backend:n}),a=$x({inputs:{x:s},backend:n}),i=Fv({inputs:{input:r},backend:n}),o=$x({inputs:{x:i},backend:n}),u=Eu({inputs:{real:a,imag:o},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),u}else return U0({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:n})}var Wke={kernelName:pm,backendName:"webgl",kernelFunc:$x};function rP(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){let s=V0({inputs:{input:r},backend:n}),a=rP({inputs:{x:s},backend:n}),i=Fv({inputs:{input:r},backend:n}),o=$x({inputs:{x:i},backend:n}),u=Eu({inputs:{real:a,imag:o},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),u}else return U0({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:n})}var Vke={kernelName:Xf,backendName:"webgl",kernelFunc:rP};function Uke(e){let{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(t.length===1)return WC({inputs:{input:t[0]},backend:n,attrs:{dim:s}});let a=t[0].shape,i=t[0].dtype;t.forEach(l=>{$.assertShapesMatch(a,l.shape,"All tensors passed to stack must have matching shapes"),$.assert(i===l.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],u=t.map(l=>{let d=WC({inputs:{input:l},backend:n,attrs:{dim:s}});return o.push(d),d}),c=VL({inputs:u,backend:n,attrs:{axis:s}});return o.forEach(l=>n.disposeIntermediateTensorInfo(l)),c}var Gke={kernelName:Qf,backendName:"webgl",kernelFunc:Uke},Hke=class{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((u,c)=>u[0]+e[c]+u[1]);let r=e.length,s=Wn(r),a=t.map(u=>u[0]).join(","),i=t.map((u,c)=>u[0]+e[c]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${a};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${a});
      ${s} end = ${s}(${i});

      void main() {
        ${s} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${s} coords = outC - start;
          setOutput(getX(${o}));
        }
      }
    `}},jke=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((f,m)=>f[0]+e[m]+f[1]);let r=e.length,s=Wn(r),a=t.map(f=>f[0]).join(","),i=t.map((f,m)=>f[0]+e[m]).join(","),o=Ps("rc",r),u=Ps("source",r),c=`${o[r-1]} < ${this.outputShape[r-1]}`,l=r===1?"source":`vec2(${u.slice(-2).join()})`,d=[`${s} rc = outputLoc;`,`${o[r-1]} += 1;
       if(${c}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${o[r-2]} += 1;
       if(${o[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${o[r-1]} += 1;
         if(${c}) {`],h=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",p="";for(let f=0,m=r===1?2:4;f<m;f++)p+=`
        ${d[f]}
        if (${h}) {
          result[${f}] = float(value);
        } else {
          ${s} source = rc - start;
          result[${f}] = getChannel(getX(${u.join()}), ${l});
        }
      `;p+=r===1?"} ":"}}",this.userCode=`
      const ${s} start = ${s}(${a});
      const ${s} end = ${s}(${i});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `}},sP=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,constantValue:i}=r;if($.sizeFromShape(s.shape)===0){let c=a.map((l,d)=>l[0]+s.shape[d]+l[1]);return U0({backend:n,attrs:{shape:c,value:i,dtype:s.dtype}})}let o=ge().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new jke(s.shape,a,i):new Hke(s.shape,a,i),u=[[i]];return n.runWebGLProgram(o,[s],s.dtype,u)},qke={kernelName:dh,backendName:"webgl",kernelFunc:sP},Kke=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,Xke=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Hh+`
  return result;
`,Qke=gs({opSnippet:Kke,packedOpSnippet:Xke}),Yke={kernelName:hh,backendName:"webgl",kernelFunc:Qke};function Jke(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,u=[],c=$.parseAxisParam(a,s.shape),l=c,d=P.getAxesPermutation(l,o),h=s;d!=null&&(h=Us({inputs:{x:s},backend:n,attrs:{perm:d}}),l=P.getInnerMostAxes(l.length,o),u.push(h)),P.assertAxesAreInnerMostDims("prod",l,o);let p;if(n.shouldExecuteOnCPU([h])){let f=n.texData.get(h.dataId).values,{outVals:m,outShape:g,outDtype:b}=K0e(h.shape,h.dtype,f,l);p=n.makeTensorInfo(g,b,m)}else{let[f,m]=P.computeOutAndReduceShapes(h.shape,l),g=$.sizeFromShape(m),b=Ye({inputs:{x:h},backend:n,attrs:{shape:[-1,g]}}),y=Nw(s.dtype),x=jh(b,y,"prod",n);p=Ye({inputs:{x},backend:n,attrs:{shape:f}}),u.push(b),u.push(x)}if(i){u.push(p);let f=P.expandShapeToKeepDim(p.shape,c);p=Ye({inputs:{x:p},backend:n,attrs:{shape:f}})}return u.forEach(f=>n.disposeIntermediateTensorInfo(f)),p}var Zke={kernelName:fh,backendName:"webgl",kernelFunc:Jke};function eCe(e){let{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:s,paramsDenseValues:a,indices:i}=t,{outputRaggedRank:o}=r,u=s.map(b=>n.readSync(b.dataId)),c=s.map(b=>b.shape),l=n.readSync(a.dataId),d=n.readSync(i.dataId),[h,p,f]=X0e(u,c,l,a.shape,a.dtype,d,i.shape,o),m=h.map(b=>n.makeTensorInfo([b.length],"int32",b)),g=n.makeTensorInfo(f,a.dtype,p);return m.concat([g])}var tCe={kernelName:vw,backendName:"webgl",kernelFunc:eCe};function nCe(e){let{inputs:t,backend:n}=e,{starts:r,limits:s,deltas:a}=t,i=n.readSync(r.dataId),o=n.readSync(s.dataId),u=n.readSync(a.dataId),[c,l]=Q0e(i,r.shape,r.dtype,o,s.shape,u,a.shape),d=n.makeTensorInfo([c.length],"int32",c),h=n.makeTensorInfo([l.length],r.dtype,l);return[d,h]}var rCe={kernelName:Iw,backendName:"webgl",kernelFunc:nCe};function sCe(e){let{inputs:t,backend:n,attrs:r}=e,{shape:s,values:a,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:u}=r,c=n.readSync(s.dataId),l=n.readSync(a.dataId),d=n.readSync(i.dataId),h=o.map(g=>n.readSync(g.dataId)),p=o.map(g=>g.shape),[f,m]=Y0e(c,s.shape,l,a.shape,a.dtype,d,i.shape,h,p,u);return n.makeTensorInfo(f,a.dtype,m)}var aCe={kernelName:kw,backendName:"webgl",kernelFunc:sCe},aP=e=>{let{backend:t,attrs:n}=e,{start:r,stop:s,step:a,dtype:i}=n,o=J0e(r,s,a,i);return t.makeTensorInfo([o.length],i,o)},iCe={kernelName:e0,backendName:"webgl",kernelFunc:aP},oCe="return 1.0 / x;",lCe=dn({opSnippet:oCe}),uCe={kernelName:mh,backendName:"webgl",kernelFunc:lCe},cCe=bi+`
  return (x < 0.0) ? 0.0 : x;
`,dCe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,hCe=dn({opSnippet:cCe,packedOpSnippet:dCe}),pCe={kernelName:gh,backendName:"webgl",kernelFunc:hCe},fCe=bi+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,mCe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,gCe=dn({opSnippet:fCe,packedOpSnippet:mCe}),bCe={kernelName:xh,backendName:"webgl",kernelFunc:gCe},yCe=class{constructor(e,t,n,r,s){this.variableNames=["A"],this.outputShape=[];let[a,i,o,u]=e;this.outputShape=[a,t,n,u];let c=[r&&t>1?i-1:i,r&&n>1?o-1:o],l=[r&&t>1?t-1:t,r&&n>1?n-1:n],d;s?d="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/l[0]},
          ${c[1]/l[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}},xCe=class{constructor(e,t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[a,i,o,u]=e;this.outputShape=[a,t,n,u];let c=[r&&t>1?i-1:i,r&&n>1?o-1:o],l=[r&&t>1?t-1:t,r&&n>1?n-1:n],d;s?d="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/l[0]},
          ${c[1]/l[1]},
          ${c[1]/l[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,
                                     ${o}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${n-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}};function wCe(e){let{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r,[u,c]=o,l=ge().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new xCe(s.shape,u,c,a,i):new yCe(s.shape,u,c,a,i);return n.runWebGLProgram(l,[s],"float32")}var vCe={kernelName:yh,backendName:"webgl",kernelFunc:wCe},ICe=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,r,s]=t,[,a,i]=e,o=[n&&a>1?r-1:r,n&&i>1?s-1:s],u=[n&&a>1?a-1:a,n&&i>1?i-1:i],c=o[0]/u[0],l=o[1]/u[1],d=1/c,h=1/l,p=Math.ceil(d)*2+2,f=Math.ceil(h)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${l});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${h});

        const int winHeight = int(${p});
        const int winWidth = int(${f});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function kCe(e){let{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=new ICe(a.shape,s.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}var CCe={kernelName:Zf,backendName:"webgl",kernelFunc:kCe},SCe=class{constructor(e,t,n,r,s){this.variableNames=["A"],this.outputShape=[];let[a,i,o,u]=e;this.outputShape=[a,t,n,u];let c=[r&&t>1?i-1:i,r&&n>1?o-1:o],l=[r&&t>1?t-1:t,r&&n>1?n-1:n],d=r?"0.5":"0.0",h;s?h="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":h="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/l[0]},
          ${c[1]/l[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${h};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}},NCe=class{constructor(e,t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[a,i,o,u]=e;this.outputShape=[a,t,n,u];let c=[r&&t>1?i-1:i,r&&n>1?o-1:o],l=[r&&t>1?t-1:t,r&&n>1?n-1:n],d=r?"0.5":"0.0",h;s?h="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":h="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/l[0]},
          ${c[1]/l[1]},
          ${c[1]/l[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,
                                     ${o}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${h};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${n-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}};function TCe(e){let{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r,[u,c]=o,l=ge().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new NCe(s.shape,u,c,a,i):new SCe(s.shape,u,c,a,i);return n.runWebGLProgram(l,[s],s.dtype)}var ECe={kernelName:bh,backendName:"webgl",kernelFunc:TCe},ACe=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,r,s]=t,[,a,i]=e,o=[n&&a>1?r-1:r,n&&i>1?s-1:s],u=[n&&a>1?a-1:a,n&&i>1?i-1:i],c=o[0]/u[0],l=o[1]/u[1],d=1/c,h=1/l,p=Math.ceil(d)*2+2,f=Math.ceil(h)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${l});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${h});

        const int winHeight = int(${p});
        const int winWidth = int(${f});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float sourceFracRow =
              float(${o[0]}) *
                (float(dyR) / float(${u[0]}));

            float sourceFracCol =
                float(${o[1]}) *
                  (float(dyC) / float(${u[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${n} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${s}) - 1),
                ${n} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function $Ce(e){let{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=new ACe(a.shape,s.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}var RCe={kernelName:Jf,backendName:"webgl",kernelFunc:$Ce},_Ce=class{constructor(e,t){this.variableNames=["x"];let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,n===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}let r=i=>t.indexOf(i)!==-1&&e[i]!==1?`${e[i]} - coords[${i}] - 1`:`coords[${i}]`,s=e.map((i,o)=>r(o)).join(","),a=Wn(n);this.userCode=`
      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${s}));
      }
    `}},DCe=class{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;let r=Ps("rc",n),s=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,a=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,i=Wn(n);n===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${s}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${i} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${o(r.slice())};
          if(${s}){
            result.g = ${u(r.slice())};
          }
          if(${a}) {
            result.b = ${c(r.slice())};
            if(${s}) {
              result.a = ${l(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function o(p){return d(p)}function u(p){return p[n-1]="("+p[n-1]+" + 1)",d(p)}function c(p){return p[n-2]="("+p[n-2]+" + 1)",d(p)}function l(p){return p[n-1]="("+p[n-1]+" + 1)",p[n-2]="("+p[n-2]+" + 1)",d(p)}function d(p){let f=e.map((b,y)=>h(y,p)),m=f.join(","),g=f.slice(-2).join(",");return`getChannel(getX(${m}), vec2(${g}))`}function h(p,f){return t.indexOf(p)!==-1&&e[p]!==1?`${e[p]} - ${f[p]} - 1`:`${f[p]}`}}};function FCe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r,i=s.shape.length,o=$.parseAxisParam(a,s.shape);if(i===0)return Aa({inputs:{x:s},backend:n});let u=ge().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new DCe(s.shape,o):new _Ce(s.shape,o);return n.runWebGLProgram(u,[s],s.dtype)}var MCe={kernelName:wh,backendName:"webgl",kernelFunc:FCe},OCe=class{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let n=e[1],r=e[2];this.outputShape=e;let s="";typeof t=="number"?s=`float outputValue = ${t.toFixed(2)};`:s=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${s}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}},LCe={kernelName:fm,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,{radians:s,fillValue:a,center:i}=t,o=n,u=new OCe(r.shape,a),[c,l]=P.getImageCenter(i,r.shape[1],r.shape[2]),d=[[c,l,Math.sin(s),Math.cos(s)]];return o.runWebGLProgram(u,[r],r.dtype,d)}},PCe=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,BCe=dn({opSnippet:PCe}),zCe={kernelName:vh,backendName:"webgl",kernelFunc:BCe},WCe="return inversesqrt(x);",VCe=dn({opSnippet:WCe,cpuKernelImpl:Z0e}),UCe={kernelName:Ih,backendName:"webgl",kernelFunc:VCe},T4=class{constructor(e,t,n,r,s,a,i=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;let u=Wn(s.length),c=Wn(a.length),l="";n===1?l="i":n===2&&(l="i, j");let d=`getIndices(${l})`,h="";r===1?h="i":r===2&&(h="i, coords[1]");let p=`getUpdates(${h})`,f="";o&&(f="coords[0], coords[1]");let m=`getDefaultValue(${f})`,g=t>1?"strides[j]":"strides";this.userCode=`
        ${u} strides = ${u}(${s});

        void main() {
          ${c} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${d});
              flattenedIndex += index * ${g};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${p};
              found = true;
            }
          }
          setOutput(mix(${m}, sum, float(found)));
        }
      `}},GCe=class{constructor(e,t,n,r,s,a,i=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a;let u=Wn(s.length),c=Wn(a.length),l="";n===1?l="i":n===2&&(l="i, j");let d=`getIndices(${l})`,h="";r===1?h="i":r===2&&(h="i, coords[1]");let p=`getUpdates(${h})`,f="";o&&(f="coords[0], coords[1]");let m=`getDefaultValue(${f})`,g=t>1?"strides[j]":"strides",b=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${u} strides = ${u}(${s});

        void main() {
          ${c} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${d});
              flattenedIndex += index.xz * ${g};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${b};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${p};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${m}, sum, found));
        }
      `}};function HCe(e){let{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:a}=t,{shape:i}=r,{sliceRank:o,numUpdates:u,sliceSize:c,strides:l,outputSize:d}=P.calculateShapes(a,s,i),h=[d/c,c];if(d===0)return n.makeTensorInfo(i,s.dtype);let p=Ye({inputs:{x:s},backend:n,attrs:{shape:[u,o]}}),f=Ye({inputs:{x:a},backend:n,attrs:{shape:[u,c]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0])),g;ge().getBool("WEBGL_PACK")?g=new GCe(u,o,p.shape.length,f.shape.length,l,h):g=new T4(u,o,p.shape.length,f.shape.length,l,h);let b=n.runWebGLProgram(g,[f,p,m],f.dtype),y=Ye({inputs:{x:b},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(m),y}var jCe={kernelName:em,backendName:"webgl",kernelFunc:HCe},qCe=class{constructor(e,t,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];let s="while (left < right) {",a=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,i=ge().getNumber("WEBGL_VERSION")===2?s:a,o=r==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${i}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${o} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};function KCe(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:s,values:a}=t,{side:i}=r,o=new qCe(s.shape[0],s.shape[1],a.shape[1],i),u=[[s.shape[1]]];return n.runWebGLProgram(o,[s,a],"int32",u)}var XCe={kernelName:nm,backendName:"webgl",kernelFunc:KCe},QCe=class{constructor(e,t,n){this.variableNames=["c","a","b"],this.outputShape=t;let r,s;if(n>4)throw Error(`Where for rank ${n} is not yet supported`);if(n===1)s="resRC",r="resRC";else{let i=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],u=[];for(let c=0;c<t.length;c++)u.push(`${i[c]}`),c<e&&o.push(`${i[c]}`);r=o.join(),s=u.join()}let a=Wn(n);this.userCode=`
      void main() {
        ${a} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${s}));
        } else {
          setOutput(getB(${s}));
        }
      }
    `}};function YCe(e){let{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t,i=new QCe(r.shape.length,s.shape,s.shape.length);return n.runWebGLProgram(i,[r,s,a],Ha(s.dtype,a.dtype))}var JCe={kernelName:rm,backendName:"webgl",kernelFunc:YCe},ZCe=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${P.SELU_SCALEALPHA};
  float scale = ${P.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,eSe=dn({opSnippet:ZCe}),tSe={kernelName:kh,backendName:"webgl",kernelFunc:eSe},nSe=Dm+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,rSe=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,sSe=dn({opSnippet:nSe,packedOpSnippet:rSe,cpuKernelImpl:t1e}),aSe={kernelName:Th,backendName:"webgl",kernelFunc:sSe},iSe=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,oSe=dn({opSnippet:iSe}),lSe={kernelName:Nh,backendName:"webgl",kernelFunc:oSe},uSe=Dm+`
  return sin(x);
`,cSe=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Hh}
  return result;
`,dSe=dn({opSnippet:uSe,packedOpSnippet:cSe}),hSe={kernelName:Ch,backendName:"webgl",kernelFunc:dSe},pSe=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,fSe=dn({opSnippet:pSe}),mSe={kernelName:Sh,backendName:"webgl",kernelFunc:fSe},gSe=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,bSe=dn({opSnippet:gSe}),ySe={kernelName:Eh,backendName:"webgl",kernelFunc:bSe},xSe=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:i}=r;$.assert(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let o=a.reduce((b,y)=>b*y),u=[[0,0]];u.push(...i);for(let b=1+a.length;b<s.shape.length;++b)u.push([0,0]);let c=[],l=sP({inputs:{x:s},backend:n,attrs:{paddings:u,constantValue:0}}),d=P.getReshaped(l.shape,a,o,!1),h=P.getPermuted(d.length,a.length,!1),p=P.getReshapedPermuted(l.shape,a,o,!1),f=Ye({inputs:{x:l},backend:n,attrs:{shape:d}}),m=Us({inputs:{x:f},backend:n,attrs:{perm:h}}),g=Ye({inputs:{x:m},backend:n,attrs:{shape:p}});return c.push(l),c.push(f),c.push(m),c.forEach(b=>n.disposeIntermediateTensorInfo(b)),g},wSe={kernelName:am,backendName:"webgl",kernelFunc:xSe};function vSe(e){let{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:a,defaultValue:i}=t;if(a.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${a.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${s.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let o=n.readSync(r.dataId),u=n.readSync(s.dataId),c=n.readSync(a.dataId),l=n.readSync(i.dataId)[0],[d,h,p,f,m]=r1e(o,r.shape,r.dtype,u,s.dtype,c,l);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([h[0]],s.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}var ISe={kernelName:t0,backendName:"webgl",kernelFunc:vSe};function kSe(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:a}=t;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);let i=Array.from(n.readSync(s.dataId)),o=n.readSync(r.dataId),u=Array.from(n.readSync(a.dataId)),[c,l,d]=s1e(o,r.shape,r.dtype,i,u);return[n.makeTensorInfo(l,r.dtype,c),n.makeTensorInfo([d.length],a.dtype,new Int32Array(d))]}var CSe={kernelName:om,backendName:"webgl",kernelFunc:kSe};function SSe(e){let{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${a.shape}`);let i=n.readSync(r.dataId),o=n.readSync(s.dataId),u=n.readSync(a.dataId),[c,l]=TL(i,r.shape,r.dtype,o,u,!0);return n.makeTensorInfo(l,r.dtype,c)}var NSe={kernelName:n0,backendName:"webgl",kernelFunc:SSe};function TSe(e){let{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${a.shape}`);let i=n.readSync(r.dataId),o=n.readSync(s.dataId),u=n.readSync(a.dataId),[c,l]=TL(i,r.shape,r.dtype,o,u);return n.makeTensorInfo(l,r.dtype,c)}var ESe={kernelName:r0,backendName:"webgl",kernelFunc:TSe};function ASe(e){let{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:u,numUpdates:c,sliceSize:l,strides:d,outputSize:h}=P.calculateShapes(a,s,o),p=!1;if(a.dtype==="string"){let b=n.bufferSync(s),y=n.bufferSync(a),x=$.decodeString(n.readSync(i.dataId)[0]),w=e1e(b,y,o,h,l,c,u,d,x,p);return n.makeTensorInfo(o,w.dtype,w.values)}let f=new T4(c,u,s.shape.length,a.shape.length,d,[h,1],p),m=n.runWebGLProgram(f,[a,s,i],a.dtype),g=Ye({inputs:{x:m},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(m),g}var $Se={kernelName:lm,backendName:"webgl",kernelFunc:ASe};function RSe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:i}=r,o=$.parseAxisParam(i,s.shape)[0],u=P.prepareSplitSize(s,a,o),c=s.shape.length,l=new Array(c).fill(0),d=s.shape.slice();return u.map(h=>{let p=[...d];p[o]=h;let f=Fm({inputs:{x:s},backend:n,attrs:{begin:l,size:p}});return l[o]+=h,f})}var _Se={kernelName:im,backendName:"webgl",kernelFunc:RSe},k_="return sqrt(x);",DSe=dn({opSnippet:k_,packedOpSnippet:k_,cpuKernelImpl:a1e}),FSe={kernelName:Ah,backendName:"webgl",kernelFunc:DSe},MSe="return x * x;",OSe=dn({opSnippet:MSe}),LSe={kernelName:s0,backendName:"webgl",kernelFunc:OSe},C_="return (a - b) * (a - b);",PSe=gs({opSnippet:C_,packedOpSnippet:C_}),BSe={kernelName:_h,backendName:"webgl",kernelFunc:PSe};function zSe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");let a=n.readSync(s.dataId),i=P.fromUint8ToStringArray(a),o=i1e(i,"string",r);return n.makeTensorInfo(s.shape,"string",o)}var WSe={kernelName:a0,backendName:"webgl",kernelFunc:zSe};function VSe({inputs:e,attrs:t,backend:n}){let{x:r}=e,s=bi+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,a=new bo(r.shape,s);return n.runWebGLProgram(a,[r],r.dtype)}var USe={kernelName:vu,backendName:"webgl",kernelFunc:VSe},GSe=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;let r=n.length,s=Wn(n.length),a=Wn(n.length),i="";if(r===1)i="coords * strides + begin";else{let o=0;i=n.map((u,c)=>(o++,n.length===1?`coords * strides[${c}] + begin[${c}]`:`coords[${o-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`
      ${s} begin = ${s}(${e});
      ${s} strides = ${s}(${t});

      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}};function HSe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,end:i,strides:o,beginMask:u,endMask:c,ellipsisMask:l,newAxisMask:d,shrinkAxisMask:h}=r,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:b,begin:y,end:x,strides:w}=Gr.sliceInfo(s.shape,a,i,o,u,c,l,d,h),v;if(m)v=Ye({inputs:{x:s},backend:n,attrs:{shape:f}});else if(g||b){$.assert(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);let N=Gr.computeOutShape(y,x,w),T=Fm({inputs:{x:s},backend:n,attrs:{begin:y,size:N}});v=Ye({inputs:{x:T},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(T)}else if(n.shouldExecuteOnCPU([s])){let N=n.readSync(s.dataId),T=Ht(s.shape,s.dtype,N),E=o1e(p,T,w,y);v=n.makeTensorInfo(f,s.dtype,E.values)}else{let N=new GSe(y,w,p);v=n.runWebGLProgram(N,[s],s.dtype)}let I=Ye({inputs:{x:v},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(v),I}var jSe={kernelName:um,backendName:"webgl",kernelFunc:HSe};function qSe(e){let{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:a,leftPad:i,rightPad:o,padWidth:u,preserveShortSequences:c}=r,{data:l,dataSplits:d}=t,h=n.readSync(l.dataId),p=n.readSync(d.dataId),[f,m]=l1e(h,p,s,a,i,o,u,c);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}var KSe={kernelName:i0,backendName:"webgl",kernelFunc:qSe};function XSe(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:a,delimiter:i}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(a.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let o=n.readSync(a.dataId),u=n.readSync(i.dataId)[0],[c,l,d]=u1e(o,u,s),h=l.length;return[n.makeTensorInfo([h,2],"int32",c),n.makeTensorInfo([h],"string",l),n.makeTensorInfo([2],"int32",new Int32Array(d))]}var QSe={kernelName:o0,backendName:"webgl",kernelFunc:XSe};function YSe(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:a}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");let i=n.readSync(a.dataId),o=c1e(i,s);return n.makeTensorInfo(a.shape,"int32",o)}var JSe={kernelName:l0,backendName:"webgl",kernelFunc:YSe},ZSe="return tan(x);",e3e=dn({opSnippet:ZSe}),t3e={kernelName:Fh,backendName:"webgl",kernelFunc:e3e},n3e=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,r3e=dn({opSnippet:n3e}),s3e={kernelName:Mh,backendName:"webgl",kernelFunc:r3e};function a3e(e){let{inputs:t,backend:n,attrs:r}=e,{tensor:s,indices:a,updates:i}=t,{sliceRank:o,numUpdates:u,sliceSize:c,strides:l,outputSize:d}=P.calculateShapes(i,a,s.shape),h=[d/c,c];if(d===0)return n.makeTensorInfo(s.shape,a.dtype);let p=Ye({inputs:{x:a},backend:n,attrs:{shape:[u,o]}}),f=Ye({inputs:{x:i},backend:n,attrs:{shape:[u,c]}}),m=Ye({inputs:{x:s},backend:n,attrs:{shape:h}}),g=new T4(u,o,p.shape.length,f.shape.length,l,h,!1,!0),b=n.runWebGLProgram(g,[f,p,m],m.dtype),y=Ye({inputs:{x:b},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(b),y}var i3e={kernelName:tm,backendName:"webgl",kernelFunc:a3e},o3e=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[a]*t[a];this.outputShape=n,this.rank=n.length;let r=Wn(this.rank),s=l3e(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${s}));
      }
    `}};function l3e(e){let t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${e[0]})`;let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<e.length;s++)r.push(`imod(${n[s]}, ${e[s]})`);return r.join()}function iP(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:a}=r;if(s.dtype==="string"||s.shape.length>5){let o=n.readSync(s.dataId),u=s.dtype==="string"?o.map(d=>$.decodeString(d)):o,c=Ht(s.shape,s.dtype,u),l=h1e(c,a);return n.makeTensorInfo(l.shape,l.dtype,l.values)}let i=new o3e(s.shape,a);return n.runWebGLProgram(i,[s],s.dtype)}var u3e={kernelName:wu,backendName:"webgl",kernelFunc:iP},c3e=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},d3e=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};function uc(e,t){t!==null&&e.disposeIntermediateTensorInfo(t)}function S_(e){let t=1;for(;t<e;)t*=2;return t}function h3e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:a,sorted:i}=r,o=ge().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),u=ge().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=s.shape,l=c[c.length-1];if(n.shouldExecuteOnCPU([s])||l<o||a>u){let E=n.readSync(s.dataId),[A,k]=p1e(E,c,s.dtype,a,i);return[n.makeTensorInfo(A.shape,A.dtype,A.values),n.makeTensorInfo(k.shape,k.dtype,k.values)]}if(a===0)return c[c.length-1]=0,[n.makeTensorInfo(c,s.dtype,[]),n.makeTensorInfo(c,"int32",[])];if(l===1)return[s,U0({attrs:{shape:c,dtype:"int32",value:0},backend:n})];let d=n.texData.get(s.dataId),h=d!==null&&d.isPacked,p=h?n.unpackTensor(s):s,f=$.sizeFromShape(c)/l,m=Ye({inputs:{x:p},attrs:{shape:[f,l]},backend:n});h&&uc(n,p);let g=S_(a),b=S_(l),y=null,x=()=>y===null?[m,m]:[m,y],w=(E,A,k)=>{let C=x(),M=new c3e(k),L=[[l],[y===null?1:0],[Number.NEGATIVE_INFINITY],[E],[A]],O=y;y=n.runWebGLProgram(M,C,"int32",L),uc(n,O)};for(let E=1;E<g;E*=2){let A=E*2;for(let k=E;k>=1;k/=2)w(A,k,[f,b])}for(let E=b;E>g;E/=2){let A=x(),k=new d3e([f,E/2]),C=[[l],[y===null?1:0],[g]],M=y;y=n.runWebGLProgram(k,A,"int32",C),uc(n,M);let L=g/2,O=L*2;for(let B=L;B>=1;B/=2)w(O,B,y.shape)}let v=y;y=Fm({inputs:{x:y},backend:n,attrs:{begin:0,size:[f,a]}}),uc(n,v);let I=JL({inputs:{x:m,indices:y},backend:n,attrs:{axis:1,batchDims:1}});uc(n,m);let N=c.slice(0,-1);N.push(a),v=y,y=Ye({inputs:{x:y},attrs:{shape:N},backend:n}),uc(n,v);let T=I;return I=Ye({inputs:{x:I},attrs:{shape:N},backend:n}),uc(n,T),[I,y]}var p3e={kernelName:cm,backendName:"webgl",kernelFunc:h3e},f3e=class{constructor(e,t,n,r,s,a){this.variableNames=["Image","Transforms"],this.outputShape=a;let i=n==="nearest"?1:2,o;switch(r){case"constant":o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4;break;default:o=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${o} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${o} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${o} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${s});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${s});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${i} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};function m3e(e){let{inputs:t,backend:n,attrs:r}=e,{image:s,transforms:a}=t,{interpolation:i,fillMode:o,fillValue:u,outputShape:c}=r,[l,d,h,p]=s.shape,[f,m]=c??[d,h],g=[l,f,m,p],b=new f3e(d,h,i,o,u,g);return n.runWebGLProgram(b,[s,a],"float32")}var g3e={kernelName:dm,backendName:"webgl",kernelFunc:m3e};function b3e(e){let{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t;Tm(a,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let i=r.readSync(a.dataId),{outputValues:o,outputShape:u,indices:c}=f1e(i,s,a.shape,a.dtype);return[r.makeTensorInfo(u,a.dtype,o),r.makeTensorInfo([c.length],"int32",c)]}var y3e={kernelName:u0,backendName:"webgl",kernelFunc:b3e};function x3e(e){let{inputs:t,backend:n,attrs:r}=e,{value:s}=t,{axis:a}=r;a<0&&(a+=s.shape.length);let i=s,o=i.shape.length,u=s.shape[a],c=new Array(o-1),l=0;for(let m=0;m<o;m++)m!==a&&(c[l++]=i.shape[m]);let d=[],h=new Array(o).fill(0),p=i.shape.slice();p[a]=1;let f=new Array(u);for(let m=0;m<f.length;m++){h[a]=m;let g=Fm({inputs:{x:i},backend:n,attrs:{begin:h,size:p}}),b=Ye({inputs:{x:g},backend:n,attrs:{shape:c}});f[m]=b,d.push(g)}return d.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}var w3e={kernelName:hm,backendName:"webgl",kernelFunc:x3e},v3e=class{constructor(e,t){this.variableNames=["x","segmentIds"];let n=e.windowSize,r=e.batchSize,s=e.inSize,a=e.numSegments,i=a*Math.ceil(s/n);this.outputShape=[r,i];let o="0.0",u="sumValue",c=Math.floor(n/4)*4,l=n%4,d=`
        sumValue += dot(values, segFilter);
    `,h="";s%n>0&&(h=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `);let p="";s%n>0&&(p=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${o};

      float getValue(int batch, int inIdx) {
        ${h}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${p}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${a})) * float(${n}));
        int currentSeg = int(mod(float(outIdx), float(${a})));

        float sumValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${d}
        }

        int inIdx = inOffset + ${c};
        if (${l===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${d}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${d}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${d}
        }
        setOutput(${u});
      }
    `}};function I3e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:a}=t,{numSegments:i}=r,o=s.shape.length,u=[],c=0,l=P.getAxesPermutation([c],o),d=s;l!=null&&(d=Us({inputs:{x:s},backend:n,attrs:{perm:l}}),u.push(d),c=P.getInnerMostAxes(1,o)[0]);let h=P.segment_util.computeOutShape(d.shape,c,i),p=$.sizeFromShape([d.shape[c]]),f=Ye({inputs:{x:d},backend:n,attrs:{shape:[-1,p]}});u.push(f);let m=Nw(s.dtype),g=(w,v,I,N,T)=>{let E=w.shape[0],A=w.shape[1],k=P.segment_util.segOpComputeOptimalWindowSize(A,T),C={windowSize:k,inSize:A,batchSize:E,numSegments:T},M=new v3e(C,v),L=n.compileAndRun(M,[w,I],N);if(u.push(L),L.shape[1]===T)return L;let O=aP({backend:n,attrs:{start:0,stop:T,step:1,dtype:"float32"}}),B=iP({inputs:{x:O},backend:n,attrs:{reps:[A/k]}});return u.push(O),u.push(B),g(L,v,B,N,T)},b=g(f,"unsortedSegmentSum",a,m,i),y=Ye({inputs:{x:b},backend:n,attrs:{shape:h}}),x=y;if(l!=null){u.push(y);let w=P.getUndoAxesPermutation(l);x=Us({inputs:{x},backend:n,attrs:{perm:w}})}return u.forEach(w=>n.disposeIntermediateTensorInfo(w)),x}var k3e={kernelName:c0,backendName:"webgl",kernelFunc:I3e},C3e=[o2e,u2e,h2e,m2e,b2e,w2e,I2e,C2e,E2e,$2e,D2e,O2e,B2e,U2e,j2e,K2e,Q2e,exe,nxe,sxe,lxe,mxe,bxe,vxe,kxe,Axe,Rxe,Mxe,G1e,Pxe,Uxe,qxe,Zxe,nwe,swe,iwe,lwe,hwe,mwe,ywe,wwe,Iwe,Cwe,Twe,Awe,Dwe,Mwe,Pwe,Wwe,Uwe,qwe,Ywe,tve,sve,ove,lve,cve,hve,fve,gve,yve,Ive,Sve,Eve,$ve,Dve,Ove,zve,Gve,U1e,jve,Wxe,Xve,Jve,tIe,j1e,aIe,uIe,dIe,mIe,yIe,IIe,SIe,AIe,DIe,OIe,PIe,VIe,GIe,jIe,QIe,JIe,eke,nke,ske,lke,hke,gke,Cke,X1e,Eke,Rke,Fke,Lke,Sxe,zke,Vke,Gke,qke,Yke,K1e,Zke,tCe,rCe,aCe,iCe,Nxe,wke,uCe,pCe,bCe,Y1e,vCe,CCe,ECe,RCe,MCe,LCe,zCe,UCe,jCe,XCe,JCe,tSe,aSe,lSe,hSe,mSe,pxe,Ike,ySe,wSe,ISe,CSe,NSe,ESe,$Se,_Se,FSe,LSe,BSe,WSe,USe,jSe,KSe,QSe,JSe,vke,s2e,t3e,s3e,i3e,u3e,p3e,g3e,a2e,y3e,w3e,k3e,Wke];for(let e of C3e)d0(e);var mn;(function(e){e[e.float32=0]="float32",e[e.int32=1]="int32",e[e.bool=2]="bool",e[e.string=3]="string",e[e.complex64=4]="complex64"})(mn||(mn={}));var Iy;(function(e){e[e.linear=0]="linear",e[e.relu=1]="relu",e[e.relu6=2]="relu6",e[e.prelu=3]="prelu",e[e.leakyrelu=4]="leakyrelu",e[e.sigmoid=5]="sigmoid",e[e.elu=6]="elu"})(Iy||(Iy={}));var oP;function S3e(e){oP=e.wasm.cwrap(Oc,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])}function N3e(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:o}=t;if(s.dtype!=="float32"||a.dtype!=="float32")throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");let{transposeA:u,transposeB:c,activation:l,leakyreluAlpha:d}=r,h=n.dataIdMap.get(s.dataId).id,p=n.dataIdMap.get(a.dataId).id,f=0;if(i!=null){let T=n.dataIdMap.get(i.dataId);if(T.shape.length!==1)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${T.shape.length}.`);f=T.id}let m=o==null?0:n.dataIdMap.get(o.dataId).id,g=Iy[l];if(g==null)throw new Error(`${l} activation not yet supported for FusedConv2D in the wasm backend.`);let b=u?s.shape[2]:s.shape[1],y=c?a.shape[1]:a.shape[2],x=mm.assertAndGetBroadcastShape(s.shape.slice(0,-2),a.shape.slice(0,-2)),w=n.makeOutput([...x,b,y],s.dtype),v=n.dataIdMap.get(w.dataId).id,I=new Uint8Array(new Int32Array(s.shape).buffer),N=new Uint8Array(new Int32Array(a.shape).buffer);return oP(h,I,s.shape.length,p,N,a.shape.length,u,c,g,f,m,d||0,v),w}var T3e={kernelName:Oc,backendName:"wasm",setupFunc:S3e,kernelFunc:N3e};function on(e,t){let n;function r(a){n=a.wasm.cwrap(e,null,["number","number","number"])}function s(a){let{backend:i,inputs:{x:o}}=a,u=i.dataIdMap.get(o.dataId).id,c=i.makeOutput(o.shape,t||o.dtype),l=i.dataIdMap.get(c.dataId).id;return $.sizeFromShape(c.shape)===0||n(u,mn[o.dtype],l),c}return{kernelName:e,backendName:"wasm",setupFunc:r,kernelFunc:s}}var E3e=on(pf),A3e=on(yd),$3e=on(xd);function Or(e,t,n){let r;function s(i){r=i.wasm.cwrap(e,null,["number","array","number","number","array","number","number","number"])}function a(i){let{backend:o,inputs:u}=i,{a:c,b:l}=u,d=o.dataIdMap.get(c.dataId).id,h=o.dataIdMap.get(l.dataId).id,p=n??c.dtype,f=P.assertAndGetBroadcastShape(c.shape,l.shape),m=o.makeOutput(f,p);if($.sizeFromShape(f)===0)return m;let g=new Uint8Array(new Int32Array(c.shape).buffer),b=new Uint8Array(new Int32Array(l.shape).buffer),y=o.dataIdMap.get(m.dataId).id;return r(d,g,c.shape.length,h,b,l.shape.length,mn[c.dtype],y),m}return{kernelName:e,backendName:"wasm",setupFunc:s,kernelFunc:a}}var R3e=Or(yu),lP;function _3e(e){lP=e.wasm.cwrap(wd,null,["array","number","number","number"])}function D3e(e){let{inputs:t,backend:n}=e,r=n.makeOutput(t[0].shape,t[0].dtype);if($.sizeFromShape(r.shape)===0)return r;let s=t.map(o=>n.dataIdMap.get(o.dataId).id),a=new Uint8Array(new Int32Array(s).buffer),i=n.dataIdMap.get(r.dataId).id;return lP(a,s.length,mn[r.dtype],i),r}var F3e={kernelName:wd,backendName:"wasm",setupFunc:_3e,kernelFunc:D3e};function Mv(e){let{inputs:{x:t},backend:n}=e;if(t.dtype==="string")return zs(n.readSync(t.dataId),t.shape,t.dtype);let r=n.makeOutput(t.shape,t.dtype),s=n.typedArrayFromHeap(t);return n.typedArrayFromHeap(r).set(s),r}var M3e={kernelName:qd,backendName:"wasm",kernelFunc:Mv},uP;function O3e(e){uP=e.wasm.cwrap(nl,null,["number","array","number","number","number","array","number"])}function lu(e){let{inputs:t,backend:n,attrs:r}=e,[s,a]=P3e(t.x.shape,r.perm),i=!0;for(let f=0;f<a.length;f++)a[f]!==f&&(i=!1);let o=L3e(t.x.shape,r.perm),u={dataId:t.x.dataId,shape:s,dtype:t.x.dtype};if(i){let f=Mv({inputs:t,backend:n});return f.shape=o,f}let c=n.makeOutput(o,u.dtype),l=n.dataIdMap.get(u.dataId).id,d=n.dataIdMap.get(c.dataId).id,h=new Uint8Array(new Int32Array(a).buffer),p=new Uint8Array(new Int32Array(u.shape).buffer);return uP(l,p,u.shape.length,mn[u.dtype],d,h,a.length),c}function L3e(e,t){let n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];return n}function P3e(e,t){let n=[],r=[];for(let s=0;s<e.length;++s)e[s]!==1&&n.push(e[s]),e[t[s]]!==1&&r.push(t[s]);for(let s=0;s<r.length;++s){let a=-1;for(let i=0;i<r.length;++i)r[i]>=s&&(a===-1||r[a]>r[i])&&(a=i);r[a]=s}return[n,r]}var B3e={kernelName:nl,backendName:"wasm",kernelFunc:lu,setupFunc:O3e};function Au(e,t,n){let r=e.shape,s=e.shape.length,a=$.parseAxisParam(t,r),i=a,o=P.getAxesPermutation(i,s),u=null,c=!1;if(o!=null){let l=new Array(s);for(let h=0;h<l.length;h++)l[h]=r[o[h]];i=P.getInnerMostAxes(i.length,s),u=lu({inputs:{x:e},attrs:{perm:o},backend:n});let d=n.dataIdMap.get(e.dataId).id;n.dataIdMap.get(u.dataId).id!==d&&(c=!0)}return{transposed:u,originalAxes:a,axes:i,inputWasTransposed:c}}var cP;function z3e(e){cP=e.wasm.cwrap(ff,null,["number, number, number"])}function W3e(e){let{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:a}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,u=i,{transposed:c,axes:l,originalAxes:d,inputWasTransposed:h}=Au(i,s,t);if(h){let y=t.dataIdMap.get(c.dataId).id;u=c,o=y}let p=u.shape.length;P.assertAxesAreInnerMostDims("all",l,p);let[f,m]=P.computeOutAndReduceShapes(u.shape,l),g=$.sizeFromShape(m),b=t.makeOutput(f,i.dtype);if($.sizeFromShape(u.shape)!==0){let y=t.dataIdMap.get(b.dataId).id;cP(o,g,y)}if(h&&t.disposeData(c.dataId),a){let y=P.expandShapeToKeepDim(b.shape,d);b.shape=y}return b}var V3e={kernelName:ff,backendName:"wasm",setupFunc:z3e,kernelFunc:W3e},dP;function U3e(e){dP=e.wasm.cwrap(mf,null,["number, number, number"])}function G3e(e){let{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:a}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,u=i,{transposed:c,axes:l,originalAxes:d,inputWasTransposed:h}=Au(i,s,t);if(h){let y=t.dataIdMap.get(c.dataId).id;u=c,o=y}let p=u.shape.length;P.assertAxesAreInnerMostDims("any",l,p);let[f,m]=P.computeOutAndReduceShapes(u.shape,l),g=$.sizeFromShape(m),b=t.makeOutput(f,i.dtype);if($.sizeFromShape(u.shape)!==0){let y=t.dataIdMap.get(b.dataId).id;dP(o,g,y)}if(h&&t.disposeData(c.dataId),a){let y=P.expandShapeToKeepDim(b.shape,d);b.shape=y}return b}var H3e={kernelName:mf,backendName:"wasm",setupFunc:U3e,kernelFunc:G3e};function hP(e){let t;function n(s){t=s.wasm.cwrap(e,null,["number","number","number","number","number"])}function r(s){let{backend:a,inputs:i,attrs:o}=s,{axis:u}=o,{x:c}=i,l=a.dataIdMap.get(c.dataId).id,d=l,h=c,{transposed:p,axes:f,inputWasTransposed:m}=Au(c,u,a);if(m){let v=a.dataIdMap.get(p.dataId).id;v!==l&&(h=p,d=v)}let g=h.shape.slice(0,-1),b=a.makeOutput(g,"int32"),y=a.dataIdMap.get(b.dataId).id,x=$.sizeFromShape(b.shape),w=h.shape[f[0]];return t(d,mn[h.dtype],x,w,y),m&&a.disposeData(p.dataId),b}return{kernelName:e,backendName:"wasm",setupFunc:n,kernelFunc:r}}var j3e=hP(gf),q3e=hP(bf),K3e=on(vd),X3e=on(Id),Q3e=on(kd),Y3e=Or(Sd),J3e=on(Cd),pP;function Z3e(e){pP=e.wasm.cwrap(Nd,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function eNe(e){let{inputs:t,attrs:n,backend:r}=e,s=t.x,a=r.dataIdMap.get(s.dataId).id,{filterSize:i,strides:o,pad:u,dimRoundingMode:c}=n,l=P.computePool2DInfo(s.shape,i,o,1,u,c),d=l.filterHeight,h=l.filterWidth,p=l.padInfo.top,f=l.padInfo.right,m=l.padInfo.bottom,g=l.padInfo.left,b=l.strideHeight,y=l.strideWidth,x=l.inChannels;if(l.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${l.dataFormat}'. Please use 'channelsLast'.`);if(l.dilationWidth!==1||l.dilationHeight!==1)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${l.dilationHeight}, ${l.dilationWidth}].`);let w=r.makeOutput(l.outShape,"float32"),v=r.dataIdMap.get(w.dataId).id;return pP(a,s.shape[0],s.shape[1],s.shape[2],d,h,p,f,m,g,b,y,x,v),w}var tNe={kernelName:Nd,backendName:"wasm",setupFunc:Z3e,kernelFunc:eNe},fP;function nNe(e){fP=e.wasm.cwrap("AvgPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function rNe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:u,dataFormat:c}=r,l=P.computePool3DInfo(s.shape,a,i,1,o,u,c),d=n.makeOutput(l.outShape,s.dtype);return fP(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(d.dataId).id,l.batchSize,l.inChannels,l.inDepth,l.inHeight,l.inWidth,l.outDepth,l.outHeight,l.outWidth,l.strideDepth,l.strideHeight,l.strideWidth,l.dilationDepth,l.dilationHeight,l.dilationWidth,l.effectiveFilterDepth,l.effectiveFilterHeight,l.effectiveFilterWidth,l.padInfo.front,l.padInfo.top,l.padInfo.left),d}var sNe={kernelName:yf,backendName:"wasm",setupFunc:nNe,kernelFunc:rNe},mP;function aNe(e){mP=e.wasm.cwrap("AvgPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function iNe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:u,dimRoundingMode:c}=r,l=P.computePool3DInfo(a.shape,i,o,1,u,c),d=n.makeOutput(a.shape,a.dtype);return mP(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(d.dataId).id,l.batchSize,l.inChannels,l.inDepth,l.inHeight,l.inWidth,l.outDepth,l.outHeight,l.outWidth,l.strideDepth,l.strideHeight,l.strideWidth,l.dilationDepth,l.dilationHeight,l.dilationWidth,l.effectiveFilterDepth,l.effectiveFilterHeight,l.effectiveFilterWidth,l.padInfo.front,l.padInfo.top,l.padInfo.left,l.filterDepth,l.filterHeight,l.filterWidth),d}var oNe={kernelName:Hy,backendName:"wasm",setupFunc:aNe,kernelFunc:iNe},gP;function lNe(e){gP=e.wasm.cwrap("AvgPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function uNe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:u}=r,c=P.computePool2DInfo(a.shape,i,o,1,u),l=n.makeOutput(a.shape,a.dtype);return gP(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(l.dataId).id,c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.top,c.padInfo.left,c.filterHeight,c.filterWidth),l}var cNe={kernelName:Gy,backendName:"wasm",setupFunc:lNe,kernelFunc:uNe};function aa(e){let{inputs:t,attrs:n}=e,{x:r}=t,{shape:s}=n,a=$.sizeFromShape(r.shape),i=$.inferFromImplicitShape(s,a);return $.assert(a===$.sizeFromShape(i),()=>`new shape: ${i}, old shape: ${r.shape}. New shape and old shape must have the same number of elements.`),e.backend.incRef(r.dataId),{dataId:r.dataId,shape:i,dtype:r.dtype}}var dNe={kernelName:Yf,backendName:"wasm",kernelFunc:aa},bP;function hNe(e){bP=e.wasm.cwrap(Td,null,["number","array","number","number","array","number","number","number","number"])}function pNe(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:o}=r;if(s.dtype!=="float32"||a.dtype!=="float32")throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");let u=s.shape.length,c=a.shape.length,l=i?s.shape[u-2]:s.shape[u-1],d=o?a.shape[c-1]:a.shape[c-2],h=i?s.shape[u-1]:s.shape[u-2],p=o?a.shape[c-2]:a.shape[c-1],f=s.shape.slice(0,-2),m=a.shape.slice(0,-2),g=$.sizeFromShape(f),b=$.sizeFromShape(m),y=mm.assertAndGetBroadcastShape(s.shape.slice(0,-2),a.shape.slice(0,-2)).concat([h,p]);$.assert(l===d,()=>`Error in matMul: inner shapes (${l}) and (${d}) of Tensors with shapes ${s.shape} and ${a.shape} and transposeA=${i} and transposeB=${o} must match.`);let x=i?[g,l,h]:[g,h,l],w=o?[b,p,d]:[b,d,p],v=aa({inputs:{x:s},backend:n,attrs:{shape:x}}),I=aa({inputs:{x:a},backend:n,attrs:{shape:w}}),N=n.dataIdMap.get(v.dataId).id,T=n.dataIdMap.get(I.dataId).id,E=i?v.shape[2]:v.shape[1],A=o?I.shape[1]:I.shape[2],k=Math.max(g,b),C=n.makeOutput([k,E,A],v.dtype),M=n.dataIdMap.get(C.dataId).id,L=new Uint8Array(new Int32Array(v.shape).buffer),O=new Uint8Array(new Int32Array(I.shape).buffer);return bP(N,L,v.shape.length,T,O,I.shape.length,i,o,M),n.disposeData(v.dataId),n.disposeData(I.dataId),C.shape=y,C}var fNe={kernelName:Td,backendName:"wasm",setupFunc:hNe,kernelFunc:pNe};function ed(e){let{inputs:{x:t},attrs:{begin:n,size:r},backend:s}=e,[a,i]=Gr.parseSliceParams(t,n,r),o=Gr.isSliceContinous(t.shape,a,i),u=s.readSync(t.dataId),c=s.makeOutput(i,t.dtype),l=$.computeStrides(t.shape),d=s.dataIdMap.get(c.dataId);if(o){let f=Gr.computeFlatOffset(a,l);return t.dtype==="string"?d.stringBytes=u.slice(f,f+$.sizeFromShape(i)):s.typedArrayFromHeap(c).set(u.subarray(f,f+$.sizeFromShape(i))),c}if(t.dtype==="string"){let f=Cx(u,a,i,t.shape,t.dtype);return d.stringBytes=f,c}let h=s.typedArrayFromHeap(c),p=t.shape.length;if(p===2)mNe(u,l[0],h,a,i);else if(p===3)gNe(u,l[0],l[1],h,a,i);else if(p===4)bNe(u,l[0],l[1],l[2],h,a,i);else{let f=Cx(u,a,i,t.shape,t.dtype);h.set(f)}return c}function mNe(e,t,n,r,s){let a=0,i=r[0],o=r[1],u=i+s[0];for(let c=i;c<u;c++){let l=c*t+o;n.set(e.subarray(l,l+s[1]),a),a+=s[1]}}function gNe(e,t,n,r,s,a){let i=0,o=s[0],u=s[1],c=s[2],l=o+a[0],d=u+a[1];for(let h=o;h<l;h++)for(let p=u;p<d;p++){let f=h*t+p*n+c;r.set(e.subarray(f,f+a[2]),i),i+=a[2]}}function bNe(e,t,n,r,s,a,i){let o=0,u=a[0],c=a[1],l=a[2],d=u+i[0],h=c+i[1],p=l+i[2],f=a[3];for(let m=u;m<d;m++)for(let g=c;g<h;g++)for(let b=l;b<p;b++){let y=m*t+g*n+b*r+f;s.set(e.subarray(y,y+i[3]),o),o+=i[3]}}var yNe={kernelName:sm,backendName:"wasm",kernelFunc:ed};function xNe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:i}=r,o=a.reduce((b,y)=>b*y),u=P.getReshaped(s.shape,a,o),c=P.getPermuted(u.length,a.length),l=P.getReshapedPermuted(s.shape,a,o),d=P.getSliceBeginCoords(i,a.length),h=P.getSliceSize(l,i,a.length),p=aa({inputs:{x:s},backend:n,attrs:{shape:u}}),f=lu({inputs:{x:p},backend:n,attrs:{perm:c}}),m=aa({inputs:{x:f},backend:n,attrs:{shape:l}}),g=ed({inputs:{x:m},backend:n,attrs:{begin:d,size:h}});return n.disposeData(p.dataId),n.disposeData(f.dataId),n.disposeData(m.dataId),g}var wNe={kernelName:xf,backendName:"wasm",kernelFunc:xNe},yP;function vNe(e){yP=e.wasm.cwrap(wf,null,["number","number","boolean","number","number","number"])}function INe(e){let{backend:t,inputs:n,attrs:r}=e,{x:s,weights:a}=n,{size:i}=r,o=a.shape.reduce((d,h)=>d*h,1)!==0,u=s.shape.length===1?[i]:[s.shape[0],i],c=t.makeOutput(u,a.dtype);function l(d){return t.dataIdMap.get(d.dataId).id}return yP(l(s),i,o,l(a),mn[a.dtype],l(c)),c}var kNe={kernelName:wf,backendName:"wasm",setupFunc:vNe,kernelFunc:INe},CNe=Or(vf);function SNe(e){let{inputs:t,backend:n}=e,{s0:r,s1:s}=t,a=n.typedArrayFromHeap(r),i=n.typedArrayFromHeap(s),o=P.assertAndGetBroadcastShape(Array.from(a),Array.from(i));return n.makeOutput([o.length],"int32",void 0,new Int32Array(o))}var NNe={kernelName:jy,backendName:"wasm",kernelFunc:SNe};function $u(e){let{inputs:{x:t},attrs:{dtype:n},backend:r}=e,s=r.makeOutput(t.shape,n),a=r.typedArrayFromHeap(t);return r.typedArrayFromHeap(s).set(a),s}var TNe={kernelName:Ed,backendName:"wasm",kernelFunc:$u},ENe=on(Ad),xP;function ANe(e){xP=e.wasm.cwrap(xu,null,["number","number","number","number"])}function $Ne(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{clipValueMin:a,clipValueMax:i}=r,o=n.dataIdMap.get(s.dataId).id,u=n.makeOutput(s.shape,s.dtype),c=n.dataIdMap.get(u.dataId).id;return xP(o,a,i,c),u}var RNe={kernelName:xu,backendName:"wasm",setupFunc:ANe,kernelFunc:$Ne};function wP(e){let{inputs:t,backend:n}=e,r=$.parseAxisParam(e.attrs.axis,t[0].shape)[0],s=t.map(p=>p.shape);P.assertParamsConsistent(s,r);let a=P.computeOutShape(t.map(p=>p.shape),r),i=t.filter(p=>$.sizeFromShape(p.shape)>0);if(i.length===1)return Mv({inputs:{x:i[0]},backend:n});let o=n.makeOutput(a,t[0].dtype);if($.sizeFromShape(a)===0)return o;if(i[0].dtype==="string"){let p=i.map(x=>{let w=[-1,$.sizeFromShape(x.shape.slice(r))];return aa({inputs:{x},backend:n,attrs:{shape:w}})}),f=p.map(x=>({vals:n.readSync(x.dataId),shape:x.shape}));a=P.computeOutShape(p.map(x=>x.shape),1);let m=p[0].shape[0]===1,g=ZT(f,a,t[0].dtype,m),b=P.computeOutShape(i.map(x=>x.shape),r);o.shape=b;let y=n.dataIdMap.get(o.dataId);return y.stringBytes=P.fromStringArrayToUint8(g),p.forEach(x=>n.disposeData(x.dataId)),o}let u=$.sizeFromShape(i[0].shape.slice(0,r)),c=0,l=i.map(p=>{let f=$.sizeFromShape(p.shape.slice(r));return c+=f,f}),d=i.map(p=>n.typedArrayFromHeap(p)),h=n.typedArrayFromHeap(o);for(let p=0;p<u;p++){let f=p*c;for(let m=0;m<d.length;m++){let g=l[m],b=p*g,y=d[m].subarray(b,b+g);h.set(y,f),f+=g}}return o}var _Ne={kernelName:If,backendName:"wasm",kernelFunc:wP},vP;function DNe(e){vP=e.wasm.cwrap($d,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function FNe(e){let{inputs:t,attrs:n,backend:r}=e,{x:s,filter:a}=t,i=r.dataIdMap.get(s.dataId).id,o=r.dataIdMap.get(a.dataId).id,{strides:u,dilations:c,pad:l,dimRoundingMode:d,dataFormat:h}=n,p=P.convertConv2DDataFormat(h),f=P.computeConv2DInfo(s.shape,a.shape,u,c,l,d,!1,p),m=f.filterHeight,g=f.filterWidth,b=f.padInfo.top,y=f.padInfo.right,x=f.padInfo.bottom,w=f.padInfo.left,v=f.dilationHeight,I=f.dilationWidth,N=f.strideHeight,T=f.strideWidth,E=f.inChannels,A=f.outChannels,k=f.padInfo.type==="SAME"?1:0;if(f.dataFormat!=="channelsLast")throw new Error(`wasm backend Conv2D does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);let C=r.makeOutput(f.outShape,"float32"),M=r.dataIdMap.get(C.dataId).id;return vP(i,s.shape[0],s.shape[1],s.shape[2],o,m,g,b,y,x,w,k,v,I,N,T,E,A,M),C}var MNe={kernelName:$d,backendName:"wasm",setupFunc:DNe,kernelFunc:FNe},IP;function ONe(e){IP=e.wasm.cwrap(Rd,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function LNe(e){let{backend:t,inputs:n,attrs:r}=e,{dy:s,filter:a}=n,{strides:i,pad:o,dataFormat:u,dimRoundingMode:c,inputShape:l}=r,d=1,h=P.convertConv2DDataFormat(u),p=P.computeConv2DInfo(l,a.shape,i,d,o,c,!1,h),{batchSize:f,filterHeight:m,filterWidth:g,inChannels:b,inHeight:y,inWidth:x,outChannels:w,outHeight:v,outWidth:I,strideHeight:N,strideWidth:T}=p,E=m-1-p.padInfo.top,A=g-1-p.padInfo.left,k=p.dataFormat==="channelsLast",C=$.computeStrides(p.inShape),M=$.computeStrides(s.shape),[L,O,B]=$.computeStrides(a.shape),G=C[0],z=k?C[1]:C[2],q=k?C[2]:1,Q=k?1:C[1],K=M[0],ee=k?M[1]:M[2],Y=k?M[2]:1,de=k?1:M[1],ue=t.makeOutput(p.inShape,"float32"),Ie=t.dataIdMap.get(ue.dataId).id,Ee=t.dataIdMap.get(s.dataId).id,ve=t.dataIdMap.get(a.dataId).id;return IP(Ee,ve,f,m,g,y,x,b,v,I,w,N,T,E,A,L,O,B,G,z,q,Q,K,ee,Y,de,Ie),ue}var PNe={kernelName:Rd,backendName:"wasm",setupFunc:ONe,kernelFunc:LNe},kP;function BNe(e){kP=e.wasm.cwrap(_d,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function zNe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:u}=r;if(s.dtype!=="float32")throw new Error(`Tensor x must have dtype float32, got ${s.dtype}`);if(a.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${a.dtype}`);let c=P.computeConv3DInfo(s.shape,a.shape,i,u,o),l=n.makeOutput(c.outShape,s.dtype);return kP(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(l.dataId).id,c.batchSize,c.inDepth,c.inHeight,c.inWidth,c.inChannels,c.outDepth,c.outHeight,c.outWidth,c.outChannels,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.filterDepth,c.filterHeight,c.filterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),l}var WNe={kernelName:_d,backendName:"wasm",setupFunc:BNe,kernelFunc:zNe},CP;function VNe(e){CP=e.wasm.cwrap(kf,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function UNe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,filterShape:u}=r;if(s.dtype!=="float32")throw new Error(`Tensor dy must have dtype float32, got ${s.dtype}`);if(a.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${a.dtype}`);let c=P.computeConv3DInfo(s.shape,u,i,1,o),l=n.makeOutput(c.filterShape,a.dtype);return CP(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(l.dataId).id,c.batchSize,c.inDepth,c.inHeight,c.inWidth,c.inChannels,c.outDepth,c.outHeight,c.outWidth,c.outChannels,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.filterDepth,c.filterHeight,c.filterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),l}var GNe={kernelName:kf,backendName:"wasm",setupFunc:VNe,kernelFunc:UNe},SP;function HNe(e){SP=e.wasm.cwrap(Cf,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function jNe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:i,strides:o,inputShape:u}=r;if(s.dtype!=="float32")throw new Error(`Tensor dy must have dtype float32, got ${s.dtype}`);if(a.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${a.dtype}`);let c=P.computeConv3DInfo(u,a.shape,o,1,i),l=n.makeOutput(c.inShape,s.dtype);return SP(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(l.dataId).id,c.batchSize,c.inDepth,c.inHeight,c.inWidth,c.inChannels,c.outDepth,c.outHeight,c.outWidth,c.outChannels,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.filterDepth,c.filterHeight,c.filterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),l}var qNe={kernelName:Cf,backendName:"wasm",setupFunc:HNe,kernelFunc:jNe},KNe=on(Dd),XNe=on(Fd),VC;(function(e){e[e.bilinear=0]="bilinear",e[e.nearest=1]="nearest"})(VC||(VC={}));var NP;function QNe(e){NP=e.wasm.cwrap(Nf,null,["number","number","number","number","array","number","number","number","number","number"])}function YNe(e){let{backend:t,inputs:n,attrs:r}=e,{method:s,extrapolationValue:a,cropSize:i}=r,{image:o,boxes:u,boxInd:c}=n,l=u.shape[0],[d,h]=i,p=[l,d,h,o.shape[3]],f=t.dataIdMap.get(o.dataId),m;o.dtype!=="float32"&&(m=$u({backend:t,inputs:{x:o},attrs:{dtype:"float32"}}),f=t.dataIdMap.get(m.dataId));let g=f.id,b=t.dataIdMap.get(u.dataId).id,y=t.dataIdMap.get(c.dataId).id,x=t.makeOutput(p,"float32"),w=t.dataIdMap.get(x.dataId).id,v=new Uint8Array(new Int32Array(o.shape).buffer);return NP(g,b,y,l,v,d,h,VC[s],a,w),m!=null&&t.disposeData(m.dataId),x}var JNe={kernelName:Nf,backendName:"wasm",setupFunc:QNe,kernelFunc:YNe},TP;function ZNe(e){TP=e.wasm.cwrap(Sf,null,["number","number","number","number","number","number"])}function eTe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r,u=s.shape.length;$.assert(s.dtype==="float32"||s.dtype==="int32",()=>`cumprod does not support ${s.dtype} tensors in the WASM backend`);let c=P.getAxesPermutation([a],u),l=s;c!==null&&(l=lu({inputs:{x:s},attrs:{perm:c},backend:n}));let d=P.getInnerMostAxes(1,u)[0];P.assertAxesAreInnerMostDims("cumprod",[d],u);let h=n.makeOutput(l.shape,l.dtype),p=l.shape[d],f=n.dataIdMap.get(l.dataId).id,m=n.dataIdMap.get(h.dataId).id;TP(f,i?1:0,o?1:0,p,m,mn[s.dtype]);let g=h;if(c!==null){let b=P.getUndoAxesPermutation(c);g=lu({inputs:{x:h},attrs:{perm:b},backend:n}),n.disposeData(l.dataId),n.disposeData(h.dataId)}return g}var tTe={kernelName:Sf,backendName:"wasm",setupFunc:ZNe,kernelFunc:eTe},EP;function nTe(e){EP=e.wasm.cwrap(Md,null,["number","number","number","number","number","number"])}function rTe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r,u=s.shape.length;$.assert(s.dtype==="float32"||s.dtype==="int32",()=>`cumsum does not support ${s.dtype} tensors in the WASM backend`);let c=P.getAxesPermutation([a],u),l=s;c!==null&&(l=lu({inputs:{x:s},attrs:{perm:c},backend:n}));let d=P.getInnerMostAxes(1,u)[0];P.assertAxesAreInnerMostDims("cumsum",[d],u);let h=n.makeOutput(l.shape,l.dtype),p=l.shape[d],f=n.dataIdMap.get(l.dataId).id,m=n.dataIdMap.get(h.dataId).id;EP(f,i?1:0,o?1:0,p,m,mn[s.dtype]);let g=h;if(c!==null){let b=P.getUndoAxesPermutation(c);g=lu({inputs:{x:h},attrs:{perm:b},backend:n}),n.disposeData(l.dataId),n.disposeData(h.dataId)}return g}var sTe={kernelName:Md,backendName:"wasm",setupFunc:nTe,kernelFunc:rTe},AP;function aTe(e){AP=e.wasm.cwrap("DenseBincount",null,["number","array","number","number","boolean","number","number","boolean","number"])}function iTe(e){let{backend:t,inputs:n,attrs:r}=e,{x:s,weights:a}=n,{size:i,binaryOutput:o}=r,u=a.shape.reduce((h,p)=>h*p,1)!==0,c=s.shape.length===1?[i]:[s.shape[0],i],l=t.makeOutput(c,a.dtype);function d(h){return t.dataIdMap.get(h.dataId).id}return AP(d(s),new Uint8Array(new Int32Array(s.shape).buffer),s.shape.length,i,u,d(a),mn[a.dtype],o,d(l)),l}var oTe={kernelName:Ky,backendName:"wasm",setupFunc:aTe,kernelFunc:iTe},$P;function lTe(e){$P=e.wasm.cwrap(Tf,null,["number","number","number","array","number","array","array","number","number"])}function uTe(e){let{backend:t,inputs:n,attrs:r}=e,{x:s}=n,{blockSize:a,dataFormat:i}=r,o=s.shape[0],u=i==="NHWC"?s.shape[1]:s.shape[2],c=i==="NHWC"?s.shape[2]:s.shape[3],l=i==="NHWC"?s.shape[3]:s.shape[1],d=u*a,h=c*a,p=l/(a*a),f=i==="NHWC"?[o,d,h,p]:[o,p,d,h],m=t.makeOutput(f,"float32"),g=t.dataIdMap.get(s.dataId).id,b=new Uint8Array(new Int32Array($.computeStrides(s.shape)).buffer),y=new Uint8Array(new Int32Array(f).buffer),x=new Uint8Array(new Int32Array($.computeStrides(f)).buffer),w=t.dataIdMap.get(m.dataId).id;return $P(g,a,i==="NHWC"?1:0,b,s.shape.length-1,y,x,f.length,w),m}var cTe={kernelName:Tf,backendName:"wasm",setupFunc:lTe,kernelFunc:uTe},RP;function dTe(e){RP=e.wasm.cwrap(Od,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function hTe(e){let{inputs:t,attrs:n,backend:r}=e,{x:s,filter:a}=t,i=r.dataIdMap.get(s.dataId).id,o=r.dataIdMap.get(a.dataId).id,{strides:u,dilations:c,pad:l,dimRoundingMode:d}=n,h=c??[1,1],p=P.computeConv2DInfo(s.shape,a.shape,u,h,l,d,!0),f=p.filterHeight,m=p.filterWidth,g=p.padInfo.top,b=p.padInfo.right,y=p.padInfo.bottom,x=p.padInfo.left,w=p.dilationHeight,v=p.dilationWidth,I=p.strideHeight,N=p.strideWidth,T=p.inChannels,E=p.outChannels,A=p.padInfo.type==="SAME"?1:0;if(p.dataFormat!=="channelsLast")throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${p.dataFormat}'. Please use 'channelsLast'.`);let k=r.makeOutput(p.outShape,"float32"),C=r.dataIdMap.get(k.dataId).id;return RP(i,s.shape[0],s.shape[1],s.shape[2],o,f,m,g,b,y,x,A,w,v,I,N,T,E,C),k}var pTe={kernelName:Od,backendName:"wasm",setupFunc:dTe,kernelFunc:hTe},_P;function fTe(e){_P=e.wasm.cwrap("Diag",null,["number","number","number","number"])}function mTe(e){let{inputs:t,backend:n}=e,{x:r}=t,s=$.sizeFromShape(r.shape),a=n.makeOutput([...r.shape,...r.shape],r.dtype);return _P(n.dataIdMap.get(r.dataId).id,mn[r.dtype],s,n.dataIdMap.get(a.dataId).id),a}var gTe={kernelName:Xy,backendName:"wasm",setupFunc:fTe,kernelFunc:mTe},DP;function bTe(e){DP=e.wasm.cwrap(Ld,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function yTe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:u}=r;if(s.dtype!==a.dtype)throw new Error(`Dilation2D error: x must have the same dtype as filter. Got ${s.dtype} and ${a.dtype}`);let c=P.computeDilation2DInfo(s.shape,a.shape,i,o,"NHWC",u),l=n.makeOutput(c.outShape,s.dtype);return DP(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(l.dataId).id,mn[s.dtype],c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.filterHeight,c.filterWidth,c.padInfo.top,c.padInfo.left),l}var xTe={kernelName:Ld,backendName:"wasm",setupFunc:bTe,kernelFunc:yTe},FP;function wTe(e){FP=e.wasm.cwrap(Mp,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function vTe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,dy:i}=t,{strides:o,pad:u,dilations:c}=r;if(s.dtype!==a.dtype||s.dtype!==i.dtype)throw new Error(`Dilation2DBackpropFilter error: x must have the same dtype as filter and dy. Got ${s.dtype}, ${a.dtype}, and ${i.dtype}`);let l=P.computeDilation2DInfo(s.shape,a.shape,o,u,"NHWC",c),d=n.makeOutput(a.shape,a.dtype);return FP(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,mn[s.dtype],l.batchSize,l.inChannels,l.inHeight,l.inWidth,l.outHeight,l.outWidth,l.strideHeight,l.strideWidth,l.dilationHeight,l.dilationWidth,l.filterHeight,l.filterWidth,l.padInfo.top,l.padInfo.left),d}var ITe={kernelName:Mp,backendName:"wasm",setupFunc:wTe,kernelFunc:vTe},MP;function kTe(e){MP=e.wasm.cwrap(Fp,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function CTe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,dy:i}=t,{strides:o,pad:u,dilations:c}=r;if(s.dtype!==a.dtype||s.dtype!==i.dtype)throw new Error(`Dilation2DBackpropInput error: x must have the same dtype as filter and dy. Got ${s.dtype}, ${a.dtype}, and ${i.dtype}`);let l=P.computeDilation2DInfo(s.shape,a.shape,o,u,"NHWC",c),d=n.makeOutput(s.shape,s.dtype);return MP(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,mn[s.dtype],l.batchSize,l.inChannels,l.inHeight,l.inWidth,l.outHeight,l.outWidth,l.strideHeight,l.strideWidth,l.dilationHeight,l.dilationWidth,l.filterHeight,l.filterWidth,l.padInfo.top,l.padInfo.left),d}var STe={kernelName:Fp,backendName:"wasm",setupFunc:kTe,kernelFunc:CTe},NTe=on(Bd),OP;function TTe(e){OP=e.wasm.cwrap(Ef,null,["number","number","number"])}function ETe(e){let{inputs:t,backend:n}=e,{dy:r,y:s}=t,a=n.makeOutput(s.shape,"float32"),i=o=>n.dataIdMap.get(o.dataId).id;return OP(i(s),i(r),i(a)),a}var ATe={kernelName:Ef,backendName:"wasm",setupFunc:TTe,kernelFunc:ETe},$Te=!1,RTe=Or(Af,$Te,"bool"),_Te=on(zd),DTe=on(Wd,"float32");function UC(e){let{inputs:t,attrs:n,backend:r}=e,{input:s}=t,{dim:a}=n,i=s.shape.length,o=s.shape.slice(),u=a;return a<0&&($.assert(-(i+1)<=a,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+a+1),o.splice(u,0,1),aa({inputs:{x:s},backend:r,attrs:{shape:o}})}var FTe={kernelName:$f,backendName:"wasm",kernelFunc:UC},MTe=on(Vd,"float32");function LP(e){let{attrs:{shape:t,value:n},backend:r}=e,{attrs:{dtype:s}}=e;s=s||$.inferDtype(n);let a=r.makeOutput(t,s);return r.typedArrayFromHeap(a).fill(n),a}var OTe={kernelName:Qy,backendName:"wasm",kernelFunc:LP},PP;function LTe(e){PP=e.wasm.cwrap(Rf,null,["number","number","number","number","number","number"])}function PTe(e){let{inputs:t,backend:n}=e,{image:r}=t,s=n.makeOutput(r.shape,r.dtype),a=n.dataIdMap.get(r.dataId).id,i=n.dataIdMap.get(s.dataId).id,[o,u,c,l]=r.shape;return PP(a,o,u,c,l,i),s}var BTe={kernelName:Rf,backendName:"wasm",kernelFunc:PTe,setupFunc:LTe},zTe=on(Ud),WTe=Or(Gd),BP;function VTe(e){BP=e.wasm.cwrap(Hd,null,["number","number","number","number","number","number","number"])}function UTe(e){let{backend:t,inputs:n,attrs:r}=e,{varianceEpsilon:s}=r,{x:a,mean:i,variance:o,offset:u,scale:c}=n,l=t.dataIdMap.get(a.dataId).id,d=t.dataIdMap.get(i.dataId).id,h=t.dataIdMap.get(o.dataId).id,p=u!=null?t.dataIdMap.get(u.dataId).id:0,f=c!=null?t.dataIdMap.get(c.dataId).id:0,m=t.makeOutput(a.shape,a.dtype);if($.sizeFromShape(a.shape)===0)return m;let g=t.dataIdMap.get(m.dataId).id;return BP(l,d,h,p,f,s,g),m}var GTe={kernelName:Hd,backendName:"wasm",setupFunc:VTe,kernelFunc:UTe},zP;function HTe(e){zP=e.wasm.cwrap(Lc,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function jTe(e){let{inputs:t,attrs:n,backend:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:u,pad:c,dilations:l,dataFormat:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=n,m=P.computeConv2DInfo(s.shape,a.shape,u,l,c,h),g=Iy[p];if(g==null)throw new Error(`${p} activation not yet supported for FusedConv2D in the wasm backend.`);let b=r.dataIdMap.get(s.dataId).id,y=r.dataIdMap.get(a.dataId).id,x=m.outChannels,w=0;if(i!=null){let Y=r.dataIdMap.get(i.dataId);if(Y.shape.length!==1)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${Y.shape.length}.`);if(Y.shape[0]!==x)throw new Error(`FusedConv2D bias shape (${Y.shape}) does not match the number of output channels (${x})`);w=Y.id}let v=m.filterHeight,I=m.filterWidth,N=m.padInfo.top,T=m.padInfo.right,E=m.padInfo.bottom,A=m.padInfo.left,k=m.dilationHeight,C=m.dilationWidth,M=m.strideHeight,L=m.strideWidth,O=m.inChannels,B=m.padInfo.type==="SAME"?1:0,G=m.batchSize,z=m.inHeight,q=m.inWidth;if(d!=="NHWC")throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${d}'. Please use 'NHWC'.`);let Q=r.makeOutput(m.outShape,"float32"),K=r.dataIdMap.get(Q.dataId).id,ee=o==null?0:r.dataIdMap.get(o.dataId).id;return zP(b,G,z,q,y,v,I,w,N,T,E,A,B,k,C,M,L,O,x,g,ee,f||0,K),Q}var qTe={kernelName:Lc,backendName:"wasm",setupFunc:HTe,kernelFunc:jTe},WP;function KTe(e){WP=e.wasm.cwrap(Pc,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function XTe(e){let{inputs:t,attrs:n,backend:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:u,pad:c,dilations:l,dataFormat:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=n,m=P.computeConv2DInfo(s.shape,a.shape,u,l,c,h,!0),g=Iy[p];if(g==null)throw new Error(`${p} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);let b=r.dataIdMap.get(s.dataId).id,y=r.dataIdMap.get(a.dataId).id,x=m.outChannels,w=0;if(i!=null){let Y=r.dataIdMap.get(i.dataId);if(Y.shape.length!==1)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${Y.shape.length}.`);if(Y.shape[0]!==x)throw new Error(`FusedDepthwiseConv2D bias shape (${Y.shape}) does not match the number of output channels (${x})`);w=Y.id}let v=m.filterHeight,I=m.filterWidth,N=m.padInfo.top,T=m.padInfo.right,E=m.padInfo.bottom,A=m.padInfo.left,k=m.dilationHeight,C=m.dilationWidth,M=m.strideHeight,L=m.strideWidth,O=m.inChannels,B=m.padInfo.type==="SAME"?1:0,G=m.batchSize,z=m.inHeight,q=m.inWidth;if(d!=="NHWC")throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${d}'. Please use 'NHWC'.`);let Q=r.makeOutput(m.outShape,"float32"),K=r.dataIdMap.get(Q.dataId).id,ee=o==null?0:r.dataIdMap.get(o.dataId).id;return WP(b,G,z,q,y,v,I,w,N,T,E,A,B,k,C,M,L,O,x,g,ee,f||0,K),Q}var QTe={kernelName:Pc,backendName:"wasm",setupFunc:KTe,kernelFunc:XTe},VP;function YTe(e){VP=e.wasm.cwrap(Df,null,["number","number","number","number","number","number","array","number"])}function JTe(e){let{backend:t,inputs:n}=e,{params:r,indices:s}=n,[a,i,o,u]=dN.prepareAndValidate(r,s),c=t.makeOutput(a,r.dtype);if(i===0)return c;let l=s.shape,d=l[l.length-1],h=t.dataIdMap.get(r.dataId).id,p=t.dataIdMap.get(s.dataId).id,f=new Uint8Array(new Int32Array(u).buffer),m=t.dataIdMap.get(c.dataId).id;return VP(h,mn[r.dtype],p,i,d,o,f,m),c}var ZTe={kernelName:Df,backendName:"wasm",setupFunc:YTe,kernelFunc:JTe},UP;function e4e(e){UP=e.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])}function t4e(e){let{backend:t,inputs:n,attrs:r}=e,{x:s,indices:a}=n,{axis:i,batchDims:o}=r,u=$.parseAxisParam(i,s.shape)[0],c=t.readSync(a.dataId),l=s.shape[u];for(let N=0;N<c.length;++N){let T=c[N];$.assert(T<=l-1&&T>=0,()=>`GatherV2: the index value ${T} is not in [0, ${l-1}]`)}let d=P.segment_util.collectGatherOpShapeInfo(s,a,u,o),h=aa({inputs:{x:s},attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]},backend:t}),p=$.sizeFromShape(a.shape),f=aa({inputs:{x:a},attrs:{shape:[d.batchSize,p/d.batchSize]},backend:t}),m=[d.batchSize,d.outerSize,p/d.batchSize,d.sliceSize],g=t.makeOutput(m,s.dtype);if($.sizeFromShape(s.shape)===0)return g;let b=h.shape.length-1,y=t.dataIdMap.get(h.dataId).id,x=t.dataIdMap.get(f.dataId).id,w=t.dataIdMap.get(g.dataId).id,v=new Uint8Array(new Int32Array($.computeStrides(h.shape)).buffer),I=new Uint8Array(new Int32Array($.computeStrides(m)).buffer);return UP(y,mn[s.dtype],v,b,x,d.batchSize,I,w),t.disposeData(h.dataId),t.disposeData(f.dataId),g.shape=d.outputShape,g}var n4e={kernelName:_f,backendName:"wasm",setupFunc:e4e,kernelFunc:t4e},r4e=!1,s4e=Or(Ff,r4e,"bool"),a4e=!1,i4e=Or(jd,a4e,"bool"),o4e=on(Kd,"bool"),l4e=on(Xd,"bool"),u4e=on(Qd,"bool"),GP;function c4e(e){GP=e.wasm.cwrap(Yd,null,["number","number","number","number"])}function d4e(e){let{inputs:{x:t},attrs:{alpha:n},backend:r}=e,s=r.dataIdMap.get(t.dataId).id,a=r.makeOutput(t.shape,"float32");if($.sizeFromShape(t.shape)!==0){let i=r.dataIdMap.get(a.dataId).id;GP(s,mn[t.dtype],n,i)}return a}var h4e={kernelName:Yd,backendName:"wasm",setupFunc:c4e,kernelFunc:d4e},p4e=!1,f4e=Or(Mf,p4e,"bool"),m4e=!1,g4e=Or(Of,m4e,"bool"),HP;function b4e(e){HP=e.wasm.cwrap(Lf,null,["number","number","number","number"])}function y4e(e){let{attrs:t,backend:n}=e,{start:r,stop:s,num:a}=t,i=Math.floor(a),o=n.makeOutput([i],"float32");return HP(n.dataIdMap.get(o.dataId).id,r,s,i),o}var x4e={kernelName:Lf,backendName:"wasm",setupFunc:b4e,kernelFunc:y4e},w4e=on(Jd),v4e=on(Zd),I4e=!1,k4e=Or(Pf,I4e,"bool"),C4e=on(Bf),S4e=!1,N4e=Or(zf,S4e,"bool"),T4e=!1,E4e=Or(GF,T4e,"bool"),jP;function A4e(e){jP=e.wasm.cwrap(eh,null,["number","number","number","number","number","number","number"])}function $4e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:i,alpha:o,beta:u}=r;if(s.dtype!=="float32")throw new Error("LRN error: x must have dtype float32");let c=n.makeOutput(s.shape,s.dtype);return jP(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(c.dataId).id,s.shape[3],a,i,o,u),c}var R4e={kernelName:eh,backendName:"wasm",setupFunc:A4e,kernelFunc:$4e},qP;function _4e(e){qP=e.wasm.cwrap(Wf,null,["number","number","number","number","number","number","number","number","number"])}function D4e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:i}=t,{depthRadius:o,bias:u,alpha:c,beta:l}=r;if(s.dtype!=="float32"||a.dtype!=="float32"||i.dtype!=="float32")throw new Error("LRNGrad error: x, y, and dy must have dtype float32");let d=n.makeOutput(s.shape,s.dtype);return qP(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,i.shape[3],o,u,c,l),d}var F4e={kernelName:Wf,backendName:"wasm",setupFunc:_4e,kernelFunc:D4e},KP;function M4e(e){KP=e.wasm.cwrap(th,null,["number","number","number","number"])}function O4e(e){let{backend:t,inputs:n,attrs:r}=e,{reductionIndices:s,keepDims:a}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,u=i,{transposed:c,axes:l,originalAxes:d,inputWasTransposed:h}=Au(i,s,t);if(h){let y=t.dataIdMap.get(c.dataId).id;u=c,o=y}let p=u.shape.length;P.assertAxesAreInnerMostDims("max",l,p);let[f,m]=P.computeOutAndReduceShapes(u.shape,l),g=$.sizeFromShape(m),b=t.makeOutput(f,i.dtype);if($.sizeFromShape(u.shape)!==0){let y=t.dataIdMap.get(b.dataId).id;KP(o,mn[i.dtype],g,y)}if(h&&t.disposeData(c.dataId),a){let y=P.expandShapeToKeepDim(b.shape,d);b.shape=y}return b}var L4e={kernelName:th,backendName:"wasm",setupFunc:M4e,kernelFunc:O4e},P4e=Or(nh),XP;function B4e(e){XP=e.wasm.cwrap(rh,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function z4e(e){let{inputs:t,attrs:n,backend:r}=e,s=t.x,a=r.dataIdMap.get(s.dataId).id;$.assert(s.dtype==="float32",()=>`Error in MaxPool: only float32 input is supported. Got ${s.dtype}.`);let{filterSize:i,strides:o,pad:u,dimRoundingMode:c}=n,l=P.computePool2DInfo(s.shape,i,o,1,u,c),d=l.filterHeight,h=l.filterWidth,p=l.padInfo.top,f=l.padInfo.right,m=l.padInfo.bottom,g=l.padInfo.left,b=l.dilationHeight,y=l.dilationWidth,x=l.strideHeight,w=l.strideWidth,v=l.inChannels,I=l.outChannels;if(l.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${l.dataFormat}'. Please use 'channelsLast'.`);let N=r.makeOutput(l.outShape,"float32"),T=r.dataIdMap.get(N.dataId).id;return XP(a,s.shape[0],s.shape[1],s.shape[2],d,h,p,f,m,g,b,y,x,w,v,I,T),N}var W4e={kernelName:rh,backendName:"wasm",setupFunc:B4e,kernelFunc:z4e},QP;function V4e(e){QP=e.wasm.cwrap("MaxPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function U4e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:u,dataFormat:c}=r,l=P.computePool3DInfo(s.shape,a,i,1,o,u,c),d=n.makeOutput(l.outShape,s.dtype);return QP(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(d.dataId).id,l.batchSize,l.inChannels,l.inDepth,l.inHeight,l.inWidth,l.outDepth,l.outHeight,l.outWidth,l.strideDepth,l.strideHeight,l.strideWidth,l.dilationDepth,l.dilationHeight,l.dilationWidth,l.effectiveFilterDepth,l.effectiveFilterHeight,l.effectiveFilterWidth,l.padInfo.front,l.padInfo.top,l.padInfo.left),d}var G4e={kernelName:Vf,backendName:"wasm",setupFunc:V4e,kernelFunc:U4e},YP;function H4e(e){YP=e.wasm.cwrap("MaxPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function j4e(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:u,dimRoundingMode:c}=r,l=P.computePool3DInfo(a.shape,i,o,1,u,c),d=n.makeOutput(a.shape,a.dtype);return YP(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(d.dataId).id,l.batchSize,l.inChannels,l.inDepth,l.inHeight,l.inWidth,l.outDepth,l.outHeight,l.outWidth,l.strideDepth,l.strideHeight,l.strideWidth,l.dilationDepth,l.dilationHeight,l.dilationWidth,l.effectiveFilterDepth,l.effectiveFilterHeight,l.effectiveFilterWidth,l.padInfo.front,l.padInfo.top,l.padInfo.left),d}var q4e={kernelName:Jy,backendName:"wasm",setupFunc:H4e,kernelFunc:j4e},JP;function K4e(e){JP=e.wasm.cwrap("MaxPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function X4e(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:u,dimRoundingMode:c}=r,l=P.computePool2DInfo(a.shape,i,o,1,u,c),d=n.makeOutput(a.shape,a.dtype);return JP(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(d.dataId).id,l.batchSize,l.inChannels,l.inHeight,l.inWidth,l.outHeight,l.outWidth,l.strideHeight,l.strideWidth,l.dilationHeight,l.dilationWidth,l.effectiveFilterHeight,l.effectiveFilterWidth,l.padInfo.top,l.padInfo.left),d}var Q4e={kernelName:Yy,backendName:"wasm",setupFunc:K4e,kernelFunc:X4e},ZP;function Y4e(e){ZP=e.wasm.cwrap("MaxPoolWithArgmax",null,["number","number","number","number","boolean","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function J4e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,includeBatchInIndex:u}=r;$.assert(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);let c=[1,1];$.assert(P.eitherStridesOrDilationsAreOne(i,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);let l=P.computePool2DInfo(s.shape,a,i,[1,1],o),d=n.makeOutput(l.outShape,s.dtype),h=n.makeOutput(l.outShape,"int32");return ZP(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(d.dataId).id,n.dataIdMap.get(h.dataId).id,mn[s.dtype],u,l.batchSize,l.inChannels,l.inHeight,l.inWidth,l.outHeight,l.outWidth,l.strideHeight,l.strideWidth,l.dilationHeight,l.dilationWidth,l.effectiveFilterHeight,l.effectiveFilterWidth,l.padInfo.top,l.padInfo.left),[d,h]}var Z4e={kernelName:Zy,backendName:"wasm",setupFunc:Y4e,kernelFunc:J4e},eB;function eEe(e){eB=e.wasm.cwrap(sh,null,["number, number, number"])}function tEe(e){let{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:a}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,u=o,c=i,{transposed:l,axes:d,originalAxes:h,inputWasTransposed:p}=Au(i,s,t),f=d;if(p){let w=t.dataIdMap.get(l.dataId).id;w!==o&&(c=l,u=w,f=P.getInnerMostAxes(f.length,c.shape.length))}P.assertAxesAreInnerMostDims("mean",f,c.shape.length);let[m,g]=P.computeOutAndReduceShapes(c.shape,f),b=$.sizeFromShape(g),y=c;c.dtype!=="float32"&&(y=$u({backend:t,inputs:{x:c},attrs:{dtype:"float32"}}),u=t.dataIdMap.get(y.dataId).id);let x=t.makeOutput(m,"float32");if($.sizeFromShape(c.shape)!==0){let w=t.dataIdMap.get(x.dataId).id;eB(u,b,w)}if(p&&t.disposeData(l.dataId),a){let w=P.expandShapeToKeepDim(x.shape,h);x.shape=w}return c.dtype!=="float32"&&t.disposeData(y.dataId),x}var nEe={kernelName:sh,backendName:"wasm",setupFunc:eEe,kernelFunc:tEe},tB;function rEe(e){tB=e.wasm.cwrap(ah,null,["number","number","number","number"])}function sEe(e){let{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:a}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,u=o,c=i,{transposed:l,axes:d,originalAxes:h,inputWasTransposed:p}=Au(i,s,t);if(p){let x=t.dataIdMap.get(l.dataId).id;x!==o&&(c=l,u=x)}let f=c.shape.length;P.assertAxesAreInnerMostDims("min",d,f);let[m,g]=P.computeOutAndReduceShapes(c.shape,d),b=$.sizeFromShape(g),y=t.makeOutput(m,c.dtype);if($.sizeFromShape(c.shape)!==0){let x=t.dataIdMap.get(y.dataId).id;tB(u,mn[i.dtype],b,x)}if(p&&t.disposeData(l.dataId),a){let x=P.expandShapeToKeepDim(y.shape,h);y.shape=x}return y}var aEe={kernelName:ah,backendName:"wasm",setupFunc:rEe,kernelFunc:sEe},iEe=Or(ih),GC;(function(e){e[e.reflect=0]="reflect",e[e.symmetric=1]="symmetric"})(GC||(GC={}));var nB;function oEe(e){nB=e.wasm.cwrap(oh,null,["number","array","number","number","array","array","number","number"])}function lEe(e){let{inputs:{x:t},backend:n,attrs:{paddings:r,mode:s}}=e,a=r.map((f,m)=>f[0]+t.shape[m]+f[1]),i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(a,t.dtype),u=n.dataIdMap.get(o.dataId).id,c=new Uint8Array(new Int32Array(t.shape).buffer),l=r.map(f=>f[0]),d=r.map(f=>f[1]),h=new Uint8Array(new Int32Array(l).buffer),p=new Uint8Array(new Int32Array(d).buffer);return nB(i,c,t.shape.length,mn[t.dtype],h,p,GC[s],u),o}var uEe={kernelName:oh,backendName:"wasm",kernelFunc:lEe,setupFunc:oEe},rB;function cEe(e){rB=e.wasm.cwrap(Rh,null,["number","number","number","number"])}function sB(e){let{backend:t,inputs:{logits:n},attrs:{dim:r}}=e,s=t.dataIdMap.get(n.dataId).id,a=t.makeOutput(n.shape,n.dtype),i=t.dataIdMap.get(a.dataId).id,o=n.shape[r],u=$.sizeFromShape(n.shape)/o;return $.sizeFromShape(a.shape)===0||rB(s,i,o,u),a}var dEe={kernelName:Rh,backendName:"wasm",setupFunc:cEe,kernelFunc:sB},aB;function hEe(e){aB=e.wasm.cwrap(Uf,null,["number","number","number","number","number","number"])}function pEe(e){let{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:i,normalized:o}=r;if(s.dtype!=="float32")throw new Error(`Tensor logits must have dtype float32, got ${s.dtype}`);let u=o?s:sB({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),[c,l]=u.shape,d=n.makeOutput([c,a],"int32");return aB(n.dataIdMap.get(u.dataId).id,c,l,a,i,n.dataIdMap.get(d.dataId).id),o||n.disposeData(u.dataId),d}var fEe={kernelName:Uf,backendName:"wasm",setupFunc:hEe,kernelFunc:pEe},mEe=Or(lh),gEe=Or(uh),bEe=on(Gf);function E4(e,t){let n=new Int32Array(e.wasm.HEAPU8.buffer,t,4),r=n[0],s=n[1],a=n[2],i=n[3];return e.wasm._free(t),{pSelectedIndices:r,selectedSize:s,pSelectedScores:a,pValidOutputs:i}}var iB;function yEe(e){iB=e.wasm.cwrap(jf,"number",["number","number","number","number","number"])}function xEe(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:s,maxOutputSize:a,scoreThreshold:i}=r,{boxes:o,scores:u}=n,c=t.dataIdMap.get(o.dataId).id,l=t.dataIdMap.get(u.dataId).id,d=iB(c,l,a,s,i),{pSelectedIndices:h,selectedSize:p,pSelectedScores:f,pValidOutputs:m}=E4(t,d);return t.wasm._free(f),t.wasm._free(m),t.makeOutput([p],"int32",h)}var wEe={kernelName:jf,backendName:"wasm",setupFunc:yEe,kernelFunc:xEe},oB;function vEe(e){oB=e.wasm.cwrap(qf,"number",["number","number","number","number","number","bool"])}function IEe(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:s,maxOutputSize:a,scoreThreshold:i,padToMaxOutputSize:o}=r,{boxes:u,scores:c}=n,l=t.dataIdMap.get(u.dataId).id,d=t.dataIdMap.get(c.dataId).id,h=oB(l,d,a,s,i,o),{pSelectedIndices:p,selectedSize:f,pSelectedScores:m,pValidOutputs:g}=E4(t,h);t.wasm._free(m);let b=t.makeOutput([f],"int32",p),y=t.makeOutput([],"int32",g);return[b,y]}var kEe={kernelName:qf,backendName:"wasm",setupFunc:vEe,kernelFunc:IEe},lB;function CEe(e){lB=e.wasm.cwrap(Kf,"number",["number","number","number","number","number","number"])}function SEe(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:s,maxOutputSize:a,scoreThreshold:i,softNmsSigma:o}=r,{boxes:u,scores:c}=n,l=t.dataIdMap.get(u.dataId).id,d=t.dataIdMap.get(c.dataId).id,h=lB(l,d,a,s,i,o),{pSelectedIndices:p,selectedSize:f,pSelectedScores:m,pValidOutputs:g}=E4(t,h);t.wasm._free(g);let b=t.makeOutput([f],"int32",p),y=t.makeOutput([f],"float32",m);return[b,y]}var NEe={kernelName:Kf,backendName:"wasm",setupFunc:CEe,kernelFunc:SEe},TEe=!1,EEe=Or(Hf,TEe,"bool"),uB;function AEe(e){uB=e.wasm.cwrap(ch,null,["number","number","number","number","number"])}function $Ee(e){let{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{dtype:a,depth:i,onValue:o,offValue:u}=r,c=n.makeOutput([...s.shape,i],a),l=n.dataIdMap.get(c.dataId).id,d=n.dataIdMap.get(s.dataId).id;return uB(d,i,o,u,l),c}var REe={kernelName:ch,backendName:"wasm",setupFunc:AEe,kernelFunc:$Ee};function _Ee(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(1),r}var DEe={kernelName:Xf,backendName:"wasm",kernelFunc:_Ee};function FEe(e){let{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(t.length===1)return UC({inputs:{input:t[0]},backend:n,attrs:{dim:s}});let a=t[0].shape,i=t[0].dtype;t.forEach(l=>{$.assertShapesMatch(a,l.shape,"All tensors passed to stack must have matching shapes"),$.assert(i===l.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],u=t.map(l=>{let d=UC({inputs:{input:l},backend:n,attrs:{dim:s}});return o.push(d),d}),c=wP({inputs:u,backend:n,attrs:{axis:s}});return o.forEach(l=>n.disposeData(l.dataId)),c}var MEe={kernelName:Qf,backendName:"wasm",kernelFunc:FEe},cB;function OEe(e){cB=e.wasm.cwrap(dh,null,["number","array","number","number","array","array","number","number"])}function LEe(e){let{inputs:{x:t},backend:n,attrs:{paddings:r,constantValue:s}}=e,a=r.map((f,m)=>f[0]+t.shape[m]+f[1]);if($.sizeFromShape(t.shape)===0)return LP({backend:n,attrs:{shape:a,value:s,dtype:t.dtype}});let i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(a,t.dtype),u=n.dataIdMap.get(o.dataId).id,c=new Uint8Array(new Int32Array(t.shape).buffer),l=r.map(f=>f[0]),d=r.map(f=>f[1]),h=new Uint8Array(new Int32Array(l).buffer),p=new Uint8Array(new Int32Array(d).buffer);return cB(i,c,t.shape.length,mn[t.dtype],h,p,s,u),o}var dB={kernelName:dh,backendName:"wasm",kernelFunc:LEe,setupFunc:OEe},PEe=Or(hh),hB;function BEe(e){hB=e.wasm.cwrap(ph,null,["number","number","number"])}function zEe(e){let{inputs:t,backend:n}=e,{x:r,alpha:s}=t,a=n.dataIdMap.get(r.dataId).id,i=n.dataIdMap.get(s.dataId).id,o=a,u=r,c=u;u.dtype!=="float32"&&(c=$u({backend:n,inputs:{x:r},attrs:{dtype:"float32"}}),o=n.dataIdMap.get(c.dataId).id);let l=n.makeOutput(r.shape,"float32"),d=n.dataIdMap.get(l.dataId).id;return hB(o,i,d),u.dtype!=="float32"&&n.disposeData(c.dataId),l}var WEe={kernelName:ph,backendName:"wasm",setupFunc:BEe,kernelFunc:zEe},pB;function VEe(e){pB=e.wasm.cwrap(fh,null,["number","number","number","number"])}function UEe(e){let{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:a}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,u=o,c=i,{transposed:l,axes:d,originalAxes:h,inputWasTransposed:p}=Au(i,s,t),f=d;if(p){let x=t.dataIdMap.get(l.dataId).id;x!==o&&(c=l,u=x,f=P.getInnerMostAxes(f.length,c.shape.length))}P.assertAxesAreInnerMostDims("prod",f,c.shape.length);let[m,g]=P.computeOutAndReduceShapes(c.shape,f),b=$.sizeFromShape(g),y=t.makeOutput(m,c.dtype);if($.sizeFromShape(c.shape)!==0){let x=t.dataIdMap.get(y.dataId).id;pB(u,b,mn[y.dtype],x)}if(p&&t.disposeData(l.dataId),a){let x=P.expandShapeToKeepDim(y.shape,h);y.shape=x}return y}var GEe={kernelName:fh,backendName:"wasm",setupFunc:VEe,kernelFunc:UEe},HEe=e=>{let{backend:t,attrs:n}=e,{start:r,stop:s,step:a,dtype:i}=n,o=n4(r,s,a,i),u=t.makeOutput([o.length],i);return t.typedArrayFromHeap(u).set(o),u},jEe={kernelName:e0,backendName:"wasm",kernelFunc:HEe},qEe=Or(Pd),KEe=on(mh),XEe=on(gh),QEe=on(xh),fB;function YEe(e){fB=e.wasm.cwrap(yh,null,["number","number","number","number","number","number","number","number","number","number"])}function JEe(e){let{backend:t,inputs:n,attrs:r}=e,{images:s}=n,{alignCorners:a,halfPixelCenters:i,size:o}=r,[u,c]=o,[l,d,h,p]=s.shape,f=[l,u,c,p],m=t.dataIdMap.get(s.dataId),g;m.dtype!=="float32"&&(g=$u({backend:t,inputs:{x:s},attrs:{dtype:"float32"}}),m=t.dataIdMap.get(g.dataId));let b=m.id,y=t.makeOutput(f,"float32");if($.sizeFromShape(s.shape)===0)return y;let x=t.dataIdMap.get(y.dataId).id;return fB(b,l,d,h,p,u,c,a?1:0,i?1:0,x),g!=null&&t.disposeData(g.dataId),y}var ZEe={kernelName:yh,backendName:"wasm",setupFunc:YEe,kernelFunc:JEe},mB;function eAe(e){mB=e.wasm.cwrap(Zf,null,["number","number","number","array","array","boolean"])}function tAe(e){let{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=n.makeOutput(s.shape,"float32"),u=n.dataIdMap.get(s.dataId),c;return u.dtype!=="float32"&&(c=$u({backend:n,inputs:{x:s},attrs:{dtype:"float32"}}),u=n.dataIdMap.get(c.dataId)),mB(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(o.dataId).id,new Uint8Array(new Int32Array(s.shape).buffer),new Uint8Array(new Int32Array(a.shape).buffer),i),c!=null&&n.disposeData(c.dataId),o}var nAe={kernelName:Zf,backendName:"wasm",setupFunc:eAe,kernelFunc:tAe},gB;function rAe(e){gB=e.wasm.cwrap(bh,null,["number","number","number","number","number","number","number","number","number","number"])}function sAe(e){let{backend:t,inputs:n,attrs:r}=e,{images:s}=n,{alignCorners:a,halfPixelCenters:i,size:o}=r,[u,c]=o,[l,d,h,p]=s.shape,f=[l,u,c,p],m=t.makeOutput(f,"float32");if($.sizeFromShape(s.shape)===0)return m;let g=t.dataIdMap.get(s.dataId),b;g.dtype!=="float32"&&(b=$u({backend:t,inputs:{x:s},attrs:{dtype:"float32"}}),g=t.dataIdMap.get(b.dataId));let y=g.id,x=t.dataIdMap.get(m.dataId).id;return gB(y,l,d,h,p,u,c,a?1:0,i?1:0,x),b!=null&&t.disposeData(b.dataId),m}var aAe={kernelName:bh,backendName:"wasm",setupFunc:rAe,kernelFunc:sAe},bB;function iAe(e){bB=e.wasm.cwrap(Jf,null,["number","number","number","array","array","boolean"])}function oAe(e){let{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=n.makeOutput(s.shape,"float32"),u=n.dataIdMap.get(s.dataId),c;return u.dtype!=="float32"&&(c=$u({backend:n,inputs:{x:s},attrs:{dtype:"float32"}}),u=n.dataIdMap.get(c.dataId)),bB(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(o.dataId).id,new Uint8Array(new Int32Array(s.shape).buffer),new Uint8Array(new Int32Array(a.shape).buffer),i),c!=null&&n.disposeData(c.dataId),o}var lAe={kernelName:Jf,backendName:"wasm",setupFunc:iAe,kernelFunc:oAe},yB;function uAe(e){yB=e.wasm.cwrap(wh,null,["number","array","number","array","number","number"])}function cAe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r,i=$.parseAxisParam(a,s.shape);if(s.shape.length===0)return Mv({inputs:{x:s},backend:n});let o=n.makeOutput(s.shape,s.dtype),u=n.dataIdMap.get(s.dataId).id,c=n.dataIdMap.get(o.dataId).id,l=new Uint8Array(new Int32Array(i).buffer),d=new Uint8Array(new Int32Array(s.shape).buffer);yB(u,l,i.length,d,s.shape.length,c);let h=aa({inputs:{x:o},attrs:{shape:s.shape},backend:n});return n.disposeData(o.dataId),h}var dAe={kernelName:wh,backendName:"wasm",kernelFunc:cAe,setupFunc:uAe},xB;function hAe(e){xB=e.wasm.cwrap(fm,null,["number","number","number","number","number","number","number","number","array","number","number"])}function pAe(e){let{inputs:t,backend:n,attrs:r}=e,{image:s}=t,{radians:a,fillValue:i,center:o}=r,u=n.makeOutput(s.shape,s.dtype),c=n.dataIdMap.get(s.dataId).id,l=n.dataIdMap.get(u.dataId).id,[d,h,p,f]=s.shape,[m,g]=P.getImageCenter(o,h,p),b=i===0,y=255,x=typeof i=="number"?[i,i,i,b?0:y]:[...i,y],w=new Uint8Array(new Int32Array(x).buffer);return xB(c,d,h,p,f,a,m,g,w,x.length,l),u}var fAe={kernelName:fm,backendName:"wasm",kernelFunc:pAe,setupFunc:hAe},mAe=on(vh),gAe=on(Ih),wB;function bAe(e){wB=e.wasm.cwrap(em,null,["number","number","number","number","number","number","array","number","number"])}function yAe(e){let{backend:t,inputs:n,attrs:r}=e,{indices:s,updates:a}=n,{shape:i}=r,o=t.makeOutput(i,a.dtype);if($.sizeFromShape(i)===0)return o;let{sliceRank:u,numUpdates:c,sliceSize:l,strides:d,outputSize:h}=Yw.calculateShapes(a,s,i),p=t.dataIdMap.get(s.dataId).id,f=t.dataIdMap.get(a.dataId).id,m=new Uint8Array(new Int32Array(d).buffer),g=t.dataIdMap.get(o.dataId).id;return wB(p,f,mn[a.dtype],u,c,l,m,h,g),o}var xAe={kernelName:em,backendName:"wasm",setupFunc:bAe,kernelFunc:yAe},vB;function wAe(e){vB=e.wasm.cwrap(nm,null,["number","number","number","number","number","number","bool","number"])}function vAe(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:s,values:a}=t,{side:i}=r;if(s.dtype!==a.dtype)throw new Error(`SearchSorted error: sorted_sequence must have the same dtype as values. Got ${s.dtype} and ${a.dtype}`);let o=n.makeOutput(a.shape,"int32");function u(c){return n.dataIdMap.get(c.dataId).id}return vB(u(s),u(a),s.shape[0],s.shape[1],a.shape[1],mn[s.dtype],i==="left",u(o)),o}var IAe={kernelName:nm,backendName:"wasm",setupFunc:wAe,kernelFunc:vAe},IB;function kAe(e){IB=e.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}function CAe(e){let{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t,i=n.dataIdMap.get(r.dataId).id,o=n.dataIdMap.get(s.dataId).id,u=n.dataIdMap.get(a.dataId).id,c=n.makeOutput(s.shape,s.dtype),l=n.dataIdMap.get(c.dataId).id,d=r.shape.length,h=s.shape.length,p=d===0||d>1||h===1?1:$.sizeFromShape(s.shape.slice(1));return IB(i,o,u,p,l),c}var SAe={kernelName:rm,backendName:"wasm",kernelFunc:CAe,setupFunc:kAe},NAe=on(kh),kB;function TAe(e){kB=e.wasm.cwrap(Th,null,["number","number"])}function EAe(e){let{backend:t,inputs:{x:n}}=e,r=t.dataIdMap.get(n.dataId).id,s=t.makeOutput(n.shape,n.dtype),a=t.dataIdMap.get(s.dataId).id;return $.sizeFromShape(s.shape)===0||kB(r,a),s}var AAe={kernelName:"Sigmoid",backendName:"wasm",setupFunc:TAe,kernelFunc:EAe},$Ae=on(Nh),RAe=on(Ch),_Ae=on(Sh),DAe=on(Eh);function FAe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:i}=r,o=$.sizeFromShape(a),u=[[0,0]];u.push(...i);for(let g=1+a.length;g<s.shape.length;++g)u.push([0,0]);let c=dB.kernelFunc({inputs:{x:s},backend:n,attrs:{paddings:u,constantValue:0}}),l=P.getReshaped(c.shape,a,o,!1),d=P.getPermuted(l.length,a.length,!1),h=P.getReshapedPermuted(c.shape,a,o,!1),p=aa({inputs:{x:c},backend:n,attrs:{shape:l}}),f=lu({inputs:{x:p},backend:n,attrs:{perm:d}}),m=aa({inputs:{x:f},backend:n,attrs:{shape:h}});return n.disposeData(c.dataId),n.disposeData(p.dataId),n.disposeData(f.dataId),m}var MAe={kernelName:am,backendName:"wasm",kernelFunc:FAe},CB;function OAe(e){CB=e.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])}function LAe(e){let{backend:t,inputs:n}=e,{indices:r,values:s,denseShape:a,defaultValue:i}=n,o=r.shape[0],u=r.shape[1],c=t.readSync(a.dataId)[0],l=[o+c,u],d=t.dataIdMap.get(r.dataId).id,h=t.dataIdMap.get(s.dataId).id,p=t.dataIdMap.get(i.dataId).id,f=t.makeOutput(l,r.dtype),m=t.dataIdMap.get(f.dataId).id,g=t.makeOutput(l.slice(0,1),s.dtype),b=t.dataIdMap.get(g.dataId).id,y=t.makeOutput([c],"bool"),x=t.dataIdMap.get(y.dataId).id,w=t.makeOutput([o],r.dtype),v=t.dataIdMap.get(w.dataId).id,I=t.makeOutput([4],"int32"),N=t.dataIdMap.get(I.dataId).id,T=CB(d,h,mn[s.dtype],o,c,u,p,m,b,x,v,N),E=t.readSync(I.dataId),A;switch(E[0]){case 1:{A=P.getSparseFillEmptyRowsIndicesDenseShapeMismatch(E[1]);break}case 2:{A=P.getSparseFillEmptyRowsNegativeIndexErrorMessage(E[1],E[2]);break}case 3:A=P.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(E[1],E[2],E[3]);break;default:A=""}if(t.disposeData(I.dataId),A)throw t.disposeData(f.dataId),t.disposeData(g.dataId),t.disposeData(y.dataId),t.disposeData(w.dataId),new Error(A);let k=f,C=g;return T!==l[0]&&(k=ed({inputs:{x:f},attrs:{begin:0,size:[T,u]},backend:t}),C=ed({inputs:{x:g},attrs:{begin:0,size:T},backend:t}),t.disposeData(f.dataId),t.disposeData(g.dataId)),[k,C,y,w]}var PAe={kernelName:t0,backendName:"wasm",setupFunc:OAe,kernelFunc:LAe},SB;function BAe(e){SB=e.wasm.cwrap(om,null,["number","number","number","number","number","number","number"])}function zAe(e){let{backend:t,inputs:n}=e,{inputIndices:r,inputShape:s,newShape:a}=n;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${s.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);let i=t.dataIdMap.get(r.dataId).id,o=t.dataIdMap.get(s.dataId).id,u=t.dataIdMap.get(a.dataId).id,c=r.shape[0],l=$.sizeFromShape(a.shape),d=t.makeOutput([c,l],r.dtype),h=t.dataIdMap.get(d.dataId).id,p=t.makeOutput([l],a.dtype),f=t.dataIdMap.get(p.dataId).id,m=t.makeOutput([3],"int32"),g=t.dataIdMap.get(m.dataId).id;SB(i,o,u,c,h,f,g);let b=t.readSync(m.dataId),y;switch(b[0]){case 0:{y=P.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(b[1],b[2]);break}case 1:{y=P.getSparseReshapeNegativeOutputDimErrorMessage(b[1],b[2]);break}case 2:y=P.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{let x=Array.from(t.readSync(s.dataId)),w=Array.from(t.readSync(p.dataId));y=P.getSparseReshapeInputOutputMultipleErrorMessage(x,w);break}case 4:{let x=Array.from(t.readSync(s.dataId)),w=Array.from(t.readSync(p.dataId));y=P.getSparseReshapeInputOutputMismatchErrorMessage(x,w);break}default:y=""}if(t.disposeData(m.dataId),y)throw t.disposeData(d.dataId),t.disposeData(p.dataId),new Error(y);return[d,p]}var WAe={kernelName:om,backendName:"wasm",setupFunc:BAe,kernelFunc:zAe},NB;function TB(e){NB=e.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function EB(e,t){let{backend:n,inputs:r}=e,{data:s,indices:a,segmentIds:i}=r,o=a.shape[0],u=n.readSync(i.dataId,o-1,o)[0],c=o>0?u+1:0;if(c<0)throw new Error(P.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let l=s.shape.slice();l[0]=c;let d=n.dataIdMap.get(s.dataId).id,h=n.dataIdMap.get(a.dataId).id,p=n.dataIdMap.get(i.dataId).id,f=n.makeOutput(l,s.dtype),m=n.dataIdMap.get(f.dataId).id,g=n.makeOutput([4],"int32"),b=n.dataIdMap.get(g.dataId).id;NB(d,mn[s.dtype],s.shape[0],h,p,m,b,t,0);let y=n.readSync(g.dataId),x;switch(y[0]){case 0:{x=P.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break}case 1:{x=P.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break}case 2:x=P.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(y[1],y[2]);break;case 3:x=P.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(y[1],y[2],y[3]);break;default:x=""}if(n.disposeData(g.dataId),x)throw n.disposeData(f.dataId),new Error(x);return f}function VAe(e){return EB(e,!0)}var UAe={kernelName:n0,backendName:"wasm",setupFunc:TB,kernelFunc:VAe};function GAe(e){return EB(e,!1)}var HAe={kernelName:r0,backendName:"wasm",setupFunc:TB,kernelFunc:GAe},AB;function jAe(e){AB=e.wasm.cwrap(lm,null,["number","number","number","number","number","number","number","number","array","number","number"])}function qAe(e){let{backend:t,inputs:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:i}=n,{outputShape:o}=r,u=t.makeOutput(o,i.dtype);if($.sizeFromShape(o)===0)return u;let{sliceRank:c,numUpdates:l,sliceSize:d,strides:h,outputSize:p}=P.calculateShapes(a,s,o),f=t.dataIdMap.get(s.dataId).id,m=t.dataIdMap.get(a.dataId).id,g=t.dataIdMap.get(i.dataId).id,b=new Uint8Array(new Int32Array(h).buffer),y=t.dataIdMap.get(u.dataId).id;return AB(f,m,a.shape.length,g,mn[i.dtype],c,l,d,b,p,y),u}var KAe={kernelName:lm,backendName:"wasm",setupFunc:jAe,kernelFunc:qAe};function XAe(e){let{inputs:t,attrs:n,backend:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:i}=n,o=$.parseAxisParam(i,s.shape)[0],u=P.prepareSplitSize(s,a,o),c=new Array(s.shape.length).fill(0),l=s.shape.slice();return u.map(d=>{let h=[...l];h[o]=d;let p=ed({inputs:{x:s},attrs:{begin:c,size:h},backend:r});return c[o]+=d,p})}var QAe={kernelName:im,backendName:"wasm",kernelFunc:XAe},YAe=on(Ah),JAe=on(s0),ZAe=Or(_h),$B;function e$e(e){$B=e.wasm.cwrap(vu,null,["number","number","number","number"])}function t$e(e){let{backend:t,inputs:n,attrs:r}=e,{alpha:s}=r,{x:a}=n,i=t.dataIdMap.get(a.dataId).id,o=t.makeOutput(a.shape,a.dtype),u=t.dataIdMap.get(o.dataId).id;return $B(i,s,mn[a.dtype],u),o}var n$e={kernelName:vu,backendName:"wasm",setupFunc:e$e,kernelFunc:t$e},RB;function r$e(e){RB=e.wasm.cwrap(um,null,["number","array","number","array","array","array","array","array","number","number"])}function s$e(e){let{backend:t,inputs:n,attrs:r}=e,{x:s}=n,{begin:a,end:i,strides:o,beginMask:u,endMask:c,ellipsisMask:l,newAxisMask:d,shrinkAxisMask:h}=r,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:b,begin:y,end:x,strides:w}=Gr.sliceInfo(s.shape,a,i,o,u,c,l,d,h),v;if(m)v=aa({inputs:{x:s},backend:t,attrs:{shape:f}});else if(g||b){$.assert(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);let I=Gr.computeOutShape(y,x,w),N=ed({inputs:{x:s},backend:t,attrs:{begin:y,size:I}});v=aa({inputs:{x:N},backend:t,attrs:{shape:f}}),t.disposeData(N.dataId)}else{let I=t.makeOutput(p,"float32"),N=t.dataIdMap.get(s.dataId).id,T=new Uint8Array(new Int32Array($.computeStrides(s.shape)).buffer),E=new Uint8Array(new Int32Array(y).buffer),A=new Uint8Array(new Int32Array(x).buffer),k=new Uint8Array(new Int32Array(w).buffer),C=new Uint8Array(new Int32Array(p).buffer),M=new Uint8Array(new Int32Array($.computeStrides(p)).buffer),L=t.dataIdMap.get(I.dataId).id;RB(N,T,s.shape.length,E,A,k,C,M,p.length,L),v=aa({inputs:{x:I},backend:t,attrs:{shape:f}}),t.disposeData(I.dataId)}return v}var a$e={kernelName:um,backendName:"wasm",setupFunc:r$e,kernelFunc:s$e};function i$e(e){let{backend:t,inputs:n,attrs:r}=e,{data:s,dataSplits:a}=n,{separator:i,nGramWidths:o,leftPad:u,rightPad:c,padWidth:l,preserveShortSequences:d}=r,h=t.readSync(s.dataId),p=t.readSync(a.dataId),[f,m]=s4(h,p,i,o,u,c,l,d),g=t.makeOutput([f.length],"string"),b=t.dataIdMap.get(g.dataId);b.stringBytes=f;let y=t.makeOutput(a.shape,"int32");return t.typedArrayFromHeap(y).set(m),[g,y]}var o$e={kernelName:i0,backendName:"wasm",kernelFunc:i$e};function l$e(e){let{backend:t,inputs:n,attrs:r}=e,{input:s,delimiter:a}=n,{skipEmpty:i}=r,o=t.readSync(s.dataId),u=t.readSync(a.dataId),[c,l,d]=a4(o,u[0],i),h=l.length,p=t.makeOutput([h,2],"int32");t.typedArrayFromHeap(p).set(c);let f=t.makeOutput([h],"string"),m=t.dataIdMap.get(f.dataId);m.stringBytes=l;let g=t.makeOutput([2],"int32");return t.typedArrayFromHeap(g).set(d),[p,f,g]}var u$e={kernelName:o0,backendName:"wasm",kernelFunc:l$e};function c$e(e){let{backend:t,inputs:n,attrs:r}=e,{input:s}=n,{numBuckets:a}=r,i=t.readSync(s.dataId),o=i4(i,a),u=t.makeOutput(s.shape,"int32");return t.typedArrayFromHeap(u).set(o),u}var d$e={kernelName:l0,backendName:"wasm",kernelFunc:c$e},h$e=Or(Dh),_B;function p$e(e){_B=e.wasm.cwrap($h,null,["number","number","number","number"])}function f$e(e){let{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:a}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,u=o,c=i,{transposed:l,axes:d,originalAxes:h,inputWasTransposed:p}=Au(i,s,t),f=d;if(p){let x=t.dataIdMap.get(l.dataId).id;x!==o&&(c=l,u=x,f=P.getInnerMostAxes(f.length,c.shape.length))}P.assertAxesAreInnerMostDims("sum",f,c.shape.length);let[m,g]=P.computeOutAndReduceShapes(c.shape,f),b=$.sizeFromShape(g),y=t.makeOutput(m,c.dtype);if($.sizeFromShape(c.shape)!==0){let x=t.dataIdMap.get(y.dataId).id;_B(u,b,mn[y.dtype],x)}if(p&&t.disposeData(l.dataId),a){let x=P.expandShapeToKeepDim(y.shape,h);y.shape=x}return y}var m$e={kernelName:$h,backendName:"wasm",setupFunc:p$e,kernelFunc:f$e},g$e=on(Fh),b$e=on(Mh),DB;function y$e(e){DB=e.wasm.cwrap(tm,null,["number","number","number","number","number","number","array","number","number","number"])}function x$e(e){let{backend:t,inputs:n,attrs:r}=e,{tensor:s,indices:a,updates:i}=n,o=t.makeOutput(s.shape,s.dtype);if($.sizeFromShape(s.shape)===0)return o;let{sliceRank:u,numUpdates:c,sliceSize:l,strides:d,outputSize:h}=Yw.calculateShapes(i,a,s.shape),p=t.dataIdMap.get(a.dataId).id,f=t.dataIdMap.get(i.dataId).id,m=t.dataIdMap.get(s.dataId).id,g=new Uint8Array(new Int32Array(d).buffer),b=t.dataIdMap.get(o.dataId).id;return DB(p,f,mn[i.dtype],u,c,l,g,h,b,m),o}var w$e={kernelName:tm,backendName:"wasm",setupFunc:y$e,kernelFunc:x$e},FB;function v$e(e){FB=e.wasm.cwrap(wu,null,["number","array","number","array","number","number"])}function I$e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,a=n.dataIdMap.get(s.dataId).id,{reps:i}=r,o=new Array(s.shape.length);for(let h=0;h<o.length;h++)o[h]=s.shape[h]*i[h];let u=new Uint8Array(new Int32Array(s.shape).buffer),c=new Uint8Array(new Int32Array(o).buffer),l=n.makeOutput(o,s.dtype),d=n.dataIdMap.get(l.dataId).id;return FB(a,u,s.shape.length,c,o.length,mn[l.dtype],d),l}var k$e={kernelName:wu,backendName:"wasm",setupFunc:v$e,kernelFunc:I$e},MB;function C$e(e){MB=e.wasm.cwrap(cm,null,["number","array","number","number","number","bool","number","number"])}var S$e=({inputs:e,backend:t,attrs:n})=>{let{x:r}=e,{k:s,sorted:a}=n,i=t.dataIdMap.get(r.dataId).id,o=new Uint8Array(new Int32Array(r.shape).buffer),u=r.shape.slice();u[u.length-1]=s;let c=t.makeOutput(u,r.dtype),l=t.dataIdMap.get(c.dataId).id,d=t.makeOutput(u,"int32"),h=t.dataIdMap.get(d.dataId).id;return MB(i,o,r.shape.length,mn[r.dtype],s,a,l,h),[c,d]},N$e={kernelName:cm,backendName:"wasm",setupFunc:C$e,kernelFunc:S$e},OB;function T$e(e){OB=e.wasm.cwrap(dm,null,["number","number","bool","number","number","number","number","number","number","array","number","array","number","number","number","number","number"])}function E$e(e){let{backend:t,inputs:n,attrs:r}=e,{image:s,transforms:a}=n,{interpolation:i,fillMode:o,fillValue:u,outputShape:c}=r,[l,d,h,p]=s.shape,[f,m]=c??[d,h],g=[l,f,m,p],b=new Uint8Array(new Int32Array($.computeStrides(s.shape)).buffer),y=new Uint8Array(new Int32Array($.computeStrides(g)).buffer),x=t.makeOutput(g,s.dtype),w=t.dataIdMap.get(x.dataId).id,v=t.dataIdMap.get(s.dataId).id,I=t.dataIdMap.get(a.dataId).id,N=i==="nearest"?1:2,T;switch(o){case"constant":T=1;break;case"reflect":T=2;break;case"wrap":T=3;break;case"nearest":T=4;break;default:T=1;break}return OB(v,I,a.shape[0]>1,l,f,m,p,h,d,b,s.shape.length-1,y,g.length-1,N,T,u,w),x}var A$e={kernelName:dm,backendName:"wasm",setupFunc:T$e,kernelFunc:E$e};function $$e(e){let{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t,{outputValues:i,outputShape:o,indices:u}=l4(r.readSync(a.dataId),s,a.shape,a.dtype);return[r.makeOutput(o,a.dtype,void 0,i),r.makeOutput([u.length],"int32",void 0,u)]}var R$e={kernelName:u0,backendName:"wasm",kernelFunc:$$e};function _$e(e){let{inputs:t,backend:n,attrs:r}=e,{value:s}=t,{axis:a}=r;a<0&&(a+=s.shape.length);let i=s.shape[a],o=s.shape.length,u=new Array(o-1),c=0;for(let p=0;p<o;p++)p!==a&&(u[c++]=s.shape[p]);let l=new Array(i),d=new Array(o).fill(0),h=s.shape.slice();h[a]=1;for(let p=0;p<l.length;p++)d[a]=p,l[p]=ed({inputs:{x:s},attrs:{begin:d,size:h},backend:n});return l.map(({dataId:p,dtype:f})=>({dataId:p,dtype:f,shape:u}))}var D$e={kernelName:hm,backendName:"wasm",kernelFunc:_$e};function F$e(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(0),r}var M$e={kernelName:pm,backendName:"wasm",kernelFunc:F$e},O$e=[T3e,E3e,A3e,$3e,R3e,F3e,V3e,H3e,j3e,q3e,K3e,X3e,Q3e,Y3e,J3e,tNe,cNe,sNe,oNe,fNe,wNe,kNe,CNe,NNe,TNe,ENe,RNe,_Ne,MNe,PNe,WNe,GNe,qNe,KNe,XNe,JNe,tTe,sTe,oTe,cTe,pTe,gTe,xTe,ITe,STe,NTe,ATe,RTe,_Te,DTe,FTe,MTe,OTe,BTe,zTe,WTe,GTe,qTe,QTe,ZTe,n4e,s4e,i4e,M3e,o4e,l4e,u4e,h4e,f4e,g4e,x4e,v4e,w4e,k4e,C4e,N4e,E4e,R4e,F4e,L4e,P4e,W4e,G4e,q4e,Q4e,Z4e,nEe,aEe,iEe,uEe,fEe,mEe,gEe,bEe,wEe,kEe,NEe,EEe,REe,DEe,MEe,dB,PEe,WEe,GEe,jEe,qEe,KEe,XEe,QEe,dNe,ZEe,nAe,aAe,lAe,dAe,fAe,mAe,gAe,xAe,IAe,SAe,NAe,AAe,$Ae,RAe,_Ae,yNe,dEe,DAe,MAe,PAe,WAe,UAe,HAe,KAe,QAe,YAe,JAe,ZAe,n$e,a$e,o$e,u$e,d$e,h$e,m$e,g$e,b$e,w$e,k$e,N$e,A$e,B3e,R$e,D$e,M$e];for(let e of O$e)d0(e);var HC=ge();HC.registerFlag("WASM_HAS_SIMD_SUPPORT",async()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))}catch{return!1}});HC.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",async()=>{if(HC.get("IS_NODE"))return!1;try{return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}});var N_=bu(bX()),L$e=bu(yX()),T_=bu(xX()),E_=N_.default||N_,P$e=T_.default||T_,LB=class extends Vy{constructor(e){super(),this.wasm=e,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(PB),jC=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new uw(this,ai())}write(e,t,n){let r={id:this.dataIdNextNumber++};return this.move(r,e,t,n,1),r}numDataIds(){return this.dataIdMap.numDataIds()}async time(e){let t=$.now();return e(),{kernelMs:$.now()-t}}move(e,t,n,r,s){let a=this.dataIdNextNumber++;if(r==="string"){let c=t;this.dataIdMap.set(e,{id:a,stringBytes:c,shape:n,dtype:r,memoryOffset:null,refCount:s});return}let i=$.sizeFromShape(n),o=i*$.bytesPerElement(r),u=this.wasm._malloc(o)>>>0;this.dataIdMap.set(e,{id:a,memoryOffset:u,shape:n,dtype:r,refCount:s}),this.wasm.tfjs.registerTensor(a,i,u),t!=null&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,o),u)}async read(e){return this.readSync(e)}readSync(e,t,n){let{memoryOffset:r,dtype:s,shape:a,stringBytes:i}=this.dataIdMap.get(e);if(s==="string")return(t==null||t===0)&&(n==null||n>=i.length)?i:i.slice(t,n);t=t||0,n=n||$.sizeFromShape(a);let o=$.bytesPerElement(s),u=this.wasm.HEAPU8.slice(r+t*o,r+n*o);return W$e(u.buffer,s)}disposeData(e,t=!1){if(this.dataIdMap.has(e)){let n=this.dataIdMap.get(e);if(n.refCount--,!t&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(e)}return!0}refCount(e){return this.dataIdMap.has(e)?this.dataIdMap.get(e).refCount:0}incRef(e){let t=this.dataIdMap.get(e);t!=null&&t.refCount++}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,t,n,r){let s;if(n==null)s=this.write(r??null,e,t);else{let a=this.dataIdNextNumber++;s={id:a},this.dataIdMap.set(s,{id:a,memoryOffset:n,shape:e,dtype:t,refCount:1});let i=$.sizeFromShape(e);this.wasm.tfjs.registerTensor(a,i,n)}return{dataId:s,shape:e,dtype:t}}typedArrayFromHeap({shape:e,dtype:t,dataId:n}){let r=this.wasm.HEAPU8.buffer,{memoryOffset:s}=this.dataIdMap.get(n),a=$.sizeFromShape(e);switch(t){case"float32":return new Float32Array(r,s,a);case"int32":return new Int32Array(r,s,a);case"bool":return new Uint8Array(r,s,a);default:throw new Error(`Unknown dtype ${t}`)}}};function B$e(e){return(t,n)=>($.fetch(e,{credentials:"same-origin"}).then(r=>{r.ok||t.env.a(`failed to load wasm binary file at '${e}'`),r.arrayBuffer().then(s=>{WebAssembly.instantiate(s,t).then(a=>{n(a.instance,a.module)})})}),{})}function A_(e,t,n){if(Rx!=null)return Rx;let r="tfjs-backend-wasm.wasm";return e&&t?r="tfjs-backend-wasm-threaded-simd.wasm":e&&(r="tfjs-backend-wasm-simd.wasm"),ey!=null&&ey[r]!=null?ey[r]:n+r}async function z$e(){let[e,t]=await Promise.all([ge().getAsync("WASM_HAS_SIMD_SUPPORT"),ge().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise((n,r)=>{let s={};s.locateFile=(o,u)=>{if(o.endsWith(".worker.js")){let c=L$e.wasmWorkerContents.replace(/\n/g,"\\n"),l=new Blob([c],{type:"application/javascript"});return URL.createObjectURL(l)}return o.endsWith(".wasm")?A_(e,t,Gb??u):u+o},A4&&(s.instantiateWasm=B$e(A_(e,t,Gb??"")));let a=!1;s.onAbort=()=>{a||ty||(ty=!0,r({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"}))};let i;t&&e&&Rx==null?(s.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+E_.toString()],{type:"text/javascript"}),i=E_(s)):i=P$e(s),i.then(o=>{a=!0,ty=!1;let u=null;o.tfjs={init:o.cwrap("init",null,[]),initWithThreadsCount:o.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:o.cwrap("get_threads_count","number",[]),registerTensor:o.cwrap("register_tensor",null,["number","number","number"]),disposeData:o.cwrap("dispose_data",u,["number"]),dispose:o.cwrap("dispose",u,[])},n({wasm:o})}).catch(r)})}function W$e(e,t){switch(t){case"float32":return new Float32Array(e);case"int32":return new Int32Array(e);case"bool":return new Uint8Array(e);default:throw new Error(`Unknown dtype ${t}`)}}var V$e=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"],Rx=null,Gb=null,ey={},ty=!1,A4=!1;function U$e(e,t=!1){if(a6("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),ty)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");Rx=e,A4=t}function G$e(e,t=!1){if(ty)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if(typeof e=="string")Gb=e;else{ey=e;let n=V$e.filter(r=>ey[r]==null);if(n.length>0)throw new Error(`There were no entries found for the following binaries: ${n.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}A4=t}var PB=-1,jC=-1;function H$e(e){PB=e}function j$e(){if(jC===-1)throw new Error("WASM backend not initialized.");return jC}var q$e="4.22.0",K$e=2;Tw("wasm",async()=>{let{wasm:e}=await z$e();return new LB(e)},K$e);var $_="4.22.0",X$e="4.22.0",Q$e="4.22.0",Y$e="4.22.0",J$e="4.22.0",Z$e={tfjs:$_,"tfjs-core":$_,"tfjs-converter":X$e,"tfjs-backend-cpu":Q$e,"tfjs-backend-webgl":Y$e,"tfjs-backend-wasm":J$e},qC={};LS(qC,{AnchorPosition:()=>ez,DrawBox:()=>rz,DrawBoxOptions:()=>nz,DrawFaceLandmarks:()=>xz,DrawFaceLandmarksOptions:()=>yz,DrawTextField:()=>M4,DrawTextFieldOptions:()=>F4,drawContour:()=>El,drawDetections:()=>hRe,drawFaceExpressions:()=>NRe,drawFaceLandmarks:()=>ERe});function El(e,t,n=!1){if(e.beginPath(),t.slice(1).forEach(({x:r,y:s},a)=>{let i=t[a];e.moveTo(i.x,i.y),e.lineTo(r,s)}),n){let r=t[t.length-1],s=t[0];if(!r||!s)return;e.moveTo(r.x,r.y),e.lineTo(s.x,s.y)}e.stroke()}var eRe={};LS(eRe,{computeReshapedDimensions:()=>VB,getCenterPoint:()=>$4,isDimensions:()=>XC,isEven:()=>KC,isFloat:()=>WB,isTensor:()=>Mm,isTensor1D:()=>tRe,isTensor2D:()=>zB,isTensor3D:()=>G0,isTensor4D:()=>sl,isValidNumber:()=>_c,isValidProbablitiy:()=>nRe,range:()=>Qp,round:()=>Ov});var Rc=class BB{constructor(t,n){if(!_c(t)||!_c(n))throw new Error(`Dimensions.constructor - expected width and height to be valid numbers, instead have ${JSON.stringify({width:t,height:n})}`);this._width=t,this._height=n}get width(){return this._width}get height(){return this._height}reverse(){return new BB(1/this.width,1/this.height)}};function Mm(e,t){return e instanceof Wt&&e.shape.length===t}function tRe(e){return Mm(e,1)}function zB(e){return Mm(e,2)}function G0(e){return Mm(e,3)}function sl(e){return Mm(e,4)}function WB(e){return e%1!==0}function KC(e){return e%2===0}function Ov(e,t=2){let n=10**t;return Math.floor(e*n)/n}function XC(e){return e&&e.width&&e.height}function VB({width:e,height:t},n){let r=n/Math.max(t,e);return new Rc(Math.round(e*r),Math.round(t*r))}function $4(e){return e.reduce((t,n)=>t.add(n),new Ln(0,0)).div(new Ln(e.length,e.length))}function Qp(e,t,n){return Array(e).fill(0).map((r,s)=>t+s*n)}function _c(e){return!!e&&e!==1/0&&e!==-1/0&&!Number.isNaN(e)||e===0}function nRe(e){return _c(e)&&e>=0&&e<=1}var Ln=class fc{constructor(t,n){this._x=t,this._y=n}get x(){return this._x}get y(){return this._y}add(t){return new fc(this.x+t.x,this.y+t.y)}sub(t){return new fc(this.x-t.x,this.y-t.y)}mul(t){return new fc(this.x*t.x,this.y*t.y)}div(t){return new fc(this.x/t.x,this.y/t.y)}abs(){return new fc(Math.abs(this.x),Math.abs(this.y))}magnitude(){return Math.sqrt(this.x**2+this.y**2)}floor(){return new fc(Math.floor(this.x),Math.floor(this.y))}},td=class _i{static isRect(t){return!!t&&[t.x,t.y,t.width,t.height].every(_c)}static assertIsValidBox(t,n,r=!1){if(!_i.isRect(t))throw new Error(`${n} - invalid box: ${JSON.stringify(t)}, expected object with properties x, y, width, height`);if(!r&&(t.width<0||t.height<0))throw new Error(`${n} - width (${t.width}) and height (${t.height}) must be positive numbers`)}constructor(t,n=!0){let r=t||{},s=[r.left,r.top,r.right,r.bottom].every(_c),a=[r.x,r.y,r.width,r.height].every(_c);if(!a&&!s)throw new Error(`Box.constructor - expected box to be IBoundingBox | IRect, instead have ${JSON.stringify(r)}`);let[i,o,u,c]=a?[r.x,r.y,r.width,r.height]:[r.left,r.top,r.right-r.left,r.bottom-r.top];_i.assertIsValidBox({x:i,y:o,width:u,height:c},"Box.constructor",n),this._x=i,this._y=o,this._width=u,this._height=c}get x(){return this._x}get y(){return this._y}get width(){return this._width}get height(){return this._height}get left(){return this.x}get top(){return this.y}get right(){return this.x+this.width}get bottom(){return this.y+this.height}get area(){return this.width*this.height}get topLeft(){return new Ln(this.left,this.top)}get topRight(){return new Ln(this.right,this.top)}get bottomLeft(){return new Ln(this.left,this.bottom)}get bottomRight(){return new Ln(this.right,this.bottom)}round(){let[t,n,r,s]=[this.x,this.y,this.width,this.height].map(a=>Math.round(a));return new _i({x:t,y:n,width:r,height:s})}floor(){let[t,n,r,s]=[this.x,this.y,this.width,this.height].map(a=>Math.floor(a));return new _i({x:t,y:n,width:r,height:s})}toSquare(){let{x:t,y:n,width:r,height:s}=this,a=Math.abs(r-s);return r<s&&(t-=a/2,r+=a),s<r&&(n-=a/2,s+=a),new _i({x:t,y:n,width:r,height:s})}rescale(t){let n=XC(t)?t.width:t,r=XC(t)?t.height:t;return new _i({x:this.x*n,y:this.y*r,width:this.width*n,height:this.height*r})}pad(t,n){let[r,s,a,i]=[this.x-t/2,this.y-n/2,this.width+t,this.height+n];return new _i({x:r,y:s,width:a,height:i})}clipAtImageBorders(t,n){let{x:r,y:s,right:a,bottom:i}=this,o=Math.max(r,0),u=Math.max(s,0),c=a-o,l=i-u,d=Math.min(c,t-o),h=Math.min(l,n-u);return new _i({x:o,y:u,width:d,height:h}).floor()}shift(t,n){let{width:r,height:s}=this,a=this.x+t,i=this.y+n;return new _i({x:a,y:i,width:r,height:s})}padAtBorders(t,n){let r=this.width+1,s=this.height+1,a=1,i=1,o=r,u=s,c=this.left,l=this.top,d=this.right,h=this.bottom;return d>n&&(o=-d+n+r,d=n),h>t&&(u=-h+t+s,h=t),c<1&&(u=2-c,c=1),l<1&&(u=2-l,l=1),{dy:i,edy:u,dx:a,edx:o,y:l,ey:h,x:c,ex:d,w:r,h:s}}calibrate(t){return new _i({left:this.left+t.left*this.width,top:this.top+t.top*this.height,right:this.right+t.right*this.width,bottom:this.bottom+t.bottom*this.height}).toSquare().round()}},UB=class extends td{constructor(e,t,n,r,s=!1){super({left:e,top:t,right:n,bottom:r},s)}},GB=class HB{constructor(t,n,r,s,a){this._imageDims=new Rc(a.width,a.height),this._score=t,this._classScore=n,this._className=r,this._box=new td(s).rescale(this._imageDims)}get score(){return this._score}get classScore(){return this._classScore}get className(){return this._className}get box(){return this._box}get imageDims(){return this._imageDims}get imageWidth(){return this.imageDims.width}get imageHeight(){return this.imageDims.height}get relativeBox(){return new td(this._box).rescale(this.imageDims.reverse())}forSize(t,n){return new HB(this.score,this.classScore,this.className,this.relativeBox,{width:t,height:n})}},hi=class jB extends GB{constructor(t,n,r){super(t,t,"",n,r)}forSize(t,n){let{score:r,relativeBox:s,imageDims:a}=super.forSize(t,n);return new jB(r,s,a)}};function rRe(e,t,n=!0){let r=Math.max(0,Math.min(e.right,t.right)-Math.max(e.left,t.left)),s=Math.max(0,Math.min(e.bottom,t.bottom)-Math.max(e.top,t.top)),a=r*s;return n?a/(e.area+t.area-a):a/Math.min(e.area,t.area)}function sRe(e){let t=e.map(o=>o.x),n=e.map(o=>o.y),r=t.reduce((o,u)=>u<o?u:o,1/0),s=n.reduce((o,u)=>u<o?u:o,1/0),a=t.reduce((o,u)=>o<u?u:o,0),i=n.reduce((o,u)=>o<u?u:o,0);return new UB(r,s,a,i)}function aRe(e,t,n,r=!0){let s=t.map((i,o)=>({score:i,boxIndex:o})).sort((i,o)=>i.score-o.score).map(i=>i.boxIndex),a=[];for(;s.length>0;){let i=s.pop();a.push(i);let o=s,u=[];for(let c=0;c<o.length;c++){let l=o[c],d=e[i],h=e[l];u.push(rRe(d,h,r))}s=s.filter((c,l)=>u[l]<=n)}return a}function H0(e,t){return ie(()=>{let[n,r,s]=t,a=Ca([...e.shape.slice(0,3),1],n,"float32"),i=Ca([...e.shape.slice(0,3),1],r,"float32"),o=Ca([...e.shape.slice(0,3),1],s,"float32"),u=Bn([a,i,o],3);return et(e,u)})}function iRe(e,t=!1){return ie(()=>{let[n,r]=e.shape.slice(1);if(n===r)return e;let s=Math.abs(n-r),a=Math.round(s*(t?.5:1)),i=n>r?2:1,o=d=>{let h=e.shape.slice();return h[i]=d,Ca(h,0,"float32")},u=o(a),c=s-u.shape[i],l=[t&&c?o(c):null,e,u].filter(d=>!!d).map(d=>Ve(d,"float32"));return Bn(l,i)})}function fk(e){return 1/(1+Math.exp(-e))}var qB=class extends td{constructor(e,t,n,r,s=!1){super({x:e,y:t,width:n,height:r},s)}},oRe=.5,lRe=.43,uRe=.45,ky=class{constructor(e,t,n=new Ln(0,0)){let{width:r,height:s}=t;this._imgDims=new Rc(r,s),this._shift=n,this._positions=e.map(a=>a.mul(new Ln(r,s)).add(n))}get shift(){return new Ln(this._shift.x,this._shift.y)}get imageWidth(){return this._imgDims.width}get imageHeight(){return this._imgDims.height}get positions(){return this._positions}get relativePositions(){return this._positions.map(e=>e.sub(this._shift).div(new Ln(this.imageWidth,this.imageHeight)))}forSize(e,t){return new this.constructor(this.relativePositions,{width:e,height:t})}shiftBy(e,t){return new this.constructor(this.relativePositions,this._imgDims,new Ln(e,t))}shiftByPoint(e){return this.shiftBy(e.x,e.y)}align(e,t={}){if(e){let s=e instanceof hi?e.box.floor():new td(e);return this.shiftBy(s.x,s.y).align(null,t)}let{useDlibAlignment:n,minBoxPadding:r}={useDlibAlignment:!1,minBoxPadding:.2,...t};return n?this.alignDlib():this.alignMinBbox(r)}alignDlib(){let e=this.getRefPointsForAlignment(),[t,n,r]=e,s=l=>r.sub(l).magnitude(),a=(s(t)+s(n))/2,i=Math.floor(a/uRe),o=$4(e),u=Math.floor(Math.max(0,o.x-oRe*i)),c=Math.floor(Math.max(0,o.y-lRe*i));return new qB(u,c,Math.min(i,this.imageWidth+u),Math.min(i,this.imageHeight+c))}alignMinBbox(e){let t=sRe(this.positions);return t.pad(t.width*e,t.height*e)}getRefPointsForAlignment(){throw new Error("getRefPointsForAlignment not implemented by base class")}},KB=class extends ky{getJawOutline(){return this.positions.slice(0,17)}getLeftEyeBrow(){return this.positions.slice(17,22)}getRightEyeBrow(){return this.positions.slice(22,27)}getNose(){return this.positions.slice(27,36)}getLeftEye(){return this.positions.slice(36,42)}getRightEye(){return this.positions.slice(42,48)}getMouth(){return this.positions.slice(48,68)}getRefPointsForAlignment(){return[this.getLeftEye(),this.getRightEye(),this.getMouth()].map($4)}},R_=class{constructor(e,t){this._label=e,this._distance=t}get label(){return this._label}get distance(){return this._distance}toString(e=!0){return`${this.label}${e?` (${Ov(this.distance)})`:""}`}},Hb=class XB{constructor(t,n){if(typeof t!="string")throw new Error("LabeledFaceDescriptors - constructor expected label to be a string");if(!Array.isArray(n)||n.some(r=>!(r instanceof Float32Array)))throw new Error("LabeledFaceDescriptors - constructor expected descriptors to be an array of Float32Array");this._label=t,this._descriptors=n}get label(){return this._label}get descriptors(){return this._descriptors}toJSON(){return{label:this.label,descriptors:this.descriptors.map(t=>Array.from(t))}}static fromJSON(t){let n=t.descriptors.map(r=>new Float32Array(r));return new XB(t.label,n)}};function Cy(e){return e.detection instanceof hi}function _x(e,t){return{...e,detection:t}}function QB(){let e=window.fetch;if(!e)throw new Error("fetch - missing fetch implementation for browser environment");return{Canvas:HTMLCanvasElement,CanvasRenderingContext2D,Image:HTMLImageElement,ImageData,Video:HTMLVideoElement,createCanvasElement:()=>document.createElement("canvas"),createImageElement:()=>document.createElement("img"),createVideoElement:()=>document.createElement("video"),fetch:e,readFile:()=>{throw new Error("readFile - filesystem not available for browser environment")}}}function R4(){return typeof globalThis=="object"&&typeof process<"u"&&process.versions!=null&&process.versions.node!=null}function YB(e){let t="";if(!e&&R4())try{e=XK("fs")}catch(n){t=n.toString()}return{readFile:e?n=>new Promise((r,s)=>{e.readFile(n,(a,i)=>a?s(a):r(i))}):()=>{throw new Error(`readFile - failed to require fs in nodejs environment with error: ${t}`)}}}function JB(){let e=globalThis.Canvas||globalThis.HTMLCanvasElement,t=globalThis.Image||globalThis.HTMLImageElement,n=globalThis.Video||globalThis.HTMLVideoElement,r=()=>{if(e)return new e;throw new Error("createCanvasElement - missing Canvas implementation for nodejs environment")},s=()=>{if(t)return new t;throw new Error("createImageElement - missing Image implementation for nodejs environment")},a=()=>{if(n)return new n;throw new Error("createVideoElement - missing Video implementation for nodejs environment")},i=globalThis.fetch,o=YB();return{Canvas:e||class{},CanvasRenderingContext2D:globalThis.CanvasRenderingContext2D||class{},Image:t||class{},ImageData:globalThis.ImageData||class{},Video:globalThis.HTMLVideoElement||class{},createCanvasElement:r,createImageElement:s,createVideoElement:a,fetch:i,...o}}function ZB(){return typeof window=="object"&&typeof document<"u"&&typeof HTMLImageElement<"u"&&typeof HTMLCanvasElement<"u"&&typeof HTMLVideoElement<"u"&&typeof ImageData<"u"&&typeof CanvasRenderingContext2D<"u"}var Jr;function cRe(){if(!Jr)throw new Error("getEnv - environment is not defined, check isNodejs() and isBrowser()");return Jr}function QC(e){Jr=e}function _4(){return ZB()?QC(QB()):R4()?QC(JB()):null}function dRe(e){if(Jr||_4(),!Jr)throw new Error("monkeyPatch - environment is not defined, check isNodejs() and isBrowser()");let{Canvas:t=Jr.Canvas,Image:n=Jr.Image}=e;Jr.Canvas=t,Jr.Image=n,Jr.createCanvasElement=e.createCanvasElement||(()=>new t),Jr.createImageElement=e.createImageElement||(()=>new n),Jr.ImageData=e.ImageData||Jr.ImageData,Jr.Video=e.Video||Jr.Video,Jr.fetch=e.fetch||Jr.fetch,Jr.readFile=e.readFile||Jr.readFile}var Gs={getEnv:cRe,setEnv:QC,initialize:_4,createBrowserEnv:QB,createFileSystem:YB,createNodejsEnv:JB,monkeyPatch:dRe,isBrowser:ZB,isNodejs:R4};_4();function D4(e){return!Gs.isNodejs()&&typeof e=="string"?document.getElementById(e):e}function uu(e){let{Canvas:t,CanvasRenderingContext2D:n}=Gs.getEnv();if(e instanceof n)return e;let r=D4(e);if(!(r instanceof t))throw new Error("resolveContext2d - expected canvas to be of instance of Canvas");let s=r.getContext("2d",{willReadFrequently:!0});if(!s)throw new Error("resolveContext2d - canvas 2d context is null");return s}var ez=(e=>(e.TOP_LEFT="TOP_LEFT",e.TOP_RIGHT="TOP_RIGHT",e.BOTTOM_LEFT="BOTTOM_LEFT",e.BOTTOM_RIGHT="BOTTOM_RIGHT",e))(ez||{}),F4=class{constructor(e={}){let{anchorPosition:t,backgroundColor:n,fontColor:r,fontSize:s,fontStyle:a,padding:i}=e;this.anchorPosition=t||"TOP_LEFT",this.backgroundColor=n||"rgba(0, 0, 0, 0.5)",this.fontColor=r||"rgba(255, 255, 255, 1)",this.fontSize=s||14,this.fontStyle=a||"Georgia",this.padding=i||4}},M4=class tz{constructor(t,n,r={}){this.text=typeof t=="string"?[t]:t instanceof tz?t.text:t,this.anchor=n,this.options=new F4(r)}measureWidth(t){let{padding:n}=this.options;return this.text.map(r=>t.measureText(r).width).reduce((r,s)=>r<s?s:r,0)+2*n}measureHeight(){let{fontSize:t,padding:n}=this.options;return this.text.length*t+2*n}getUpperLeft(t,n){let{anchorPosition:r}=this.options,s=r==="BOTTOM_RIGHT"||r==="TOP_RIGHT",a=r==="BOTTOM_LEFT"||r==="BOTTOM_RIGHT",i=this.measureWidth(t),o=this.measureHeight(),u=s?this.anchor.x-i:this.anchor.x,c=a?this.anchor.y-o:this.anchor.y;if(n){let{width:l,height:d}=n,h=Math.max(Math.min(u,l-i),0),p=Math.max(Math.min(c,d-o),0);return{x:h,y:p}}return{x:u,y:c}}draw(t){let n=D4(t),r=uu(n),{backgroundColor:s,fontColor:a,fontSize:i,fontStyle:o,padding:u}=this.options;r.font=`${i}px ${o}`;let c=this.measureWidth(r),l=this.measureHeight();r.fillStyle=s;let d=this.getUpperLeft(r,n);r.fillRect(d.x,d.y,c,l),r.fillStyle=a,this.text.forEach((h,p)=>{let f=u+d.x,m=u+d.y+(p+1)*i;r.fillText(h,f,m)})}},nz=class{constructor(e={}){let{boxColor:t,lineWidth:n,label:r,drawLabelOptions:s}=e;this.boxColor=t||"rgba(0, 0, 255, 1)",this.lineWidth=n||2,this.label=r;let a={anchorPosition:"BOTTOM_LEFT",backgroundColor:this.boxColor};this.drawLabelOptions=new F4({...a,...s})}},rz=class{constructor(e,t={}){this.box=new td(e),this.options=new nz(t)}draw(e){let t=uu(e),{boxColor:n,lineWidth:r}=this.options,{x:s,y:a,width:i,height:o}=this.box;t.strokeStyle=n,t.lineWidth=r,t.strokeRect(s,a,i,o);let{label:u}=this.options;u&&new M4([u],{x:s-r/2,y:a},this.options.drawLabelOptions).draw(e)}};function hRe(e,t){(Array.isArray(t)?t:[t]).forEach(n=>{let r=n instanceof hi?n.score:Cy(n)?n.detection.score:void 0,s=n instanceof hi?n.box:Cy(n)?n.detection.box:new td(n),a=r?`${Ov(r)}`:void 0;new rz(s,{label:a}).draw(e)})}function sz(e){let{Image:t,Video:n}=Gs.getEnv();return e instanceof t&&e.complete||e instanceof n&&e.readyState>=3}function pRe(e){return new Promise((t,n)=>{if(e instanceof Gs.getEnv().Canvas||sz(e)){t(null);return}function r(a){a.currentTarget&&(a.currentTarget.removeEventListener("load",s),a.currentTarget.removeEventListener("error",r),n(a))}function s(a){a.currentTarget&&(a.currentTarget.removeEventListener("load",s),a.currentTarget.removeEventListener("error",r),t(a))}e.addEventListener("load",s),e.addEventListener("error",r)})}function fRe(e){return new Promise((t,n)=>{e instanceof Blob||n(new Error("bufferToImage - expected buf to be of type: Blob"));let r=new FileReader;r.onload=()=>{typeof r.result!="string"&&n(new Error("bufferToImage - expected reader.result to be a string, in onload"));let s=Gs.getEnv().createImageElement();s.onload=()=>t(s),s.onerror=n,s.src=r.result},r.onerror=n,r.readAsDataURL(e)})}function az(e){let{Image:t,Video:n}=Gs.getEnv();return e instanceof t?new Rc(e.naturalWidth,e.naturalHeight):e instanceof n?new Rc(e.videoWidth,e.videoHeight):new Rc(e.width,e.height)}function Dx({width:e,height:t}){let{createCanvasElement:n}=Gs.getEnv(),r=n();return r.width=e,r.height=t,r}function iz(e,t){let{ImageData:n}=Gs.getEnv();if(!(e instanceof n)&&!sz(e))throw new Error("createCanvasFromMedia - media has not finished loading yet");let{width:r,height:s}=az(e),a=Dx({width:r,height:s});return e instanceof n?uu(a).putImageData(e,0,0):uu(a).drawImage(e,0,0,r,s),a}async function mRe(e,t){let n=t||Gs.getEnv().createCanvasElement(),[r,s,a]=e.shape.slice(sl(e)?1:0),i=ie(()=>e.as3D(r,s,a).toInt());return await $0.toPixels(i,n),i.dispose(),n}function __(e){let{Image:t,Canvas:n,Video:r}=Gs.getEnv();return e instanceof t||e instanceof n||e instanceof r}function gRe(e,t,n=!1){let{Image:r,Canvas:s}=Gs.getEnv();if(!(e instanceof r||e instanceof s))throw new Error("imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement");if(t<=0)return Dx({width:1,height:1});let a=az(e),i=t/Math.max(a.height,a.width),o=i*a.width,u=i*a.height,c=Dx({width:t,height:t}),l=e instanceof s?e:iz(e),d=Math.abs(o-u)/2,h=n&&o<u?d:0,p=n&&u<o?d:0;return l.width>0&&l.height>0&&uu(c).drawImage(l,h,p,o,u),c}var Fx=class{constructor(e,t=!1){if(this._imageTensors=[],this._canvases=[],this._treatAsBatchInput=!1,this._inputDimensions=[],this._inputSize=0,!Array.isArray(e))throw new Error(`NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have ${e}`);this._treatAsBatchInput=t,this._batchSize=e.length,e.forEach((n,r)=>{if(G0(n)){this._imageTensors[r]=n,this._inputDimensions[r]=n.shape;return}if(sl(n)){let a=n.shape[0];if(a!==1)throw new Error(`NetInput - tf.Tensor4D with batchSize ${a} passed, but not supported in input array`);this._imageTensors[r]=n,this._inputDimensions[r]=n.shape.slice(1);return}let s=n instanceof Gs.getEnv().Canvas?n:iz(n);this._canvases[r]=s,this._inputDimensions[r]=[s.height,s.width,3]})}get imageTensors(){return this._imageTensors}get canvases(){return this._canvases}get isBatchInput(){return this.batchSize>1||this._treatAsBatchInput}get batchSize(){return this._batchSize}get inputDimensions(){return this._inputDimensions}get inputSize(){return this._inputSize}get reshapedInputDimensions(){return Qp(this.batchSize,0,1).map((e,t)=>this.getReshapedInputDimensions(t))}getInput(e){return this.canvases[e]||this.imageTensors[e]}getInputDimensions(e){return this._inputDimensions[e]}getInputHeight(e){return this._inputDimensions[e][0]}getInputWidth(e){return this._inputDimensions[e][1]}getReshapedInputDimensions(e){if(typeof this.inputSize!="number")throw new Error("getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet");let t=this.getInputWidth(e),n=this.getInputHeight(e);return VB({width:t,height:n},this.inputSize)}toBatchTensor(e,t=!0){return this._inputSize=e,ie(()=>{let n=Qp(this.batchSize,0,1).map(r=>{let s=this.getInput(r);if(s instanceof Wt){let a=sl(s)?s:ns(s);return a=iRe(a,t),(a.shape[1]!==e||a.shape[2]!==e)&&(a=La.resizeBilinear(a,[e,e],!1,!1)),a.as3D(e,e,3)}if(s instanceof Gs.getEnv().Canvas)return $0.fromPixels(gRe(s,e,t));throw new Error(`toBatchTensor - at batchIdx ${r}, expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have ${s}`)});return Dr(n.map(r=>Ve(r,"float32"))).as4D(this.batchSize,e,e,3)})}};async function Hs(e){if(e instanceof Fx)return e;let t=Array.isArray(e)?e:[e];if(!t.length)throw new Error("toNetInput - empty array passed as input");let n=s=>Array.isArray(e)?` at input index ${s}:`:"",r=t.map(D4);return r.forEach((s,a)=>{if(!__(s)&&!G0(s)&&!sl(s))throw typeof t[a]=="string"?new Error(`toNetInput -${n(a)} string passed, but could not resolve HTMLElement for element id ${t[a]}`):new Error(`toNetInput -${n(a)} expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id`);if(sl(s)){let i=s.shape[0];if(i!==1)throw new Error(`toNetInput -${n(a)} tf.Tensor4D with batchSize ${i} passed, but not supported in input array`)}}),await Promise.all(r.map(s=>__(s)&&pRe(s))),new Fx(r,Array.isArray(e))}async function O4(e,t){let{Canvas:n}=Gs.getEnv(),r=e;if(!(e instanceof n)){let a=await Hs(e);if(a.batchSize>1)throw new Error("extractFaces - batchSize > 1 not supported");let i=a.getInput(0);r=i instanceof n?i:await mRe(i)}let s=uu(r);return t.map(a=>a instanceof hi?a.forSize(r.width,r.height).box.floor():a).map(a=>a.clipAtImageBorders(r.width,r.height)).map(({x:a,y:i,width:o,height:u})=>{let c=Dx({width:o,height:u});return o>0&&u>0&&uu(c).putImageData(s.getImageData(a,i,o,u),0,0),c})}async function L4(e,t){if(!G0(e)&&!sl(e))throw new Error("extractFaceTensors - expected image tensor to be 3D or 4D");if(sl(e)&&e.shape[0]>1)throw new Error("extractFaceTensors - batchSize > 1 not supported");return ie(()=>{let[n,r,s]=e.shape.slice(sl(e)?1:0);return t.map(a=>a instanceof hi?a.forSize(r,n).box:a).map(a=>a.clipAtImageBorders(r,n)).filter(a=>a.width>0&&a.height>0).map(({x:a,y:i,width:o,height:u})=>vm(e.as3D(n,r,s),[i,a,0],[u,o,s]))})}async function oz(e,t){let{fetch:n}=Gs.getEnv(),r=await n(e,t);if(!(r.status<400))throw new Error(`failed to fetch: (${r.status}) ${r.statusText}, from url: ${r.url}`);return r}async function bRe(e){let t=await oz(e),n=await t.blob();if(!n.type.startsWith("image/"))throw new Error(`fetchImage - expected blob type to be of type image/*, instead have: ${n.type}, for url: ${t.url}`);return fRe(n)}async function yRe(e){return(await oz(e)).json()}function lz(e,t){let n=`${t}-weights_manifest.json`;if(!e)return{modelBaseUri:"",manifestUri:n};if(e==="/")return{modelBaseUri:"/",manifestUri:`/${n}`};let r=e.startsWith("http://")?"http://":e.startsWith("https://")?"https://":"";e=e.replace(r,"");let s=e.split("/").filter(o=>o),a=e.endsWith(".json")?s[s.length-1]:n,i=r+(e.endsWith(".json")?s.slice(0,s.length-1):s).join("/");return i=e.startsWith("/")?`/${i}`:i,{modelBaseUri:i,manifestUri:i==="/"?`/${a}`:`${i}/${a}`}}async function xRe(e,t){let{manifestUri:n,modelBaseUri:r}=lz(e,t),s=await yRe(n);return fs.loadWeights(s,r)}var Ru=class{constructor(e){this._params=void 0,this._paramMappings=[],this._name=e}get params(){return this._params}get paramMappings(){return this._paramMappings}get isLoaded(){return!!this.params}getParamFromPath(e){let{obj:t,objProp:n}=this.traversePropertyPath(e);return t[n]}reassignParamFromPath(e,t){let{obj:n,objProp:r}=this.traversePropertyPath(e);n[r].dispose(),n[r]=t}getParamList(){return this._paramMappings.map(({paramPath:e})=>({path:e,tensor:this.getParamFromPath(e)}))}getTrainableParams(){return this.getParamList().filter(e=>e.tensor instanceof Bc)}getFrozenParams(){return this.getParamList().filter(e=>!(e.tensor instanceof Bc))}variable(){this.getFrozenParams().forEach(({path:e,tensor:t})=>{this.reassignParamFromPath(e,t.variable())})}freeze(){this.getTrainableParams().forEach(({path:e,tensor:t})=>{let n=zs(t.dataSync());t.dispose(),this.reassignParamFromPath(e,n)})}dispose(e=!0){this.getParamList().forEach(t=>{if(e&&t.tensor.isDisposed)throw new Error(`param tensor has already been disposed for path ${t.path}`);t.tensor.dispose()}),this._params=void 0}serializeParams(){return new Float32Array(this.getParamList().map(({tensor:e})=>Array.from(e.dataSync())).reduce((e,t)=>e.concat(t)))}async load(e){if(e instanceof Float32Array){this.extractWeights(e);return}await this.loadFromUri(e)}async loadFromUri(e){if(e&&typeof e!="string")throw new Error(`${this._name}.loadFromUri - expected model uri`);let t=await xRe(e,this.getDefaultModelName());this.loadFromWeightMap(t)}async loadFromDisk(e){if(e&&typeof e!="string")throw new Error(`${this._name}.loadFromDisk - expected model file path`);let{readFile:t}=Gs.getEnv(),{manifestUri:n,modelBaseUri:r}=lz(e,this.getDefaultModelName()),s=u=>Promise.all(u.map(c=>t(c).then(l=>typeof l=="string"?Buffer.from(l):l.buffer))),a=fs.weightsLoaderFactory(s),i=JSON.parse((await t(n)).toString()),o=await a(i,r);this.loadFromWeightMap(o)}loadFromWeightMap(e){let{paramMappings:t,params:n}=this.extractParamsFromWeightMap(e);this._paramMappings=t,this._params=n}extractWeights(e){let{paramMappings:t,params:n}=this.extractParams(e);this._paramMappings=t,this._params=n}traversePropertyPath(e){if(!this.params)throw new Error("traversePropertyPath - model has no loaded params");let t=e.split("/").reduce((s,a)=>{if(!s.nextObj.hasOwnProperty(a))throw new Error(`traversePropertyPath - object does not have property ${a}, for path ${e}`);return{obj:s.nextObj,objProp:a,nextObj:s.nextObj[a]}},{nextObj:this.params}),{obj:n,objProp:r}=t;if(!n||!r||!(n[r]instanceof Wt))throw new Error(`traversePropertyPath - parameter is not a tensor, for path ${e}`);return{obj:n,objProp:r}}};function za(e,t,n){return ie(()=>{let r=wm(e,t.depthwise_filter,t.pointwise_filter,n,"same");return r=Se(r,t.bias),r})}function mk(e,t,n=!1){return ie(()=>{let r=Rn(n?Se(Vs(e,t.conv0.filters,[2,2],"same"),t.conv0.bias):za(e,t.conv0,[2,2])),s=za(r,t.conv1,[1,1]),a=Rn(Se(r,s)),i=za(a,t.conv2,[1,1]);return Rn(Se(r,Se(s,i)))})}function C2(e,t,n=!1,r=!0){return ie(()=>{let s=Rn(n?Se(Vs(e,t.conv0.filters,r?[2,2]:[1,1],"same"),t.conv0.bias):za(e,t.conv0,r?[2,2]:[1,1])),a=za(s,t.conv1,[1,1]),i=Rn(Se(s,a)),o=za(i,t.conv2,[1,1]),u=Rn(Se(s,Se(a,o))),c=za(u,t.conv3,[1,1]);return Rn(Se(s,Se(a,Se(o,c))))})}function ny(e,t,n="same",r=!1){return ie(()=>{let s=Se(Vs(e,t.filters,[1,1],n),t.bias);return r?Rn(s):s})}function _u(e,t){Object.keys(e).forEach(n=>{t.some(r=>r.originalPath===n)||e[n].dispose()})}function P4(e,t){return(n,r,s,a)=>{let i=nu(e(n*r*s*s),[s,s,n,r]),o=Tn(e(r));return t.push({paramPath:`${a}/filters`},{paramPath:`${a}/bias`}),{filters:i,bias:o}}}function uz(e,t){return(n,r,s)=>{let a=wo(e(n*r),[n,r]),i=Tn(e(r));return t.push({paramPath:`${s}/weights`},{paramPath:`${s}/bias`}),{weights:a,bias:i}}}var cz=class{constructor(e,t,n){this.depthwise_filter=e,this.pointwise_filter=t,this.bias=n}};function B4(e,t){return(n,r,s)=>{let a=nu(e(9*n),[3,3,n,1]),i=nu(e(n*r),[1,1,n,r]),o=Tn(e(r));return t.push({paramPath:`${s}/depthwise_filter`},{paramPath:`${s}/pointwise_filter`},{paramPath:`${s}/bias`}),new cz(a,i,o)}}function z4(e){return t=>{let n=e(`${t}/depthwise_filter`,4),r=e(`${t}/pointwise_filter`,4),s=e(`${t}/bias`,1);return new cz(n,r,s)}}function qh(e,t){return(n,r,s)=>{let a=e[n];if(!Mm(a,r))throw new Error(`expected weightMap[${n}] to be a Tensor${r}D, instead have ${a}`);return t.push({originalPath:n,paramPath:s||n}),a}}function Du(e){let t=e;function n(s){let a=t.slice(0,s);return t=t.slice(s),a}function r(){return t}return{extractWeights:n,getRemainingWeights:r}}function dz(e,t){let n=P4(e,t),r=B4(e,t);function s(i,o,u,c=!1){let l=c?n(i,o,3,`${u}/conv0`):r(i,o,`${u}/conv0`),d=r(o,o,`${u}/conv1`),h=r(o,o,`${u}/conv2`);return{conv0:l,conv1:d,conv2:h}}function a(i,o,u,c=!1){let{conv0:l,conv1:d,conv2:h}=s(i,o,u,c),p=r(o,o,`${u}/conv3`);return{conv0:l,conv1:d,conv2:h,conv3:p}}return{extractDenseBlock3Params:s,extractDenseBlock4Params:a}}function wRe(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Du(e),{extractDenseBlock4Params:s}=dz(n,t),a=s(3,32,"dense0",!0),i=s(32,64,"dense1"),o=s(64,128,"dense2"),u=s(128,256,"dense3");if(r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{dense0:a,dense1:i,dense2:o,dense3:u}}}function hz(e){return t=>{let n=e(`${t}/filters`,4),r=e(`${t}/bias`,1);return{filters:n,bias:r}}}function pz(e,t){let n=qh(e,t),r=hz(n),s=z4(n);function a(o,u=!1){let c=u?r(`${o}/conv0`):s(`${o}/conv0`),l=s(`${o}/conv1`),d=s(`${o}/conv2`);return{conv0:c,conv1:l,conv2:d}}function i(o,u=!1){let c=u?r(`${o}/conv0`):s(`${o}/conv0`),l=s(`${o}/conv1`),d=s(`${o}/conv2`),h=s(`${o}/conv3`);return{conv0:c,conv1:l,conv2:d,conv3:h}}return{extractDenseBlock3Params:a,extractDenseBlock4Params:i}}function vRe(e){let t=[],{extractDenseBlock4Params:n}=pz(e,t),r={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2"),dense3:n("dense3")};return _u(e,t),{params:r,paramMappings:t}}var fz=class extends Ru{constructor(){super("FaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceFeatureExtractor - load model before inference");return ie(()=>{let n=Ve(e.toBatchTensor(112,!0),"float32"),r=H0(n,[122.782,117.001,104.298]).div(255),s=C2(r,t.dense0,!0);return s=C2(s,t.dense1),s=C2(s,t.dense2),s=C2(s,t.dense3),s=fl(s,[7,7],[2,2],"valid"),s})}async forward(e){return this.forwardInput(await Hs(e))}getDefaultModelName(){return"face_feature_extractor_model"}extractParamsFromWeightMap(e){return vRe(e)}extractParams(e){return wRe(e)}};function YC(e,t){return ie(()=>Se(Ut(e,t.weights),t.bias))}function IRe(e,t,n){let r=[],{extractWeights:s,getRemainingWeights:a}=Du(e),i=uz(s,r)(t,n,"fc");if(a().length!==0)throw new Error(`weights remaing after extract: ${a().length}`);return{paramMappings:r,params:{fc:i}}}function kRe(e){let t=[],n=qh(e,t);function r(a){let i=n(`${a}/weights`,2),o=n(`${a}/bias`,1);return{weights:i,bias:o}}let s={fc:r("fc")};return _u(e,t),{params:s,paramMappings:t}}function mz(e){let t={},n={};return Object.keys(e).forEach(r=>{let s=r.startsWith("fc")?n:t;s[r]=e[r]}),{featureExtractorMap:t,classifierMap:n}}var gz=class extends Ru{constructor(e,t){super(e),this._faceFeatureExtractor=t}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return ie(()=>{let n=e instanceof Fx?this.faceFeatureExtractor.forwardInput(e):e;return YC(n.as2D(n.shape[0],-1),t.fc)})}dispose(e=!0){this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return IRe(e,this.getClassifierChannelsIn(),this.getClassifierChannelsOut())}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=mz(e);return this.faceFeatureExtractor.loadFromWeightMap(t),kRe(n)}extractParams(e){let t=this.getClassifierChannelsIn(),n=this.getClassifierChannelsOut(),r=n*t+n,s=e.slice(0,e.length-r),a=e.slice(e.length-r);return this.faceFeatureExtractor.extractWeights(s),this.extractClassifierParams(a)}},D_=["neutral","happy","sad","angry","fearful","disgusted","surprised"],W4=class{constructor(e){if(this.neutral=0,this.happy=0,this.sad=0,this.angry=0,this.fearful=0,this.disgusted=0,this.surprised=0,e.length!==7)throw new Error(`FaceExpressions.constructor - expected probabilities.length to be 7, have: ${e.length}`);D_.forEach((t,n)=>{this[t]=e[n]})}asSortedArray(){return D_.map(e=>({expression:e,probability:this[e]})).sort((e,t)=>t.probability-e.probability)}},CRe=class extends gz{constructor(e=new fz){super("FaceExpressionNet",e)}forwardInput(e){return ie(()=>Su(this.runNet(e)))}async forward(e){return this.forwardInput(await Hs(e))}async predictExpressions(e){let t=await Hs(e),n=await this.forwardInput(t),r=await Promise.all(br(n).map(async a=>{let i=a.dataSync();return a.dispose(),i}));n.dispose();let s=r.map(a=>new W4(a));return t.isBatchInput?s:s[0]}getDefaultModelName(){return"face_expression_model"}getClassifierChannelsIn(){return 256}getClassifierChannelsOut(){return 7}};function SRe(e){return e.expressions instanceof W4}function bz(e,t){return{...e,expressions:t}}function NRe(e,t,n=.1,r){(Array.isArray(t)?t:[t]).forEach(s=>{let a=s instanceof W4?s:SRe(s)?s.expressions:void 0;if(!a)throw new Error("drawFaceExpressions - expected faceExpressions to be FaceExpressions | WithFaceExpressions<{}> or array thereof");let i=a.asSortedArray().filter(u=>u.probability>n),o=Cy(s)?s.detection.box.bottomLeft:r||new Ln(0,0);new M4(i.map(u=>`${u.expression} (${Ov(u.probability)})`),o).draw(e)})}function V4(e){return Cy(e)&&e.landmarks instanceof ky&&e.unshiftedLandmarks instanceof ky&&e.alignedRect instanceof hi}function TRe(e){let t=u=>u*180/Math.PI,n=(u,c)=>Math.sqrt((u.x-c.x)**2+(u.y-c.y)**2),r={roll:void 0,pitch:void 0,yaw:void 0},s=(u,c,l)=>{let d=Math.floor(u.x-c.x),h=Math.floor(c.x-l.x);return d-h},a=(u,c)=>{let l=Math.hypot(c.x-u.x,c.y-u.y),d=c.y-u.y,h=Math.asin(d/l),p=t(h),f=Math.floor(90-p),m=c.x-u.x<0?-1:1;return f*m},i=(u,c,l)=>{let d=n(u,l),h=new Ln((u.x+l.x)/2,(u.y+l.y)/2),p=n(c,h),f=Math.atan(p/d),m=Math.floor(t(f)),g=h.y-c.y<0?-1:1;return m*g};if(!e||!e.positions||e.positions.length!==68)return r;let o=e.positions;return r.roll=a(o[27],o[66]),r.pitch=i(o[14],o[30],o[2]),r.yaw=s(o[14],o[33],o[2]),r}function U4(e,t){let{box:n}=e.detection,r=t.shiftBy(n.x,n.y),s=r.align(),{imageDims:a}=e.detection,i=new hi(e.detection.score,s.rescale(a.reverse()),a),o=TRe(t);return{...e,landmarks:r,unshiftedLandmarks:t,alignedRect:i,angle:o}}var yz=class{constructor(e={}){let{drawLines:t=!0,drawPoints:n=!0,lineWidth:r,lineColor:s,pointSize:a,pointColor:i}=e;this.drawLines=t,this.drawPoints=n,this.lineWidth=r||1,this.pointSize=a||2,this.lineColor=s||"rgba(0, 255, 255, 1)",this.pointColor=i||"rgba(255, 0, 255, 1)"}},xz=class{constructor(e,t={}){this.faceLandmarks=e,this.options=new yz(t)}draw(e){let t=uu(e),{drawLines:n,drawPoints:r,lineWidth:s,lineColor:a,pointSize:i,pointColor:o}=this.options;if(n&&this.faceLandmarks instanceof KB&&(t.strokeStyle=a,t.lineWidth=s,El(t,this.faceLandmarks.getJawOutline()),El(t,this.faceLandmarks.getLeftEyeBrow()),El(t,this.faceLandmarks.getRightEyeBrow()),El(t,this.faceLandmarks.getNose()),El(t,this.faceLandmarks.getLeftEye(),!0),El(t,this.faceLandmarks.getRightEye(),!0),El(t,this.faceLandmarks.getMouth(),!0)),r){t.strokeStyle=o,t.fillStyle=o;let u=c=>{t.beginPath(),t.arc(c.x,c.y,i,0,2*Math.PI),t.fill()};this.faceLandmarks.positions.forEach(u)}}};function ERe(e,t){(Array.isArray(t)?t:[t]).forEach(n=>{let r=n instanceof ky?n:V4(n)?n.landmarks:void 0;if(!r)throw new Error("drawFaceLandmarks - expected faceExpressions to be FaceLandmarks | WithFaceLandmarks<WithFaceDetection<{}>> or array thereof");new xz(r).draw(e)})}function ARe(e,t){let n=P4(e,t),r=B4(e,t);function s(i,o,u){let c=r(i,o,`${u}/separable_conv0`),l=r(o,o,`${u}/separable_conv1`),d=n(i,o,1,`${u}/expansion_conv`);return{separable_conv0:c,separable_conv1:l,expansion_conv:d}}function a(i,o){let u=r(i,i,`${o}/separable_conv0`),c=r(i,i,`${o}/separable_conv1`),l=r(i,i,`${o}/separable_conv2`);return{separable_conv0:u,separable_conv1:c,separable_conv2:l}}return{extractConvParams:n,extractSeparableConvParams:r,extractReductionBlockParams:s,extractMainBlockParams:a}}function $Re(e,t){let n=[],{extractWeights:r,getRemainingWeights:s}=Du(e),{extractConvParams:a,extractSeparableConvParams:i,extractReductionBlockParams:o,extractMainBlockParams:u}=ARe(r,n),c=a(3,32,3,"entry_flow/conv_in"),l=o(32,64,"entry_flow/reduction_block_0"),d=o(64,128,"entry_flow/reduction_block_1"),h={conv_in:c,reduction_block_0:l,reduction_block_1:d},p={};Qp(t,0,1).forEach(b=>{p[`main_block_${b}`]=u(128,`middle_flow/main_block_${b}`)});let f=o(128,256,"exit_flow/reduction_block"),m=i(256,512,"exit_flow/separable_conv"),g={reduction_block:f,separable_conv:m};if(s().length!==0)throw new Error(`weights remaing after extract: ${s().length}`);return{paramMappings:n,params:{entry_flow:h,middle_flow:p,exit_flow:g}}}function RRe(e,t){let n=qh(e,t),r=hz(n),s=z4(n);function a(o){let u=s(`${o}/separable_conv0`),c=s(`${o}/separable_conv1`),l=r(`${o}/expansion_conv`);return{separable_conv0:u,separable_conv1:c,expansion_conv:l}}function i(o){let u=s(`${o}/separable_conv0`),c=s(`${o}/separable_conv1`),l=s(`${o}/separable_conv2`);return{separable_conv0:u,separable_conv1:c,separable_conv2:l}}return{extractConvParams:r,extractSeparableConvParams:s,extractReductionBlockParams:a,extractMainBlockParams:i}}function _Re(e,t){let n=[],{extractConvParams:r,extractSeparableConvParams:s,extractReductionBlockParams:a,extractMainBlockParams:i}=RRe(e,n),o=r("entry_flow/conv_in"),u=a("entry_flow/reduction_block_0"),c=a("entry_flow/reduction_block_1"),l={conv_in:o,reduction_block_0:u,reduction_block_1:c},d={};Qp(t,0,1).forEach(m=>{d[`main_block_${m}`]=i(`middle_flow/main_block_${m}`)});let h=a("exit_flow/reduction_block"),p=s("exit_flow/separable_conv"),f={reduction_block:h,separable_conv:p};return _u(e,n),{params:{entry_flow:l,middle_flow:d,exit_flow:f},paramMappings:n}}function wz(e,t,n){return Se(Vs(e,t.filters,n,"same"),t.bias)}function gk(e,t,n=!0){let r=n?Rn(e):e;return r=za(r,t.separable_conv0,[1,1]),r=za(Rn(r),t.separable_conv1,[1,1]),r=Zr(r,[3,3],[2,2],"same"),r=Se(r,wz(e,t.expansion_conv,[2,2])),r}function DRe(e,t){let n=za(Rn(e),t.separable_conv0,[1,1]);return n=za(Rn(n),t.separable_conv1,[1,1]),n=za(Rn(n),t.separable_conv2,[1,1]),n=Se(n,e),n}var FRe=class extends Ru{constructor(e){super("TinyXception"),this._numMainBlocks=e}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyXception - load model before inference");return ie(()=>{let n=Ve(e.toBatchTensor(112,!0),"float32"),r=H0(n,[122.782,117.001,104.298]).div(255),s=Rn(wz(r,t.entry_flow.conv_in,[2,2]));return s=gk(s,t.entry_flow.reduction_block_0,!1),s=gk(s,t.entry_flow.reduction_block_1),Qp(this._numMainBlocks,0,1).forEach(a=>{s=DRe(s,t.middle_flow[`main_block_${a}`])}),s=gk(s,t.exit_flow.reduction_block),s=Rn(za(s,t.exit_flow.separable_conv,[1,1])),s})}async forward(e){return this.forwardInput(await Hs(e))}getDefaultModelName(){return"tiny_xception_model"}extractParamsFromWeightMap(e){return _Re(e,this._numMainBlocks)}extractParams(e){return $Re(e,this._numMainBlocks)}};function MRe(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Du(e),s=uz(n,t),a=s(512,1,"fc/age"),i=s(512,2,"fc/gender");if(r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{fc:{age:a,gender:i}}}}function ORe(e){let t=[],n=qh(e,t);function r(a){let i=n(`${a}/weights`,2),o=n(`${a}/bias`,1);return{weights:i,bias:o}}let s={fc:{age:r("fc/age"),gender:r("fc/gender")}};return _u(e,t),{params:s,paramMappings:t}}var LRe=(e=>(e.FEMALE="female",e.MALE="male",e))(LRe||{}),PRe=class extends Ru{constructor(e=new FRe(2)){super("AgeGenderNet"),this._faceFeatureExtractor=e}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return ie(()=>{let n=e instanceof Fx?this.faceFeatureExtractor.forwardInput(e):e,r=fl(n,[7,7],[2,2],"valid").as2D(n.shape[0],-1),s=YC(r,t.fc.age).as1D(),a=YC(r,t.fc.gender);return{age:s,gender:a}})}forwardInput(e){return ie(()=>{let{age:t,gender:n}=this.runNet(e);return{age:t,gender:Su(n)}})}async forward(e){return this.forwardInput(await Hs(e))}async predictAgeAndGender(e){let t=await Hs(e),n=await this.forwardInput(t),r=br(n.age),s=br(n.gender),a=r.map((o,u)=>({ageTensor:o,genderTensor:s[u]})),i=await Promise.all(a.map(async({ageTensor:o,genderTensor:u})=>{let c=o.dataSync()[0],l=u.dataSync()[0],d=l>.5,h=d?"male":"female",p=d?l:1-l;return o.dispose(),u.dispose(),{age:c,gender:h,genderProbability:p}}));return n.age.dispose(),n.gender.dispose(),t.isBatchInput?i:i[0]}getDefaultModelName(){return"age_gender_model"}dispose(e=!0){this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return MRe(e)}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=mz(e);return this.faceFeatureExtractor.loadFromWeightMap(t),ORe(n)}extractParams(e){let t=e.slice(0,e.length-1539),n=e.slice(e.length-1539);return this.faceFeatureExtractor.extractWeights(t),this.extractClassifierParams(n)}},vz=class extends gz{postProcess(e,t,n){let r=n.map(({width:a,height:i})=>{let o=t/Math.max(i,a);return{width:a*o,height:i*o}}),s=r.length;return ie(()=>{let a=(c,l)=>Dr([Ca([68],c,"float32"),Ca([68],l,"float32")],1).as2D(1,136).as1D(),i=(c,l)=>{let{width:d,height:h}=r[c];return l(d,h)?Math.abs(d-h)/2:0},o=c=>i(c,(l,d)=>l<d),u=c=>i(c,(l,d)=>d<l);return e.mul(Ca([s,136],t,"float32")).sub(Dr(Array.from(Array(s),(c,l)=>a(o(l),u(l))))).div(Dr(Array.from(Array(s),(c,l)=>a(r[l].width,r[l].height))))})}forwardInput(e){return ie(()=>{let t=this.runNet(e);return this.postProcess(t,e.inputSize,e.inputDimensions.map(([n,r])=>({height:n,width:r})))})}async forward(e){return this.forwardInput(await Hs(e))}async detectLandmarks(e){let t=await Hs(e),n=ie(()=>br(this.forwardInput(t))),r=await Promise.all(n.map(async(s,a)=>{let i=Array.from(s.dataSync()),o=i.filter((c,l)=>KC(l)),u=i.filter((c,l)=>!KC(l));return new KB(Array(68).fill(0).map((c,l)=>new Ln(o[l],u[l])),{height:t.getInputHeight(a),width:t.getInputWidth(a)})}));return n.forEach(s=>s.dispose()),t.isBatchInput?r:r[0]}getClassifierChannelsOut(){return 136}},BRe=class extends vz{constructor(e=new fz){super("FaceLandmark68Net",e)}getDefaultModelName(){return"face_landmark_68_model"}getClassifierChannelsIn(){return 256}};function zRe(e){let t=[],{extractDenseBlock3Params:n}=pz(e,t),r={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2")};return _u(e,t),{params:r,paramMappings:t}}function WRe(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Du(e),{extractDenseBlock3Params:s}=dz(n,t),a=s(3,32,"dense0",!0),i=s(32,64,"dense1"),o=s(64,128,"dense2");if(r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{dense0:a,dense1:i,dense2:o}}}var VRe=class extends Ru{constructor(){super("TinyFaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyFaceFeatureExtractor - load model before inference");return ie(()=>{let n=Ve(e.toBatchTensor(112,!0),"float32"),r=H0(n,[122.782,117.001,104.298]).div(255),s=mk(r,t.dense0,!0);return s=mk(s,t.dense1),s=mk(s,t.dense2),s=fl(s,[14,14],[2,2],"valid"),s})}async forward(e){return this.forwardInput(await Hs(e))}getDefaultModelName(){return"face_feature_extractor_tiny_model"}extractParamsFromWeightMap(e){return zRe(e)}extractParams(e){return WRe(e)}},URe=class extends vz{constructor(e=new VRe){super("FaceLandmark68TinyNet",e)}getDefaultModelName(){return"face_landmark_68_tiny_model"}getClassifierChannelsIn(){return 128}};function GRe(e,t){return Se(se(e,t.weights),t.biases)}function G4(e,t,n,r,s="same"){let{filters:a,bias:i}=t.conv,o=Vs(e,a,n,s);return o=Se(o,i),o=GRe(o,t.scale),r?Rn(o):o}function HRe(e,t){return G4(e,t,[1,1],!0)}function Iz(e,t){return G4(e,t,[1,1],!1)}function kz(e,t){return G4(e,t,[2,2],!0,"valid")}function jRe(e,t){function n(o,u,c){let l=e(o),d=l.length/(u*c*c);if(WB(d))throw new Error(`depth has to be an integer: ${d}, weights.length: ${l.length}, numFilters: ${u}, filterSize: ${c}`);return ie(()=>Gt(nu(l,[u,d,c,c]),[2,3,1,0]))}function r(o,u,c,l){let d=n(o,u,c),h=Tn(e(u));return t.push({paramPath:`${l}/filters`},{paramPath:`${l}/bias`}),{filters:d,bias:h}}function s(o,u){let c=Tn(e(o)),l=Tn(e(o));return t.push({paramPath:`${u}/weights`},{paramPath:`${u}/biases`}),{weights:c,biases:l}}function a(o,u,c,l){let d=r(o,u,c,`${l}/conv`),h=s(u,`${l}/scale`);return{conv:d,scale:h}}function i(o,u,c,l,d=!1){let h=a((d?.5:1)*o,u,c,`${l}/conv1`),p=a(o,u,c,`${l}/conv2`);return{conv1:h,conv2:p}}return{extractConvLayerParams:a,extractResidualLayerParams:i}}function qRe(e){let{extractWeights:t,getRemainingWeights:n}=Du(e),r=[],{extractConvLayerParams:s,extractResidualLayerParams:a}=jRe(t,r),i=s(4704,32,7,"conv32_down"),o=a(9216,32,3,"conv32_1"),u=a(9216,32,3,"conv32_2"),c=a(9216,32,3,"conv32_3"),l=a(36864,64,3,"conv64_down",!0),d=a(36864,64,3,"conv64_1"),h=a(36864,64,3,"conv64_2"),p=a(36864,64,3,"conv64_3"),f=a(147456,128,3,"conv128_down",!0),m=a(147456,128,3,"conv128_1"),g=a(147456,128,3,"conv128_2"),b=a(589824,256,3,"conv256_down",!0),y=a(589824,256,3,"conv256_1"),x=a(589824,256,3,"conv256_2"),w=a(589824,256,3,"conv256_down_out"),v=ie(()=>Gt(wo(t(256*128),[128,256]),[1,0]));if(r.push({paramPath:"fc"}),n().length!==0)throw new Error(`weights remaing after extract: ${n().length}`);return{params:{conv32_down:i,conv32_1:o,conv32_2:u,conv32_3:c,conv64_down:l,conv64_1:d,conv64_2:h,conv64_3:p,conv128_down:f,conv128_1:m,conv128_2:g,conv256_down:b,conv256_1:y,conv256_2:x,conv256_down_out:w,fc:v},paramMappings:r}}function KRe(e,t){let n=qh(e,t);function r(i){let o=n(`${i}/scale/weights`,1),u=n(`${i}/scale/biases`,1);return{weights:o,biases:u}}function s(i){let o=n(`${i}/conv/filters`,4),u=n(`${i}/conv/bias`,1),c=r(i);return{conv:{filters:o,bias:u},scale:c}}function a(i){return{conv1:s(`${i}/conv1`),conv2:s(`${i}/conv2`)}}return{extractConvLayerParams:s,extractResidualLayerParams:a}}function XRe(e){let t=[],{extractConvLayerParams:n,extractResidualLayerParams:r}=KRe(e,t),s=n("conv32_down"),a=r("conv32_1"),i=r("conv32_2"),o=r("conv32_3"),u=r("conv64_down"),c=r("conv64_1"),l=r("conv64_2"),d=r("conv64_3"),h=r("conv128_down"),p=r("conv128_1"),f=r("conv128_2"),m=r("conv256_down"),g=r("conv256_1"),b=r("conv256_2"),y=r("conv256_down_out"),{fc:x}=e;if(t.push({originalPath:"fc",paramPath:"fc"}),!zB(x))throw new Error(`expected weightMap[fc] to be a Tensor2D, instead have ${x}`);let w={conv32_down:s,conv32_1:a,conv32_2:i,conv32_3:o,conv64_down:u,conv64_1:c,conv64_2:l,conv64_3:d,conv128_down:h,conv128_1:p,conv128_2:f,conv256_down:m,conv256_1:g,conv256_2:b,conv256_down_out:y,fc:x};return _u(e,t),{params:w,paramMappings:t}}function so(e,t){let n=HRe(e,t.conv1);return n=Iz(n,t.conv2),n=Se(n,e),n=Rn(n),n}function S2(e,t){let n=kz(e,t.conv1);n=Iz(n,t.conv2);let r=fl(e,2,2,"valid"),s=dr(r.shape),a=r.shape[3]!==n.shape[3];if(r.shape[1]!==n.shape[1]||r.shape[2]!==n.shape[2]){let i=[...n.shape];i[1]=1;let o=dr(i);n=Bn([n,o],1);let u=[...n.shape];u[2]=1;let c=dr(u);n=Bn([n,c],2)}return r=a?Bn([r,s],3):r,n=Se(r,n),n=Rn(n),n}var QRe=class extends Ru{constructor(){super("FaceRecognitionNet")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceRecognitionNet - load model before inference");return ie(()=>{let n=Ve(e.toBatchTensor(150,!0),"float32"),r=H0(n,[122.782,117.001,104.298]).div(255),s=kz(r,t.conv32_down);s=Zr(s,3,2,"valid"),s=so(s,t.conv32_1),s=so(s,t.conv32_2),s=so(s,t.conv32_3),s=S2(s,t.conv64_down),s=so(s,t.conv64_1),s=so(s,t.conv64_2),s=so(s,t.conv64_3),s=S2(s,t.conv128_down),s=so(s,t.conv128_1),s=so(s,t.conv128_2),s=S2(s,t.conv256_down),s=so(s,t.conv256_1),s=so(s,t.conv256_2),s=S2(s,t.conv256_down_out);let a=s.mean([1,2]);return Ut(a,t.fc)})}async forward(e){return this.forwardInput(await Hs(e))}async computeFaceDescriptor(e){var t;if((t=e?.shape)!=null&&t.some(a=>a<=0))return new Float32Array(128);let n=await Hs(e),r=ie(()=>br(this.forwardInput(n))),s=await Promise.all(r.map(a=>a.data()));return r.forEach(a=>a.dispose()),n.isBatchInput?s:s[0]}getDefaultModelName(){return"face_recognition_model"}extractParamsFromWeightMap(e){return XRe(e)}extractParams(e){return qRe(e)}};function Cz(e,t){return{...e,descriptor:t}}function Sz(e,t){return{...e,age:t}}function Nz(e,t,n){return{...e,gender:t,genderProbability:n}}function YRe(e,t){function n(u,c){let l=nu(e(9*u),[3,3,u,1]),d=Tn(e(u)),h=Tn(e(u)),p=Tn(e(u)),f=Tn(e(u));return t.push({paramPath:`${c}/filters`},{paramPath:`${c}/batch_norm_scale`},{paramPath:`${c}/batch_norm_offset`},{paramPath:`${c}/batch_norm_mean`},{paramPath:`${c}/batch_norm_variance`}),{filters:l,batch_norm_scale:d,batch_norm_offset:h,batch_norm_mean:p,batch_norm_variance:f}}function r(u,c,l,d,h){let p=nu(e(u*c*l*l),[l,l,u,c]),f=Tn(e(c));return t.push({paramPath:`${d}/filters`},{paramPath:`${d}/${h?"batch_norm_offset":"bias"}`}),{filters:p,bias:f}}function s(u,c,l,d){let{filters:h,bias:p}=r(u,c,l,d,!0);return{filters:h,batch_norm_offset:p}}function a(u,c,l){let d=n(u,`${l}/depthwise_conv`),h=s(u,c,1,`${l}/pointwise_conv`);return{depthwise_conv:d,pointwise_conv:h}}function i(){let u=s(3,32,3,"mobilenetv1/conv_0"),c=a(32,64,"mobilenetv1/conv_1"),l=a(64,128,"mobilenetv1/conv_2"),d=a(128,128,"mobilenetv1/conv_3"),h=a(128,256,"mobilenetv1/conv_4"),p=a(256,256,"mobilenetv1/conv_5"),f=a(256,512,"mobilenetv1/conv_6"),m=a(512,512,"mobilenetv1/conv_7"),g=a(512,512,"mobilenetv1/conv_8"),b=a(512,512,"mobilenetv1/conv_9"),y=a(512,512,"mobilenetv1/conv_10"),x=a(512,512,"mobilenetv1/conv_11"),w=a(512,1024,"mobilenetv1/conv_12"),v=a(1024,1024,"mobilenetv1/conv_13");return{conv_0:u,conv_1:c,conv_2:l,conv_3:d,conv_4:h,conv_5:p,conv_6:f,conv_7:m,conv_8:g,conv_9:b,conv_10:y,conv_11:x,conv_12:w,conv_13:v}}function o(){let u=s(1024,256,1,"prediction_layer/conv_0"),c=s(256,512,3,"prediction_layer/conv_1"),l=s(512,128,1,"prediction_layer/conv_2"),d=s(128,256,3,"prediction_layer/conv_3"),h=s(256,128,1,"prediction_layer/conv_4"),p=s(128,256,3,"prediction_layer/conv_5"),f=s(256,64,1,"prediction_layer/conv_6"),m=s(64,128,3,"prediction_layer/conv_7"),g=r(512,12,1,"prediction_layer/box_predictor_0/box_encoding_predictor"),b=r(512,9,1,"prediction_layer/box_predictor_0/class_predictor"),y=r(1024,24,1,"prediction_layer/box_predictor_1/box_encoding_predictor"),x=r(1024,18,1,"prediction_layer/box_predictor_1/class_predictor"),w=r(512,24,1,"prediction_layer/box_predictor_2/box_encoding_predictor"),v=r(512,18,1,"prediction_layer/box_predictor_2/class_predictor"),I=r(256,24,1,"prediction_layer/box_predictor_3/box_encoding_predictor"),N=r(256,18,1,"prediction_layer/box_predictor_3/class_predictor"),T=r(256,24,1,"prediction_layer/box_predictor_4/box_encoding_predictor"),E=r(256,18,1,"prediction_layer/box_predictor_4/class_predictor"),A=r(128,24,1,"prediction_layer/box_predictor_5/box_encoding_predictor"),k=r(128,18,1,"prediction_layer/box_predictor_5/class_predictor");return{conv_0:u,conv_1:c,conv_2:l,conv_3:d,conv_4:h,conv_5:p,conv_6:f,conv_7:m,box_predictor_0:{box_encoding_predictor:g,class_predictor:b},box_predictor_1:{box_encoding_predictor:y,class_predictor:x},box_predictor_2:{box_encoding_predictor:w,class_predictor:v},box_predictor_3:{box_encoding_predictor:I,class_predictor:N},box_predictor_4:{box_encoding_predictor:T,class_predictor:E},box_predictor_5:{box_encoding_predictor:A,class_predictor:k}}}return{extractMobilenetV1Params:i,extractPredictionLayerParams:o}}function JRe(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Du(e),{extractMobilenetV1Params:s,extractPredictionLayerParams:a}=YRe(n,t),i=s(),o=a(),u={extra_dim:Qw(n(5118*4),[1,5118,4])};if(t.push({paramPath:"output_layer/extra_dim"}),r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{params:{mobilenetv1:i,prediction_layer:o,output_layer:u},paramMappings:t}}function ZRe(e,t){let n=qh(e,t);function r(c,l,d){let h=n(`${c}/Conv2d_${l}_pointwise/weights`,4,`${d}/filters`),p=n(`${c}/Conv2d_${l}_pointwise/convolution_bn_offset`,1,`${d}/batch_norm_offset`);return{filters:h,batch_norm_offset:p}}function s(c){let l=`mobilenetv1/conv_${c}`,d=`MobilenetV1/Conv2d_${c}_depthwise`,h=`${l}/depthwise_conv`,p=`${l}/pointwise_conv`,f=n(`${d}/depthwise_weights`,4,`${h}/filters`),m=n(`${d}/BatchNorm/gamma`,1,`${h}/batch_norm_scale`),g=n(`${d}/BatchNorm/beta`,1,`${h}/batch_norm_offset`),b=n(`${d}/BatchNorm/moving_mean`,1,`${h}/batch_norm_mean`),y=n(`${d}/BatchNorm/moving_variance`,1,`${h}/batch_norm_variance`);return{depthwise_conv:{filters:f,batch_norm_scale:m,batch_norm_offset:g,batch_norm_mean:b,batch_norm_variance:y},pointwise_conv:r("MobilenetV1",c,p)}}function a(){return{conv_0:r("MobilenetV1",0,"mobilenetv1/conv_0"),conv_1:s(1),conv_2:s(2),conv_3:s(3),conv_4:s(4),conv_5:s(5),conv_6:s(6),conv_7:s(7),conv_8:s(8),conv_9:s(9),conv_10:s(10),conv_11:s(11),conv_12:s(12),conv_13:s(13)}}function i(c,l){let d=n(`${c}/weights`,4,`${l}/filters`),h=n(`${c}/biases`,1,`${l}/bias`);return{filters:d,bias:h}}function o(c){let l=i(`Prediction/BoxPredictor_${c}/BoxEncodingPredictor`,`prediction_layer/box_predictor_${c}/box_encoding_predictor`),d=i(`Prediction/BoxPredictor_${c}/ClassPredictor`,`prediction_layer/box_predictor_${c}/class_predictor`);return{box_encoding_predictor:l,class_predictor:d}}function u(){return{conv_0:r("Prediction",0,"prediction_layer/conv_0"),conv_1:r("Prediction",1,"prediction_layer/conv_1"),conv_2:r("Prediction",2,"prediction_layer/conv_2"),conv_3:r("Prediction",3,"prediction_layer/conv_3"),conv_4:r("Prediction",4,"prediction_layer/conv_4"),conv_5:r("Prediction",5,"prediction_layer/conv_5"),conv_6:r("Prediction",6,"prediction_layer/conv_6"),conv_7:r("Prediction",7,"prediction_layer/conv_7"),box_predictor_0:o(0),box_predictor_1:o(1),box_predictor_2:o(2),box_predictor_3:o(3),box_predictor_4:o(4),box_predictor_5:o(5)}}return{extractMobilenetV1Params:a,extractPredictionLayerParams:u}}function e_e(e){let t=[],{extractMobilenetV1Params:n,extractPredictionLayerParams:r}=ZRe(e,t),s=e["Output/extra_dim"];if(t.push({originalPath:"Output/extra_dim",paramPath:"output_layer/extra_dim"}),!G0(s))throw new Error(`expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have ${s}`);let a={mobilenetv1:n(),prediction_layer:r(),output_layer:{extra_dim:s}};return _u(e,t),{params:a,paramMappings:t}}function oo(e,t,n){return ie(()=>{let r=Vs(e,t.filters,n,"same");return r=Se(r,t.batch_norm_offset),vs(r,0,6)})}var t_e=.0010000000474974513;function n_e(e,t,n){return ie(()=>{let r=Lh(e,t.filters,n,"same");return r=Oh(r,t.batch_norm_mean,t.batch_norm_variance,t.batch_norm_offset,t.batch_norm_scale,t_e),vs(r,0,6)})}function r_e(e){return[2,4,6,12].some(t=>t===e)?[2,2]:[1,1]}function s_e(e,t){return ie(()=>{let n,r=oo(e,t.conv_0,[2,2]);if([t.conv_1,t.conv_2,t.conv_3,t.conv_4,t.conv_5,t.conv_6,t.conv_7,t.conv_8,t.conv_9,t.conv_10,t.conv_11,t.conv_12,t.conv_13].forEach((s,a)=>{let i=a+1,o=r_e(i);r=n_e(r,s.depthwise_conv,o),r=oo(r,s.pointwise_conv,[1,1]),i===11&&(n=r)}),n===null)throw new Error("mobileNetV1 - output of conv layer 11 is null");return{out:r,conv11:n}})}function a_e(e,t,n){let r=e.arraySync(),s=Math.min(r[t][0],r[t][2]),a=Math.min(r[t][1],r[t][3]),i=Math.max(r[t][0],r[t][2]),o=Math.max(r[t][1],r[t][3]),u=Math.min(r[n][0],r[n][2]),c=Math.min(r[n][1],r[n][3]),l=Math.max(r[n][0],r[n][2]),d=Math.max(r[n][1],r[n][3]),h=(i-s)*(o-a),p=(l-u)*(d-c);if(h<=0||p<=0)return 0;let f=Math.max(s,u),m=Math.max(a,c),g=Math.min(i,l),b=Math.min(o,d),y=Math.max(g-f,0)*Math.max(b-m,0);return y/(h+p-y)}function i_e(e,t,n,r,s){let a=e.shape[0],i=Math.min(n,a),o=t.map((l,d)=>({score:l,boxIndex:d})).filter(l=>l.score>s).sort((l,d)=>d.score-l.score),u=l=>l<=r?1:0,c=[];return o.forEach(l=>{if(c.length>=i)return;let d=l.score;for(let h=c.length-1;h>=0;--h){let p=a_e(e,l.boxIndex,c[h]);if(p!==0&&(l.score*=u(p),l.score<=s))break}d===l.score&&c.push(l.boxIndex)}),c}function o_e(e){let t=br(Gt(e,[1,0])),n=[et(t[2],t[0]),et(t[3],t[1])],r=[Se(t[0],it(n[0],2)),Se(t[1],it(n[1],2))];return{sizes:n,centers:r}}function l_e(e,t){let{sizes:n,centers:r}=o_e(e),s=br(Gt(t,[1,0])),a=it(se(Is(it(s[2],5)),n[0]),2),i=Se(se(it(s[0],10),n[0]),r[0]),o=it(se(Is(it(s[3],5)),n[1]),2),u=Se(se(it(s[1],10),n[1]),r[1]);return Gt(Dr([et(i,a),et(u,o),Se(i,a),Se(u,o)]),[1,0])}function u_e(e,t,n){return ie(()=>{let r=e.shape[0],s=l_e(ae(Ia(n.extra_dim,[r,1,1]),[-1,4]),ae(e,[-1,4]));s=ae(s,[r,s.shape[0]/r,4]);let a=ci(en(t,[0,0,1],[-1,-1,-1])),i=en(a,[0,0,0],[-1,-1,1]);i=ae(i,[r,i.shape[1]]);let o=br(s),u=br(i);return{boxes:o,scores:u}})}function fp(e,t){return ie(()=>{let n=e.shape[0],r=ae(ny(e,t.box_encoding_predictor),[n,-1,1,4]),s=ae(ny(e,t.class_predictor),[n,-1,3]);return{boxPredictionEncoding:r,classPrediction:s}})}function c_e(e,t,n){return ie(()=>{let r=oo(e,n.conv_0,[1,1]),s=oo(r,n.conv_1,[2,2]),a=oo(s,n.conv_2,[1,1]),i=oo(a,n.conv_3,[2,2]),o=oo(i,n.conv_4,[1,1]),u=oo(o,n.conv_5,[2,2]),c=oo(u,n.conv_6,[1,1]),l=oo(c,n.conv_7,[2,2]),d=fp(t,n.box_predictor_0),h=fp(e,n.box_predictor_1),p=fp(s,n.box_predictor_2),f=fp(i,n.box_predictor_3),m=fp(u,n.box_predictor_4),g=fp(l,n.box_predictor_5),b=Bn([d.boxPredictionEncoding,h.boxPredictionEncoding,p.boxPredictionEncoding,f.boxPredictionEncoding,m.boxPredictionEncoding,g.boxPredictionEncoding],1),y=Bn([d.classPrediction,h.classPrediction,p.classPrediction,f.classPrediction,m.classPrediction,g.classPrediction],1);return{boxPredictions:b,classPredictions:y}})}var j0=class{constructor({minConfidence:e,maxResults:t}={}){if(this._name="SsdMobilenetv1Options",this._minConfidence=e||.5,this._maxResults=t||100,typeof this._minConfidence!="number"||this._minConfidence<=0||this._minConfidence>=1)throw new Error(`${this._name} - expected minConfidence to be a number between 0 and 1`);if(typeof this._maxResults!="number")throw new Error(`${this._name} - expected maxResults to be a number`)}get minConfidence(){return this._minConfidence}get maxResults(){return this._maxResults}},d_e=class extends Ru{constructor(){super("SsdMobilenetv1")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("SsdMobilenetv1 - load model before inference");return ie(()=>{let n=Ve(e.toBatchTensor(512,!1),"float32"),r=et(it(n,127.5),1),s=s_e(r,t.mobilenetv1),{boxPredictions:a,classPredictions:i}=c_e(s.out,s.conv11,t.prediction_layer);return u_e(a,i,t.output_layer)})}async forward(e){return this.forwardInput(await Hs(e))}async locateFaces(e,t={}){let{maxResults:n,minConfidence:r}=new j0(t),s=await Hs(e),{boxes:a,scores:i}=this.forwardInput(s),o=a[0],u=i[0];for(let b=1;b<a.length;b++)a[b].dispose(),i[b].dispose();let c=Array.from(u.dataSync()),l=i_e(o,c,n,.5,r),d=s.getReshapedInputDimensions(0),h=s.inputSize,p=h/d.width,f=h/d.height,m=o.arraySync(),g=l.map(b=>{let[y,x]=[Math.max(0,m[b][0]),Math.min(1,m[b][2])].map(I=>I*f),[w,v]=[Math.max(0,m[b][1]),Math.min(1,m[b][3])].map(I=>I*p);return new hi(c[b],new qB(w,y,v-w,x-y),{height:s.getInputHeight(0),width:s.getInputWidth(0)})});return o.dispose(),u.dispose(),g}getDefaultModelName(){return"ssd_mobilenetv1_model"}extractParamsFromWeightMap(e){return e_e(e)}extractParams(e){return JRe(e)}},h_e=.4,p_e=[new Ln(.738768,.874946),new Ln(2.42204,2.65704),new Ln(4.30971,7.04493),new Ln(10.246,4.59428),new Ln(12.6868,11.8741)],f_e=[new Ln(1.603231,2.094468),new Ln(6.041143,7.080126),new Ln(2.882459,3.518061),new Ln(4.266906,5.178857),new Ln(9.041765,10.66308)],m_e=[117.001,114.697,97.404],g_e="tiny_yolov2_model",b_e="tiny_yolov2_separable_conv_model",N2=e=>typeof e=="number";function y_e(e){if(!e)throw new Error(`invalid config: ${e}`);if(typeof e.withSeparableConvs!="boolean")throw new Error(`config.withSeparableConvs has to be a boolean, have: ${e.withSeparableConvs}`);if(!N2(e.iouThreshold)||e.iouThreshold<0||e.iouThreshold>1)throw new Error(`config.iouThreshold has to be a number between [0, 1], have: ${e.iouThreshold}`);if(!Array.isArray(e.classes)||!e.classes.length||!e.classes.every(t=>typeof t=="string"))throw new Error(`config.classes has to be an array class names: string[], have: ${JSON.stringify(e.classes)}`);if(!Array.isArray(e.anchors)||!e.anchors.length||!e.anchors.map(t=>t||{}).every(t=>N2(t.x)&&N2(t.y)))throw new Error(`config.anchors has to be an array of { x: number, y: number }, have: ${JSON.stringify(e.anchors)}`);if(e.meanRgb&&(!Array.isArray(e.meanRgb)||e.meanRgb.length!==3||!e.meanRgb.every(N2)))throw new Error(`config.meanRgb has to be an array of shape [number, number, number], have: ${JSON.stringify(e.meanRgb)}`)}function H4(e){return ie(()=>{let t=se(e,vt(.10000000149011612));return Se(Rn(et(e,t)),t)})}function Cl(e,t){return ie(()=>{let n=Ji(e,[[0,0],[1,1],[1,1],[0,0]]);return n=Vs(n,t.conv.filters,[1,1],"valid"),n=et(n,t.bn.sub),n=se(n,t.bn.truediv),n=Se(n,t.conv.bias),H4(n)})}function Sl(e,t){return ie(()=>{let n=Ji(e,[[0,0],[1,1],[1,1],[0,0]]);return n=wm(n,t.depthwise_filter,t.pointwise_filter,[1,1],"valid"),n=Se(n,t.bias),H4(n)})}function x_e(e,t){let n=P4(e,t);function r(i,o){let u=Tn(e(i)),c=Tn(e(i));return t.push({paramPath:`${o}/sub`},{paramPath:`${o}/truediv`}),{sub:u,truediv:c}}function s(i,o,u){let c=n(i,o,3,`${u}/conv`),l=r(o,`${u}/bn`);return{conv:c,bn:l}}let a=B4(e,t);return{extractConvParams:n,extractConvWithBatchNormParams:s,extractSeparableConvParams:a}}function w_e(e,t,n,r){let{extractWeights:s,getRemainingWeights:a}=Du(e),i=[],{extractConvParams:o,extractConvWithBatchNormParams:u,extractSeparableConvParams:c}=x_e(s,i),l;if(t.withSeparableConvs){let[d,h,p,f,m,g,b,y,x]=r,w=t.isFirstLayerConv2d?o(d,h,3,"conv0"):c(d,h,"conv0"),v=c(h,p,"conv1"),I=c(p,f,"conv2"),N=c(f,m,"conv3"),T=c(m,g,"conv4"),E=c(g,b,"conv5"),A=y?c(b,y,"conv6"):void 0,k=x?c(y,x,"conv7"):void 0,C=o(x||y||b,5*n,1,"conv8");l={conv0:w,conv1:v,conv2:I,conv3:N,conv4:T,conv5:E,conv6:A,conv7:k,conv8:C}}else{let[d,h,p,f,m,g,b,y,x]=r,w=u(d,h,"conv0"),v=u(h,p,"conv1"),I=u(p,f,"conv2"),N=u(f,m,"conv3"),T=u(m,g,"conv4"),E=u(g,b,"conv5"),A=u(b,y,"conv6"),k=u(y,x,"conv7"),C=o(x,5*n,1,"conv8");l={conv0:w,conv1:v,conv2:I,conv3:N,conv4:T,conv5:E,conv6:A,conv7:k,conv8:C}}if(a().length!==0)throw new Error(`weights remaing after extract: ${a().length}`);return{params:l,paramMappings:i}}function v_e(e,t){let n=qh(e,t);function r(o){let u=n(`${o}/sub`,1),c=n(`${o}/truediv`,1);return{sub:u,truediv:c}}function s(o){let u=n(`${o}/filters`,4),c=n(`${o}/bias`,1);return{filters:u,bias:c}}function a(o){let u=s(`${o}/conv`),c=r(`${o}/bn`);return{conv:u,bn:c}}let i=z4(n);return{extractConvParams:s,extractConvWithBatchNormParams:a,extractSeparableConvParams:i}}function I_e(e,t){let n=[],{extractConvParams:r,extractConvWithBatchNormParams:s,extractSeparableConvParams:a}=v_e(e,n),i;if(t.withSeparableConvs){let o=t.filterSizes&&t.filterSizes.length||9;i={conv0:t.isFirstLayerConv2d?r("conv0"):a("conv0"),conv1:a("conv1"),conv2:a("conv2"),conv3:a("conv3"),conv4:a("conv4"),conv5:a("conv5"),conv6:o>7?a("conv6"):void 0,conv7:o>8?a("conv7"):void 0,conv8:r("conv8")}}else i={conv0:s("conv0"),conv1:s("conv1"),conv2:s("conv2"),conv3:s("conv3"),conv4:s("conv4"),conv5:s("conv5"),conv6:s("conv6"),conv7:s("conv7"),conv8:r("conv8")};return _u(e,n),{params:i,paramMappings:n}}var j4=class{constructor({inputSize:e,scoreThreshold:t}={}){if(this._name="TinyYolov2Options",this._inputSize=e||416,this._scoreThreshold=t||.5,typeof this._inputSize!="number"||this._inputSize%32!==0)throw new Error(`${this._name} - expected inputSize to be a number divisible by 32`);if(typeof this._scoreThreshold!="number"||this._scoreThreshold<=0||this._scoreThreshold>=1)throw new Error(`${this._name} - expected scoreThreshold to be a number between 0 and 1`)}get inputSize(){return this._inputSize}get scoreThreshold(){return this._scoreThreshold}},Tz=class Ez extends Ru{constructor(t){super("TinyYolov2"),y_e(t),this._config=t}get config(){return this._config}get withClassScores(){return this.config.withClassScores||this.config.classes.length>1}get boxEncodingSize(){return 5+(this.withClassScores?this.config.classes.length:0)}runTinyYolov2(t,n){let r=Cl(t,n.conv0);return r=Zr(r,[2,2],[2,2],"same"),r=Cl(r,n.conv1),r=Zr(r,[2,2],[2,2],"same"),r=Cl(r,n.conv2),r=Zr(r,[2,2],[2,2],"same"),r=Cl(r,n.conv3),r=Zr(r,[2,2],[2,2],"same"),r=Cl(r,n.conv4),r=Zr(r,[2,2],[2,2],"same"),r=Cl(r,n.conv5),r=Zr(r,[2,2],[1,1],"same"),r=Cl(r,n.conv6),r=Cl(r,n.conv7),ny(r,n.conv8,"valid",!1)}runMobilenet(t,n){let r=this.config.isFirstLayerConv2d?H4(ny(t,n.conv0,"valid",!1)):Sl(t,n.conv0);return r=Zr(r,[2,2],[2,2],"same"),r=Sl(r,n.conv1),r=Zr(r,[2,2],[2,2],"same"),r=Sl(r,n.conv2),r=Zr(r,[2,2],[2,2],"same"),r=Sl(r,n.conv3),r=Zr(r,[2,2],[2,2],"same"),r=Sl(r,n.conv4),r=Zr(r,[2,2],[2,2],"same"),r=Sl(r,n.conv5),r=Zr(r,[2,2],[1,1],"same"),r=n.conv6?Sl(r,n.conv6):r,r=n.conv7?Sl(r,n.conv7):r,ny(r,n.conv8,"valid",!1)}forwardInput(t,n){let{params:r}=this;if(!r)throw new Error("TinyYolov2 - load model before inference");return ie(()=>{let s=Ve(t.toBatchTensor(n,!1),"float32");return s=this.config.meanRgb?H0(s,this.config.meanRgb):s,s=s.div(255),this.config.withSeparableConvs?this.runMobilenet(s,r):this.runTinyYolov2(s,r)})}async forward(t,n){return this.forwardInput(await Hs(t),n)}async detect(t,n={}){let{inputSize:r,scoreThreshold:s}=new j4(n),a=await Hs(t),i=await this.forwardInput(a,r),o=ie(()=>br(i)[0].expandDims()),u={width:a.getInputWidth(0),height:a.getInputHeight(0)},c=await this.extractBoxes(o,a.getReshapedInputDimensions(0),s);i.dispose(),o.dispose();let l=c.map(f=>f.box),d=c.map(f=>f.score),h=c.map(f=>f.classScore),p=c.map(f=>this.config.classes[f.label]);return aRe(l.map(f=>f.rescale(r)),d,this.config.iouThreshold,!0).map(f=>new GB(d[f],h[f],p[f],l[f],u))}getDefaultModelName(){return""}extractParamsFromWeightMap(t){return I_e(t,this.config)}extractParams(t){let n=this.config.filterSizes||Ez.DEFAULT_FILTER_SIZES,r=n?n.length:void 0;if(r!==7&&r!==8&&r!==9)throw new Error(`TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found ${r} filterSizes in config`);return w_e(t,this.config,this.boxEncodingSize,n)}async extractBoxes(t,n,r){let{width:s,height:a}=n,i=Math.max(s,a),o=i/s,u=i/a,c=t.shape[1],l=this.config.anchors.length,[d,h,p]=ie(()=>{let b=t.reshape([c,c,l,this.boxEncodingSize]),y=b.slice([0,0,0,0],[c,c,l,4]),x=b.slice([0,0,0,4],[c,c,l,1]),w=this.withClassScores?Su(b.slice([0,0,0,5],[c,c,l,this.config.classes.length]),3):vt(0);return[y,x,w]}),f=[],m=await h.array(),g=await d.array();for(let b=0;b<c;b++)for(let y=0;y<c;y++)for(let x=0;x<l;x++){let w=fk(m[b][y][x][0]);if(!r||w>r){let v=(y+fk(g[b][y][x][0]))/c*o,I=(b+fk(g[b][y][x][1]))/c*u,N=Math.exp(g[b][y][x][2])*this.config.anchors[x].x/c*o,T=Math.exp(g[b][y][x][3])*this.config.anchors[x].y/c*u,E=v-N/2,A=I-T/2,k={row:b,col:y,anchor:x},{classScore:C,label:M}=this.withClassScores?await this.extractPredictedClass(p,k):{classScore:1,label:0};f.push({box:new UB(E,A,E+N,A+T),score:w,classScore:w*C,label:M,...k})}}return d.dispose(),h.dispose(),p.dispose(),f}async extractPredictedClass(t,n){let{row:r,col:s,anchor:a}=n,i=await t.array();return Array(this.config.classes.length).fill(0).map((o,u)=>i[r][s][a][u]).map((o,u)=>({classScore:o,label:u})).reduce((o,u)=>o.classScore>u.classScore?o:u)}};Tz.DEFAULT_FILTER_SIZES=[3,16,32,64,128,256,512,1024,1024];var Az=Tz,k_e=class extends Az{constructor(e=!0){let t={withSeparableConvs:e,iouThreshold:h_e,classes:["face"],...e?{anchors:f_e,meanRgb:m_e}:{anchors:p_e,withClassScores:!0}};super(t)}get withSeparableConvs(){return this.config.withSeparableConvs}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map(n=>new hi(n.score,n.relativeBox,{width:n.imageWidth,height:n.imageHeight}))}getDefaultModelName(){return this.withSeparableConvs?b_e:g_e}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}},$z=class extends j4{constructor(){super(...arguments),this._name="TinyFaceDetectorOptions"}},q0=class{async then(e){return e(await this.run())}async run(){throw new Error("ComposableTask - run is not implemented")}};async function Lv(e,t,n,r,s=({alignedRect:a})=>a){let a=e.map(u=>V4(u)?s(u):u.detection),i=r||(t instanceof Wt?await L4(t,a):await O4(t,a)),o=await n(i);return i.forEach(u=>u instanceof Wt&&u.dispose()),o}async function q4(e,t,n,r,s){return Lv([e],t,async a=>n(a[0]),r,s)}var C_e=.4,S_e=[new Ln(1.603231,2.094468),new Ln(6.041143,7.080126),new Ln(2.882459,3.518061),new Ln(4.266906,5.178857),new Ln(9.041765,10.66308)],N_e=[117.001,114.697,97.404],T_e=class extends Az{constructor(){let e={withSeparableConvs:!0,iouThreshold:C_e,classes:["face"],anchors:S_e,meanRgb:N_e,isFirstLayerConv2d:!0,filterSizes:[3,16,32,64,128,256,512]};super(e)}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map(n=>new hi(n.score,n.relativeBox,{width:n.imageWidth,height:n.imageHeight}))}getDefaultModelName(){return"tiny_face_detector_model"}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}},Sa={ssdMobilenetv1:new d_e,tinyFaceDetector:new T_e,tinyYolov2:new k_e,faceLandmark68Net:new BRe,faceLandmark68TinyNet:new URe,faceRecognitionNet:new QRe,faceExpressionNet:new CRe,ageGenderNet:new PRe},Rz=class extends q0{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},K4=class extends Rz{async run(){let e=await this.parentTask,t=await Lv(e,this.input,async n=>Promise.all(n.map(r=>Sa.faceExpressionNet.predictExpressions(r))),this.extractedFaces);return e.map((n,r)=>bz(n,t[r]))}withAgeAndGender(){return new J4(this,this.input)}},X4=class extends Rz{async run(){let e=await this.parentTask;if(!e)return;let t=await q4(e,this.input,n=>Sa.faceExpressionNet.predictExpressions(n),this.extractedFaces);return bz(e,t)}withAgeAndGender(){return new Z4(this,this.input)}},Q4=class extends K4{withAgeAndGender(){return new eE(this,this.input)}withFaceDescriptors(){return new nE(this,this.input)}},Y4=class extends X4{withAgeAndGender(){return new tE(this,this.input)}withFaceDescriptor(){return new rE(this,this.input)}},_z=class extends q0{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},J4=class extends _z{async run(){let e=await this.parentTask,t=await Lv(e,this.input,async n=>Promise.all(n.map(r=>Sa.ageGenderNet.predictAgeAndGender(r))),this.extractedFaces);return e.map((n,r)=>{let{age:s,gender:a,genderProbability:i}=t[r];return Sz(Nz(n,a,i),s)})}withFaceExpressions(){return new K4(this,this.input)}},Z4=class extends _z{async run(){let e=await this.parentTask;if(!e)return;let{age:t,gender:n,genderProbability:r}=await q4(e,this.input,s=>Sa.ageGenderNet.predictAgeAndGender(s),this.extractedFaces);return Sz(Nz(e,n,r),t)}withFaceExpressions(){return new X4(this,this.input)}},eE=class extends J4{withFaceExpressions(){return new Q4(this,this.input)}withFaceDescriptors(){return new nE(this,this.input)}},tE=class extends Z4{withFaceExpressions(){return new Y4(this,this.input)}withFaceDescriptor(){return new rE(this,this.input)}},Dz=class extends q0{constructor(e,t){super(),this.parentTask=e,this.input=t}},nE=class extends Dz{async run(){let e=await this.parentTask;return(await Lv(e,this.input,t=>Promise.all(t.map(n=>Sa.faceRecognitionNet.computeFaceDescriptor(n))),null,t=>t.landmarks.align(null,{useDlibAlignment:!0}))).map((t,n)=>Cz(e[n],t))}withFaceExpressions(){return new Q4(this,this.input)}withAgeAndGender(){return new eE(this,this.input)}},rE=class extends Dz{async run(){let e=await this.parentTask;if(!e)return;let t=await q4(e,this.input,n=>Sa.faceRecognitionNet.computeFaceDescriptor(n),null,n=>n.landmarks.align(null,{useDlibAlignment:!0}));return Cz(e,t)}withFaceExpressions(){return new Y4(this,this.input)}withAgeAndGender(){return new tE(this,this.input)}},Fz=class extends q0{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.useTinyLandmarkNet=n}get landmarkNet(){return this.useTinyLandmarkNet?Sa.faceLandmark68TinyNet:Sa.faceLandmark68Net}},E_e=class extends Fz{async run(){let e=await this.parentTask,t=e.map(s=>s.detection),n=this.input instanceof Wt?await L4(this.input,t):await O4(this.input,t),r=await Promise.all(n.map(s=>this.landmarkNet.detectLandmarks(s)));return n.forEach(s=>s instanceof Wt&&s.dispose()),e.filter((s,a)=>r[a]).map((s,a)=>U4(s,r[a]))}withFaceExpressions(){return new Q4(this,this.input)}withAgeAndGender(){return new eE(this,this.input)}withFaceDescriptors(){return new nE(this,this.input)}},A_e=class extends Fz{async run(){let e=await this.parentTask;if(!e)return;let{detection:t}=e,n=this.input instanceof Wt?await L4(this.input,[t]):await O4(this.input,[t]),r=await this.landmarkNet.detectLandmarks(n[0]);return n.forEach(s=>s instanceof Wt&&s.dispose()),U4(e,r)}withFaceExpressions(){return new Y4(this,this.input)}withAgeAndGender(){return new tE(this,this.input)}withFaceDescriptor(){return new rE(this,this.input)}},Mz=class extends q0{constructor(e,t=new j0){super(),this.input=e,this.options=t}},Oz=class extends Mz{async run(){let{input:e,options:t}=this,n;if(t instanceof $z)n=Sa.tinyFaceDetector.locateFaces(e,t);else if(t instanceof j0)n=Sa.ssdMobilenetv1.locateFaces(e,t);else if(t instanceof j4)n=Sa.tinyYolov2.locateFaces(e,t);else throw new Error("detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | TinyYolov2Options");return n}runAndExtendWithFaceDetections(){return new Promise((e,t)=>{this.run().then(n=>e(n.map(r=>_x({},r)))).catch(n=>t(n))})}withFaceLandmarks(e=!1){return new E_e(this.runAndExtendWithFaceDetections(),this.input,e)}withFaceExpressions(){return new K4(this.runAndExtendWithFaceDetections(),this.input)}withAgeAndGender(){return new J4(this.runAndExtendWithFaceDetections(),this.input)}},$_e=class extends Mz{async run(){let e=await new Oz(this.input,this.options),t=e[0];return e.forEach(n=>{n.score>t.score&&(t=n)}),t}runAndExtendWithFaceDetection(){return new Promise(async e=>{let t=await this.run();e(t?_x({},t):void 0)})}withFaceLandmarks(e=!1){return new A_e(this.runAndExtendWithFaceDetection(),this.input,e)}withFaceExpressions(){return new X4(this.runAndExtendWithFaceDetection(),this.input)}withAgeAndGender(){return new Z4(this.runAndExtendWithFaceDetection(),this.input)}};function R_e(e,t=new j0){return new $_e(e,t)}function __e(e,t=new j0){return new Oz(e,t)}function D_e(e,t){if(e.length!==t.length)throw new Error("euclideanDistance: arr1.length !== arr2.length");let n=Array.from(e),r=Array.from(t);return Math.sqrt(n.map((s,a)=>s-r[a]).reduce((s,a)=>s+a*a,0))}var F_e=class Lz{constructor(t,n=.6){this._distanceThreshold=n;let r=Array.isArray(t)?t:[t];if(!r.length)throw new Error("FaceRecognizer.constructor - expected atleast one input");let s=1,a=()=>`person ${s++}`;this._labeledDescriptors=r.map(i=>{if(i instanceof Hb)return i;if(i instanceof Float32Array)return new Hb(a(),[i]);if(i.descriptor&&i.descriptor instanceof Float32Array)return new Hb(a(),[i.descriptor]);throw new Error("FaceRecognizer.constructor - expected inputs to be of type LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array | Array<LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array>")})}get labeledDescriptors(){return this._labeledDescriptors}get distanceThreshold(){return this._distanceThreshold}computeMeanDistance(t,n){return n.map(r=>D_e(r,t)).reduce((r,s)=>r+s,0)/(n.length||1)}matchDescriptor(t){return this.labeledDescriptors.map(({descriptors:n,label:r})=>new R_(r,this.computeMeanDistance(t,n))).reduce((n,r)=>n.distance<r.distance?n:r)}findBestMatch(t){let n=this.matchDescriptor(t);return n.distance<this._distanceThreshold?n:new R_("unknown",n.distance)}toJSON(){return{distanceThreshold:this._distanceThreshold,labeledDescriptors:this._labeledDescriptors.map(t=>t.toJSON())}}static fromJSON(t){let n=t.labeledDescriptors.map(r=>Hb.fromJSON(r));return new Lz(n,t.distanceThreshold)}};function Pz(e,t){let{width:n,height:r}=new Rc(t.width,t.height);if(n<=0||r<=0)throw new Error(`resizeResults - invalid dimensions: ${JSON.stringify({width:n,height:r})}`);if(Array.isArray(e))return e.map(s=>Pz(s,{width:n,height:r}));if(V4(e)){let s=e.detection.forSize(n,r),a=e.unshiftedLandmarks.forSize(s.box.width,s.box.height);return U4(_x(e,s),a)}return Cy(e)?_x(e,e.detection.forSize(n,r)):e instanceof ky||e instanceof hi?e.forSize(n,r):e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M_e=1e-7,O_e=1e-4;class sE{constructor(t,n){this.backend=t,this.dataMover=n,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,n){this.dataIdsCount++,this.data.set(t,n)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class Pv{refCount(t){return ga("refCount")}incRef(t){return ga("incRef")}timerAvailable(){return!0}time(t){return ga("time")}read(t){return ga("read")}readSync(t){return ga("readSync")}readToGPU(t,n){return ga("readToGPU")}numDataIds(){return ga("numDataIds")}disposeData(t,n){return ga("disposeData")}write(t,n,r){return ga("write")}move(t,n,r,s,a){return ga("move")}createTensorFromGPUData(t,n,r){return ga("createTensorFromGPUData")}memory(){return ga("memory")}floatPrecision(){return ga("floatPrecision")}epsilon(){return this.floatPrecision()===32?M_e:O_e}dispose(){return ga("dispose")}}function ga(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L_e(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,vp(e,t,n)}function nd(e,t,n){return Math.max(e,Math.min(t,n))}function aE(e){return e%2===0?e:e+1}function vp(e,t,n){const r=e[t];e[t]=e[n],e[n]=r}function P_e(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function U(e,t){if(!e)throw new Error(typeof t=="string"?t:t())}function Bv(e,t,n=""){U(Nn(e,t),()=>n+` Shapes ${e} and ${t} must match`)}function Bz(e){U(e!=null,()=>"The input to the tensor constructor must be a non-null value.")}function fe(e){if(e.length===0)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function Nn(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function Yp(e){return e%1===0}function JC(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function Ap(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function F_(e,t=s=>0,n,r){return new Promise((s,a)=>{let i=0;const o=()=>{if(e()){s();return}i++;const u=t(i);if(n!=null&&i>=n){a();return}r!=null?r(o,u):setTimeout(o,u)};o()})}function iE(e,t){let n=1,r=-1;for(let a=0;a<e.length;++a)if(e[a]>=0)n*=e[a];else if(e[a]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${a}`);r=a}else if(e[a]<0)throw Error(`Shapes can not be < 0. Found ${e[a]} at dim ${a}`);if(r===-1){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(n===0)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const s=e.slice();return s[r]=t/n,s}function zt(e,t){const n=t.length;return e=e==null?t.map((r,s)=>s):[].concat(e),U(e.every(r=>r>=-n&&r<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`),U(e.every(r=>Yp(r)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(r=>r<0?n+r:r)}function Fu(e,t){const n=[],r=[],s=t!=null&&Array.isArray(t)&&t.length===0,a=t==null||s?null:zt(t,e).sort();let i=0;for(let o=0;o<e.length;++o){if(a!=null){if(a[i]===o&&e[o]!==1)throw new Error(`Can't squeeze axis ${o} since its dim '${e[o]}' is not 1`);(a[i]==null||a[i]>o)&&e[o]===1&&(n.push(e[o]),r.push(o)),a[i]<=o&&i++}e[o]!==1&&(n.push(e[o]),r.push(o))}return{newShape:n,keptDims:r}}function ks(e,t){return wr(e,t)}function wr(e,t){let n=null;if(e==null||e==="float32")n=new Float32Array(t);else if(e==="int32")n=new Int32Array(t);else if(e==="bool")n=new Uint8Array(t);else if(e==="string")n=new Array(t);else throw new Error(`Unknown data type ${e}`);return n}function B_e(e,t){for(let n=0;n<e.length;n++){const r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function z_e(e){return e==="bool"||e==="complex64"||e==="float32"||e==="int32"||e==="string"}function zz(e,t){return!(t==="complex64"||t==="float32"&&e!=="complex64"||t==="int32"&&e!=="float32"&&e!=="complex64"||t==="bool"&&e==="bool")}function Jp(e){if(e==="float32"||e==="int32")return 4;if(e==="complex64")return 8;if(e==="bool")return 1;throw new Error(`Unknown dtype ${e}`)}function W_e(e){if(e==null)return 0;let t=0;return e.forEach(n=>t+=n.length),t}function K0(e){return typeof e=="string"||e instanceof String}function V_e(e){return typeof e=="boolean"}function ZC(e){return typeof e=="number"}function Kh(e){return Array.isArray(e)?Kh(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":ZC(e)?"float32":K0(e)?"string":V_e(e)?"bool":"float32"}function eS(e){return!!(e&&e.constructor&&e.call&&e.apply)}function tS(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function ot(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function Wz(e,t,n,r=!1){const s=new Array;if(t.length===1){const a=t[0]*(r?2:1);for(let i=0;i<a;i++)s[i]=n[e+i]}else{const a=t[0],i=t.slice(1),o=i.reduce((u,c)=>u*c)*(r?2:1);for(let u=0;u<a;u++)s[u]=Wz(e+u*o,i,n,r)}return s}function Vi(e,t,n=!1){if(e.length===0)return t[0];const r=e.reduce((s,a)=>s*a)*(n?2:1);if(r===0)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return Wz(0,e,t,n)}function U_e(e,t){if(Array.isArray(e))return e;if(t==="float32")return e instanceof Float32Array?e:new Float32Array(e);if(t==="int32")return e instanceof Int32Array?e:new Int32Array(e);if(t==="bool"||t==="string")return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function oE(e,t){const n=Cs(e,t);for(let r=0;r<n.length;r++)n[r]=1;return n}function Cs(e,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool")return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function Vz(e,t){const n=e.reduce((r,s)=>r*s,1);if(t==null||t==="float32")return Vi(e,new Float32Array(n));if(t==="int32")return Vi(e,new Int32Array(n));if(t==="bool")return Vi(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function wl(e){e.forEach(t=>{U(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function Io(e,t,n){if(t===0)return 0;if(t===1)return e[0];let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=n[s]*e[s];return r}function Om(e,t,n){if(t===0)return[];if(t===1)return[e];const r=new Array(t);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(e/n[s]),e-=r[s]*n[s];return r[r.length-1]=e,r}function lE(e){return e&&e.then&&typeof e.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M_="tfjsflags";class G_e{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=H_e,this.populateURLFlags()}setPlatform(t,n){this.platform!=null&&(ke().getBool("IS_TEST")||ke().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=n}registerFlag(t,n,r){if(this.flagRegistry[t]={evaluationFn:n,setHook:r},this.urlFlags[t]!=null){const s=this.urlFlags[t];ke().getBool("IS_TEST")||ke().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${s}.`),this.set(t,s)}}async getAsync(t){return t in this.flags?this.flags[t]:(this.flags[t]=await this.evaluateFlag(t),this.flags[t])}get(t){if(t in this.flags)return this.flags[t];const n=this.evaluateFlag(t);if(lE(n))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=n,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getString(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,n){if(this.flagRegistry[t]==null)throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=n,this.flagRegistry[t].setHook!=null&&this.flagRegistry[t].setHook(n)}evaluateFlag(t){if(this.flagRegistry[t]==null)throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const t=this.getQueryParams(this.global.location.search);M_ in t&&t[M_].split(",").forEach(r=>{const[s,a]=r.split(":");this.urlFlags[s]=q_e(s,a)})}}function H_e(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...r)=>(j_e(t,r[0],r[1]),r.join("="))),t}function j_e(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}function q_e(e,t){const n=t.toLowerCase();return n==="true"||n==="false"?n==="true":`${+n}`===n?+n:t}function ke(){return Uz}let Uz=null;function K_e(e){Uz=e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let bk;function Gz(){if(bk==null){let e;if(typeof window<"u")e=window;else if(typeof globalThis<"u")e=globalThis;else if(typeof process<"u")e=process;else if(typeof self<"u")e=self;else throw new Error("Could not find a global object");bk=e}return bk}function X_e(){const e=Gz();return e._tfGlobals==null&&(e._tfGlobals=new Map),e._tfGlobals}function uE(e,t){const n=X_e();if(n.has(e))return n.get(e);{const r=t();return n.set(e,r),n.get(e)}}const X0="Abs",Lm="Acos",Pm="Acosh",Xh="Add",Q0="AddN",Y0="All",J0="Any",Z0="ArgMax",e1="ArgMin",Bm="Asin",zm="Asinh",Wm="Atan",Vm="Atanh",Um="Atan2",Gm="AvgPool",zv="AvgPoolGrad",t1="AvgPool3D",Wv="AvgPool3DGrad",Hm="BatchMatMul",n1="BatchToSpaceND",r1="Bincount",Vv="BitwiseAnd",Q_e="BroadcastTo",cE="BroadcastArgs",jm="Cast",qm="Ceil",Qh="ClipByValue",dE="Complex",Uv="ComplexAbs",s1="Concat",Km="Conv2D",hE="Conv2DBackpropFilter",Xm="Conv2DBackpropInput",Qm="Conv3D",a1="Conv3DBackpropFilterV2",i1="Conv3DBackpropInputV2",Ym="Cos",Jm="Cosh",o1="Cumprod",Zm="Cumsum",l1="CropAndResize",Gv="DenseBincount",u1="DepthToSpace",eg="DepthwiseConv2dNative",pE="DepthwiseConv2dNativeBackpropFilter",fE="DepthwiseConv2dNativeBackpropInput",mE="Diag",tg="Dilation2D",Sy="Dilation2DBackpropInput",Ny="Dilation2DBackpropFilter",Y_e="Draw",ng="RealDiv",gE="Einsum",rg="Elu",c1="EluGrad",sg="Erf",d1="Equal",ag="Exp",h1="ExpandDims",ig="Expm1",bE="FFT",Hv="Fill",p1="FlipLeftRight",og="Floor",lg="FloorDiv",ug="FusedBatchNorm",f1="GatherV2",jv="GatherNd",m1="Greater",cg="GreaterEqual",dg="Identity",yE="IFFT",xE="Imag",hg="IsFinite",pg="IsInf",fg="IsNan",mg="LeakyRelu",g1="Less",b1="LessEqual",qv="LinSpace",gg="Log",bg="Log1p",y1="LogicalAnd",x1="LogicalNot",w1="LogicalOr",J_e="LogicalXor",Z_e="LogSoftmax",yg="LRN",v1="LRNGrad",xg="Max",wg="Maximum",vg="MaxPool",Kv="MaxPoolGrad",I1="MaxPool3D",Xv="MaxPool3DGrad",wE="MaxPoolWithArgmax",Ig="Mean",kg="Min",Cg="Minimum",Sg="MirrorPad",Ng="Mod",Qv="Multinomial",Tg="Multiply",k1="Neg",C1="NotEqual",S1="NonMaxSuppressionV3",N1="NonMaxSuppressionV4",T1="NonMaxSuppressionV5",E1="OnesLike",Eg="OneHot",A1="Pack",Ag="PadV2",$g="Pow",Rg="Prelu",_g="Prod",Hz="RaggedGather",jz="RaggedRange",qz="RaggedTensorToTensor",Yv="Range",vE="Real",Dg="Reciprocal",Fg="Relu",$1="Reshape",Mg="ResizeNearestNeighbor",R1="ResizeNearestNeighborGrad",Og="ResizeBilinear",_1="ResizeBilinearGrad",Lg="Relu6",Pg="Reverse",Bg="Round",zg="Rsqrt",Jv="ScatterNd",Zv="TensorScatterUpdate",eI="SearchSorted",D1="Select",Wg="Selu",F1="Slice",Vg="Sin",Ug="Sinh",Gg="Sign",Hg="Sigmoid",jg="Softplus",qg="Sqrt",Kg="Sum",M1="SpaceToBatchND",O1="SplitV",Xg="Softmax",IE="SparseFillEmptyRows",tI="SparseReshape",kE="SparseSegmentMean",CE="SparseSegmentSum",nI="SparseToDense",Qg="SquaredDifference",rI="Square",SE="StaticRegexReplace",L1="StridedSlice",NE="StringNGrams",TE="StringSplit",EE="StringToHashBucketFast",Yg="Sub",Jg="Tan",Zg="Tanh",Yh="Tile",P1="TopK",B1="Transform",Gl="Transpose",sI="Unique",z1="Unpack",aI="UnsortedSegmentSum",W1="ZerosLike",Jh="Step",eDe="FromPixels",V1="RotateWithOffset",Zp="_FusedMatMul",ef="FusedConv2D",iI="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oa(...e){ke().getBool("IS_TEST")||ke().getBool("PROD")||console.warn(...e)}function tDe(...e){ke().getBool("IS_TEST")||ke().getBool("PROD")||console.log(...e)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mx=uE("kernelRegistry",()=>new Map),nS=uE("gradRegistry",()=>new Map);function O_(e,t){const n=Kz(e,t);return Mx.get(n)}function L_(e){return nS.get(e)}function P_(e){const t=Mx.entries(),n=[];for(;;){const{done:r,value:s}=t.next();if(r)break;const[a,i]=s,[o]=a.split("_");o===e&&n.push(i)}return n}function AE(e){const{kernelName:t,backendName:n}=e,r=Kz(t,n);Mx.has(r)&&Oa(`The kernel '${t}' for backend '${n}' is already registered`),Mx.set(r,e)}function nDe(e){const{kernelName:t}=e;nS.has(t)&&ke().getBool("DEBUG")&&Oa(`Overriding the gradient for '${t}'`),nS.set(t,e)}function Kz(e,t){return`${t}_${e}`}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xz(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var yk,B_;function rDe(){if(B_)return yk;B_=1,yk=t;var e=null;try{e=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function t(A,k,C){this.low=A|0,this.high=k|0,this.unsigned=!!C}t.prototype.__isLong__,Object.defineProperty(t.prototype,"__isLong__",{value:!0});function n(A){return(A&&A.__isLong__)===!0}t.isLong=n;var r={},s={};function a(A,k){var C,M,L;return k?(A>>>=0,(L=0<=A&&A<256)&&(M=s[A],M)?M:(C=o(A,(A|0)<0?-1:0,!0),L&&(s[A]=C),C)):(A|=0,(L=-128<=A&&A<128)&&(M=r[A],M)?M:(C=o(A,A<0?-1:0,!1),L&&(r[A]=C),C))}t.fromInt=a;function i(A,k){if(isNaN(A))return k?y:b;if(k){if(A<0)return y;if(A>=f)return N}else{if(A<=-m)return T;if(A+1>=m)return I}return A<0?i(-A,k).neg():o(A%p|0,A/p|0,k)}t.fromNumber=i;function o(A,k,C){return new t(A,k,C)}t.fromBits=o;var u=Math.pow;function c(A,k,C){if(A.length===0)throw Error("empty string");if(A==="NaN"||A==="Infinity"||A==="+Infinity"||A==="-Infinity")return b;if(typeof k=="number"?(C=k,k=!1):k=!!k,C=C||10,C<2||36<C)throw RangeError("radix");var M;if((M=A.indexOf("-"))>0)throw Error("interior hyphen");if(M===0)return c(A.substring(1),k,C).neg();for(var L=i(u(C,8)),O=b,B=0;B<A.length;B+=8){var G=Math.min(8,A.length-B),z=parseInt(A.substring(B,B+G),C);if(G<8){var q=i(u(C,G));O=O.mul(q).add(i(z))}else O=O.mul(L),O=O.add(i(z))}return O.unsigned=k,O}t.fromString=c;function l(A,k){return typeof A=="number"?i(A,k):typeof A=="string"?c(A,k):o(A.low,A.high,typeof k=="boolean"?k:A.unsigned)}t.fromValue=l;var d=65536,h=1<<24,p=d*d,f=p*p,m=f/2,g=a(h),b=a(0);t.ZERO=b;var y=a(0,!0);t.UZERO=y;var x=a(1);t.ONE=x;var w=a(1,!0);t.UONE=w;var v=a(-1);t.NEG_ONE=v;var I=o(-1,2147483647,!1);t.MAX_VALUE=I;var N=o(-1,-1,!0);t.MAX_UNSIGNED_VALUE=N;var T=o(0,-2147483648,!1);t.MIN_VALUE=T;var E=t.prototype;return E.toInt=function(){return this.unsigned?this.low>>>0:this.low},E.toNumber=function(){return this.unsigned?(this.high>>>0)*p+(this.low>>>0):this.high*p+(this.low>>>0)},E.toString=function(k){if(k=k||10,k<2||36<k)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(T)){var C=i(k),M=this.div(C),L=M.mul(C).sub(this);return M.toString(k)+L.toInt().toString(k)}else return"-"+this.neg().toString(k);for(var O=i(u(k,6),this.unsigned),B=this,G="";;){var z=B.div(O),q=B.sub(z.mul(O)).toInt()>>>0,Q=q.toString(k);if(B=z,B.isZero())return Q+G;for(;Q.length<6;)Q="0"+Q;G=""+Q+G}},E.getHighBits=function(){return this.high},E.getHighBitsUnsigned=function(){return this.high>>>0},E.getLowBits=function(){return this.low},E.getLowBitsUnsigned=function(){return this.low>>>0},E.getNumBitsAbs=function(){if(this.isNegative())return this.eq(T)?64:this.neg().getNumBitsAbs();for(var k=this.high!=0?this.high:this.low,C=31;C>0&&(k&1<<C)==0;C--);return this.high!=0?C+33:C+1},E.isZero=function(){return this.high===0&&this.low===0},E.eqz=E.isZero,E.isNegative=function(){return!this.unsigned&&this.high<0},E.isPositive=function(){return this.unsigned||this.high>=0},E.isOdd=function(){return(this.low&1)===1},E.isEven=function(){return(this.low&1)===0},E.equals=function(k){return n(k)||(k=l(k)),this.unsigned!==k.unsigned&&this.high>>>31===1&&k.high>>>31===1?!1:this.high===k.high&&this.low===k.low},E.eq=E.equals,E.notEquals=function(k){return!this.eq(k)},E.neq=E.notEquals,E.ne=E.notEquals,E.lessThan=function(k){return this.comp(k)<0},E.lt=E.lessThan,E.lessThanOrEqual=function(k){return this.comp(k)<=0},E.lte=E.lessThanOrEqual,E.le=E.lessThanOrEqual,E.greaterThan=function(k){return this.comp(k)>0},E.gt=E.greaterThan,E.greaterThanOrEqual=function(k){return this.comp(k)>=0},E.gte=E.greaterThanOrEqual,E.ge=E.greaterThanOrEqual,E.compare=function(k){if(n(k)||(k=l(k)),this.eq(k))return 0;var C=this.isNegative(),M=k.isNegative();return C&&!M?-1:!C&&M?1:this.unsigned?k.high>>>0>this.high>>>0||k.high===this.high&&k.low>>>0>this.low>>>0?-1:1:this.sub(k).isNegative()?-1:1},E.comp=E.compare,E.negate=function(){return!this.unsigned&&this.eq(T)?T:this.not().add(x)},E.neg=E.negate,E.add=function(k){n(k)||(k=l(k));var C=this.high>>>16,M=this.high&65535,L=this.low>>>16,O=this.low&65535,B=k.high>>>16,G=k.high&65535,z=k.low>>>16,q=k.low&65535,Q=0,K=0,ee=0,Y=0;return Y+=O+q,ee+=Y>>>16,Y&=65535,ee+=L+z,K+=ee>>>16,ee&=65535,K+=M+G,Q+=K>>>16,K&=65535,Q+=C+B,Q&=65535,o(ee<<16|Y,Q<<16|K,this.unsigned)},E.subtract=function(k){return n(k)||(k=l(k)),this.add(k.neg())},E.sub=E.subtract,E.multiply=function(k){if(this.isZero())return b;if(n(k)||(k=l(k)),e){var C=e.mul(this.low,this.high,k.low,k.high);return o(C,e.get_high(),this.unsigned)}if(k.isZero())return b;if(this.eq(T))return k.isOdd()?T:b;if(k.eq(T))return this.isOdd()?T:b;if(this.isNegative())return k.isNegative()?this.neg().mul(k.neg()):this.neg().mul(k).neg();if(k.isNegative())return this.mul(k.neg()).neg();if(this.lt(g)&&k.lt(g))return i(this.toNumber()*k.toNumber(),this.unsigned);var M=this.high>>>16,L=this.high&65535,O=this.low>>>16,B=this.low&65535,G=k.high>>>16,z=k.high&65535,q=k.low>>>16,Q=k.low&65535,K=0,ee=0,Y=0,de=0;return de+=B*Q,Y+=de>>>16,de&=65535,Y+=O*Q,ee+=Y>>>16,Y&=65535,Y+=B*q,ee+=Y>>>16,Y&=65535,ee+=L*Q,K+=ee>>>16,ee&=65535,ee+=O*q,K+=ee>>>16,ee&=65535,ee+=B*z,K+=ee>>>16,ee&=65535,K+=M*Q+L*q+O*z+B*G,K&=65535,o(Y<<16|de,K<<16|ee,this.unsigned)},E.mul=E.multiply,E.divide=function(k){if(n(k)||(k=l(k)),k.isZero())throw Error("division by zero");if(e){if(!this.unsigned&&this.high===-2147483648&&k.low===-1&&k.high===-1)return this;var C=(this.unsigned?e.div_u:e.div_s)(this.low,this.high,k.low,k.high);return o(C,e.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?y:b;var M,L,O;if(this.unsigned){if(k.unsigned||(k=k.toUnsigned()),k.gt(this))return y;if(k.gt(this.shru(1)))return w;O=y}else{if(this.eq(T)){if(k.eq(x)||k.eq(v))return T;if(k.eq(T))return x;var B=this.shr(1);return M=B.div(k).shl(1),M.eq(b)?k.isNegative()?x:v:(L=this.sub(k.mul(M)),O=M.add(L.div(k)),O)}else if(k.eq(T))return this.unsigned?y:b;if(this.isNegative())return k.isNegative()?this.neg().div(k.neg()):this.neg().div(k).neg();if(k.isNegative())return this.div(k.neg()).neg();O=b}for(L=this;L.gte(k);){M=Math.max(1,Math.floor(L.toNumber()/k.toNumber()));for(var G=Math.ceil(Math.log(M)/Math.LN2),z=G<=48?1:u(2,G-48),q=i(M),Q=q.mul(k);Q.isNegative()||Q.gt(L);)M-=z,q=i(M,this.unsigned),Q=q.mul(k);q.isZero()&&(q=x),O=O.add(q),L=L.sub(Q)}return O},E.div=E.divide,E.modulo=function(k){if(n(k)||(k=l(k)),e){var C=(this.unsigned?e.rem_u:e.rem_s)(this.low,this.high,k.low,k.high);return o(C,e.get_high(),this.unsigned)}return this.sub(this.div(k).mul(k))},E.mod=E.modulo,E.rem=E.modulo,E.not=function(){return o(~this.low,~this.high,this.unsigned)},E.and=function(k){return n(k)||(k=l(k)),o(this.low&k.low,this.high&k.high,this.unsigned)},E.or=function(k){return n(k)||(k=l(k)),o(this.low|k.low,this.high|k.high,this.unsigned)},E.xor=function(k){return n(k)||(k=l(k)),o(this.low^k.low,this.high^k.high,this.unsigned)},E.shiftLeft=function(k){return n(k)&&(k=k.toInt()),(k&=63)===0?this:k<32?o(this.low<<k,this.high<<k|this.low>>>32-k,this.unsigned):o(0,this.low<<k-32,this.unsigned)},E.shl=E.shiftLeft,E.shiftRight=function(k){return n(k)&&(k=k.toInt()),(k&=63)===0?this:k<32?o(this.low>>>k|this.high<<32-k,this.high>>k,this.unsigned):o(this.high>>k-32,this.high>=0?0:-1,this.unsigned)},E.shr=E.shiftRight,E.shiftRightUnsigned=function(k){if(n(k)&&(k=k.toInt()),k&=63,k===0)return this;var C=this.high;if(k<32){var M=this.low;return o(M>>>k|C<<32-k,C>>>k,this.unsigned)}else return k===32?o(C,0,this.unsigned):o(C>>>k-32,0,this.unsigned)},E.shru=E.shiftRightUnsigned,E.shr_u=E.shiftRightUnsigned,E.toSigned=function(){return this.unsigned?o(this.low,this.high,!1):this},E.toUnsigned=function(){return this.unsigned?this:o(this.low,this.high,!0)},E.toBytes=function(k){return k?this.toBytesLE():this.toBytesBE()},E.toBytesLE=function(){var k=this.high,C=this.low;return[C&255,C>>>8&255,C>>>16&255,C>>>24,k&255,k>>>8&255,k>>>16&255,k>>>24]},E.toBytesBE=function(){var k=this.high,C=this.low;return[k>>>24,k>>>16&255,k>>>8&255,k&255,C>>>24,C>>>16&255,C>>>8&255,C&255]},t.fromBytes=function(k,C,M){return M?t.fromBytesLE(k,C):t.fromBytesBE(k,C)},t.fromBytesLE=function(k,C){return new t(k[0]|k[1]<<8|k[2]<<16|k[3]<<24,k[4]|k[5]<<8|k[6]<<16|k[7]<<24,C)},t.fromBytesBE=function(k,C){return new t(k[4]<<24|k[5]<<16|k[6]<<8|k[7],k[0]<<24|k[1]<<16|k[2]<<8|k[3],C)},yk}var Qz=rDe();const Yz=ow(Qz),sDe=OS({__proto__:null,default:Yz},[Qz]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vc=Yz||sDe;function oI(e){return vc.fromString(e,!0,16)}const Jz=oI("c3a5c85c97cb3127"),mc=oI("b492b66fbe98f273"),Os=oI("9ae16a3b2f90404f");function rS(e){return e.xor(e.shru(47))}function Zz(e,t,n){const r=e.slice(t,t+n);return vc.fromBytes(Array.from(r),!0,!0)}function Qn(e,t){return Zz(e,t,8)}function z_(e,t){return Zz(e,t,4)}function rs(e,t){return t===0?e:e.shru(t).or(e.shl(64-t))}function Hl(e,t,n=oI("9ddfea08eb382d69")){let r=e.xor(t).mul(n);r=r.xor(r.shru(47));let s=t.xor(r).mul(n);return s=s.xor(s.shru(47)),s=s.mul(n),s}function aDe(e,t,n,r,s,a){s=s.add(e),a=rs(a.add(s).add(r),21);const i=s;return s=s.add(t),s=s.add(n),a=a.add(rs(s,44)),[s.add(r),a.add(i)]}function T2(e,t,n,r){return aDe(Qn(e,t),Qn(e,t+8),Qn(e,t+16),Qn(e,t+24),n,r)}function iDe(e,t=e.length){if(t>=8){const n=Os.add(t*2),r=Qn(e,0).add(Os),s=Qn(e,t-8),a=rs(s,37).mul(n).add(r),i=rs(r,25).add(s).mul(n);return Hl(a,i,n)}if(t>=4){const n=Os.add(t*2),r=z_(e,0);return Hl(r.shl(3).add(t),z_(e,t-4),n)}if(t>0){const n=e[0],r=e[t>>1],s=e[t-1],a=n+(r<<8),i=t+(s<<2);return rS(Os.mul(a).xor(Jz.mul(i))).mul(Os)}return Os}function oDe(e,t=e.length){const n=Os.add(t*2),r=Qn(e,0).mul(mc),s=Qn(e,8),a=Qn(e,t-8).mul(n),i=Qn(e,t-16).mul(Os);return Hl(rs(r.add(s),43).add(rs(a,30)).add(i),r.add(rs(s.add(Os),18)).add(a),n)}function lDe(e,t=e.length){const n=Os.add(t*2),r=Qn(e,0).mul(Os),s=Qn(e,8),a=Qn(e,t-8).mul(n),i=Qn(e,t-16).mul(Os),o=rs(r.add(s),43).add(rs(a,30)).add(i),u=Hl(o,r.add(rs(s.add(Os),18)).add(a),n),c=Qn(e,16).mul(n),l=Qn(e,24),d=o.add(Qn(e,t-32)).mul(n),h=u.add(Qn(e,t-24)).mul(n);return Hl(rs(c.add(l),43).add(rs(d,30)).add(h),c.add(rs(l.add(r),18)).add(d),n)}function uDe(e,t=e.length){const n=vc.fromNumber(81,!0);if(t<=32)return t<=16?iDe(e,t):oDe(e,t);if(t<=64)return lDe(e,t);let r=n,s=n.mul(mc).add(113),a=rS(s.mul(Os).add(113)).mul(Os),i=[vc.UZERO,vc.UZERO],o=[vc.UZERO,vc.UZERO];r=r.mul(Os).add(Qn(e,0));let u=0;const c=(t-1>>6)*64,l=c+(t-1&63)-63;do r=rs(r.add(s).add(i[0]).add(Qn(e,u+8)),37).mul(mc),s=rs(s.add(i[1]).add(Qn(e,u+48)),42).mul(mc),r=r.xor(o[1]),s=s.add(i[0]).add(Qn(e,u+40)),a=rs(a.add(o[0]),33).mul(mc),i=T2(e,u,i[1].mul(mc),r.add(o[0])),o=T2(e,u+32,a.add(o[1]),s.add(Qn(e,u+16))),[a,r]=[r,a],u+=64;while(u!==c);const d=mc.add(a.and(255).shl(1));return u=l,o[0]=o[0].add(t-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),r=rs(r.add(s).add(i[0]).add(Qn(e,u+8)),37).mul(d),s=rs(s.add(i[1]).add(Qn(e,u+48)),42).mul(d),r=r.xor(o[1].mul(9)),s=s.add(i[0].mul(9).add(Qn(e,u+40))),a=rs(a.add(o[0]),33).mul(d),i=T2(e,u,i[1].mul(d),r.add(o[0])),o=T2(e,u+32,a.add(o[1]),s.add(Qn(e,u+16))),[a,r]=[r,a],Hl(Hl(i[0],o[0],d).add(rS(s).mul(Jz)).add(a),Hl(i[1],o[1],d).add(r),d)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mu(e,t){return t==="string"?jl(e):Zh([e],t)}function cDe(e,t){return e instanceof Float32Array&&t==="float32"||e instanceof Int32Array&&t==="int32"||e instanceof Uint8Array&&t==="bool"}function Zh(e,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=rd(e)),ke().getBool("DEBUG")&&B_e(e,t),cDe(e,t))return e;if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool"){const n=new Uint8Array(e.length);for(let r=0;r<n.length;++r)Math.round(e[r])!==0&&(n[r]=1);return n}else throw new Error(`Unknown data type ${t}`)}function ws(){return ke().platform.now()}function jl(e,t="utf-8"){return t=t||"utf-8",ke().platform.encode(e,t)}function cu(e,t="utf-8"){return t=t||"utf-8",ke().platform.decode(e,t)}function pi(e){return ke().platform.isTypedArray!=null?ke().platform.isTypedArray(e):Xz(e)}function rd(e,t=[],n=!1){if(t==null&&(t=[]),typeof e=="boolean"||typeof e=="number"||typeof e=="string"||lE(e)||e==null||pi(e)&&n)t.push(e);else if(Array.isArray(e)||pi(e))for(let r=0;r<e.length;++r)rd(e[r],t,n);else{let r=-1;for(const s of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(s)&&(r=Math.max(r,Number(s)));for(let s=0;s<=r;s++)rd(e[s],t,n)}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dDe{constructor(t,n){this.backendTimer=t,this.logger=n,n==null&&(this.logger=new pDe)}profileKernel(t,n,r){let s;const a=()=>{s=r()};let i;const o=ws();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(a);else{a();for(const c of s)c.dataSync();i=Promise.resolve({kernelMs:ws()-o})}if(ke().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<s.length;c++){const l=s[c];l.data().then(d=>{hDe(d,l.dtype,t)})}return{kernelName:t,outputs:s,inputs:n,timeMs:i.then(c=>c.kernelMs),extraInfo:i.then(c=>c.getExtraProfileInfo!=null?c.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:n,outputs:r,timeMs:s,inputs:a,extraInfo:i}=t;r.forEach(o=>{Promise.all([o.data(),s,i]).then(u=>{this.logger.logKernelProfile(n,o,u[0],u[1],a,u[2])})})}}function hDe(e,t,n){if(t!=="float32")return!1;for(let r=0;r<e.length;r++){const s=e[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${n}'`),!0}return!1}class pDe{logKernelProfile(t,n,r,s,a,i){const o=typeof s=="number"?Ap(`${s}ms`,9):s.error,u=Ap(t,25),c=n.rank,l=n.size,d=Ap(n.shape.toString(),14);let h="";for(const p in a){const f=a[p];if(f!=null){const m=f.shape||n.shape,g=m.length;h+=`${p}: ${g}D ${g>0?m:""} `}}console.log(`%c${u}	%c${o}	%c${c}D ${d}	%c${l}	%c${h}	%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fDe(e,t,n){const r={},s={};for(let u=0;u<t.length;u++)r[t[u].id]=!0;for(let u=0;u<e.length;u++){const c=e[u],l=c.inputs;for(const d in l){const h=l[d];let p=!1;for(let f=0;f<t.length;f++)if(r[h.id]){c.outputs.forEach(m=>r[m.id]=!0),p=!0,s[c.id]=!0;break}if(p)break}}const a={};a[n.id]=!0;const i={};for(let u=e.length-1;u>=0;u--){const c=e[u],l=c.inputs;for(let d=0;d<c.outputs.length;d++)if(a[c.outputs[d].id]){for(const h in l)a[l[h].id]=!0,i[c.id]=!0;break}}const o=[];for(let u=0;u<e.length;u++){const c=e[u];if(s[c.id]&&i[c.id]){const l={};for(const h in c.inputs){const p=c.inputs[h];r[p.id]&&(l[h]=p)}const d=Object.assign({},c);d.inputs=l,d.outputs=c.outputs,o.push(d)}}return o}function mDe(e,t,n,r){for(let s=t.length-1;s>=0;s--){const a=t[s],i=[];if(a.outputs.forEach(u=>{const c=e[u.id];c!=null?i.push(c):i.push(null)}),a.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);const o=a.gradient(i);for(const u in a.inputs){if(!(u in o))throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(o)}.`);const c=n(()=>o[u]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${c.dtype}'`);const l=a.inputs[u];if(!Nn(c.shape,l.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${u}' has shape '${c.shape}', which does not match the shape of the input '${l.shape}'`);if(e[l.id]==null)e[l.id]=c;else{const d=e[l.id];e[l.id]=r(d,c),d.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W_=20,Rb=3,xk=7;function gDe(e,t,n,r){const s=ot(t),a=bDe(e,t,n,s),i=t.length,o=X2(e,t,n,s,a),u=["Tensor"];return r&&(u.push(`  dtype: ${n}`),u.push(`  rank: ${i}`),u.push(`  shape: [${t}]`),u.push("  values:")),u.push(o.map(c=>"    "+c).join(`
`)),u.join(`
`)}function bDe(e,t,n,r){const s=fe(t),a=r[r.length-1],i=new Array(a).fill(0),o=t.length,u=n==="complex64"?qb(e):e;if(o>1)for(let c=0;c<s/a;c++){const l=c*a;for(let d=0;d<a;d++)i[d]=Math.max(i[d],jb(u[l+d],0,n).length)}return i}function jb(e,t,n){let r;return Array.isArray(e)?r=`${parseFloat(e[0].toFixed(xk))} + ${parseFloat(e[1].toFixed(xk))}j`:K0(e)?r=`'${e}'`:n==="bool"?r=eW(e):r=parseFloat(e.toFixed(xk)).toString(),Ap(r,t)}function eW(e){return e===0?"false":"true"}function X2(e,t,n,r,s,a=!0){const i=n==="complex64"?2:1,o=t[0],u=t.length;if(u===0){if(n==="complex64"){const m=qb(e);return[jb(m[0],0,n)]}return n==="bool"?[eW(e[0])]:[e[0].toString()]}if(u===1){if(o>W_){const g=Rb*i;let b=Array.from(e.slice(0,g)),y=Array.from(e.slice((o-Rb)*i,o*i));return n==="complex64"&&(b=qb(b),y=qb(y)),["["+b.map((x,w)=>jb(x,s[w],n)).join(", ")+", ..., "+y.map((x,w)=>jb(x,s[o-Rb+w],n)).join(", ")+"]"]}return["["+(n==="complex64"?qb(e):Array.from(e)).map((g,b)=>jb(g,s[b],n)).join(", ")+"]"]}const c=t.slice(1),l=r.slice(1),d=r[0]*i,h=[];if(o>W_){for(let m=0;m<Rb;m++){const g=m*d,b=g+d;h.push(...X2(e.slice(g,b),c,n,l,s,!1))}h.push("...");for(let m=o-Rb;m<o;m++){const g=m*d,b=g+d;h.push(...X2(e.slice(g,b),c,n,l,s,m===o-1))}}else for(let m=0;m<o;m++){const g=m*d,b=g+d;h.push(...X2(e.slice(g,b),c,n,l,s,m===o-1))}const p=u===2?",":"";h[0]="["+(o>0?h[0]+p:"");for(let m=1;m<h.length-1;m++)h[m]=" "+h[m]+p;let f=`,
`;for(let m=2;m<u;m++)f+=`
`;return h[h.length-1]=" "+h[h.length-1]+"]"+(a?"":f),h}function qb(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ms{constructor(t,n,r){if(this.dtype=n,this.shape=t.slice(),this.size=fe(t),r!=null){const s=r.length;U(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if(n==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||wr(n,this.size),this.strides=ot(t)}set(t,...n){n.length===0&&(n=[0]),U(n.length===this.rank,()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`);const r=this.locToIndex(n);this.values[r]=t}get(...t){t.length===0&&(t=[0]);let n=0;for(const s of t){if(s<0||s>=this.shape[n]){const a=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(a)}n++}let r=t[t.length-1];for(let s=0;s<t.length-1;++s)r+=this.strides[s]*t[s];return this.values[r]}locToIndex(t){if(this.rank===0)return 0;if(this.rank===1)return t[0];let n=t[t.length-1];for(let r=0;r<t.length-1;++r)n+=this.strides[r]*t[r];return n}indexToLoc(t){if(this.rank===0)return[];if(this.rank===1)return[t];const n=new Array(this.shape.length);for(let r=0;r<n.length-1;++r)n[r]=Math.floor(t/this.strides[r]),t-=n[r]*this.strides[r];return n[n.length-1]=t,n}get rank(){return this.shape.length}toTensor(){return Oi().makeTensor(this.values,this.shape,this.dtype)}}let Oi=null,Ip=null;function yDe(e){Oi=e}function xDe(e){Ip=e}class Br{constructor(t,n,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=n||"float32",this.size=fe(t),this.strides=ot(t),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return Ip.buffer(this.shape,this.dtype,t)}bufferSync(){return Ip.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return Vi(this.shape,t,this.dtype==="complex64")}arraySync(){return Vi(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const t=Oi().read(this.dataId);if(this.dtype==="string"){const n=await t;try{return n.map(r=>cu(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){return this.throwIfDisposed(),Oi().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=Oi().readSync(this.dataId);if(this.dtype==="string")try{return t.map(n=>cu(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await Oi().read(this.dataId);return this.dtype==="string"?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Oi().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return Ip.print(this,t)}clone(){return this.throwIfDisposed(),Ip.clone(this)}toString(t=!1){const n=this.dataSync();return gDe(n,this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),Ip.cast(this,t)}variable(t=!0,n,r){return this.throwIfDisposed(),Oi().makeVariable(this,t,n,r)}}Object.defineProperty(Br,Symbol.hasInstance,{value:e=>!!e&&e.data!=null&&e.dataSync!=null&&e.throwIfDisposed!=null});function Te(){return uE("Tensor",()=>Br)}Te();class Ox extends Br{constructor(t,n,r,s){super(t.shape,t.dtype,t.dataId,s),this.trainable=n,this.name=r}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!Nn(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);Oi().disposeTensor(this),this.dataId=t.dataId,Oi().incRef(this,null)}dispose(){Oi().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(Ox,Symbol.hasInstance,{value:e=>e instanceof Br&&e.assign!=null&&e.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var V_;(function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"})(V_||(V_={}));var sS;(function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"})(sS||(sS={}));var aS;(function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"})(aS||(aS={}));var iS;(function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"})(iS||(iS={}));var oS;(function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"})(oS||(oS={}));const wDe={float32:iS,int32:sS,bool:aS,complex64:oS};function $a(e,t){if(e==="string"||t==="string"){if(e==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return wDe[e][t]}function $E(e){return $a(e,"int32")}function tW(e){return e!=null&&typeof e=="object"&&"texture"in e&&e.texture instanceof WebGLTexture}function nW(e){return typeof GPUBuffer<"u"&&e!=null&&typeof e=="object"&&"buffer"in e&&e.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ir(e,t){if(e.dtype===t.dtype)return[e,t];const n=$a(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function rW(e){const t=[];return sW(e,t,new Set),t}function sW(e,t,n){if(e==null)return;if(e instanceof Br){t.push(e);return}if(!vDe(e))return;const r=e;for(const s in r){const a=r[s];n.has(a)||(n.add(a),sW(a,t,n))}}function vDe(e){return Array.isArray(e)||typeof e=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wk(e){return e.kernelName!=null}class U_{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class tf{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new U_}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const t=this.getSortedBackends();for(let n=0;n<t.length;n++){const r=t[n];if(await this.initializeBackend(r).success){await this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:t,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){const{asyncInit:n}=this.initializeBackend(t);if(n)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,n,r=1){return t in this.registryFactory?(Oa(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:n,priority:r},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;const{success:n,asyncInit:r}=this.initializeBackend(t);if(!(r?await n:n))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new dDe(this.backendInstance),!0}setupRegisteredKernels(){P_(this.backendName).forEach(n=>{n.setupFunc!=null&&n.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){P_(t).forEach(r=>{r.disposeFunc!=null&&r.disposeFunc(this.registry[t])})}initializeBackend(t){const n=this.registryFactory[t];if(n==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const r=n.factory();if(r&&!(r instanceof Pv)&&typeof r.then=="function"){const s=++this.pendingBackendInitId,a=r.then(i=>s<this.pendingBackendInitId?!1:(this.registry[t]=i,this.pendingBackendInit=null,!0)).catch(i=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,Oa(`Initialization of backend ${t} failed`),Oa(i.stack||i.message)),!1));return this.pendingBackendInit=a,{success:a,asyncInit:!0}}else return this.registry[t]=r,{success:!0,asyncInit:!1}}catch(r){return Oa(`Initialization of backend ${t} failed`),Oa(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,n)=>this.registryFactory[n].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let n=0;n<t.length;n++){const r=t[n],{success:s,asyncInit:a}=this.initializeBackend(r);if(a||s)return{name:r,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,n){const r=this.state.tensorInfo.get(n),s=r.backend,a=this.readSync(n),i=s.refCount(n);s.disposeData(n,!0),r.backend=t,t.move(n,a,r.shape,r.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,n){let r=null;if(n==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");n=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof n!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=t}let s;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(s),()=>(s=n(),s instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(t,n,r){t();try{const s=r();return n(),s}catch(s){throw n(),s}}nextTensorId(){return tf.nextTensorId++}nextVariableId(){return tf.nextVariableId++}clone(t){const n=pe.runKernel(dg,{x:t}),r={x:t},s=i=>({x:()=>{const o="float32",u={x:i},c={dtype:o};return pe.runKernel(jm,u,c)}}),a=[];return this.addTapeNode(this.state.activeScope.name,r,[n],s,a,{}),n}runKernel(t,n,r){if(this.backendName==null&&this.backend,!(O_(t,this.backendName)!=null))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:n,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,n,r){const s=this.backend.numDataIds();let a=0;r.forEach(u=>{a+=u.dtype==="complex64"?3:1});const i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=s-n-a-i;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${t}'`)}runKernelFunc(t){let n,r=[];const s=this.isTapeOn(),a=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let o;this.backendName==null&&this.backend;let u;const c=wk(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(wk(t)){const{kernelName:f,inputs:m,attrs:g}=t;this.backendName==null&&this.backend;const b=O_(f,this.backendName);U(b!=null,()=>`Cannot find registered kernel '${f}' for backend '${this.backendName}'`),o=()=>{const y=this.backend.numDataIds();u=b.kernelFunc({inputs:m,attrs:g,backend:this.backend});const x=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(f,y,x);const w=x.map(v=>v.rank!=null?v:this.makeTensorFromTensorInfo(v));if(s){const v=this.getTensorsForGradient(f,m,w);r=this.saveTensorsForBackwardMode(v)}return w}}else{const{forwardFunc:f}=t,m=g=>{s&&(r=g.map(b=>this.keep(this.clone(b))))};o=()=>{const g=this.backend.numDataIds();u=this.tidy(()=>f(this.backend,m));const b=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,g,b),b}}const{inputs:l,attrs:d}=t,h=wk(t)?null:t.backwardsFunc;let p;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?n=o():(p=this.profiler.profileKernel(c,l,()=>o()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),n=p.outputs)}),s&&this.addTapeNode(c,l,n,h,r,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(l).map(f=>l[f]!=null?l[f].shape:null),outputShapes:n.map(f=>f.shape),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(u)?n:n[0]}saveTensorsForBackwardMode(t){return t.map(r=>this.keep(this.clone(r)))}getTensorsForGradient(t,n,r){const s=L_(t);if(s!=null){const a=s.inputsToSave||[],i=s.outputsToSave||[];let o;s.saveAllInputs?(U(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),o=Object.keys(n).map(c=>n[c])):o=a.map(c=>n[c]);const u=r.filter((c,l)=>i[l]);return o.concat(u)}return[]}makeTensor(t,n,r,s){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",s=s||this.backend;let a=t;r==="string"&&K0(t[0])&&(a=t.map(u=>jl(u)));const i=s.write(a,n,r),o=new Br(n,r,i,this.nextTensorId());if(this.trackTensor(o,s),r==="string"){const u=this.state.tensorInfo.get(i),c=W_e(a);this.state.numBytes+=c-u.bytes,u.bytes=c}return o}makeTensorFromDataId(t,n,r,s){r=r||"float32";const a={dataId:t,shape:n,dtype:r};return this.makeTensorFromTensorInfo(a,s)}makeTensorFromTensorInfo(t,n){const{dataId:r,shape:s,dtype:a}=t,i=new Br(s,a,r,this.nextTensorId());return this.trackTensor(i,n),i}makeVariable(t,n=!0,r,s){r=r||this.nextVariableId().toString(),s!=null&&s!==t.dtype&&(t=t.cast(s));const a=new Ox(t,n,r,this.nextTensorId());if(this.state.registeredVariables[a.name]!=null)throw new Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(t,n){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let r=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(r=t.size*Jp(t.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:n||this.backend,dtype:t.dtype,shape:t.shape,bytes:r})),t instanceof Ox||this.track(t)}incRef(t,n){this.trackTensor(t,n),this.backend.incRef(t.dataId)}removeDataId(t,n){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===n&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const n=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){const r=t.size*Jp(t.dtype);this.state.numBytes-=r}n.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,n.backend)}disposeVariables(){for(const t in this.state.registeredVariables){const n=this.state.registeredVariables[t];this.disposeVariable(n)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const n=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-r;for(const s of this.state.activeProfile.kernels)s.kernelTimeMs=await s.kernelTimeMs,s.extraInfo=await s.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,n,r,s,a,i){const o={id:this.state.nextTapeNodeId++,kernelName:t,inputs:n,outputs:r,saved:a},u=L_(t);u!=null&&(s=u.gradFunc),s!=null&&(o.gradient=c=>(c=c.map((l,d)=>{if(l==null){const h=r[d],p=Cs(h.size,h.dtype);return this.makeTensor(p,h.shape,h.dtype)}return l}),s(c.length>1?c:c[0],a,i))),this.state.activeTape.push(o)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(n.name=t),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(t){const n=rW(t),r=new Set(n.map(a=>a.id));for(let a=0;a<this.state.activeScope.track.length;a++){const i=this.state.activeScope.track[a];!i.kept&&!r.has(i.id)&&i.dispose()}const s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(a=>{!a.kept&&a.scopeId===s.id&&this.track(a)})}gradients(t,n,r,s=!1){if(U(n.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);const a=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));U(a instanceof Br,()=>"The result y returned by f() must be a tensor.");const i=fDe(this.state.activeTape,n,a);if(!s&&i.length===0&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const o={};o[a.id]=r??IDe(a.shape),mDe(o,i,c=>this.tidy(c),kDe);const u=n.map(c=>o[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(const l of c.saved)l.dispose()}),this.state.activeTape=null),{value:a,grads:u}})}customGrad(t){return U(eS(t),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{U(n.every(o=>o instanceof Br),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r;const s={};n.forEach((o,u)=>{s[u]=o});const a=(o,u)=>(r=t(...n,u),U(r.value instanceof Br,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),U(eS(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),i=(o,u)=>{const c=r.gradFunc(o,u),l=Array.isArray(c)?c:[c];U(l.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),U(l.every(h=>h instanceof Br),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const d={};return l.forEach((h,p)=>{d[p]=()=>h}),d};return this.runKernelFunc({forwardFunc:a,backwardsFunc:i,inputs:s})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,n){return this.state.tensorInfo.get(t).backend.readToGPU(t,n)}async time(t){const n=ws(),r=await this.backend.time(t);return r.wallMs=ws()-n,r}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new U_;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}tf.nextTensorId=0;tf.nextVariableId=0;function IDe(e){const t=oE(fe(e),"float32");return pe.makeTensor(t,e,"float32")}function aW(){const e=Gz();if(e._tfengine==null){const t=new G_e(e);e._tfengine=new tf(t)}return K_e(e._tfengine.ENV),yDe(()=>e._tfengine),e._tfengine}const pe=aW();function kDe(e,t){const n={a:e,b:t};return pe.runKernel(Xh,n)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CDe(){return typeof navigator<"u"&&navigator!=null}function iW(e){if(e||CDe()){if(e||(e=navigator),e.product==="ReactNative")return!0;const t=e.userAgent||e.vendor||(typeof window<"u"?window.opera:"");if(!t){const n=e;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function oW(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const da=ke();da.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});da.registerFlag("IS_BROWSER",()=>oW());da.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");da.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));da.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));da.registerFlag("PROD",()=>!1);da.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>da.getBool("DEBUG"));da.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);da.registerFlag("IS_TEST",()=>!1);da.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>da.getBool("DEBUG"));da.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);da.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);da.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lI(e,t){let n=e;if(pi(e))return t==="string"?[]:[e.length];if(tW(e)){const s=e.channels||"RGBA";return[e.height,e.width*s.length]}else if(nW(e))return[e.buffer.size/(t==null?4:Jp(t))];if(!Array.isArray(e))return[];const r=[];for(;Array.isArray(n)||pi(n)&&t!=="string";)r.push(n.length),n=n[0];return Array.isArray(e)&&ke().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&lW(e,r,[]),r}function lW(e,t,n){if(n=n||[],!Array.isArray(e)&&!pi(e)){U(t.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}U(t.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`),U(e.length===t[0],()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`);const r=t.slice(1);for(let s=0;s<e.length;++s)lW(e[s],r,n.concat(s))}function G_(e,t,n,r){if(e!=="string_or_numeric"){if(e==null)throw new Error("Expected dtype cannot be null.");if(e!=="numeric"&&e!==t||e==="numeric"&&t==="string")throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function Z(e,t,n,r="numeric"){if(e instanceof Te())return G_(r,e.dtype,t,n),e;let s=Kh(e);if(s!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),G_(r,s,t,n),e==null||!pi(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string"){const u=e==null?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${u}'`)}const a=lI(e,s);!pi(e)&&!Array.isArray(e)&&(e=[e]);const o=s!=="string"?Zh(e,s):rd(e,[],!0);return pe.makeTensor(o,a,s)}function uW(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((a,i)=>Z(a,`${t}[${i}]`,n,r))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SDe="__op";function ye(e){const t=Object.keys(e);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+SDe;const s=(...a)=>{pe.startScope(n);try{const i=r(...a);return lE(i)&&console.error("Cannot return a Promise inside of tidy."),pe.endScope(i),i}catch(i){throw pe.endScope(null),i}};return Object.defineProperty(s,"name",{value:n,configurable:!0}),s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NDe(e,t){const n=Z(e,"real","complex"),r=Z(t,"imag","complex");Bv(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);const s={real:n,imag:r};return pe.runKernel(dE,s)}const nf=ye({complex_:NDe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uI(e,t,n,r){if(r==null)r=Kh(e);else if(r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(nW(e)||tW(e)){if(r!=="float32"&&r!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return pe.backend.createTensorFromGPUData(e,t||n,r)}if(!pi(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){wl(t);const s=fe(t),a=fe(n);U(s===a,()=>`Based on the provided shape, [${t}], the tensor should have ${s} values but has ${a}`);for(let i=0;i<n.length;++i){const o=n[i],u=i===n.length-1?o!==fe(t.slice(i)):!0;U(n[i]===t[i]||!u,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return!pi(e)&&!Array.isArray(e)&&(e=[e]),t=t||n,e=r!=="string"?Zh(e,r):rd(e,[],!0),pe.makeTensor(e,t,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RE(e,t,n){const r=lI(e,n);return uI(e,t,r,n)}class eb{static join(t){return new eb(t).slice()}constructor(t){if(this.shards=[],this.previousShardIndex=0,t==null||(t instanceof Array||(t=[t]),t=t.map(r=>pi(r)?r.buffer:r),t.length===0))return;this.bufferUniformSize=t[0].byteLength;let n=0;for(let r=0;r<t.length;r++){const s=t[r];r!==t.length-1&&s.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const a=n+s.byteLength;this.shards.push({buffer:s,start:n,end:a}),n=a}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,n=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,n=isNaN(Number(n))?0:n,t=Math.max(0,t),n=Math.min(this.byteLength,n),n<=t)return new ArrayBuffer(0);const r=this.findShardForByte(t);if(r===-1)throw new Error(`Could not find start shard for byte ${t}`);const s=n-t,a=new ArrayBuffer(s),i=new Uint8Array(a);let o=0;for(let u=r;u<this.shards.length;u++){const c=this.shards[u],d=t+o-c.start,h=o,f=Math.min(n,c.end)-c.start,m=new Uint8Array(c.buffer,d,f-d);if(i.set(m,h),o+=m.length,n<c.end)break}return a}findShardForByte(t){if(this.shards.length===0||t<0||t>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function n(s){return t<s.start?-1:t>=s.end?1:0}if(n(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const r=TDe(this.shards,n);return r===-1?-1:(this.previousShardIndex=r,this.previousShardIndex)}}function TDe(e,t){let n=0,r=e.length;for(;n<=r;){const s=Math.floor((r-n)/2)+n,a=t(e[s]);if(a===0)return s;a<0?r=s:n=s+1}return-1}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fi(){return pe}function H_(){return pe.memory()}function we(e,t){return pe.tidy(e,t)}function tn(e){rW(e).forEach(n=>n.dispose())}function ko(e){return pe.keep(e)}function j_(e){return pe.setBackend(e)}function q_(){return pe.ready()}function _E(e,t,n=1){return pe.registerBackend(e,t,n)}function EDe(){return pe.backend}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const K_=4;async function X_(e,t){const n=[],r=[],s=Array.isArray(e)?e.map(i=>i.name):Object.keys(e);for(let i=0;i<s.length;++i){const o=s[i],u=Array.isArray(e)?e[i].tensor:e[o];if(u.dtype!=="float32"&&u.dtype!=="int32"&&u.dtype!=="bool"&&u.dtype!=="string"&&u.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${o}': ${u.dtype}`);const c={name:o,shape:u.shape,dtype:u.dtype};if(u.dtype==="string"){const l=new Promise(async d=>{const h=await u.bytes(),p=h.reduce((g,b)=>g+b.length,0)+K_*h.length,f=new Uint8Array(p);let m=0;for(let g=0;g<h.length;g++){const b=h[g],y=new Uint8Array(new Uint32Array([b.length]).buffer);f.set(y,m),m+=K_,f.set(b,m),m+=b.length}d(f)});r.push(l)}else r.push(u.data());t!=null&&(c.group=t),n.push(c)}const a=await Promise.all(r);return{data:ADe(a),specs:n}}function ADe(e){if(e===null)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0;const n=[];e.forEach(a=>{if(t+=a.byteLength,n.push(a.byteLength===a.buffer.byteLength?a:new a.constructor(a)),!(a instanceof Float32Array||a instanceof Int32Array||a instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${a.constructor.name}`)});const r=new Uint8Array(t);let s=0;return n.forEach(a=>{r.set(new Uint8Array(a.buffer),s),s+=a.byteLength}),r.buffer}const DE=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function Q_(e){return DE?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function $De(e){if(DE)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let r=0,s=t.length;r<s;r++)n+=String.fromCharCode(t[r]);return btoa(n)}function RDe(e){if(DE){const r=Buffer.from(e,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let r=0;r<t.length;++r)n.set([t.charCodeAt(r)],r);return n.buffer}function _De(e){return eb.join(e)}function cW(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:e.modelTopology==null?0:Q_(JSON.stringify(e.modelTopology)),weightSpecsBytes:e.weightSpecs==null?0:Q_(JSON.stringify(e.weightSpecs)),weightDataBytes:e.weightData==null?0:new eb(e.weightData).byteLength}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ds{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Ds.instance==null&&(Ds.instance=new Ds),Ds.instance}static registerSaveRouter(t){Ds.getInstance().saveRouters.push(t)}static registerLoadRouter(t){Ds.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return Ds.getHandlers(t,"save")}static getLoadHandlers(t,n){return Ds.getHandlers(t,"load",n)}static getHandlers(t,n,r){const s=[];return(n==="load"?Ds.getInstance().loadRouters:Ds.getInstance().saveRouters).forEach(i=>{const o=i(t,r);o!==null&&s.push(o)}),s}}const DDe=e=>Ds.getSaveHandlers(e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lS="tensorflowjs",uS=1,Nc="models_store",Pl="model_info_store";function dW(){if(!ke().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e=typeof window>"u"?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function cS(e){const t=e.result;t.createObjectStore(Nc,{keyPath:"modelPath"}),t.createObjectStore(Pl,{keyPath:"modelPath"})}class sd{constructor(t){if(this.indexedDB=dW(),t==null||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,n){return new Promise((r,s)=>{const a=this.indexedDB.open(lS,uS);a.onupgradeneeded=()=>cS(a),a.onsuccess=()=>{const i=a.result;if(n==null){const o=i.transaction(Nc,"readonly"),c=o.objectStore(Nc).get(this.modelPath);c.onsuccess=()=>{if(c.result==null)return i.close(),s(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));r(c.result.modelArtifacts)},c.onerror=l=>(i.close(),s(c.error)),o.oncomplete=()=>i.close()}else{n.weightData=eb.join(n.weightData);const o=cW(n),u=i.transaction(Pl,"readwrite");let c=u.objectStore(Pl),l;try{l=c.put({modelPath:this.modelPath,modelArtifactsInfo:o})}catch(h){return s(h)}let d;l.onsuccess=()=>{d=i.transaction(Nc,"readwrite");const h=d.objectStore(Nc);let p;try{p=h.put({modelPath:this.modelPath,modelArtifacts:n,modelArtifactsInfo:o})}catch(f){return s(f)}p.onsuccess=()=>r({modelArtifactsInfo:o}),p.onerror=f=>{c=u.objectStore(Pl);const m=c.delete(this.modelPath);m.onsuccess=()=>(i.close(),s(p.error)),m.onerror=g=>(i.close(),s(p.error))}},l.onerror=h=>(i.close(),s(l.error)),u.oncomplete=()=>{d==null?i.close():d.oncomplete=()=>i.close()}}},a.onerror=i=>s(a.error)})}}sd.URL_SCHEME="indexeddb://";const hW=e=>ke().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(sd.URL_SCHEME)?FDe(e.slice(sd.URL_SCHEME.length)):null;Ds.registerSaveRouter(hW);Ds.registerLoadRouter(hW);function FDe(e){return new sd(e)}function MDe(e){return e.startsWith(sd.URL_SCHEME)?e.slice(sd.URL_SCHEME.length):e}class ODe{constructor(){this.indexedDB=dW()}async listModels(){return new Promise((t,n)=>{const r=this.indexedDB.open(lS,uS);r.onupgradeneeded=()=>cS(r),r.onsuccess=()=>{const s=r.result,a=s.transaction(Pl,"readonly"),o=a.objectStore(Pl).getAll();o.onsuccess=()=>{const u={};for(const c of o.result)u[c.modelPath]=c.modelArtifactsInfo;t(u)},o.onerror=u=>(s.close(),n(o.error)),a.oncomplete=()=>s.close()},r.onerror=s=>n(r.error)})}async removeModel(t){return t=MDe(t),new Promise((n,r)=>{const s=this.indexedDB.open(lS,uS);s.onupgradeneeded=()=>cS(s),s.onsuccess=()=>{const a=s.result,i=a.transaction(Pl,"readwrite"),o=i.objectStore(Pl),u=o.get(t);let c;u.onsuccess=()=>{if(u.result==null)return a.close(),r(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const l=o.delete(t),d=()=>{c=a.transaction(Nc,"readwrite");const p=c.objectStore(Nc).delete(t);p.onsuccess=()=>n(u.result.modelArtifactsInfo),p.onerror=f=>r(u.error)};l.onsuccess=d,l.onerror=h=>(d(),a.close(),r(u.error))}},u.onerror=l=>(a.close(),r(u.error)),i.oncomplete=()=>{c==null?a.close():c.oncomplete=()=>a.close()}},s.onerror=a=>r(s.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const el="/",kp="tensorflowjs_models",pW="info",LDe="model_topology",PDe="weight_specs",BDe="weight_data",zDe="model_metadata";function fW(e){return{info:[kp,e,pW].join(el),topology:[kp,e,LDe].join(el),weightSpecs:[kp,e,PDe].join(el),weightData:[kp,e,BDe].join(el),modelMetadata:[kp,e,zDe].join(el)}}function mW(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function WDe(e){const t=e.split(el);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(el)}function VDe(e){return e.startsWith(ad.URL_SCHEME)?e.slice(ad.URL_SCHEME.length):e}class ad{constructor(t){if(!ke().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,t==null||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=fW(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(t.modelTopology),r=JSON.stringify(t.weightSpecs),s=cW(t),a=eb.join(t.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,$De(a));const i={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:t.signature!=null?t.signature:void 0,userDefinedMetadata:t.userDefinedMetadata!=null?t.userDefinedMetadata:void 0,modelInitializer:t.modelInitializer!=null?t.modelInitializer:void 0,initializerSignature:t.initializerSignature!=null?t.initializerSignature:void 0,trainingConfig:t.trainingConfig!=null?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(i)),{modelArtifactsInfo:s}}catch{throw mW(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(t==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(t.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const n={},r=JSON.parse(this.LS.getItem(this.keys.topology));if(r==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);n.modelTopology=r;const s=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(s==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);n.weightSpecs=s;const a=this.LS.getItem(this.keys.modelMetadata);if(a!=null){const o=JSON.parse(a);n.format=o.format,n.generatedBy=o.generatedBy,n.convertedBy=o.convertedBy,o.signature!=null&&(n.signature=o.signature),o.userDefinedMetadata!=null&&(n.userDefinedMetadata=o.userDefinedMetadata),o.modelInitializer!=null&&(n.modelInitializer=o.modelInitializer),o.initializerSignature!=null&&(n.initializerSignature=o.initializerSignature),o.trainingConfig!=null&&(n.trainingConfig=o.trainingConfig)}const i=this.LS.getItem(this.keys.weightData);if(i==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return n.weightData=RDe(i),n}}ad.URL_SCHEME="localstorage://";const gW=e=>ke().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(ad.URL_SCHEME)?UDe(e.slice(ad.URL_SCHEME.length)):null;Ds.registerSaveRouter(gW);Ds.registerLoadRouter(gW);function UDe(e){return new ad(e)}class GDe{constructor(){U(ke().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),U(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const t={},n=kp+el,r=el+pW;for(let s=0;s<this.LS.length;++s){const a=this.LS.key(s);if(a.startsWith(n)&&a.endsWith(r)){const i=WDe(a);t[i]=JSON.parse(this.LS.getItem(a))}}return t}async removeModel(t){t=VDe(t);const n=fW(t);if(this.LS.getItem(n.info)==null)throw new Error(`Cannot find model at path '${t}'`);const r=JSON.parse(this.LS.getItem(n.info));return mW(n),r}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y_="://";class lo{constructor(){this.managers={}}static getInstance(){return lo.instance==null&&(lo.instance=new lo),lo.instance}static registerManager(t,n){U(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(Y_)&&(t=t.slice(0,t.indexOf(Y_))),U(t.length>0,()=>"scheme must not be an empty string.");const r=lo.getInstance();U(r.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),r.managers[t]=n}static getManager(t){const n=lo.getInstance().managers[t];if(n==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return n}static getSchemes(){return Object.keys(lo.getInstance().managers)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HDe{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,n){return fetch(t,n)}now(){return performance.now()}encode(t,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${n}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,n){return new TextDecoder(n).decode(t)}setTimeoutCustom(t,n){if(typeof window>"u"||!ke().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(t,n);return}this.functionRefs.push(t),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},n),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",r=>{if(r.source===window&&r.data.name===this.messageName){r.stopPropagation();const s=this.functionRefs[r.data.index];s(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(t){return Xz(t)}}if(ke().get("IS_BROWSER")){ke().setPlatform("browser",new HDe);try{lo.registerManager(ad.URL_SCHEME,new GDe)}catch{}try{lo.registerManager(sd.URL_SCHEME,new ODe)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jDe={importFetch:()=>require("node-fetch")};let vk;class qDe{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(t,n){return ke().global.fetch!=null?ke().global.fetch(t,n):(vk==null&&(vk=jDe.importFetch()),vk(t,n))}now(){const t=process.hrtime();return t[0]*1e3+t[1]/1e6}encode(t,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${n}`);return this.textEncoder.encode(t)}decode(t,n){return t.length===0?"":new this.util.TextDecoder(n).decode(t)}isTypedArray(t){return this.util.types.isFloat32Array(t)||this.util.types.isInt32Array(t)||this.util.types.isUint8Array(t)||this.util.types.isUint8ClampedArray(t)}}ke().get("IS_NODE")&&!ke().get("IS_BROWSER")&&ke().setPlatform("node",new qDe);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yt(e,t="float32",n){return t=t||"float32",wl(e),new ms(e,t,n)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KDe(e,t){const n=Z(e,"x","cast");if(!z_e(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&n.dtype!=="string"||t!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");const r={x:n},s={dtype:t};return pe.runKernel(jm,r,s)}const at=ye({cast_:KDe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XDe(e){const n={x:Z(e,"x","clone","string_or_numeric")};return pe.runKernel(dg,n)}const Dc=ye({clone_:XDe});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QDe(e,t=!1){console.log(e.toString(t))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */aW();const YDe={buffer:Yt,cast:at,clone:Dc,print:QDe};xDe(YDe);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JDe(e,t){let n=Z(e,"a","add"),r=Z(t,"b","add");[n,r]=Ir(n,r);const s={a:n,b:r};return pe.runKernel(Xh,s)}const We=ye({add_:JDe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZDe(e,t){let n=Z(e,"a","floorDiv"),r=Z(t,"b","floorDiv");[n,r]=Ir(n,r);const s={a:n,b:r};return pe.runKernel(lg,s)}const bW=ye({floorDiv_:ZDe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eFe(e,t){let n=Z(e,"a","div"),r=Z(t,"b","div");if([n,r]=Ir(n,r),n.dtype==="int32"&&r.dtype==="int32")return bW(n,r);const s={a:n,b:r},a={};return pe.runKernel(ng,s,a)}const Nt=ye({div_:eFe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tFe(e,t){let n=Z(e,"a","mul"),r=Z(t,"b","mul");[n,r]=Ir(n,r);const s={a:n,b:r};return pe.runKernel(Tg,s)}const ce=ye({mul_:tFe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nFe(e){const t=Z(e,"x","abs");if(t.dtype==="complex64"){const n={x:t};return pe.runKernel(Uv,n)}else{const n={x:t};return pe.runKernel(X0,n)}}const Fs=ye({abs_:nFe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rFe(e){const n={x:Z(e,"x","acos")};return pe.runKernel(Lm,n)}const sFe=ye({acos_:rFe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aFe(e){const n={x:Z(e,"x","acosh")};return pe.runKernel(Pm,n)}const iFe=ye({acosh_:aFe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oFe(e,t=null,n=!1){const s={x:Z(e,"x","all","bool")},a={axis:t,keepDims:n};return pe.runKernel(Y0,s,a)}const yW=ye({all_:oFe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lFe(e,t=null,n=!1){const s={x:Z(e,"x","any","bool")},a={axis:t,keepDims:n};return pe.runKernel(J0,s,a)}const dS=ye({any_:lFe});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uFe(e,t=0){const r={x:Z(e,"x","argMax")},s={axis:t};return pe.runKernel(Z0,r,s)}const Ty=ye({argMax_:uFe});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cFe(e,t=0){const r={x:Z(e,"x","argMin")},s={axis:t};return pe.runKernel(e1,r,s)}const dFe=ye({argMin_:cFe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hFe(e){const n={x:Z(e,"x","asin")};return pe.runKernel(Bm,n)}const pFe=ye({asin_:hFe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fFe(e){const n={x:Z(e,"x","asinh")};return pe.runKernel(zm,n)}const mFe=ye({asinh_:fFe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gFe(e){const n={x:Z(e,"x","atan")};return pe.runKernel(Wm,n)}const bFe=ye({atan_:gFe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yFe(e,t){let n=Z(e,"a","atan2"),r=Z(t,"b","atan2");[n,r]=Ir(n,r);const s={a:n,b:r};return pe.runKernel(Um,s)}const xFe=ye({atan2_:yFe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wFe(e){const n={x:Z(e,"x","atanh")};return pe.runKernel(Vm,n)}const vFe=ye({atanh_:wFe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ou(e,t,n,r,s="NHWC",a){const i=e[3],o=[...t,i],u=to(s);return yr(e,o,n,a,r,null,null,u)}function Es(e,t,n,r,s,a,i="channelsLast"){const[o,u]=Ey(t);let c;if(i==="channelsLast")c=[o,u,e[3],e[3]];else if(i==="channelsFirst")c=[o,u,e[1],e[1]];else throw new Error(`Unknown dataFormat ${i}`);return yr(e,c,n,r,s,a,!1,i)}function Qa(e,t,n,r,s,a,i="NDHWC"){const[o,u,c]=hS(t);let l,d;if(i==="NDHWC")d="channelsLast",l=[o,u,c,e[4],e[4]];else if(i==="NCDHW")d="channelsFirst",l=[o,u,c,e[1],e[1]];else throw new Error(`Unknown dataFormat ${i}`);return eo(e,l,n,r,s,!1,d,a)}function yr(e,t,n,r,s,a,i=!1,o="channelsLast"){let[u,c,l,d]=[-1,-1,-1,-1];if(o==="channelsLast")[u,c,l,d]=e;else if(o==="channelsFirst")[u,d,c,l]=e;else throw new Error(`Unknown dataFormat ${o}`);const[h,p,,f]=t,[m,g]=Ey(n),[b,y]=Ey(r),x=$p(h,b),w=$p(p,y),{padInfo:v,outHeight:I,outWidth:N}=CFe(s,c,l,m,g,x,w,a,o),T=i?f*d:f;let E;return o==="channelsFirst"?E=[u,T,I,N]:o==="channelsLast"&&(E=[u,I,N,T]),{batchSize:u,dataFormat:o,inHeight:c,inWidth:l,inChannels:d,outHeight:I,outWidth:N,outChannels:T,padInfo:v,strideHeight:m,strideWidth:g,filterHeight:h,filterWidth:p,effectiveFilterHeight:x,effectiveFilterWidth:w,dilationHeight:b,dilationWidth:y,inShape:e,outShape:E,filterShape:t}}function eo(e,t,n,r,s,a=!1,i="channelsLast",o){let[u,c,l,d,h]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[u,c,l,d,h]=e;else if(i==="channelsFirst")[u,h,c,l,d]=e;else throw new Error(`Unknown dataFormat ${i}`);const[p,f,m,,g]=t,[b,y,x]=hS(n),[w,v,I]=hS(r),N=$p(p,w),T=$p(f,v),E=$p(m,I),{padInfo:A,outDepth:k,outHeight:C,outWidth:M}=SFe(s,c,l,d,b,y,x,N,T,E,o),L=a?g*h:g;let O;return i==="channelsFirst"?O=[u,L,k,C,M]:i==="channelsLast"&&(O=[u,k,C,M,L]),{batchSize:u,dataFormat:i,inDepth:c,inHeight:l,inWidth:d,inChannels:h,outDepth:k,outHeight:C,outWidth:M,outChannels:L,padInfo:A,strideDepth:b,strideHeight:y,strideWidth:x,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:N,effectiveFilterHeight:T,effectiveFilterWidth:E,dilationDepth:w,dilationHeight:v,dilationWidth:I,inShape:e,outShape:O,filterShape:t}}function IFe(e,t,n,r,s){r==null&&(r=FE(e,t,n));const a=e[0],i=e[1],o=Ay((a-t+2*r)/n+1,s),u=Ay((i-t+2*r)/n+1,s);return[o,u]}function kFe(e,t,n,r,s,a){s==null&&(s=FE(e,t[0],r[0]));const i=[0,0,0,n];for(let o=0;o<3;o++)e[o]+2*s>=t[o]&&(i[o]=Ay((e[o]-t[o]+2*s)/r[o]+1,a));return i}function FE(e,t,n,r=1){const s=$p(t,r);return Math.floor((e[0]*(n-1)-n+s)/2)}function Ey(e){return typeof e=="number"?[e,e,e]:e.length===2?[e[0],e[1],1]:e}function hS(e){return typeof e=="number"?[e,e,e]:e}function $p(e,t){return t<=1?e:e+(e-1)*(t-1)}function CFe(e,t,n,r,s,a,i,o,u){let c,l,d;if(typeof e=="number"){c={top:e,bottom:e,left:e,right:e,type:e===0?"VALID":"NUMBER"};const p=IFe([t,n],a,r,e,o);l=p[0],d=p[1]}else if(e==="same"){l=Math.ceil(t/r),d=Math.ceil(n/s);const h=Math.max(0,(l-1)*r+a-t),p=Math.max(0,(d-1)*s+i-n),f=Math.floor(h/2),m=h-f,g=Math.floor(p/2),b=p-g;c={top:f,bottom:m,left:g,right:b,type:"SAME"}}else if(e==="valid")c={top:0,bottom:0,left:0,right:0,type:"VALID"},l=Math.ceil((t-a+1)/r),d=Math.ceil((n-i+1)/s);else if(typeof e=="object"){const h=u==="channelsLast"?e[1][0]:e[2][0],p=u==="channelsLast"?e[1][1]:e[2][1],f=u==="channelsLast"?e[2][0]:e[3][0],m=u==="channelsLast"?e[2][1]:e[3][1];c={top:h,bottom:p,left:f,right:m,type:h===0&&p===0&&f===0&&m===0?"VALID":"EXPLICIT"},l=Ay((t-a+h+p)/r+1,o),d=Ay((n-i+f+m)/s+1,o)}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:c,outHeight:l,outWidth:d}}function SFe(e,t,n,r,s,a,i,o,u,c,l){let d,h,p,f;if(e==="valid"&&(e=0),typeof e=="number"){d={top:e,bottom:e,left:e,right:e,front:e,back:e,type:e===0?"VALID":"NUMBER"};const g=kFe([t,n,r,1],[o,u,c],1,[s,a,i],e,l);h=g[0],p=g[1],f=g[2]}else if(e==="same"){h=Math.ceil(t/s),p=Math.ceil(n/a),f=Math.ceil(r/i);const m=(h-1)*s+o-t,g=(p-1)*a+u-n,b=(f-1)*i+c-r,y=Math.floor(m/2),x=m-y,w=Math.floor(g/2),v=g-w,I=Math.floor(b/2),N=b-I;d={top:w,bottom:v,left:I,right:N,front:y,back:x,type:"SAME"}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:d,outDepth:h,outHeight:p,outWidth:f}}function Ay(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function id(e){const[t,n,r]=Ey(e);return t===1&&n===1&&r===1}function bs(e,t){return id(e)||id(t)}function od(e){return Ey(e).every(t=>t>0)}function to(e){if(e==="NHWC")return"channelsLast";if(e==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function pa(e,t,n){if(n!=null){if(typeof t=="string")throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if(typeof t=="number")U(Yp(t),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);else if(typeof t=="object")t.forEach(r=>{r.forEach(s=>{U(Yp(s),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${s}.`)})});else throw Error(`Error in ${e}: Unknown padding parameter: ${t}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NFe(e,t){const r={x:Z(e,"x","reshape","string_or_numeric")},s={shape:t};return pe.runKernel($1,r,s)}const be=ye({reshape_:NFe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TFe(e,t,n,r,s){const a=Z(e,"x","avgPool","float32"),i=1;U(bs(n,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`);let o=a,u=!1;a.rank===3&&(u=!0,o=be(a,[1,a.shape[0],a.shape[1],a.shape[2]])),U(o.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),pa("avgPool",r,s);const c={x:o},l={filterSize:t,strides:n,pad:r,dimRoundingMode:s};let d=pe.runKernel(Gm,c,l);return d=at(d,a.dtype),u?be(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const ME=ye({avgPool_:TFe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EFe(e,t,n,r,s,a="NDHWC"){const i=Z(e,"x","avgPool3d","float32");let o=i,u=!1;i.rank===4&&(u=!0,o=be(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),U(o.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),U(a==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),U(typeof n=="number"&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`),pa("avgPool3d",r,s);const c={x:o},l={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a};let d=pe.runKernel(t1,c,l);return d=at(d,o.dtype),u?be(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const AFe=ye({avgPool3d_:EFe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Fe(e,t=0){U(e.length>=1,()=>"Pass at least one tensor to concat");const n=uW(e,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(a=>{if(a.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${a.dtype}. `)}),n.length===1)return Dc(n[0]);const r=n,s={axis:t};return pe.runKernel(s1,r,s)}const ia=ye({concat_:$Fe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RFe(e,t,n=!1,r=!1){let s=Z(e,"a","matMul"),a=Z(t,"b","matMul");[s,a]=Ir(s,a);const i={a:s,b:a},o={transposeA:n,transposeB:r};return pe.runKernel(Hm,i,o)}const Cn=ye({matMul_:RFe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Fe(e){const n={x:Z(e,"x","sigmoid","float32")};return pe.runKernel(Hg,n)}const tb=ye({sigmoid_:_Fe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DFe(e,t,n){const r=Z(e,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");const s={x:r},a={begin:t,size:n};return pe.runKernel(F1,s,a)}const Yn=ye({slice_:DFe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FFe(e){const n={x:Z(e,"x","tanh","float32")};return pe.runKernel(Zg,n)}const cI=ye({tanh_:FFe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MFe(e,t,n){const r=Z(e,"x","batchToSpaceND"),s=t.reduce((o,u)=>o*u);U(r.rank>=1+t.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`),U(n.length===t.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`),U(r.shape[0]%s===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${s}`);const a={x:r},i={blockShape:t,crops:n};return pe.runKernel(n1,a,i)}const OE=ye({batchToSpaceND_:MFe});function OFe(e){let t;return e.rank===0||e.rank===1?t=be(e,[1,1,1,e.size]):e.rank===2?t=be(e,[1,1,e.shape[0],e.shape[1]]):e.rank===3?t=be(e,[1,e.shape[0],e.shape[1],e.shape[2]]):t=e,t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LFe(e,t,n,r,s,a){a==null&&(a=.001);const i=Z(e,"x","batchNorm"),o=Z(t,"mean","batchNorm"),u=Z(n,"variance","batchNorm");let c;s!=null&&(c=Z(s,"scale","batchNorm"));let l;r!=null&&(l=Z(r,"offset","batchNorm")),U(o.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),U(l==null||o.rank===l.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),U(c==null||o.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const h={x:OFe(i),scale:c,offset:l,mean:o,variance:u},p={varianceEpsilon:a},f=pe.runKernel(ug,h,p);return be(f,i.shape)}const dI=ye({batchNorm_:LFe});function PFe(e,t,n,r,s,a){const i=Z(e,"x","batchNorm"),o=Z(t,"mean","batchNorm"),u=Z(n,"variance","batchNorm");let c;s!=null&&(c=Z(s,"scale","batchNorm"));let l;return r!=null&&(l=Z(r,"offset","batchNorm")),U(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),U(o.rank===2||o.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),U(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`),c!=null&&U(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),l!=null&&U(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${l.rank}.`),dI(i,o,u,l,c,a)}const BFe=ye({batchNorm2d_:PFe});function zFe(e,t,n,r,s,a){const i=Z(e,"x","batchNorm"),o=Z(t,"mean","batchNorm"),u=Z(n,"variance","batchNorm");let c;s!=null&&(c=Z(s,"scale","batchNorm"));let l;return r!=null&&(l=Z(r,"offset","batchNorm")),U(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),U(o.rank===3||o.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),U(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`),c!=null&&U(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),l!=null&&U(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${l.rank}.`),dI(i,o,u,l,c,a)}const WFe=ye({batchNorm3d_:zFe});function VFe(e,t,n,r,s,a){const i=Z(e,"x","batchNorm"),o=Z(t,"mean","batchNorm"),u=Z(n,"variance","batchNorm");let c;s!=null&&(c=Z(s,"scale","batchNorm"));let l;return r!=null&&(l=Z(r,"offset","batchNorm")),U(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),U(o.rank===4||o.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),U(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`),c!=null&&U(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),l!=null&&U(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${l.rank}.`),dI(i,o,u,l,c,a)}const UFe=ye({batchNorm4d_:VFe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GFe(e,t,n){const r=Z(e,"x","bincount"),s=Z(t,"weights","bincount");U(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),U(n>=0,()=>`size must be non-negative, but got ${n}.`),U(s.size===r.size||s.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`);const a={x:r,weights:s},i={size:n};return pe.runKernel(r1,a,i)}const HFe=ye({bincount_:GFe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jFe(e,t){let n=Z(e,"broadcastTo","x");const r=n.shape;if(wl(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){const c=n.shape.slice();for(;c.length<t.length;)c.unshift(1);n=be(n,c)}const s=n.shape,a=Array.from(t);for(let c=t.length-1;c>=0;c--)if(s[c]===t[c])a[c]=1;else if(n.shape[c]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);if(a.map((c,l)=>c>1?l:-1).filter(c=>c>=0).length===0)return Dc(n);const o={x:n},u={reps:a};return pe.runKernel(Yh,o,u)}const ry=ye({broadcastTo_:jFe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qFe(e){const n={x:Z(e,"x","ceil","float32")};return pe.runKernel(qm,n)}const KFe=ye({ceil_:qFe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hI(e,t,n){wl(e),n=n||Kh(t);const r={shape:e,value:t,dtype:n};return pe.runKernel(Hv,{},r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XFe(e,t,n){const r=Z(e,"x","clipByValue");if(U(t<=n,()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`),t===n)return hI(r.shape,t,r.dtype);const s={x:r},a={clipValueMin:t,clipValueMax:n};return pe.runKernel(Qh,s,a)}const Ka=ye({clipByValue_:XFe});function QFe(e){return ia(e,0)}const YFe=ye({concat1d_:QFe});function JFe(e,t){return ia(e,t)}const ZFe=ye({concat2d_:JFe});function e6e(e,t){return ia(e,t)}const t6e=ye({concat3d_:e6e});function n6e(e,t){return ia(e,t)}const r6e=ye({concat4d_:n6e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s6e(e,t,n,r,s="NHWC",a=[1,1],i){const o=Z(e,"x","conv2d","float32"),u=Z(t,"filter","conv2d","float32");let c=o,l=!1;o.rank===3&&(l=!0,c=be(o,[1,o.shape[0],o.shape[1],o.shape[2]])),U(c.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),U(u.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),pa("conv2d",r,i);const d=s==="NHWC"?c.shape[3]:c.shape[1];U(d===u.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${u.shape[2]}.`),U(bs(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),U(od(a),()=>"Error in conv2D: Dilated rates should be larger than 0."),U(od(n),()=>"Error in conv2D: Strides should be larger than 0.");const h={x:c,filter:u},p={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i},f=pe.runKernel(Km,h,p);return l?be(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const ld=ye({conv2d_:s6e});function a6e(e,t,n,r,s="NWC",a=1,i){const o=Z(e,"x","conv1d"),u=Z(t,"filter","conv1d");let c=o,l=!1;o.rank===2&&(l=!0,c=be(o,[1,o.shape[0],o.shape[1]])),U(c.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),U(u.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),pa("conv1d",r,i),U(c.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${u.shape[1]}.`),U(bs(n,a),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${a}'`),U(od(a),()=>"Error in conv1D: Dilated rates should be larger than 0."),U(od(n),()=>"Error in conv1D: Stride should be larger than 0."),U(s==="NWC",()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const d=be(u,[1,u.shape[0],u.shape[1],u.shape[2]]),h=be(c,[c.shape[0],1,c.shape[1],c.shape[2]]),g=ld(h,d,[1,n],r,"NHWC",[1,a],i);return l?be(g,[g.shape[2],g.shape[3]]):be(g,[g.shape[0],g.shape[2],g.shape[3]])}const xW=ye({conv1d_:a6e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i6e(e,t,n,r,s,a="NHWC",i){U(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let o=e,u=t,c=!1;t.rank===3&&(c=!0,u=be(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),U(o.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),U(u.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),U(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);const l=a==="NHWC"?o[3]:o[1],d=a==="NHWC"?u.shape[3]:u.shape[1];U(l===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[2]}.`),U(d===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${n.shape[3]}.`),pa("conv2dDerInput",s,i);const h={dy:u,filter:n},p={strides:r,pad:s,dataFormat:a,dimRoundingMode:i,inputShape:o},f=pe.runKernel(Xm,h,p);return c?be(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const LE=ye({conv2DBackpropInput_:i6e});function o6e(e,t,n,r,s,a){const i=Z(e,"x","conv2dTranspose"),o=Z(t,"filter","conv2dTranspose");return LE(n,i,o,r,s,"NHWC",a)}const wW=ye({conv2dTranspose_:o6e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l6e(e,t,n,r,s="NDHWC",a=[1,1,1]){const i=Z(e,"x","conv3d"),o=Z(t,"filter","conv3d");let u=i,c=!1;i.rank===4&&(c=!0,u=be(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),U(u.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),U(o.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),U(u.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${o.shape[3]}.`),U(bs(n,a),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),U(s==="NDHWC",()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`),U(od(a),()=>"Error in conv3D: Dilated rates should be larger than 0."),U(od(n),()=>"Error in conv3D: Strides should be larger than 0.");const l={x:u,filter:o},d={strides:n,pad:r,dataFormat:s,dilations:a},h=pe.runKernel(Qm,l,d);return c?be(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const u6e=ye({conv3d_:l6e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c6e(e,t,n,r,s){U(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let a=e,i=t,o=!1;t.rank===4&&(o=!0,i=be(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),a=[1,e[0],e[1],e[2],e[3]]);const u=a[4],c=i.shape[4];U(a.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`),U(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),U(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),U(u===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${n.shape[3]}.`),U(c===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${n.shape[4]}.`);const l={dy:i,filter:n},d={pad:s,strides:r,inputShape:a},h=pe.runKernel(i1,l,d);return o?be(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const vW=ye({conv3DBackpropInput_:c6e});function d6e(e,t,n,r,s){const a=Z(e,"x","conv3dTranspose"),i=Z(t,"filter","conv3dTranspose");return vW(n,a,i,r,s)}const h6e=ye({conv3dTranspose_:d6e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p6e(e){const n={x:Z(e,"x","cos","float32")};return pe.runKernel(Ym,n)}const PE=ye({cos_:p6e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f6e(e){const n={x:Z(e,"x","cosh","float32")};return pe.runKernel(Jm,n)}const IW=ye({cosh_:f6e});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m6e(e,t=0,n=!1,r=!1){const a={x:Z(e,"x","cumprod")},i={axis:t,exclusive:n,reverse:r};return pe.runKernel(o1,a,i)}const pS=ye({cumprod_:m6e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g6e(e,t=0,n=!1,r=!1){const a={x:Z(e,"x","cumsum")},i={axis:t,exclusive:n,reverse:r};return pe.runKernel(Zm,a,i)}const kW=ye({cumsum_:g6e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b6e(e,t,n,r=!1){const s=Z(e,"x","denseBincount"),a=Z(t,"weights","denseBincount");U(s.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),U(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),U(n>=0,()=>`size must be non-negative, but got ${n}.`),U(a.size===s.size||a.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${a.shape}.`);const i={x:s,weights:a},o={size:n,binaryOutput:r};return pe.runKernel(Gv,i,o)}const J_=ye({denseBincount_:b6e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y6e(e,t,n="NHWC"){const r=Z(e,"x","depthToSpace","float32"),s=n==="NHWC"?r.shape[1]:r.shape[2],a=n==="NHWC"?r.shape[2]:r.shape[3],i=n==="NHWC"?r.shape[3]:r.shape[1];U(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),U(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${t}  for depthToSpace with input shape
    ${r.shape}`),U(a*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${a} and ${t} for depthToSpace with input shape
        ${r.shape}`),U(i%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${r.shape}`);const o={x:r},u={blockSize:t,dataFormat:n};return pe.runKernel(u1,o,u)}const x6e=ye({depthToSpace_:y6e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w6e(e,t,n,r,s="NHWC",a=[1,1],i){const o=Z(e,"x","depthwiseConv2d","float32"),u=Z(t,"filter","depthwiseConv2d","float32");let c=o,l=!1;o.rank===3&&(l=!0,c=be(o,[1,o.shape[0],o.shape[1],o.shape[2]])),U(c.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),U(u.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`);const d=s==="NHWC"?c.shape[3]:c.shape[1];U(d===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${u.shape[2]}.`),pa("depthwiseConv2d",r,i);const h={x:c,filter:u},p={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i},f=pe.runKernel(eg,h,p);return l?be(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const BE=ye({depthwiseConv2d_:w6e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v6e(e,t,n,r,s=[1,1],a="NHWC"){const i=Z(e,"x","dilation2d"),o=Z(t,"filter","dilation2d");U(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),U(o.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),U(a==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`);let u=i,c=!1;i.rank===3&&(u=be(i,[1,i.shape[0],i.shape[1],i.shape[2]]),c=!0),U(u.shape[3]===o.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${u.shape[3]} vs ${o.shape[2]}`);const l={x:u,filter:o},d={strides:n,pad:r,dilations:s},h=pe.runKernel(tg,l,d);return c?be(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const I6e=ye({dilation2d_:v6e});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rf(e,t){const n=e.length,r=[];for(let s=0;s<n;s++){const a=n-1-s,i=e[a]||1;(t[t.length-1-s]||1)>1&&i===1&&r.unshift(a)}return r}function Xr(e,t){const n=[];for(let r=0;r<t.length;r++){const s=e[e.length-r-1],a=t.length-r-1,i=t[a];(s==null||s===1&&i>1)&&n.unshift(a)}return n}function Ot(e,t){const n=Math.max(e.length,t.length),r=new Array(n);for(let s=0;s<n;s++){let a=e[e.length-s-1];a==null&&(a=1);let i=t[t.length-s-1];if(i==null&&(i=1),a===1)r[n-s-1]=i;else if(i===1)r[n-s-1]=a;else if(a!==i){const o=`Operands could not be broadcast together with shapes ${e} and ${t}.`;throw Error(o)}else r[n-s-1]=a}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k6e(e,t){let n=Z(e,"a","equal","string_or_numeric"),r=Z(t,"b","equal","string_or_numeric");[n,r]=Ir(n,r),Ot(n.shape,r.shape);const s={a:n,b:r};return pe.runKernel(d1,s)}const $o=ye({equal_:k6e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C6e(e,t,n){const r=Z(t,"a","where"),s=Z(n,"b","where"),a=Z(e,"condition","where","bool"),i=Ot(Ot(a.shape,r.shape),s.shape),o=ry(a,i),u=ry(r,i),c=ry(s,i),l={condition:o,t:u,e:c};return pe.runKernel(D1,l)}const Ws=ye({where_:C6e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S6e(e){const n={x:Z(e,"x","zerosLike")};return pe.runKernel(W1,n)}const cn=ye({zerosLike_:S6e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N6e(e,t){let n=Z(e,"a","div"),r=Z(t,"b","div");[n,r]=Ir(n,r);const s=Nt(n,r),a=cn(s),i=$o(r,a);return Ws(i,a,s)}const T6e=ye({divNoNan_:N6e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E6e(e,t){const n=Z(e,"t1","dot"),r=Z(t,"t2","dot");U((n.rank===1||n.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`);const s=n.rank===1?n.size:n.shape[1],a=r.rank===1?r.size:r.shape[0];if(U(s===a,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${a}.`),n.rank===1&&r.rank===1){const i=be(n,[1,-1]),o=be(r,[-1,1]),u=Cn(i,o);return be(u,[])}else if(n.rank===1&&r.rank===2){const i=be(n,[1,-1]),o=be(r,[r.shape[0],r.shape[1]]),u=Cn(i,o);return be(u,[u.size])}else if(n.rank===2&&r.rank===1){const i=be(r,[-1,1]),o=Cn(n,i);return be(o,[o.size])}else{const i=be(r,[r.shape[0],r.shape[1]]);return Cn(n,i)}}const A6e=ye({dot_:E6e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $6e(e,...t){const n=t.map((s,a)=>Z(s,`tensors${a}`,"einsum")),r={equation:e};return pe.runKernel(gE,n,r)}const _b=ye({einsum_:$6e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R6e(e){const n={x:Z(e,"x","elu","float32")};return pe.runKernel(rg,n)}const pI=ye({elu_:R6e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _6e(e){let t=Z(e,"x","erf");U(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=at(t,"float32"));const n={x:t};return pe.runKernel(sg,n)}const CW=ye({erf_:_6e});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zE(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function SW(e,t,n){const r=e.length+t.length,s=[];let a=0,i=0;for(let o=0;o<r;o++)n.indexOf(o)===-1?s.push(e[a++]):s.push(t[i++]);return s}function sr(e,t){const n=[],r=e.length;for(let a=0;a<r;a++)t.indexOf(a)===-1&&n.push(e[a]);const s=t.map(a=>e[a]);return[n,s]}function jn(e,t){const n=t.map(r=>1);return SW(e,n,t)}function tr(e,t,n){U(zE(t,n),()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`)}function nr(e,t){if(zE(e,t))return null;const n=[];for(let r=0;r<t;++r)e.indexOf(r)===-1&&n.push(r);return e.forEach(r=>n.push(r)),n}function Bo(e){return e.map((t,n)=>[n,t]).sort((t,n)=>t[1]-n[1]).map(t=>t[0])}function qn(e,t){const n=[];for(let r=t-e;r<t;++r)n.push(r);return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D6e(e,t=null,n=!1){const s={x:Z(e,"x","max")},a={reductionIndices:t,keepDims:n};return pe.runKernel(xg,s,a)}const Ui=ye({max_:D6e});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F6e(e,t=null,n=!1){const s={x:Z(e,"x","min")},a={axis:t,keepDims:n};return pe.runKernel(kg,s,a)}const Lx=ye({min_:F6e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M6e(e,t){let n=Z(e,"base","pow"),r=Z(t,"exp","pow");[n,r]=Ir(n,r);const s={a:n,b:r};return pe.runKernel($g,s)}const ud=ye({pow_:M6e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sn(e,t){if((pi(e)&&t!=="string"||Array.isArray(e))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&pi(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return uI(e,[],[],t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O6e(e){const n={x:Z(e,"x","sqrt","float32")};return pe.runKernel(qg,n)}const Ss=ye({sqrt_:O6e});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L6e(e){const t=Z(e,"x","square"),n={};return pe.runKernel("Square",{x:t},n)}const rr=ye({square_:L6e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P6e(e,t=null,n=!1){let r=Z(e,"x","sum");r.dtype==="bool"&&(r=at(r,"int32"));const s={x:r},a={axis:t,keepDims:n};return pe.runKernel(Kg,s,a)}const Ct=ye({sum_:P6e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B6e(e,t="euclidean",n=null,r=!1){e=Z(e,"x","norm");const s=NW(e,t,n);let a=s.shape;if(r){const i=zt(n,e.shape);a=jn(s.shape,i)}return be(s,a)}function NW(e,t,n=null){if(e.rank===0)return Fs(e);if(e.rank!==1&&n===null)return NW(be(e,[-1]),t,n);if(e.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(t===1)return Ct(Fs(e),n);if(t===1/0)return Ui(Fs(e),n);if(t===-1/0)return Lx(Fs(e),n);if(t==="euclidean"||t===2)return Ss(Ct(ud(Fs(e),Sn(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&n.length===2){if(t===1)return Ui(Ct(Fs(e),n[0]),n[1]-1);if(t===1/0)return Ui(Ct(Fs(e),n[1]),n[0]);if(t===-1/0)return Lx(Ct(Fs(e),n[1]),n[0]);if(t==="fro"||t==="euclidean")return Ss(Ct(rr(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const fI=ye({norm_:B6e});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z6e(e,t=null,n=!1){return fI(e,"euclidean",t,n)}const W6e=ye({euclideanNorm_:z6e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V6e(e){const n={x:Z(e,"x","exp")};return pe.runKernel(ag,n)}const Ro=ye({exp_:V6e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U6e(e,t=0){const n=Z(e,"x","expandDims","string_or_numeric");U(t<=n.rank,()=>"Axis must be <= rank of the tensor");const r={input:n},s={dim:t};return pe.runKernel(h1,r,s)}const ta=ye({expandDims_:U6e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G6e(e){const n={x:Z(e,"x","expm1")};return pe.runKernel(ig,n)}const H6e=ye({expm1_:G6e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j6e(e,t){const n=Z(e,"x","tile","string_or_numeric");U(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`);const r={x:n},s={reps:t};return pe.runKernel(Yh,r,s)}const Pi=ye({tile_:j6e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q6e(e,t,n,r="float32"){t==null&&(t=e);const s=Yt([e,t],r),a=e<=t?e:t;for(let o=0;o<a;++o)s.set(1,o,o);const i=be(s.toTensor(),[e,t]);if(n==null)return i;if(n.length===1)return Pi(ta(i,0),[n[0],1,1]);if(n.length===2)return Pi(ta(ta(i,0),0),[n[0],n[1],1,1]);if(n.length===3)return Pi(ta(ta(ta(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}const TW=ye({eye_:q6e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K6e(e){const n={x:Z(e,"x","floor","float32")};return pe.runKernel(og,n)}const mI=ye({floor_:K6e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X6e(e,t,n=0,r=0){const s=Z(e,"x","gather"),a=Z(t,"indices","gather","int32"),i={x:s,indices:a},o={axis:n,batchDims:r};return pe.runKernel(f1,i,o)}const WE=ye({gather_:X6e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q6e(e,t){let n=Z(e,"a","greater","string_or_numeric"),r=Z(t,"b","greater","string_or_numeric");[n,r]=Ir(n,r),Ot(n.shape,r.shape);const s={a:n,b:r};return pe.runKernel(m1,s)}const Ya=ye({greater_:Q6e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y6e(e,t){let n=Z(e,"a","greaterEqual","string_or_numeric"),r=Z(t,"b","greaterEqual","string_or_numeric");[n,r]=Ir(n,r),Ot(n.shape,r.shape);const s={a:n,b:r};return pe.runKernel(cg,s)}const ep=ye({greaterEqual_:Y6e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J6e(e){const n={input:Z(e,"input","imag")};return pe.runKernel(xE,n)}const VE=ye({imag_:J6e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z6e(e){const n={x:Z(e,"x","isFinite")};return pe.runKernel(hg,n)}const e5e=ye({isFinite_:Z6e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t5e(e){const n={x:Z(e,"x","isInf")};return pe.runKernel(pg,n)}const n5e=ye({isInf_:t5e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r5e(e){const n={x:Z(e,"x","isNaN")};return pe.runKernel(fg,n)}const s5e=ye({isNaN_:r5e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a5e(e,t=.2){const r={x:Z(e,"x","leakyRelu")},s={alpha:t};return pe.runKernel(mg,r,s)}const UE=ye({leakyRelu_:a5e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i5e(e,t){let n=Z(e,"a","less","string_or_numeric"),r=Z(t,"b","less","string_or_numeric");[n,r]=Ir(n,r),Ot(n.shape,r.shape);const s={a:n,b:r};return pe.runKernel(g1,s)}const Px=ye({less_:i5e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o5e(e,t){let n=Z(e,"a","lessEqual","string_or_numeric"),r=Z(t,"b","lessEqual","string_or_numeric");[n,r]=Ir(n,r),Ot(n.shape,r.shape);const s={a:n,b:r};return pe.runKernel(b1,s)}const nb=ye({lessEqual_:o5e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l5e(e,t=5,n=1,r=1,s=.5){const a=Z(e,"x","localResponseNormalization");U(a.rank===4||a.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${a.rank}.`),U(Yp(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let i=a,o=!1;a.rank===3&&(o=!0,i=be(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const u={x:i},c={depthRadius:t,bias:n,alpha:r,beta:s},l=pe.runKernel(yg,u,c);return o?be(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const u5e=ye({localResponseNormalization_:l5e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c5e(e){const n={x:Z(e,"x","log","float32")};return pe.runKernel(gg,n)}const _o=ye({log_:c5e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d5e(e){const n={x:Z(e,"x","log1p")};return pe.runKernel(bg,n)}const EW=ye({log1p_:d5e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h5e(e,t){U(eS(e),()=>"The f passed in variableGrads(f) must be a function"),U(t==null||Array.isArray(t)&&t.every(c=>c instanceof Ox),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=t!=null;if(!n){t=[];for(const c in pe.registeredVariables)t.push(pe.registeredVariables[c])}const r=n?t.filter(c=>!c.trainable):null,s=t.length;t=t.filter(c=>c.trainable),U(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);const a=!0,{value:i,grads:o}=pe.gradients(e,t,null,a);U(o.some(c=>c!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),U(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);const u={};return t.forEach((c,l)=>{o[l]!=null&&(u[c.name]=o[l])}),r?.forEach(c=>u[c.name]=null),{value:i,grads:u}}function sf(e){return pe.customGrad(e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p5e(e){const n={x:Z(e,"x","neg")};return pe.runKernel(k1,n)}const vr=ye({neg_:p5e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f5e(e){const n={x:Z(e,"x","softplus")};return pe.runKernel(jg,n)}const U1=ye({softplus_:f5e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m5e(e){const t=Z(e,"x","logSigmoid");return sf(r=>({value:vr(U1(vr(r))),gradFunc:i=>ce(i,tb(vr(r)))}))(t)}const g5e=ye({logSigmoid_:m5e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b5e(e,t){let n=Z(e,"a","sub"),r=Z(t,"b","sub");[n,r]=Ir(n,r);const s={a:n,b:r};return pe.runKernel(Yg,s)}const _t=ye({sub_:b5e});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y5e(e,t=-1){const n=Z(e,"logits","logSoftmax");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return sf((s,a)=>{const o=Ui(s,t,!0),u=_t(s,o),c=_t(at(u,"float32"),_o(Ct(Ro(u),t,!0)));return a([c]),{value:c,gradFunc:(d,h)=>{const[p]=h,f=!0,m=Ro(p);return _t(d,ce(Ct(d,t,f),m))}}})(n)}const AW=ye({logSoftmax_:y5e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x5e(e,t=null,n=!1){const r=Z(e,"x","logSumExp"),s=zt(t,r.shape),a=Ui(r,s,!0),i=_t(r,a),o=Ro(i),u=Ct(o,s),c=_o(u),l=We(be(a,c.shape),c);if(n){const d=jn(l.shape,s);return be(l,d)}return l}const $W=ye({logSumExp_:x5e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w5e(e,t){const n=Z(e,"a","logicalAnd","bool"),r=Z(t,"b","logicalAnd","bool");Ot(n.shape,r.shape);const s={a:n,b:r};return pe.runKernel(y1,s)}const ll=ye({logicalAnd_:w5e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v5e(e){const n={x:Z(e,"x","logicalNot","bool")};return pe.runKernel(x1,n)}const GE=ye({logicalNot_:v5e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I5e(e,t){const n=Z(e,"a","logicalOr","bool"),r=Z(t,"b","logicalOr","bool");Ot(n.shape,r.shape);const s={a:n,b:r};return pe.runKernel(w1,s)}const RW=ye({logicalOr_:I5e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k5e(e,t){const n=Z(e,"a","logicalXor","bool"),r=Z(t,"b","logicalXor","bool");return Ot(n.shape,r.shape),ll(RW(e,t),GE(ll(e,t)))}const C5e=ye({logicalXor_:k5e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S5e(e,t,n,r,s){const a=Z(e,"x","maxPool"),i=1;let o=a,u=!1;a.rank===3&&(u=!0,o=be(a,[1,a.shape[0],a.shape[1],a.shape[2]])),U(o.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),U(bs(n,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),pa("maxPool",r,s);const c={x:o},l={filterSize:t,strides:n,pad:r,dimRoundingMode:s},d=pe.runKernel(vg,c,l);return u?be(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const HE=ye({maxPool_:S5e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N5e(e,t=[1,1,1],n,r,s,a="NDHWC"){const i=Z(e,"x","maxPool3d");let o=i,u=!1;i.rank===4&&(u=!0,o=be(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),U(o.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),U(a==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),pa("maxPool3d",r,s);const c={x:o},l={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a},d=pe.runKernel(I1,c,l);return u?be(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const T5e=ye({maxPool3d_:N5e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E5e(e,t){let n=Z(e,"a","maximum"),r=Z(t,"b","maximum");[n,r]=Ir(n,r),n.dtype==="bool"&&(n=at(n,"int32"),r=at(r,"int32")),Ot(n.shape,r.shape);const s={a:n,b:r};return pe.runKernel(wg,s)}const Lu=ye({maximum_:E5e});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A5e(e,t=null,n=!1){const s={x:Z(e,"x","mean")},a={axis:t,keepDims:n};return pe.runKernel(Ig,s,a)}const $r=ye({mean_:A5e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ss(e,t="float32"){if(wl(e),t==="complex64"){const r=ss(e,"float32"),s=ss(e,"float32");return nf(r,s)}const n=Cs(fe(e),t);return pe.makeTensor(n,e,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pu(e,t="float32"){if(wl(e),t==="complex64"){const r=Pu(e,"float32"),s=ss(e,"float32");return nf(r,s)}const n=oE(fe(e),t);return pe.makeTensor(n,e,t)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $5e(e,t){let n=Z(e,"a","minimum"),r=Z(t,"b","minimum");[n,r]=Ir(n,r),n.dtype==="bool"&&(n=at(n,"int32"),r=at(r,"int32")),Ot(n.shape,r.shape);const s={a:n,b:r};return pe.runKernel(Cg,s)}const $y=ye({minimum_:$5e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R5e(e,t,n){U(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);const r=Z(e,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");U(t.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`);const s=n==="reflect"?1:0;for(let o=0;o<r.rank;o++)U(t[o].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),U(t[o][0]>=0&&t[o][0]<=r.shape[o]-s&&t[o][1]>=0&&t[o][1]<=r.shape[o]-s,()=>`Padding in dimension ${o} cannot be greater than or equal to ${r.shape[o]-s} or less than 0 for input of shape ${r.shape}`);const a={paddings:t,mode:n},i={x:r};return pe.runKernel(Sg,i,a)}const _5e=ye({mirrorPad_:R5e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D5e(e,t){let n=Z(e,"a","mod"),r=Z(t,"b","mod");[n,r]=Ir(n,r);const s={a:n,b:r};return pe.runKernel(Ng,s)}const F5e=ye({mod_:D5e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M5e(e,t=null,n=!1){e=Z(e,"x","moments");const r=zt(t,e.shape),s=$r(e,r,n);let a=s.shape;n||(a=jn(s.shape,r));const i=rr(_t(at(e,"float32"),be(s,a))),o=$r(i,r,n);return{mean:s,variance:o}}const jE=ye({moments_:M5e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O5e(e,t){let n=Z(e,"a","notEqual","string_or_numeric"),r=Z(t,"b","notEqual","string_or_numeric");[n,r]=Ir(n,r),Ot(n.shape,r.shape);const s={a:n,b:r};return pe.runKernel(C1,s)}const Bx=ye({notEqual_:O5e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L5e(e,t,n=1,r=0,s="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const i={indices:Z(e,"indices","oneHot","int32")},o={dtype:s,depth:t,onValue:n,offValue:r};return pe.runKernel(Eg,i,o)}const _W=ye({oneHot_:L5e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P5e(e){const n={x:Z(e,"x","onesLike")};return pe.runKernel(E1,n)}const fi=ye({onesLike_:P5e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B5e(e,t,n=0){const r=Z(e,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const s={paddings:t,constantValue:n},a={x:r};return pe.runKernel(Ag,a,s)}const qE=ye({pad_:B5e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z5e(e,t,n){const r=Z(e,"x","spaceToBatchND");U(r.rank>=1+t.length,()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`),U(n.length===t.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`),U(r.shape.reduce((i,o,u)=>u>0&&u<=t.length?i&&(o+n[u-1][0]+n[u-1][1])%t[u-1]===0:i,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`);const s={x:r},a={blockShape:t,paddings:n};return pe.runKernel(M1,s,a)}const KE=ye({spaceToBatchND_:z5e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W5e(e,t,n,r,s,a,i){s==null&&(s=[1,1]),a==null&&(a=1),r===0&&(r="valid");const o=Z(e,"x","maxPool");let u=o,c=!1;o.rank===3&&(c=!0,u=be(o,[1,o.shape[0],o.shape[1],o.shape[2]])),U(bs(a,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${s}'`);const l=Es(u.shape,t,a,s,r),d=[l.dilationHeight,l.dilationWidth];let h;r==="same"?h=U5e([l.filterHeight,l.filterWidth],d):h=[[0,0],[0,0]];const p=d[0]===1&&d[1]===1,[f,m]=V5e([l.inHeight,l.inWidth],d,h),g=p?r:"valid",b=p?u:KE(u,d,f),x=(n==="avg"?()=>ME(b,t,a,g,i):()=>HE(b,t,a,g,i))(),w=p?x:OE(x,d,m);return c?be(w,[w.shape[1],w.shape[2],w.shape[3]]):w}function V5e(e,t,n){const r=n.map(l=>l[0]),s=n.map(l=>l[1]),a=e.concat(r,s),i=t.map((l,d)=>(l-a[d]%l)%l),o=s.map((l,d)=>l+i[d]),u=t.map((l,d)=>[r[d],o[d]]),c=t.map((l,d)=>[0,i[d]]);return[u,c]}function U5e(e,t){const r=e.map((i,o)=>i+(i-1)*(t[o]-1)).map(i=>i-1),s=r.map(i=>Math.floor(i/2)),a=r.map((i,o)=>i-s[o]);return r.map((i,o)=>[s[o],a[o]])}const G5e=ye({pool_:W5e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H5e(e,t){const n=Z(e,"x","prelu"),r=Z(t,"alpha","prelu"),s={x:n,alpha:r};return pe.runKernel(Rg,s)}const XE=ye({prelu_:H5e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j5e(e,t=null,n=!1){let r=Z(e,"x","prod");r.dtype==="bool"&&(r=at(r,"int32"));const s={x:r},a={axis:t,keepDims:n};return pe.runKernel(_g,s,a)}const q5e=ye({prod_:j5e});var Q2={exports:{}},K5e=Q2.exports,Z_;function X5e(){return Z_||(Z_=1,(function(e){(function(t,n,r){function s(u){var c=this,l=o();c.next=function(){var d=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=d-(c.c=d|0)},c.c=1,c.s0=l(" "),c.s1=l(" "),c.s2=l(" "),c.s0-=l(u),c.s0<0&&(c.s0+=1),c.s1-=l(u),c.s1<0&&(c.s1+=1),c.s2-=l(u),c.s2<0&&(c.s2+=1),l=null}function a(u,c){return c.c=u.c,c.s0=u.s0,c.s1=u.s1,c.s2=u.s2,c}function i(u,c){var l=new s(u),d=c&&c.state,h=l.next;return h.int32=function(){return l.next()*4294967296|0},h.double=function(){return h()+(h()*2097152|0)*11102230246251565e-32},h.quick=h,d&&(typeof d=="object"&&a(d,l),h.state=function(){return a(l,{})}),h}function o(){var u=4022871197,c=function(l){l=String(l);for(var d=0;d<l.length;d++){u+=l.charCodeAt(d);var h=.02519603282416938*u;u=h>>>0,h-=u,h*=u,u=h>>>0,h-=u,u+=h*4294967296}return(u>>>0)*23283064365386963e-26};return c}n&&n.exports?n.exports=i:this.alea=i})(K5e,e)})(Q2)),Q2.exports}var Y2={exports:{}},Q5e=Y2.exports,eD;function Y5e(){return eD||(eD=1,(function(e){(function(t,n,r){function s(o){var u=this,c="";u.x=0,u.y=0,u.z=0,u.w=0,u.next=function(){var d=u.x^u.x<<11;return u.x=u.y,u.y=u.z,u.z=u.w,u.w^=u.w>>>19^d^d>>>8},o===(o|0)?u.x=o:c+=o;for(var l=0;l<c.length+64;l++)u.x^=c.charCodeAt(l)|0,u.next()}function a(o,u){return u.x=o.x,u.y=o.y,u.z=o.z,u.w=o.w,u}function i(o,u){var c=new s(o),l=u&&u.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var h=c.next()>>>11,p=(c.next()>>>0)/4294967296,f=(h+p)/(1<<21);while(f===0);return f},d.int32=c.next,d.quick=d,l&&(typeof l=="object"&&a(l,c),d.state=function(){return a(c,{})}),d}n&&n.exports?n.exports=i:this.xor128=i})(Q5e,e)})(Y2)),Y2.exports}var J2={exports:{}},J5e=J2.exports,tD;function Z5e(){return tD||(tD=1,(function(e){(function(t,n,r){function s(o){var u=this,c="";u.next=function(){var d=u.x^u.x>>>2;return u.x=u.y,u.y=u.z,u.z=u.w,u.w=u.v,(u.d=u.d+362437|0)+(u.v=u.v^u.v<<4^(d^d<<1))|0},u.x=0,u.y=0,u.z=0,u.w=0,u.v=0,o===(o|0)?u.x=o:c+=o;for(var l=0;l<c.length+64;l++)u.x^=c.charCodeAt(l)|0,l==c.length&&(u.d=u.x<<10^u.x>>>4),u.next()}function a(o,u){return u.x=o.x,u.y=o.y,u.z=o.z,u.w=o.w,u.v=o.v,u.d=o.d,u}function i(o,u){var c=new s(o),l=u&&u.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var h=c.next()>>>11,p=(c.next()>>>0)/4294967296,f=(h+p)/(1<<21);while(f===0);return f},d.int32=c.next,d.quick=d,l&&(typeof l=="object"&&a(l,c),d.state=function(){return a(c,{})}),d}n&&n.exports?n.exports=i:this.xorwow=i})(J5e,e)})(J2)),J2.exports}var Z2={exports:{}},eMe=Z2.exports,nD;function tMe(){return nD||(nD=1,(function(e){(function(t,n,r){function s(o){var u=this;u.next=function(){var l=u.x,d=u.i,h,p;return h=l[d],h^=h>>>7,p=h^h<<24,h=l[d+1&7],p^=h^h>>>10,h=l[d+3&7],p^=h^h>>>3,h=l[d+4&7],p^=h^h<<7,h=l[d+7&7],h=h^h<<13,p^=h^h<<9,l[d]=p,u.i=d+1&7,p};function c(l,d){var h,p=[];if(d===(d|0))p[0]=d;else for(d=""+d,h=0;h<d.length;++h)p[h&7]=p[h&7]<<15^d.charCodeAt(h)+p[h+1&7]<<13;for(;p.length<8;)p.push(0);for(h=0;h<8&&p[h]===0;++h);for(h==8?p[7]=-1:p[h],l.x=p,l.i=0,h=256;h>0;--h)l.next()}c(u,o)}function a(o,u){return u.x=o.x.slice(),u.i=o.i,u}function i(o,u){o==null&&(o=+new Date);var c=new s(o),l=u&&u.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var h=c.next()>>>11,p=(c.next()>>>0)/4294967296,f=(h+p)/(1<<21);while(f===0);return f},d.int32=c.next,d.quick=d,l&&(l.x&&a(l,c),d.state=function(){return a(c,{})}),d}n&&n.exports?n.exports=i:this.xorshift7=i})(eMe,e)})(Z2)),Z2.exports}var ex={exports:{}},nMe=ex.exports,rD;function rMe(){return rD||(rD=1,(function(e){(function(t,n,r){function s(o){var u=this;u.next=function(){var l=u.w,d=u.X,h=u.i,p,f;return u.w=l=l+1640531527|0,f=d[h+34&127],p=d[h=h+1&127],f^=f<<13,p^=p<<17,f^=f>>>15,p^=p>>>12,f=d[h]=f^p,u.i=h,f+(l^l>>>16)|0};function c(l,d){var h,p,f,m,g,b=[],y=128;for(d===(d|0)?(p=d,d=null):(d=d+"\0",p=0,y=Math.max(y,d.length)),f=0,m=-32;m<y;++m)d&&(p^=d.charCodeAt((m+32)%d.length)),m===0&&(g=p),p^=p<<10,p^=p>>>15,p^=p<<4,p^=p>>>13,m>=0&&(g=g+1640531527|0,h=b[m&127]^=p+g,f=h==0?f+1:0);for(f>=128&&(b[(d&&d.length||0)&127]=-1),f=127,m=512;m>0;--m)p=b[f+34&127],h=b[f=f+1&127],p^=p<<13,h^=h<<17,p^=p>>>15,h^=h>>>12,b[f]=p^h;l.w=g,l.X=b,l.i=f}c(u,o)}function a(o,u){return u.i=o.i,u.w=o.w,u.X=o.X.slice(),u}function i(o,u){o==null&&(o=+new Date);var c=new s(o),l=u&&u.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var h=c.next()>>>11,p=(c.next()>>>0)/4294967296,f=(h+p)/(1<<21);while(f===0);return f},d.int32=c.next,d.quick=d,l&&(l.X&&a(l,c),d.state=function(){return a(c,{})}),d}n&&n.exports?n.exports=i:this.xor4096=i})(nMe,e)})(ex)),ex.exports}var tx={exports:{}},sMe=tx.exports,sD;function aMe(){return sD||(sD=1,(function(e){(function(t,n,r){function s(o){var u=this,c="";u.next=function(){var d=u.b,h=u.c,p=u.d,f=u.a;return d=d<<25^d>>>7^h,h=h-p|0,p=p<<24^p>>>8^f,f=f-d|0,u.b=d=d<<20^d>>>12^h,u.c=h=h-p|0,u.d=p<<16^h>>>16^f,u.a=f-d|0},u.a=0,u.b=0,u.c=-1640531527,u.d=1367130551,o===Math.floor(o)?(u.a=o/4294967296|0,u.b=o|0):c+=o;for(var l=0;l<c.length+20;l++)u.b^=c.charCodeAt(l)|0,u.next()}function a(o,u){return u.a=o.a,u.b=o.b,u.c=o.c,u.d=o.d,u}function i(o,u){var c=new s(o),l=u&&u.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var h=c.next()>>>11,p=(c.next()>>>0)/4294967296,f=(h+p)/(1<<21);while(f===0);return f},d.int32=c.next,d.quick=d,l&&(typeof l=="object"&&a(l,c),d.state=function(){return a(c,{})}),d}n&&n.exports?n.exports=i:this.tychei=i})(sMe,e)})(tx)),tx.exports}var nx={exports:{}},iMe=nx.exports,aD;function oMe(){return aD||(aD=1,(function(e){(function(t,n,r){var s=256,a=6,i=52,o="random",u=r.pow(s,a),c=r.pow(2,i),l=c*2,d=s-1,h;function p(w,v,I){var N=[];v=v==!0?{entropy:!0}:v||{};var T=b(g(v.entropy?[w,x(n)]:w??y(),3),N),E=new f(N),A=function(){for(var k=E.g(a),C=u,M=0;k<c;)k=(k+M)*s,C*=s,M=E.g(1);for(;k>=l;)k/=2,C/=2,M>>>=1;return(k+M)/C};return A.int32=function(){return E.g(4)|0},A.quick=function(){return E.g(4)/4294967296},A.double=A,b(x(E.S),n),(v.pass||I||function(k,C,M,L){return L&&(L.S&&m(L,E),k.state=function(){return m(E,{})}),M?(r[o]=k,C):k})(A,T,"global"in v?v.global:this==r,v.state)}function f(w){var v,I=w.length,N=this,T=0,E=N.i=N.j=0,A=N.S=[];for(I||(w=[I++]);T<s;)A[T]=T++;for(T=0;T<s;T++)A[T]=A[E=d&E+w[T%I]+(v=A[T])],A[E]=v;(N.g=function(k){for(var C,M=0,L=N.i,O=N.j,B=N.S;k--;)C=B[L=d&L+1],M=M*s+B[d&(B[L]=B[O=d&O+C])+(B[O]=C)];return N.i=L,N.j=O,M})(s)}function m(w,v){return v.i=w.i,v.j=w.j,v.S=w.S.slice(),v}function g(w,v){var I=[],N=typeof w,T;if(v&&N=="object")for(T in w)try{I.push(g(w[T],v-1))}catch{}return I.length?I:N=="string"?w:w+"\0"}function b(w,v){for(var I=w+"",N,T=0;T<I.length;)v[d&T]=d&(N^=v[d&T]*19)+I.charCodeAt(T++);return x(v)}function y(){try{var w;return h&&(w=h.randomBytes)?w=w(s):(w=new Uint8Array(s),(t.crypto||t.msCrypto).getRandomValues(w)),x(w)}catch{var v=t.navigator,I=v&&v.plugins;return[+new Date,t,I,t.screen,x(n)]}}function x(w){return String.fromCharCode.apply(0,w)}if(b(r.random(),n),e.exports){e.exports=p;try{h=_l}catch{}}else r["seed"+o]=p})(typeof self<"u"?self:iMe,[],Math)})(nx)),nx.exports}var Ik,iD;function lMe(){if(iD)return Ik;iD=1;var e=X5e(),t=Y5e(),n=Z5e(),r=tMe(),s=rMe(),a=aMe(),i=oMe();return i.alea=e,i.xor128=t,i.xorwow=n,i.xorshift7=r,i.xor4096=s,i.tychei=a,Ik=i,Ik}var QE=lMe();/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DW{constructor(t,n,r,s,a){this.mean=t,this.stdDev=n,this.dtype=r,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const i=a||Math.random();this.random=QE.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){const s=this.nextVal;return this.nextVal=NaN,s}let t,n,r=!1;for(;!r;){let s,a,i;do s=2*this.random()-1,a=2*this.random()-1,i=s*s+a*a;while(i>=1||i===0);const o=Math.sqrt(-2*Math.log(i)/i);t=this.mean+this.stdDev*s*o,n=this.mean+this.stdDev*a*o,(!this.truncated||this.isValidTruncated(t))&&(r=!0)}return(!this.truncated||this.isValidTruncated(n))&&(this.nextVal=this.convertValue(n)),this.convertValue(t)}convertValue(t){return this.dtype==null||this.dtype==="float32"?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class uMe{constructor(t=0,n=1,r,s){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=t,this.range=n-t,this.dtype=r,s==null&&(s=Math.random()),typeof s=="number"&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${n} <= 1 and dtype is not float`);this.random=QE.alea(s)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cMe(e,t=0,n=1,r,s){if(wl(e),r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);const a=new DW(t,n,r,!1,s),i=Yt(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}const dMe=ye({randomNormal_:cMe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hMe(e,t=0,n=1,r="float32",s){wl(e);const a=Yt(e,r),i=new uMe(t,n,null,s);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}const G1=ye({randomUniform_:hMe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ry(e,t,n=1,r="float32"){if(n===0)throw new Error("Cannot have a step of zero");const s={start:e,stop:t,step:n,dtype:r};return pe.runKernel(Yv,{},s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pMe(e){const n={input:Z(e,"input","real")};return pe.runKernel(vE,n)}const zx=ye({real_:pMe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fMe(e){const n={x:Z(e,"x","reciprocal")};return pe.runKernel(Dg,n)}const mMe=ye({reciprocal_:fMe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gMe(e){const n={x:Z(e,"x","relu")};return pe.runKernel(Fg,n)}const tp=ye({relu_:gMe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bMe(e){const n={x:Z(e,"x","relu6")};return pe.runKernel(Lg,n)}const FW=ye({relu6_:bMe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yMe(e,t){const r={x:Z(e,"x","reverse")},s={dims:t};return pe.runKernel(Pg,r,s)}const cd=ye({reverse_:yMe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xMe(e){const n={x:Z(e,"x","round")};return pe.runKernel(Bg,n)}const MW=ye({round_:xMe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wMe(e){const n={x:Z(e,"x","rsqrt","float32")};return pe.runKernel(zg,n)}const OW=ye({rsqrt_:wMe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vMe(e){const n={x:Z(e,"x","selu")};return pe.runKernel(Wg,n)}const LW=ye({selu_:vMe});function IMe(e,t,n,r,s,a=[1,1],i="NHWC"){const o=Z(e,"x","separableConv2d"),u=Z(t,"depthwiseFilter","separableConv2d"),c=Z(n,"pointwiseFilter","separableConv2d");let l=o,d=!1;if(o.rank===3&&(d=!0,l=be(o,[1,o.shape[0],o.shape[1],o.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");U(l.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${l.rank}.`),U(u.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`),U(c.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`),U(c.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),U(c.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);const h=u.shape[2],p=u.shape[3];U(c.shape[2]===h*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${h*p}, but got ${c.shape[2]}.`);const f=BE(l,u,r,s,i,a),g=ld(f,c,1,"valid",i);return d?be(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const PW=ye({separableConv2d_:IMe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kMe(e){const n={x:Z(e,"x","sign")};return pe.runKernel(Gg,n)}const CMe=ye({sign_:kMe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SMe(e){const n={x:Z(e,"x","sin","float32")};return pe.runKernel(Vg,n)}const BW=ye({sin_:SMe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NMe(e){const n={x:Z(e,"x","sinh")};return pe.runKernel(Ug,n)}const zW=ye({sinh_:NMe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TMe(e,t,n){const r=Z(e,"x","slice1d");return U(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),Yn(r,[t],[n])}const YE=ye({slice1d_:TMe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EMe(e,t,n){const r=Z(e,"x","slice2d");return U(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),Yn(r,t,n)}const WW=ye({slice2d_:EMe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AMe(e,t,n){const r=Z(e,"x","slice3d");return U(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),Yn(r,t,n)}const JE=ye({slice3d_:AMe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Me(e,t,n){const r=Z(e,"x","slice4d");return U(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),Yn(r,t,n)}const Wx=ye({slice4d_:$Me});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RMe(e,t=-1){const n=Z(e,"logits","softmax","float32");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);const r={logits:n},s={dim:t};return pe.runKernel(Xg,r,s)}const ZE=ye({softmax_:RMe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Me(e){U(e.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`);const t={input:e};return pe.runKernel(bE,t)}const VW=ye({fft_:_Me});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DMe(e){U(e.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`);const t={input:e};return pe.runKernel(yE,t)}const fS=ye({ifft_:DMe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FMe(e){const t=e.shape[e.shape.length-1],n=e.size/t;let r;if(t<=2){const s=be(e,[n,t]);r=fS(s)}else{const s=[n,2*(t-1)],a=be(zx(e),[n,t]),i=be(VE(e),[n,t]),o=cd(Yn(a,[0,1],[n,t-2]),1),u=ce(cd(Yn(i,[0,1],[n,t-2]),1),Sn(-1)),c=ia([a,o],1),l=ia([i,u],1),d=be(nf(c,l),[s[0],s[1]]);r=fS(d)}if(r=zx(r),e.rank===3&&e.shape[0]!==0){const s=r,a=e.shape[0];r=be(r,[a,r.shape[0]/a,r.shape[1]]),s.dispose()}return r}const MMe=ye({irfft_:FMe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OMe(e,t,n=0){const s={x:Z(e,"x","split")},a={numOrSizeSplits:t,axis:n};return pe.runKernel(O1,s,a)}const Ua=ye({split_:OMe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LMe(e,t){U(e.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let n=e.shape[e.shape.length-1];const r=e.size/n;let s;if(t!=null&&t<n){const f=e.shape.map(g=>0),m=e.shape.map(g=>g);m[e.shape.length-1]=t,s=Yn(e,f,m),n=t}else if(t!=null&&t>n){const f=e.shape.map(m=>m);f[e.shape.length-1]=t-n,s=ia([e,ss(f)],e.shape.length-1),n=t}else s=e;const a=cn(s),i=be(nf(s,a),[r,n]),o=VW(i),u=Math.floor(n/2)+1,c=zx(o),l=VE(o),d=Ua(c,[u,n-u],c.shape.length-1),h=Ua(l,[u,n-u],l.shape.length-1),p=s.shape.slice();return p[s.shape.length-1]=u,be(nf(d[0],h[0]),p)}const PMe=ye({rfft_:LMe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BMe(e,t){let n=Z(e,"a","squaredDifference"),r=Z(t,"b","squaredDifference");[n,r]=Ir(n,r),Ot(n.shape,r.shape);const s={a:n,b:r},a={};return pe.runKernel(Qg,s,a)}const zMe=ye({squaredDifference_:BMe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WMe(e,t){const n=Z(e,"x","squeeze","string_or_numeric");return be(n,Fu(n.shape,t).newShape)}const H1=ye({squeeze_:WMe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VMe(e,t=0){const n=uW(e,"tensors","stack","string_or_numeric");U(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&U(t<=n[0].rank,()=>"Axis must be <= rank of the tensor");const r=n,s={axis:t};return pe.runKernel(A1,r,s)}const ul=ye({stack_:VMe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UMe(e,t=0){const r={x:Z(e,"x","step")},s={alpha:t};return pe.runKernel(Jh,r,s)}const j1=ye({step_:UMe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GMe(e,t,n,r,s=0,a=0,i=0,o=0,u=0){const l={x:Z(e,"x","stridedSlice","string_or_numeric")},d={begin:t,end:n,strides:r,beginMask:s,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:u};return pe.runKernel(L1,l,d)}const HMe=ye({stridedSlice_:GMe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jMe(e){const n={x:Z(e,"x","tan","float32")};return pe.runKernel(Jg,n)}const qMe=ye({tan_:jMe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ka(e,t){Bz(e);const n=lI(e,t);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return uI(e,null,n,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kk(e,t,n){if(Bz(e),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const r=lI(e,n);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return uI(e,t,r,n)}function UW(e,t,n){const r=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(a+` update.rank < ${s}. `);if(e.length<r+(n.rank-s))throw new Error(a+` Output shape length < ${r+(n.rank-s)}`);if(n.rank!==s+e.length-r)throw new Error(a+` update.rank != ${s+e.length-r}`);for(let i=0;i<s;++i)if(n.shape[i]!==t.shape[i])throw new Error(a+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<n.rank-s;++i)if(n.shape[i+s]!==e[i+r])throw new Error(a+` updates.shape[${i+s}] (${n.shape[i+s]}) != shape[${i+s}] (${e[i+s]})`)}function KMe(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(e.size===0)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}UW(n,t,e)}function zo(e,t,n){const r=t.shape.length,s=r>1?t.shape[r-1]:1,a=n.length;let i=1;for(let d=s;d<a;++d)i*=n[d];const o=s<1?1:s,u=fe(t.shape)/o,c=[...ot(n.slice(0,s)),1],l=fe(n);return{sliceRank:s,numUpdates:u,sliceSize:i,strides:c,outputSize:l}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XMe(e,t=1,n=!0){const r=Z(e,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${t}`);const a={x:r},i={k:t,sorted:n},[o,u]=pe.runKernel(P1,a,i);return{values:o,indices:u}}const QMe=ye({topk_:XMe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YMe(e,t=0,n=1,r,s){if(wl(e),r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");const a=new DW(t,n,r,!0,s),i=Yt(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}const GW=ye({truncatedNormal_:YMe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JMe(e,t=0){const n=Z(e,"x","unique","string_or_numeric");U(n.rank>0,()=>"The input tensor must be at least 1D");const r={x:n},s={axis:t},[a,i]=pe.runKernel(sI,r,s);return{values:a,indices:i}}const ZMe=ye({unique_:JMe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e8e(e,t,n){const r=Z(e,"x","unsortedSegmentSum"),s=Z(t,"segmentIds","unsortedSegmentSum","int32");U(Yp(n),()=>"numSegments must be of dtype int");const a={x:r,segmentIds:s},i={numSegments:n};return pe.runKernel(aI,a,i)}const HW=ye({unsortedSegmentSum_:e8e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t8e(e,t=0){const n=Z(e,"x","unstack","string_or_numeric");U(t>=-n.shape.length&&t<n.shape.length,()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`);const r={value:n},s={axis:t};return pe.runKernel(z1,r,s)}const dd=ye({unstack_:t8e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n8e(e,t=!0,n,r){return pe.makeVariable(e,t,n,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jW(e,t){const n=[];for(let a=0;a<t.length;a++)t[a]&&n.push(a);const r=Yt(e,"int32"),s=Yt([n.length,e.length],"int32");for(let a=0;a<n.length;a++){const i=r.indexToLoc(n[a]),o=a*e.length;s.values.set(i,o)}return s.toTensor()}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r8e(e,t,n){const r=Z(e,"x","transpose");if(t==null&&(t=r.shape.map((i,o)=>o).reverse()),U(r.rank===t.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`),t.forEach(i=>{U(i>=0&&i<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${t}`)}),r.rank<=1)return r.clone();const s={x:r},a={perm:t};return r.dtype==="complex64"?we(()=>{let i=zx(r),o=VE(r);return i=pe.runKernel(Gl,{x:i},a),o=pe.runKernel(Gl,{x:o},a),n&&(o=vr(o)),nf(i,o)}):pe.runKernel(Gl,s,a)}const un=ye({transpose_:r8e});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s8e(e,t){if(t==null)return e.shape.slice();if(Nn(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let r=0;r<e.shape.length;r++)t[r]==null&&e.shape[r]!=null?n.push(e.shape[r]):n.push(t[r]);return n}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a8e(e,t,n,r){const s=Z(e,"x","dropout");if(U(s.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),U(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return e instanceof Br?s.clone():s;const a=s8e(s,n),i=1-t,o=Nt(mI(We(G1(a,0,1,"float32",r),i)),i);return ce(s,o)}const i8e=ye({dropout_:a8e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o8e(e,t,n,r,s,a="NHWC",i){let o=e;e.rank===3&&(o=be(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u=t;u.rank===3&&(u=be(t,[1,t.shape[0],t.shape[1],t.shape[2]])),U(o.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),U(u.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),U(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);const c=a==="NHWC"?o.shape[3]:o.shape[1],l=a==="NHWC"?u.shape[3]:u.shape[1];U(c===n[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${n[2]}.`),U(l===n[3],()=>`Error in conv2dDerFilter: depth of dy (${l}) must match output depth for filter (${n[3]}).`),pa("conv2dDerFilter",s,i);const d={x:o,dy:u},h={strides:r,pad:s,dataFormat:a,dimRoundingMode:i,filterShape:n};return pe.runKernel(hE,d,h)}const eA=ye({conv2DBackpropFilter_:o8e});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tA(e,t,n){if(n==null||n==="linear")return e;if(n==="relu")return ce(e,j1(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function nA(e,t){let n=t;const r=Xr(e.shape,t.shape);return r.length>0&&(n=Ct(n,r)),be(n,e.shape)}function rA(e,t,n,r){if(t==="linear")return e;if(t==="relu")return tp(e);if(t==="elu")return pI(e);if(t==="relu6")return FW(e);if(t==="prelu")return XE(e,n);if(t==="leakyrelu")return UE(e,r);if(t==="sigmoid")return tb(e);throw new Error(`Unknown fused activation ${t}.`)}const sA=(e,t)=>!(e>0)||t==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l8e({x:e,filter:t,strides:n,pad:r,dataFormat:s="NHWC",dilations:a=[1,1],dimRoundingMode:i,bias:o,activation:u="linear",preluActivationWeights:c,leakyreluAlpha:l}){if(u=u||"linear",sA(pe.state.gradientDepth,u)===!1){U(s==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let I=ld(e,t,n,r,s,a,i);return o!=null&&(I=We(I,o)),rA(I,u,c,l)}const d=Z(e,"x","conv2d","float32"),h=Z(t,"filter","conv2d","float32");let p=d,f=!1;d.rank===3&&(f=!0,p=be(d,[1,d.shape[0],d.shape[1],d.shape[2]])),U(p.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),U(h.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${h.rank}.`),pa("fused conv2d",r,i);const m=s==="NHWC"?p.shape[3]:p.shape[1];U(h.shape[2]===m,()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${h.shape[2]}.`),U(bs(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`);const g=yr(p.shape,h.shape,n,a,r,i);let b;o!=null&&(b=Z(o,"bias","fused conv2d"),[b]=Ir(b,d),s==="NHWC"?Ot(g.outShape,b.shape):(U(b.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${b.shape.length}.`),U(b.shape.length===0||b.shape[0]===g.outChannels||b.shape[0]===1,()=>`Error in fused conv2d: bias shape (${b.shape}) is not compatible with the number of output channels (${g.outChannels})`)));let y;if(c!=null){const I=c.shape;if(U(I.length<=1||I.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${I.length}.`),I.length===1)U(I[0]===1||I[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${I}) is not compatible with the number of output channels (${g.outChannels}).`);else if(I.length===3)try{Ot(I,g.outShape)}catch{const T=`Error in fused conv2d: PReLU activation weights (${I}) is not compatible with the output shape of the conv2d (${g.outShape}).`;throw Error(T)}y=Z(c,"prelu weights","fused conv2d")}const x=(I,N)=>{U(s==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`);const[T,E,A,k]=N,C=tA(I,A,u);U(id(a),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`);const M=LE(E.shape,C,T,n,r),L=eA(E,C,T.shape,n,r),O=[M,L];if(k!=null){const B=nA(k,C);O.push(B)}return O},w={x:p,filter:h,bias:b,preluActivationWeights:y},v={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i,activation:u,leakyreluAlpha:l};return o==null?sf((N,T,E)=>{let A=pe.runKernel(ef,w,v);return E([T,N,A]),f&&(A=be(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:x}})(p,h):sf((N,T,E,A)=>{let k=pe.runKernel(ef,w,v);return A([T,N,k,E]),f&&(k=be(k,[k.shape[1],k.shape[2],k.shape[3]])),{value:k,gradFunc:x}})(p,h,b)}const u8e=ye({fusedConv2d_:l8e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c8e(e,t,n,r,s,a=[1,1],i){let o=e;e.rank===3&&(o=be(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u=t;u.rank===3&&(u=be(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const c={x:o,dy:u},l={strides:r,pad:s,dimRoundingMode:i,dilations:a,filterShape:n};return pe.runKernel(pE,c,l)}const d8e=ye({depthwiseConv2dNativeBackpropFilter_:c8e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h8e(e,t,n,r,s,a=[1,1],i){let o=t,u=!1;t.rank===3&&(u=!0,o=be(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const c={dy:o,filter:n},l={strides:r,pad:s,dimRoundingMode:i,dilations:a,inputShape:e},d=pe.runKernel(fE,c,l);return u?be(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const p8e=ye({depthwiseConv2dNativeBackpropInput_:h8e});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f8e({a:e,b:t,transposeA:n=!1,transposeB:r=!1,bias:s,activation:a="linear",preluActivationWeights:i,leakyreluAlpha:o=.2}){if(sA(pe.state.gradientDepth,a)===!1){let k=Cn(e,t,n,r);return s!=null&&(k=We(k,s)),rA(k,a,i,o)}let u=Z(e,"a","fused matMul"),c=Z(t,"b","fused matMul");[u,c]=Ir(u,c);const l=n?u.shape[u.rank-2]:u.shape[u.rank-1],d=r?c.shape[c.rank-1]:c.shape[c.rank-2],h=n?u.shape[u.rank-1]:u.shape[u.rank-2],p=r?c.shape[c.rank-2]:c.shape[c.rank-1],f=u.shape.slice(0,-2),m=c.shape.slice(0,-2),g=fe(f),b=fe(m);U(l===d,()=>`Error in fused matMul: inner shapes (${l}) and (${d}) of Tensors with shapes ${u.shape} and ${c.shape} and transposeA=${n} and transposeB=${r} must match.`);const x=Ot(u.shape.slice(0,-2),c.shape.slice(0,-2)).concat([h,p]),w=n?be(u,[g,l,h]):be(u,[g,h,l]),v=r?be(c,[b,p,d]):be(c,[b,d,p]);let I;s!=null&&(I=Z(s,"bias","fused matMul"),[I]=Ir(I,u),Ot(x,I.shape));let N;i!=null&&(N=Z(i,"prelu weights","fused matMul"));const T=(k,C)=>{const[M,L,O,B]=C,G=tA(be(k,O.shape),O,a);let z,q;if(!n&&!r?(z=Cn(G,L,!1,!0),q=Cn(M,G,!0,!1)):!n&&r?(z=Cn(G,L,!1,!1),q=Cn(G,M,!0,!1)):n&&!r?(z=Cn(L,G,!1,!0),q=Cn(M,G,!1,!1)):(z=Cn(L,G,!0,!0),q=Cn(G,M,!0,!0)),s!=null){const Q=nA(B,G);return[z,q,Q]}else return[z,q]},E={a:w,b:v,bias:I,preluActivationWeights:N},A={transposeA:n,transposeB:r,activation:a,leakyreluAlpha:o};return s==null?sf((C,M,L)=>{const O=pe.runKernel(Zp,E,A);return L([C,M,O]),{value:be(O,x),gradFunc:T}})(w,v):sf((C,M,L,O)=>{const B=pe.runKernel(Zp,E,A);return O([C,M,B,L]),{value:be(B,x),gradFunc:T}})(w,v,I)}const oD=ye({fusedMatMul_:f8e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m8e(e,t,n,r,s="bilinear",a=0){const i=Z(e,"image","cropAndResize"),o=Z(t,"boxes","cropAndResize","float32"),u=Z(n,"boxInd","cropAndResize","int32"),c=o.shape[0];U(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),U(o.rank===2&&o.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${o.shape}.`),U(u.rank===1&&u.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${o.shape}.`),U(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),U(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),U(s==="bilinear"||s==="nearest",()=>`method must be bilinear or nearest, but was ${s}`);const l={image:i,boxes:o,boxInd:u},d={method:s,extrapolationValue:a,cropSize:r};return pe.runKernel(l1,l,d)}const g8e=ye({cropAndResize_:m8e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b8e(e){const t=Z(e,"image","flipLeftRight","float32");U(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);const n={image:t};return pe.runKernel(p1,n,{})}const y8e=ye({flipLeftRight_:b8e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x8e(e){const t=Z(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];U(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),U(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const s=new Array(t.rank);return s.fill(1,0,n),s[n]=3,Pi(t,s)}const w8e=ye({grayscaleToRGB_:x8e});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v8e(e){const t=Z(e,"image","RGBToGrayscale"),n=t.rank-1,r=t.shape[n];U(t.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`),U(r===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`);const s=t.dtype,a=at(t,"float32"),i=ka([.2989,.587,.114]);let o;switch(t.rank){case 2:o=_b("ij,j->i",a,i);break;case 3:o=_b("ijk,k->ij",a,i);break;case 4:o=_b("ijkl,l->ijk",a,i);break;case 5:o=_b("ijklm,m->ijkl",a,i);break;case 6:o=_b("ijklmn,n->ijklm",a,i);break;default:throw new Error("Not a valid tensor rank.")}return o=ta(o,-1),at(o,s)}const I8e=ye({rgbToGrayscale_:v8e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k8e(e,t,n=0,r=.5){const s=Z(e,"image","rotateWithOffset","float32");U(s.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`);const a={image:s},i={radians:t,fillValue:n,center:r};return pe.runKernel(V1,a,i)}const C8e=ye({rotateWithOffset_:k8e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rb(e,t,n,r,s,a){r==null&&(r=.5),s==null&&(s=Number.NEGATIVE_INFINITY),a==null&&(a=0);const i=e.shape[0];return n=Math.min(n,i),U(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),U(e.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),U(e.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),U(t.rank===1,()=>"scores must be a 1D tensor"),U(t.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`),U(0<=a&&a<=1,()=>`softNmsSigma must be in [0, 1], but was '${a}'`),{maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S8e(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){const a=Z(e,"boxes","nonMaxSuppression","float32"),i=Z(t,"scores","nonMaxSuppression","float32"),o=rb(a,i,n,r,s);n=o.maxOutputSize,r=o.iouThreshold,s=o.scoreThreshold;const u={maxOutputSize:n,iouThreshold:r,scoreThreshold:s};return pe.runKernel(S1,{boxes:a,scores:i},u)}const N8e=ye({nonMaxSuppression_:S8e});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T8e(e,t,n){const r=E8e(e,t,n),s=r<0?-(r+1):r;e.splice(s,0,t)}function E8e(e,t,n){return $8e(e,t,n||A8e)}function A8e(e,t){return e>t?1:e<t?-1:0}function $8e(e,t,n){let r=0,s=e.length,a=0,i=!1;for(;r<s;){a=r+(s-r>>>1);const o=n(t,e[a]);o>0?r=a+1:(s=a,i=!o)}return i?r:-r-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aA(e,t,n,r,s){return lA(e,t,n,r,s,0)}function iA(e,t,n,r,s,a){return lA(e,t,n,r,s,0,!1,a,!0)}function oA(e,t,n,r,s,a){return lA(e,t,n,r,s,a,!0)}function lA(e,t,n,r,s,a,i=!1,o=!1,u=!1){const c=[];for(let g=0;g<t.length;g++)t[g]>s&&c.push({score:t[g],boxIndex:g,suppressBeginIndex:0});c.sort(lD);const l=a>0?-.5/a:0,d=[],h=[];for(;d.length<n&&c.length>0;){const g=c.pop(),{score:b,boxIndex:y,suppressBeginIndex:x}=g;if(b<s)break;let w=!1;for(let v=d.length-1;v>=x;--v){const I=R8e(e,y,d[v]);if(I>=r){w=!0;break}if(g.score=g.score*_8e(r,l,I),g.score<=s)break}g.suppressBeginIndex=d.length,w||(g.score===b?(d.push(y),h.push(g.score)):g.score>s&&T8e(c,g,lD))}const p=d.length,f=n-p;o&&f>0&&(d.push(...new Array(f).fill(0)),h.push(...new Array(f).fill(0)));const m={selectedIndices:d};return i&&(m.selectedScores=h),u&&(m.validOutputs=p),m}function R8e(e,t,n){const r=e.subarray(t*4,t*4+4),s=e.subarray(n*4,n*4+4),a=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),u=Math.max(r[1],r[3]),c=Math.min(s[0],s[2]),l=Math.min(s[1],s[3]),d=Math.max(s[0],s[2]),h=Math.max(s[1],s[3]),p=(o-a)*(u-i),f=(d-c)*(h-l);if(p<=0||f<=0)return 0;const m=Math.max(a,c),g=Math.max(i,l),b=Math.min(o,d),y=Math.min(u,h),x=Math.max(b-m,0)*Math.max(y-g,0);return x/(p+f-x)}function _8e(e,t,n){const r=Math.exp(t*n*n);return n<=e?r:0}function lD(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function D8e(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){const a=Z(e,"boxes","nonMaxSuppressionAsync"),i=Z(t,"scores","nonMaxSuppressionAsync"),o=rb(a,i,n,r,s);n=o.maxOutputSize,r=o.iouThreshold,s=o.scoreThreshold;const u=await Promise.all([a.data(),i.data()]),c=u[0],l=u[1],{selectedIndices:d}=aA(c,l,n,r,s);return a!==e&&a.dispose(),i!==t&&i.dispose(),ka(d,"int32")}const F8e=D8e;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M8e(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){const i=Z(e,"boxes","nonMaxSuppression"),o=Z(t,"scores","nonMaxSuppression"),u=rb(i,o,n,r,s,a);n=u.maxOutputSize,r=u.iouThreshold,s=u.scoreThreshold,a=u.softNmsSigma;const c={boxes:i,scores:o},l={maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a},d=pe.runKernel(T1,c,l);return{selectedIndices:d[0],selectedScores:d[1]}}const O8e=ye({nonMaxSuppressionWithScore_:M8e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function L8e(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){const i=Z(e,"boxes","nonMaxSuppressionAsync"),o=Z(t,"scores","nonMaxSuppressionAsync"),u=rb(i,o,n,r,s,a);n=u.maxOutputSize,r=u.iouThreshold,s=u.scoreThreshold,a=u.softNmsSigma;const c=await Promise.all([i.data(),o.data()]),l=c[0],d=c[1],{selectedIndices:h,selectedScores:p}=oA(l,d,n,r,s,a);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:ka(h,"int32"),selectedScores:ka(p)}}const P8e=L8e;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B8e(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){const i=Z(e,"boxes","nonMaxSuppression"),o=Z(t,"scores","nonMaxSuppression"),u=rb(i,o,n,r,s,null),c=u.maxOutputSize,l=u.iouThreshold,d=u.scoreThreshold,h={boxes:i,scores:o},p={maxOutputSize:c,iouThreshold:l,scoreThreshold:d,padToMaxOutputSize:a},f=pe.runKernel(N1,h,p);return{selectedIndices:f[0],validOutputs:f[1]}}const z8e=ye({nonMaxSuppressionPadded_:B8e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function W8e(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){const i=Z(e,"boxes","nonMaxSuppressionAsync"),o=Z(t,"scores","nonMaxSuppressionAsync"),u=rb(i,o,n,r,s,null),c=u.maxOutputSize,l=u.iouThreshold,d=u.scoreThreshold,[h,p]=await Promise.all([i.data(),o.data()]),{selectedIndices:f,validOutputs:m}=iA(h,p,c,l,d,a);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:ka(f,"int32"),validOutputs:Sn(m,"int32")}}const V8e=W8e;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U8e(e,t,n=!1,r=!1){const s=Z(e,"images","resizeBilinear");U(s.rank===3||s.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),U(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),U(r===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let a=s,i=!1;s.rank===3&&(i=!0,a=be(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const o={images:a},u={alignCorners:n,halfPixelCenters:r,size:t},c=pe.runKernel(Og,o,u);return i?be(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const qW=ye({resizeBilinear_:U8e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G8e(e,t,n=!1,r=!1){const s=Z(e,"images","resizeNearestNeighbor");U(s.rank===3||s.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),U(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),U(s.dtype==="float32"||s.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),U(r===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let a=s,i=!1;s.rank===3&&(i=!0,a=be(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const o={images:a},u={alignCorners:n,halfPixelCenters:r,size:t},c=pe.runKernel(Mg,o,u);return i?be(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const KW=ye({resizeNearestNeighbor_:G8e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H8e(e,t="binary",n=!1,r=.5){const s=Z(e,"image","threshold"),a=.2989,i=.587,o=.114,u=s.shape[0]*s.shape[1];let c=ce(ka([r]),255),l,d,h,p;if(U(s.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),U(s.shape[2]===3||s.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),U(s.dtype==="int32"||s.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),U(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),s.shape[2]===3){[l,d,h]=Ua(s,[1,1,1],-1);const g=ce(l,a),b=ce(d,i),y=ce(h,o);p=We(We(g,b),y)}else p=e;if(t==="otsu"){const g=HFe(at(MW(p),"int32"),RE([]),256);c=j8e(g,u)}const f=n?nb(p,c):Ya(p,c);return at(ce(f,255),"int32")}function j8e(e,t){let n=ka([-1]),r=ka([0]),s=ka([0]),a,i,o,u,c,l;for(let d=0;d<e.size-1;d++){a=Yn(e,0,d+1),i=Yn(e,d+1),c=Nt(Ct(a),t),l=Nt(Ct(i),t);const h=Ct(ce(a,Ry(0,a.size)));o=Nt(h,Ct(a));const p=hI(i.shape,a.size),f=We(Ry(0,i.size),p),m=ce(i,f);u=Nt(Ct(m),Ct(i));const g=_t(o,u),b=_t(o,u),y=ce(c,l);s=ce(ce(y,g),b);const x=Ya(s,r);r=Ws(x,s,r),n=Ws(x,ka([d]),n)}return n}const q8e=ye({threshold_:H8e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K8e(e,t,n="nearest",r="constant",s=0,a){const i=Z(e,"image","transform","float32"),o=Z(t,"transforms","transform","float32");U(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),U(o.rank===2&&(o.shape[0]===i.shape[0]||o.shape[0]===1)&&o.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),U(a==null||a.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${a}.`);const u={image:i,transforms:o},c={interpolation:n,fillMode:r,fillValue:s,outputShape:a};return pe.runKernel(B1,u,c)}const X8e=ye({transform_:K8e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q8e(e,t,n){const r=Z(e,"a","bandPart");U(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[a,i]=r.shape.slice(-2);let o,u;typeof t=="number"?(U(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),U(t<=a,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${a}).`),o=Z(t<0?a:t,"numLower","bandPart")):(U(t.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),o=Ws(Px(t,0),a,$y(t,a))),typeof n=="number"?(U(n%1===0,()=>`bandPart(): numUpper must be an integer, got ${n}.`),U(n<=i,()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`),u=Z(n<0?i:n,"numUpper","bandPart")):(U(n.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),u=Ws(Px(n,0),i,$y(n,i)));const c=be(Ry(0,a,1,"int32"),[-1,1]),l=Ry(0,i,1,"int32"),d=_t(c,l),h=ll(nb(d,o),ep(d,vr(u))),p=ss([a,i],r.dtype);return be(ul(dd(be(r,[-1,a,i])).map(f=>Ws(h,f,p))),s)}const Y8e=ye({bandPart_:Q8e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J8e(e){let t;if(Array.isArray(e)){t=!1,U(e!=null&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const s=e[0].shape[0];for(let a=1;a<e.length;++a)U(e[a].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[a].shape[0]} vs. ${s})`)}else t=!0,e=Ua(e,e.shape[0],0).map(s=>H1(s,[0]));U(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);const n=[],r=e;for(let s=0;s<e.length;++s)n.push(pe.tidy(()=>{let a=r[s];if(s>0)for(let i=0;i<s;++i){const o=ce(Ct(ce(n[i],a)),n[i]);a=_t(a,o)}return Nt(a,fI(a,"euclidean"))}));return t?ul(n,0):n}const Z8e=ye({gramSchmidt_:J8e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eOe(e,t=!1){if(U(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),e.rank===2)return uD(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce((u,c)=>u*c),r=dd(be(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),s=[],a=[];r.forEach(u=>{const[c,l]=uD(u,t);s.push(c),a.push(l)});const i=be(ul(s,0),e.shape),o=be(ul(a,0),e.shape);return[i,o]}}function uD(e,t=!1){return pe.tidy(()=>{U(e.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);const n=e.shape[0],r=e.shape[1];let s=TW(n),a=Dc(e);const i=kk([[1]],[1,1]);let o=Dc(i);const u=n>=r?r:n;for(let c=0;c<u;++c){const l=a,d=o,h=s;[o,a,s]=pe.tidy(()=>{const p=Yn(a,[c,c],[n-c,1]),f=fI(p),m=Yn(a,[c,c],[1,1]),g=Ws(Ya(m,0),kk([[-1]]),kk([[1]])),b=_t(m,ce(g,f)),y=Nt(p,b);y.shape[0]===1?o=Dc(i):o=ia([i,Yn(y,[1,0],[y.shape[0]-1,y.shape[1]])],0);const x=vr(Nt(Cn(g,b),f)),w=Yn(a,[c,0],[n-c,r]),v=ce(x,o),I=un(o);if(c===0)a=_t(w,Cn(v,Cn(I,w)));else{const E=_t(w,Cn(v,Cn(I,w)));a=ia([Yn(a,[0,0],[c,r]),E],0)}const N=un(v),T=Yn(s,[0,c],[n,s.shape[1]-c]);if(c===0)s=_t(T,Cn(Cn(T,o),N));else{const E=_t(T,Cn(Cn(T,o),N));s=ia([Yn(s,[0,0],[n,c]),E],1)}return[o,a,s]}),tn([l,d,h])}return!t&&n>r&&(s=Yn(s,[0,0],[n,r]),a=Yn(a,[0,0],[r,r])),[s,a]})}const tOe=ye({qr_:eOe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tl={flipLeftRight:y8e,grayscaleToRGB:w8e,resizeNearestNeighbor:KW,resizeBilinear:qW,rgbToGrayscale:I8e,rotateWithOffset:C8e,cropAndResize:g8e,nonMaxSuppression:N8e,nonMaxSuppressionAsync:F8e,nonMaxSuppressionWithScore:O8e,nonMaxSuppressionWithScoreAsync:P8e,nonMaxSuppressionPadded:z8e,nonMaxSuppressionPaddedAsync:V8e,threshold:q8e,transform:X8e},nOe={bandPart:Y8e,gramSchmidt:Z8e,qr:tOe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rOe=new Map,sOe=new Map;class sb{getClassName(){return this.constructor.className}static fromConfig(t,n){return new t(n)}}class oi{constructor(){this.classNameMap={}}static getMap(){return oi.instance==null&&(oi.instance=new oi),oi.instance}static register(t){oi.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function Le(e,t,n){U(e.className!=null,()=>"Class being registered does not have the static className property defined."),U(typeof e.className=="string",()=>"className is required to be a string, but got type "+typeof e.className),U(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof t>"u"&&(t="Custom"),typeof n>"u"&&(n=e.className);const r=n,s=t+">"+r;return oi.register(e),rOe.set(s,e),sOe.set(e,s),e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bu extends sb{minimize(t,n=!1,r){const{value:s,grads:a}=this.computeGradients(t,r);if(r!=null){const i=r.map(o=>({name:o.name,tensor:a[o.name]}));this.applyGradients(i)}else this.applyGradients(a);return tn(a),n?s:(s.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,n){return h5e(t,n)}dispose(){this.iterations_!=null&&tn(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:Sn(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty(Bu,Symbol.hasInstance,{value:e=>e.minimize!=null&&e.computeGradients!=null&&e.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XW extends Bu{static get className(){return"Adadelta"}constructor(t,n,r=null){super(),this.learningRate=t,this.rho=n,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],r==null&&(this.epsilon=pe.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,s)=>{const a=pe.registeredVariables[r],i=!1;this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${r}/accum_grad`,variable:we(()=>cn(a).variable(i))}),this.accumulatedUpdates[s]==null&&(this.accumulatedUpdates[s]={originalName:`${r}/accum_var`,variable:we(()=>cn(a).variable(i))});const o=Array.isArray(t)?t[s].tensor:t[r];if(o==null)return;const u=this.accumulatedGrads[s].variable,c=this.accumulatedUpdates[s].variable;we(()=>{const l=We(ce(u,this.rho),ce(rr(o),1-this.rho)),d=ce(Nt(Ss(We(c,this.epsilon)),Ss(We(u,this.epsilon))),o),h=We(ce(c,this.rho),ce(rr(d),1-this.rho));u.assign(l),c.assign(h);const p=We(ce(d,-this.learningRate),a);a.assign(p)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(tn(this.accumulatedGrads.map(t=>t.variable)),tn(this.accumulatedUpdates.map(t=>t.variable)))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(t){t=await this.extractIterations(t);const n=t.length/2,r=!1;this.accumulatedGrads=t.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedUpdates=t.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,n){return new t(n.learningRate,n.rho,n.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QW extends Bu{static get className(){return"Adagrad"}constructor(t,n=.1){super(),this.learningRate=t,this.initialAccumulatorValue=n,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,s)=>{const a=pe.registeredVariables[r];this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${r}/accumulator`,variable:we(()=>hI(a.shape,this.initialAccumulatorValue).variable(!1))});const i=Array.isArray(t)?t[s].tensor:t[r];if(i==null)return;const o=this.accumulatedGrads[s].variable;we(()=>{const u=We(o,rr(i));o.assign(u);const c=We(ce(Nt(i,Ss(We(u,pe.backend.epsilon()))),-this.learningRate),a);a.assign(c)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&tn(this.accumulatedGrads.map(t=>t.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const n=!1;this.accumulatedGrads=t.map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,n){return new t(n.learningRate,n.initialAccumulatorValue)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YW extends Bu{static get className(){return"Adam"}constructor(t,n,r,s=null){super(),this.learningRate=t,this.beta1=n,this.beta2=r,this.epsilon=s,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],we(()=>{this.accBeta1=Sn(n).variable(),this.accBeta2=Sn(r).variable()}),s==null&&(this.epsilon=pe.backend.epsilon())}applyGradients(t){const n=Array.isArray(t)?t.map(r=>r.name):Object.keys(t);we(()=>{const r=_t(1,this.accBeta1),s=_t(1,this.accBeta2);n.forEach((a,i)=>{const o=pe.registeredVariables[a],u=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${a}/m`,variable:we(()=>cn(o).variable(u))}),this.accumulatedSecondMoment[i]==null&&(this.accumulatedSecondMoment[i]={originalName:`${a}/v`,variable:we(()=>cn(o).variable(u))});const c=Array.isArray(t)?t[i].tensor:t[a];if(c==null)return;const l=this.accumulatedFirstMoment[i].variable,d=this.accumulatedSecondMoment[i].variable,h=We(ce(l,this.beta1),ce(c,1-this.beta1)),p=We(ce(d,this.beta2),ce(rr(c),1-this.beta2)),f=Nt(h,r),m=Nt(p,s);l.assign(h),d.assign(p);const g=We(ce(Nt(f,We(Ss(m),this.epsilon)),-this.learningRate),o);o.assign(g)}),this.accBeta1.assign(ce(this.accBeta1,this.beta1)),this.accBeta2.assign(ce(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&tn(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedSecondMoment!=null&&tn(this.accumulatedSecondMoment.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(t){t=await this.extractIterations(t),we(()=>{this.accBeta1.assign(ud(this.beta1,this.iterations_+1)),this.accBeta2.assign(ud(this.beta2,this.iterations_+1))});const n=t.length/2,r=!1;this.accumulatedFirstMoment=t.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedSecondMoment=t.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,n){return new t(n.learningRate,n.beta1,n.beta2,n.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JW extends Bu{static get className(){return"Adamax"}constructor(t,n,r,s=null,a=0){super(),this.learningRate=t,this.beta1=n,this.beta2=r,this.epsilon=s,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],we(()=>{this.iteration=Sn(0).variable(),this.accBeta1=Sn(n).variable()}),s==null&&(this.epsilon=pe.backend.epsilon())}applyGradients(t){const n=Array.isArray(t)?t.map(r=>r.name):Object.keys(t);we(()=>{const r=_t(1,this.accBeta1),s=Nt(-this.learningRate,We(ce(this.iteration,this.decay),1));n.forEach((a,i)=>{const o=pe.registeredVariables[a],u=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${a}/m`,variable:cn(o).variable(u)}),this.accumulatedWeightedInfNorm[i]==null&&(this.accumulatedWeightedInfNorm[i]={originalName:`${a}/v`,variable:cn(o).variable(u)});const c=Array.isArray(t)?t[i].tensor:t[a];if(c==null)return;const l=this.accumulatedFirstMoment[i].variable,d=this.accumulatedWeightedInfNorm[i].variable,h=We(ce(l,this.beta1),ce(c,1-this.beta1)),p=ce(d,this.beta2),f=Fs(c),m=Lu(p,f);l.assign(h),d.assign(m);const g=We(ce(Nt(s,r),Nt(h,We(m,this.epsilon))),o);o.assign(g)}),this.iteration.assign(We(this.iteration,1)),this.accBeta1.assign(ce(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&tn(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedWeightedInfNorm!=null&&tn(this.accumulatedWeightedInfNorm.map(t=>t.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,n){return new t(n.learningRate,n.beta1,n.beta2,n.epsilon,n.decay)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uA extends Bu{static get className(){return"SGD"}constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,s)=>{const a=Array.isArray(t)?t[s].tensor:t[r];if(a==null)return;const i=pe.registeredVariables[r];we(()=>{const o=We(ce(this.c,a),i);i.assign(o)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,this.c!=null&&this.c.dispose(),this.c=ko(Sn(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(t=await this.extractIterations(t),t.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,n){return new t(n.learningRate)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZW extends uA{static get className(){return"Momentum"}constructor(t,n,r=!1){super(t),this.learningRate=t,this.momentum=n,this.useNesterov=r,this.accumulations=[],this.m=Sn(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,s)=>{const a=pe.registeredVariables[r];this.accumulations[s]==null&&(this.accumulations[s]={originalName:`${r}/momentum`,variable:we(()=>cn(a).variable(!1))});const i=this.accumulations[s].variable,o=Array.isArray(t)?t[s].tensor:t[r];o!=null&&we(()=>{let u;const c=We(ce(this.m,i),o);this.useNesterov?u=We(ce(this.c,We(o,ce(c,this.m))),a):u=We(ce(this.c,c),a),i.assign(c),a.assign(u)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&tn(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const n=!1;this.accumulations=t.map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,n){return new t(n.learningRate,n.momentum,n.useNesterov)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eV extends Bu{static get className(){return"RMSProp"}constructor(t,n=.9,r=0,s=null,a=!1){if(super(),this.learningRate=t,this.decay=n,this.momentum=r,this.epsilon=s,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,s==null&&(this.epsilon=pe.backend.epsilon()),t==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,s)=>{const a=pe.registeredVariables[r],i=!1;this.accumulatedMeanSquares[s]==null&&(this.accumulatedMeanSquares[s]={originalName:`${r}/rms`,variable:we(()=>cn(a).variable(i))}),this.accumulatedMoments[s]==null&&(this.accumulatedMoments[s]={originalName:`${r}/momentum`,variable:we(()=>cn(a).variable(i))}),this.accumulatedMeanGrads[s]==null&&this.centered&&(this.accumulatedMeanGrads[s]={originalName:`${r}/mg`,variable:we(()=>cn(a).variable(i))});const o=Array.isArray(t)?t[s].tensor:t[r];if(o==null)return;const u=this.accumulatedMeanSquares[s].variable,c=this.accumulatedMoments[s].variable;we(()=>{const l=We(ce(u,this.decay),ce(rr(o),1-this.decay));if(this.centered){const d=this.accumulatedMeanGrads[s].variable,h=We(ce(d,this.decay),ce(o,1-this.decay)),p=Nt(ce(o,this.learningRate),Ss(_t(l,We(rr(h),this.epsilon)))),f=We(ce(c,this.momentum),p);u.assign(l),d.assign(h),c.assign(f);const m=_t(a,f);a.assign(m)}else{const d=We(ce(u,this.decay),ce(rr(o),1-this.decay)),h=We(ce(c,this.momentum),Nt(ce(o,this.learningRate),Ss(We(d,this.epsilon))));u.assign(d),c.assign(h);const p=_t(a,h);a.assign(p)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&tn(this.accumulatedMeanSquares.map(t=>t.variable)),this.accumulatedMeanGrads!=null&&this.centered&&tn(this.accumulatedMeanGrads.map(t=>t.variable)),this.accumulatedMoments!=null&&tn(this.accumulatedMoments.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(t){t=await this.extractIterations(t);const n=this.centered?t.length/3:t.length/2,r=!1;this.accumulatedMeanSquares=t.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedMoments=t.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.centered&&(this.accumulatedMeanGrads=t.slice(n*2,n*3).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,n){return new t(n.learningRate,n.decay,n.momentum,n.epsilon,n.centered)}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aOe=[XW,QW,YW,JW,ZW,eV,uA];function iOe(){for(const e of aOe)Le(e)}function gI(e,t){const n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(fe(e.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const s=t.shape,a=s[s.length-1];let i=1;for(let d=0;d<s.length-1;++d)i*=s[d];const o=e.shape,u=s.slice();u.pop();let c=1;for(let d=a;d<n;++d)c*=o[d],u.push(o[d]);const l=[...ot(e.shape).map(d=>d/c),1].slice(0,a);return[u,i,c,l]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mS=-2,oOe=-1;function cA(e,t,n){const r=e.shape.length;U(r===t.length,()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`),U(r===n.length,()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)U(t[s]+n[s]<=e.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${t[s]+n[s]}) would overflow input.shape[${s}] (${e.shape[s]})`)}function lOe(e){const t=[];let n=0;for(;e>0;)e&1&&t.push(n),e/=2,n++;return t}function bI(e,t,n){const r=[];for(let s=0;s<e.length;s++)r[s]=Math.ceil((t[s]-e[s])/n[s]);return r}function tV(e,t,n,r){const s=[...e];for(let a=s.length;a<r.length;a++)s.push(1);for(let a=0;a<n;a++)a===0?s[t]=1:(s.splice(t,0,1),s.pop());return s}function nV(e,t,n){return n<=e?n:n-(t-1)}function rV(e,t){const n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function uOe(e,t,n,r,s,a,i,o,u){const c=e.length;let l=new Array(c),d=new Array(c),h=new Array(c);if(t.length&&n>0){const p=t[0],f=n+1;l=sV(i,p,f,r,e),d=aV(o,p,f,s,e),h=tV(a,p,f,e)}else for(let p=0;p<c;p++)l[p]=oV(i,r,a,e,p,u),d[p]=lV(o,s,a,e,p,u),h[p]=iV(a,p,u);return{begin:l,end:d,strides:h}}function sV(e,t,n,r,s){const a=[...s],i=rV(n,t);for(let o=0;o<a.length;o++)if(i.indexOf(o)>-1)a[o]=0;else{const u=nV(t,n,o);let c=r[u];e&1<<u&&(c=0),a[o]=c}return a}function aV(e,t,n,r,s){const a=[...s],i=rV(n,t);for(let o=0;o<a.length;o++)if(i.indexOf(o)>-1)a[o]=Number.MAX_SAFE_INTEGER;else{const u=nV(t,n,o);let c=r[u];e&1<<u&&(c=Number.MAX_SAFE_INTEGER),a[o]=c}for(let o=0;o<a.length;o++){const u=s[o];a[o]<0&&(a[o]+=u),a[o]=nd(0,a[o],s[o])}return a}function iV(e,t,n){let r=e[t];return(n&1<<t||r==null)&&(r=1),r}function oV(e,t,n,r,s,a){let i=t[s];const o=n[s]||1;(e&1<<s||a&1<<s||i==null)&&(o>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);const u=r[s];return i<0&&(i+=u),i=nd(0,i,u-1),i}function lV(e,t,n,r,s,a){let i=t[s];const o=n[s]||1;(e&1<<s||a&1<<s||i==null)&&(o>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);const u=r[s];return i<0&&(i+=u),o>0?i=nd(0,i,u):i=nd(-1,i,u-1),i}function yI(e,t,n){let r=n.length;for(let s=0;s<n.length;s++)if(n[s]>1){r=s;break}for(let s=r+1;s<n.length;s++)if(t[s]>0||n[s]!==e[s])return!1;return!0}function xI(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function q1(e,t,n){let r;const s=e.shape.length;typeof t=="number"?r=[t,...new Array(s-1).fill(0)]:t.length<s?r=t.concat(new Array(s-t.length).fill(0)):r=t.slice(),r.forEach(i=>{U(i!==-1,()=>"slice() does not support negative begin indexing.")});let a;return n==null?a=new Array(s).fill(-1):typeof n=="number"?a=[n,...new Array(s-1).fill(-1)]:n.length<s?a=n.concat(new Array(s-n.length).fill(-1)):a=n,a=a.map((i,o)=>i>=0?i:(U(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${o}.`),e.shape[o]-r[o])),[r,a]}function wI(e,t,n,r,s,a,i,o,u){let c;if(r==null?(c=new Array(t.length),c.fill(1)):c=r,i!=null&&(i&i-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let l=!1;const d={dims:c.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:c.slice(),beginMask:s,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:u};for(let x=0;x<d.dims;x++)l&&(1<<x&o)!==0&&d.numAddAxisAfterEllipsis++,1<<x&i&&(l=!0);l||(d.ellipsisMask|=1<<d.dims,d.dims++);const h={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};cOe(d,h);let p=!0,f=!0,m=!0;const g=[],b=[];for(let x=0;x<e.length;++x){if(h.strides[x]===0)throw Error(`strides[${x}] must be non-zero`);const w=!!(h.shrinkAxisMask&1<<x),v=e[x];if(v===-1){g.push(w?1:-1);continue}const I=[h.beginMask&1<<x,h.endMask&1<<x],N=[h.strides[x]>0?0:-1,h.strides[x]>0?v:v-1];if(w&&h.strides[x]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&h.strides[x]===1;const T=!!(h.beginMask&1<<x&&h.endMask&1<<x);if(h.beginValid&&h.endValid){if(w){const C=h.begin[x]<0?v+h.begin[x]:h.begin[x];if(h.begin[x]=C,h.end[x]=h.begin[x]+1,C<0||C>=v)throw Error(`slice index ${h.begin[x]} of dimension ${x} out of bounds.`)}else h.begin[x]=cD(h.begin[x],0,h.strides[x],v,I,N),h.end[x]=cD(h.end[x],1,h.strides[x],v,I,N);const k=h.strides[x]===1&&h.begin[x]===0&&h.end[x]===v;p=p&&k,f=f&&(x===0&&h.strides[x]===1||k)}else p=p&&h.strides[x]===1&&T,f=f&&(x===0&&h.strides[x]===1||T);let E,A=!1;if(h.beginValid&&h.endValid?(E=h.end[x]-h.begin[x],A=!0):w?(E=1,A=!0):T&&v>=0&&(h.strides[x]<0?E=-v:E=v,A=!0),A){let k;E===0||E<0!=h.strides[x]<0?k=0:k=Math.trunc(E/h.strides[x])+(E%h.strides[x]!==0?1:0),g.push(k)}else g.push(-1)}for(let x=0;x<h.finalShapeGatherIndices.length;++x){const w=h.finalShapeGatherIndices[x];w>=0?b.push(g[w]):w===mS&&b.push(1)}return{finalShapeSparse:b.filter((x,w)=>h.finalShapeGatherIndices[w]!==mS),finalShape:b,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:h.begin,end:h.end,strides:h.strides}}function cOe(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=e.begin!=null,t.endValid=e.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){const s=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<s;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(mS),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);e.begin!=null&&(t.begin[n]=e.begin[r]),e.end!=null&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(oOe),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}function cD(e,t,n,r,s,a){if(s[t])return n>0?a[t]:a[t+1&1];{const i=e<0?r+e:e;return i<a[0]?a[0]:i>a[1]?a[1]:i}}const dOe=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:cA,computeFlatOffset:xI,computeOutShape:bI,getNormalizedAxes:uOe,isSliceContinous:yI,maskToAxes:lOe,parseSliceParams:q1,sliceInfo:wI,startForAxis:oV,startIndicesWithElidedDims:sV,stopForAxis:lV,stopIndicesWithElidedDims:aV,stridesForAxis:iV,stridesWithElidedDims:tV},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hOe{static sgd(t){return new uA(t)}static momentum(t,n,r=!1){return new ZW(t,n,r)}static rmsprop(t,n=.9,r=0,s=null,a=!1){return new eV(t,n,r,s,a)}static adam(t=.001,n=.9,r=.999,s=null){return new YW(t,n,r,s)}static adadelta(t=.001,n=.95,r=null){return new XW(t,n,r)}static adamax(t=.002,n=.9,r=.999,s=null,a=0){return new JW(t,n,r,s,a)}static adagrad(t,n=.1){return new QW(t,n)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mp=hOe;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pOe=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:e=>e();function uV(){return new Promise(e=>pOe(()=>e()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vI(e,t){const n=e[0].length;e.forEach((s,a)=>{U(s.length===n,()=>`Error in concat${n}D: rank of tensors[${a}] must be the same as the rank of the rest (${n})`)}),U(t>=0&&t<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const r=e[0];e.forEach((s,a)=>{for(let i=0;i<n;i++)U(i===t||s[i]===r[i],()=>`Error in concat${n}D: Shape of tensors[${a}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${a}.`)})}function Ga(e,t){const n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Li;(function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"})(Li||(Li={}));function cV(e,t,n){let r=new Array;if(n==null&&t==null)return r;if(t==null)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(n==null)return r;if(e+n.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let s=1;s<n.length;++s){const a=n[s],i=r[r.length-n.length+s],o=r[i];if(a>=0)if(o>=0){if(o!==a)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${s+e}] = ${a} but shape[${s+e}] = ${o}`)}else r[i]=a}return r}function dV(e){const t={FIRST_DIM_SIZE:Li.FIRST_DIM_SIZE,VALUE_ROWIDS:Li.VALUE_ROWIDS,ROW_LENGTHS:Li.ROW_LENGTHS,ROW_SPLITS:Li.ROW_SPLITS,ROW_LIMITS:Li.ROW_LIMITS,ROW_STARTS:Li.ROW_STARTS},n=[];for(const r of e)if(r in t)n.push(t[r]);else break;return n}function hV(e){return e.length===0?0:e[0]===Li.FIRST_DIM_SIZE?e.length-1:e.length}function pV(e,t){if(e==null||t==null)return;const n=e.length,r=t.length;if(n>=r)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let s=0;s<Math.min(n,r-1);++s){const a=e[s],i=t[s+1];if(a>=0&&i>=0&&a!==1&&a!==i)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${s-e.length}] = ${a} but ragged tensor input.flatValues.shape[${s-e.length}] = ${i}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dA=30;function II(e){return e<=dA?e:tS(e,Math.floor(Math.sqrt(e)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kI(e,t,n){const r=n*(typeof e=="number"?e:e[0]),s=t*(typeof e=="number"?e:e[1]);return[r,s]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function np(e,t,n,r=!0){let s=[];if(r)s=s.concat(t.slice(0)),s.push(e[0]/n),s=s.concat(e.slice(1));else{s=s.concat(e[0]);const a=t.length;for(let i=0;i<a;++i)s=s.concat([e[i+1]/t[i],t[i]]);s=s.concat(e.slice(a+1))}return s}function rp(e,t,n=!0){const r=[];if(n){r.push(t);for(let s=t+1;s<e;++s)s<=2*t?(r.push(s),r.push(s-(t+1))):r.push(s)}else{const s=[],a=[];for(let i=1;i<e;++i)i>=t*2+1||i%2===1?a.push(i):s.push(i);r.push(...s),r.push(0),r.push(...a)}return r}function sp(e,t,n,r=!0){const s=[];r?s.push(e[0]/n):s.push(e[0]*n);for(let a=1;a<e.length;++a)a<=t.length?r?s.push(t[a-1]*e[a]):s.push(e[a]/t[a-1]):s.push(e[a]);return s}function CI(e,t){const n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function SI(e,t,n){const r=e.slice(0,1);for(let s=0;s<n;++s)r.push(e[s+1]-t[s][0]-t[s][1]);return r}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NI=1.7580993408473768,TI=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hA=.3275911,pA=.254829592,fA=-.284496736,mA=1.421413741,gA=-1.453152027,bA=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cl(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);const n=new Float32Array(e.length*2);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function fV(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function mV(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let s=0;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],r[Math.floor(s/4)]=e[s+1];return{real:n,imag:r}}function gV(e){const t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let s=2;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],r[Math.floor(s/4)]=e[s+1];return{real:n,imag:r}}function yA(e,t){const n=e[t*2],r=e[t*2+1];return{real:n,imag:r}}function bV(e,t,n,r){e[r*2]=t,e[r*2+1]=n}function yV(e,t){const n=new Float32Array(e/2),r=new Float32Array(e/2);for(let s=0;s<Math.ceil(e/2);s++){const a=(t?2:-2)*Math.PI*(s/e);n[s]=Math.cos(a),r[s]=Math.sin(a)}return{real:n,imag:r}}function xV(e,t,n){const r=(n?2:-2)*Math.PI*(e/t),s=Math.cos(r),a=Math.sin(r);return{real:s,imag:a}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ck="->",fOe=/->/g,dD=",",hD="...";function xA(e,t){e=e.replace(/\s/g,"");const n=(e.length-e.replace(fOe,"").length)/Ck.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${Ck}").`);const[r,s]=e.split(Ck);U(r.indexOf(hD)===-1,()=>`The ellipsis notation ("${hD}") is not supported yet.`);const a=r.split(dD),i=a.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let h=0;h<s.length;++h){const p=s[h];if(!a.some(f=>f.indexOf(p)!==-1))throw new Error(`Output subscripts contain the label ${p} not present in the input subscripts.`);o.indexOf(p)===-1&&o.push(p)}for(let h=0;h<r.length;++h){const p=r[h];o.indexOf(p)===-1&&p!==dD&&o.push(p)}const u=new Array(a.length);for(let h=0;h<i;++h){if(new Set(a[h].split("")).size!==a[h].length)throw new Error(`Found duplicate axes in input component ${a[h]}. Support for duplicate axes in input is not implemented yet.`);u[h]=[];for(let p=0;p<a[h].length;++p)u[h].push(o.indexOf(a[h][p]))}const c=o.length,l=s.length,d=[];for(let h=l;h<c;++h)d.push(h);return{allDims:o,summedDims:d,idDims:u}}function wA(e,t){let n=new Array(e);n.fill(-1);for(let s=0;s<t.length;++s)n[t[s]]=s;const r=[];for(let s=0;s<e;++s)n[s]===-1&&r.push(s);return n=n.filter(s=>s!==-1),{permutationIndices:n,expandDims:r}}function vA(e,t,n){const r=new Array(e);for(let s=0;s<n.length;++s){const a=n[s].shape;for(let i=0;i<t[s].length;++i)r[t[s][i]]===void 0?r[t[s][i]]=a[i]:U(r[t[s][i]]===a[i],()=>`Expected dimension ${r[t[s][i]]} at axis ${i} of input shaped ${JSON.stringify(a)}, but got dimension ${a[i]}`)}}function IA(e,t){const n=e,r=[];let s=0;e.length===0&&n.push(-1),s=e.length+1;for(let i=0;i<s;++i)r.push([]);const a=[];for(let i=0;i<n.length;++i){const o=n[i],u=mOe(t,o);for(const c of u)a.indexOf(c)===-1&&(r[i].push(c),a.push(c))}return{path:n,steps:r}}function kA(e){return e.every((t,n)=>t===n)}function mOe(e,t){const n=[];for(let r=0;r<e.length;++r)(e[r].length===0||e[r].indexOf(t)!==-1||t===-1)&&n.push(r);return n}function EI(e,t,n=0){let r=[];if(typeof t=="number")U(e.shape[n]%t===0,()=>"Number of splits must evenly divide the axis."),r=new Array(t).fill(e.shape[n]/t);else{const s=t.reduce((i,o)=>(o===-1&&(i+=1),i),0);U(s<=1,()=>"There should be only one negative value in split array.");const a=t.indexOf(-1);if(a!==-1){const i=t.reduce((o,u)=>u>0?o+u:o);t[a]=e.shape[n]-i}U(e.shape[n]===t.reduce((i,o)=>i+o),()=>"The sum of sizes must match the size of the axis dimension."),r=t}return r}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CA(e){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${e}`}function SA(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function NA(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TA(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function EA(e,t){return`size ${e} must be non-negative, not ${t}`}function AA(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function $A(e,t){const n=fe(e),r=fe(t);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${e} outputShape= ${t}`}function RA(e,t){const n=fe(e),r=fe(t);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${r}. inputShape=${e} outputShape=${t}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _y(){return"segment ids must be >= 0"}function _A(){return"segment ids are not increasing"}function DA(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function FA(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wV(e,t){let n=!1,r;for(e<=dA?(r=e,n=!0):r=tS(e,Math.floor(Math.sqrt(e)));!n;)r>t||r===e?n=!0:r=tS(e,r+1);return r}function vV(e,t,n){const r=[],s=e.length;for(let a=0;a<s;a++)a!==t?r.push(e[a]):r.push(n);return r}function AI(e,t,n,r){const s=t.shape.length,a=e.shape.length;if(r!==0&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>a)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${a}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let d=0;d<r;++d)if(e.shape[d]!==t.shape[d])throw new Error(`x.shape[${d}]: ${e.shape[d]} should be equal to indices.shape[${d}]: ${t.shape[d]}.`);const i=e.shape[n],o=[];let u=1,c=1,l=1;for(let d=0;d<r;++d)o.push(e.shape[d]),u*=e.shape[d];for(let d=r;d<n;d++)o.push(e.shape[d]),c*=e.shape[d];for(let d=r;d<s;d++)o.push(t.shape[d]);for(let d=n+1;d<a;d++)o.push(e.shape[d]),l*=e.shape[d];return{batchSize:u,sliceSize:l,outerSize:c,dimSize:i,outputShape:o}}const gOe=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:AI,computeOutShape:vV,segOpComputeOptimalWindowSize:wV},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dl(e){try{return e.map(t=>cu(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function MA(e){return e.map(t=>jl(t))}const bOe=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:pA,ERF_A2:fA,ERF_A3:mA,ERF_A4:gA,ERF_A5:bA,ERF_P:hA,PARALLELIZE_THRESHOLD:dA,get RowPartitionType(){return Li},SELU_SCALE:TI,SELU_SCALEALPHA:NI,applyActivation:rA,assertAndGetBroadcastShape:Ot,assertAxesAreInnerMostDims:tr,assertParamsConsistent:vI,assignToTypedArray:bV,axesAreInnerMostDims:zE,calculateShapes:zo,checkEinsumDimSizes:vA,checkPadOnDimRoundingMode:pa,combineLocations:SW,combineRaggedTensorToTensorShapes:cV,complexWithEvenIndex:mV,complexWithOddIndex:gV,computeConv2DInfo:yr,computeConv3DInfo:eo,computeDefaultPad:FE,computeDilation2DInfo:Ou,computeOptimalWindowSize:II,computeOutAndReduceShapes:sr,computeOutShape:Ga,computePool2DInfo:Es,computePool3DInfo:Qa,convertConv2DDataFormat:to,decodeEinsumEquation:xA,eitherStridesOrDilationsAreOne:bs,expandShapeToKeepDim:jn,exponent:xV,exponents:yV,fromStringArrayToUint8:MA,fromUint8ToStringArray:dl,getAxesPermutation:nr,getBroadcastDims:rf,getComplexWithIndex:yA,getEinsumComputePath:IA,getEinsumPermutation:wA,getFusedBiasGradient:nA,getFusedDyActivation:tA,getImageCenter:kI,getInnerMostAxes:qn,getPermuted:rp,getRaggedRank:hV,getReductionAxes:Xr,getReshaped:np,getReshapedPermuted:sp,getRowPartitionTypesHelper:dV,getSliceBeginCoords:CI,getSliceSize:SI,getSparseFillEmptyRowsIndicesDenseShapeMismatch:CA,getSparseFillEmptyRowsNegativeIndexErrorMessage:SA,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:NA,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:AA,getSparseReshapeInputOutputMismatchErrorMessage:RA,getSparseReshapeInputOutputMultipleErrorMessage:$A,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:TA,getSparseReshapeNegativeOutputDimErrorMessage:EA,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:FA,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:_y,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:_A,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:DA,getUndoAxesPermutation:Bo,isIdentityPermutation:kA,log:tDe,mergeRealAndImagArrays:cl,prepareAndValidate:gI,prepareSplitSize:EI,segment_util:gOe,shouldFuse:sA,slice_util:dOe,splitRealAndImagArrays:fV,stridesOrDilationsArePositive:od,tupleValuesAreOne:id,upcastType:$a,validateDefaultValueShape:pV,validateInput:KMe,validateUpdateShape:UW,warn:Oa},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */iOe();/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IV={kernelName:X0,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ce(e,j1(at(n,"float32"),-1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yOe={kernelName:Lm,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const r=rr(at(n,"float32")),s=Ss(_t(Sn(1),r));return vr(Nt(e,s))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xOe={kernelName:Pm,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const r=Ss(_t(rr(at(n,"float32")),1));return Nt(e,r)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wOe={kernelName:Xh,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Ot(n.shape,r.shape);return{a:()=>{let o=e;const u=Xr(n.shape,s);return u.length>0&&(o=Ct(o,u)),be(o,n.shape)},b:()=>{let o=e;const u=Xr(r.shape,s);return u.length>0&&(o=Ct(o,u)),be(o,r.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vOe={kernelName:Q0,saveAllInputs:!0,gradFunc:(e,t)=>{const n={};return t.forEach((r,s)=>{n[s]=()=>e.clone()}),n}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IOe={kernelName:Z0,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>cn(n)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kOe={kernelName:e1,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>cn(n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const COe={kernelName:Bm,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Nt(e,Ss(_t(Sn(1),rr(at(n,"float32")))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SOe={kernelName:zm,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const r=Ss(We(Sn(1),rr(at(n,"float32"))));return Nt(e,r)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NOe={kernelName:Um,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Ot(n.shape,r.shape);return{a:()=>{const o=We(rr(n),rr(r));let u=ce(e,Nt(r,o));const c=Xr(n.shape,s);return c.length>0&&(u=Ct(u,c)),be(u,n.shape)},b:()=>{const o=We(rr(n),rr(r));let u=vr(ce(e,Nt(n,o)));const c=Xr(r.shape,s);return c.length>0&&(u=Ct(u,c)),be(u,r.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TOe={kernelName:Wm,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Nt(e,We(rr(at(n,"float32")),1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EOe={kernelName:Vm,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Nt(e,_t(Sn(1),rr(at(n,"float32"))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AOe(e,t,n,r,s,a){const i=Z(e,"dy","avgPool3dGrad"),o=Z(t,"input","avgPool3dGrad");let u=i,c=o,l=!1;o.rank===4&&(l=!0,u=be(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),c=be(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),U(u.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),U(c.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${c.rank}.`),pa("avgPool3dGrad",s,a);const d={dy:u,input:c},h={filterSize:n,strides:r,pad:s,dimRoundingMode:a},p=pe.runKernel(Wv,d,h);return l?be(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const $Oe=ye({avgPool3dGrad_:AOe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ROe={kernelName:t1,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:s,strides:a,pad:i,dimRoundingMode:o}=n;return{x:()=>$Oe(e,r,s,a,i,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Oe(e,t,n,r,s){const a=Z(e,"dy","avgPoolGrad"),i=Z(t,"input","avgPoolGrad");U(i.rank===a.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${a.rank})`);let o=i,u=a,c=!1;i.rank===3&&(c=!0,o=be(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=be(a,[1,a.shape[0],a.shape[1],a.shape[2]])),U(u.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${u.rank}.`),U(o.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);const l={dy:u,input:o},d={filterSize:n,strides:r,pad:s},h=pe.runKernel(zv,l,d);return c?be(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const DOe=ye({avgPoolGrad_:_Oe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FOe={kernelName:Gm,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:s,strides:a,pad:i}=n;return{x:()=>DOe(e,r,s,a,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MOe={kernelName:Hm,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{const[r,s]=t,{transposeA:a,transposeB:i}=n;return!a&&!i?{a:()=>Cn(e,s,!1,!0),b:()=>Cn(r,e,!0,!1)}:!a&&i?{a:()=>Cn(e,s,!1,!1),b:()=>Cn(e,r,!0,!1)}:a&&!i?{a:()=>Cn(s,e,!1,!0),b:()=>Cn(r,e,!1,!1)}:{a:()=>Cn(s,e,!0,!0),b:()=>Cn(e,r,!0,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OOe={kernelName:n1,gradFunc:(e,t,n)=>{const{blockShape:r,crops:s}=n;return{x:()=>KE(e,r,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LOe={kernelName:Q_e,gradFunc:(e,t,n)=>{const r=n,s=r.inputShape,a=r.shape,i=Array.from(a);for(let u=s.length-1;u>=0;u--)if(s[u]===a[u])i[u]=1;else if(s[u]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${a}].`);const o=[];for(let u=0;u<i.length;u++)i[u]>1&&o.push(u);return{x:()=>Ct(e,o,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const POe={kernelName:jm,gradFunc:e=>({x:()=>e.clone()})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BOe={kernelName:qm,gradFunc:e=>({x:()=>cn(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zOe={kernelName:Qh,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{clipValueMin:s,clipValueMax:a}=n;return{x:()=>Ws(ll(ep(r,s),nb(r,a)),e,cn(e))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WOe={kernelName:Uv,inputsToSave:["x"],gradFunc:IV.gradFunc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VOe={kernelName:s1,saveAllInputs:!0,gradFunc:(e,t,n)=>{const r=t.map(u=>u.shape),{axis:s}=n,a=zt(s,t[0].shape)[0],i=r.map(u=>u[a]);return Ua(e,i,a).map(u=>()=>u)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UOe={kernelName:Km,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,{dilations:a,strides:i,pad:o,dataFormat:u}=n;return U(id(a),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`),{x:()=>LE(r.shape,e,s,i,o,u),filter:()=>eA(r,e,s.shape,i,o,u)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GOe={kernelName:Xm,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,{strides:a,pad:i,dataFormat:o,dimRoundingMode:u}=n;return{dy:()=>ld(e,s,a,i,o,1,u),filter:()=>eA(e,r,s.shape,a,i,o,u)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HOe(e,t,n,r,s){let a=e;e.rank===4&&(a=be(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;i.rank===4&&(i=be(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),U(a.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${a.shape}.`),U(i.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),U(n.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),U(a.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${a.shape[4]}) must match input depth in filter (${n[3]}.`),U(i.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`);const o={x:a,dy:i},u={strides:r,pad:s,filterShape:n};return pe.runKernel(a1,o,u)}const jOe=ye({conv3DBackpropFilter_:HOe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qOe={kernelName:Qm,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:s,pad:a}=n;U(id(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const[i,o]=t;return{x:()=>vW(i.shape,e,o,s,a),filter:()=>jOe(i,e,o.shape,s,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KOe={kernelName:Ym,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ce(vr(BW(at(n,"float32"))),e)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XOe={kernelName:Jm,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ce(zW(at(n,"float32")),e)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QOe={kernelName:Zm,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s,exclusive:a,reverse:i}=n;return{x:()=>{const o=nr([s],r.rank);let u=kW(e,s,a,!i);return o!=null&&(u=un(u,o)),u}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YOe={kernelName:eg,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:s,pad:a,dimRoundingMode:i}=n,o=r??[1,1];U(id(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[u,c]=t;return U(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${u.rank}.`),U(c.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${c.rank}.`),U(u.shape[3]===c.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`),U(bs(s,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${o}'.`),pa("depthwiseConv2d",a,i),{x:()=>p8e(u.shape,e,c,s,a,o,i),filter:()=>d8e(u,e,c.shape,s,a,o,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JOe={kernelName:tg,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,a={x:r,filter:s,dy:e},i={x:r,filter:s,dy:e};return{x:()=>pe.runKernel(Sy,a,n),filter:()=>pe.runKernel(Ny,i,n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZOe={kernelName:rg,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t,r={dy:e,y:n};return{x:()=>pe.runKernel(c1,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e9e={kernelName:sg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=ce(Ro(vr(rr(n))),2/Math.sqrt(Math.PI));return{x:()=>ce(e,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t9e={kernelName:ag,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ce(e,n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n9e={kernelName:h1,inputsToSave:["input"],gradFunc:(e,t)=>{const[n]=t;return{input:()=>be(e,n.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r9e={kernelName:ig,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ce(e,Ro(n))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s9e={kernelName:og,gradFunc:e=>({x:()=>cn(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a9e={kernelName:lg,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Ot(n.shape,r.shape);return{a:()=>{const o=Nt(e,at(r,"float32")),u=Xr(n.shape,s);return u.length>0?be(Ct(o,u),n.shape):o},b:()=>{let o=ce(e,at(n,"float32"));const u=Xr(r.shape,s);u.length>0&&(o=be(Ct(o,u),r.shape));const c=rr(r);return vr(Nt(o,at(c,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i9e={kernelName:ug,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{const{varianceEpsilon:r}=n,[s,a,i,o]=t,u=o??Sn(1),c=Xr(a.shape,s.shape),l=[];if(a.rank===1){for(let w=0;w<s.shape.length-1;++w)l.push(s.shape[w]);l.push(1)}const d=_t(s,a),h=ce(e,u),p=OW(We(i,Sn(r))),f=ce(ce(ce(p,p),p),Sn(-.5));return{x:()=>a.rank===1?be(ce(ce(e,Pi(be(p,[1,1,1,a.shape[0]]),l)),u),s.shape):be(ce(ce(e,p),u),s.shape),mean:()=>{let w=ce(ce(p,Sn(-1)),h);return a.rank===1&&(w=Ct(w,c)),be(w,a.shape)},variance:()=>{let w=ce(ce(f,d),h);return a.rank===1&&(w=Ct(w,c)),be(w,a.shape)},scale:()=>{const w=ce(d,p);let v=ce(e,w);return a.rank===1&&(v=Ct(v,c)),be(v,a.shape)},offset:()=>{let w=e;return a.rank===1&&(w=Ct(w,c)),be(w,a.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o9e={kernelName:f1,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{const[r,s]=t,{axis:a,batchDims:i}=n,o=zt(a,r.shape)[0],u=(c,l,d)=>()=>{const h=c.shape,p=l.size,f=h.slice(0,o),m=f.length,g=h.slice(a,h.length).slice(1),b=g.length,y=pD(0,m),x=pD(m+1,m+1+b),w=fD([f,[p],g]),v=be(d,w),I=be(l,[p]),N=fD([[m],y,x]),T=un(v,N);let E=HW(T,I,c.shape[o]);const A=Bo(N);return E=un(E,A),E};if(i===1){const c=r.shape[0],l=r.split(c,0);return{x:()=>ul(l.map((p,f)=>u(p,s.slice(f,1),e.slice(f,1))())).reshape(r.shape),indices:()=>s}}else return{x:u(r,s,e),indices:()=>s}}};function pD(e,t){const n=[];for(let r=e;r<t;++r)n.push(r);return n}function fD(e){const t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const l9e={kernelName:cg,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>cn(n),b:()=>cn(r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u9e={kernelName:dg,gradFunc:e=>({x:()=>at(e,"float32")})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c9e={kernelName:hg,gradFunc:e=>({x:()=>cn(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const d9e={kernelName:pg,gradFunc:e=>({x:()=>cn(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h9e={kernelName:fg,gradFunc:e=>({x:()=>cn(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p9e={kernelName:mg,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{alpha:s}=n,a=Ya(r,0);return{x:()=>Ws(a,e,ce(e,s))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f9e={kernelName:bg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Nt(e,We(n,1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m9e={kernelName:gg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Nt(e,at(n,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g9e={kernelName:Z_e,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n;return{logits:()=>{const i=Ro(r);return _t(e,ce(Ct(e,s,!0),i))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b9e(e,t,n,r=5,s=1,a=1,i=.5){const o={x:e,y:t,dy:n},u={depthRadius:r,bias:s,alpha:a,beta:i};return pe.runKernel(v1,o,u)}const y9e=ye({localResponseNormalizationBackprop_:b9e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x9e={kernelName:yg,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{depthRadius:a,bias:i,alpha:o,beta:u}=n;return{x:()=>y9e(r,s,e,a,i,o,u)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kV(e,t,n,r){return t.rank<n.rank&&(t=be(t,jn(t.shape,r))),e.rank<n.rank&&(e=be(e,jn(e.shape,r))),{x:()=>ce(e,at($o(n,t),e.dtype))}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mD={kernelName:xg,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{reductionIndices:s}=r,a=t[0],i=t[1],o=zt(s,a.shape),u=kV(e,i,a,o);return{x:()=>u.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w9e={kernelName:wg,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>ce(e,at(ep(n,r),"float32")),b:()=>ce(e,at(Px(n,r),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v9e(e,t,n,r,s,a,i){const o=Z(e,"dy","maxPool3dGrad"),u=Z(t,"input","maxPool3dGrad"),c=Z(n,"output","maxPool3dGrad");let l=o,d=u,h=c,p=!1;u.rank===4&&(p=!0,l=be(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),d=be(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),h=be(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),U(l.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),U(d.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),U(h.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${h.rank}.`),pa("maxPool3dGrad",a,i);const f={dy:l,input:d,output:h},m={filterSize:r,strides:s,pad:a,dimRoundingMode:i},g=pe.runKernel(Xv,f,m);return p?be(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}const I9e=ye({maxPool3dGrad_:v9e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k9e={kernelName:I1,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:u}=n;return{x:()=>I9e(e,r,s,a,i,o,u)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C9e(e,t,n,r,s,a,i){const o=Z(e,"dy","maxPoolGrad"),u=Z(t,"input","maxPoolGrad"),c=Z(n,"output","maxPoolGrad");U(u.rank===o.rank,()=>`Rank of input (${u.rank}) does not match rank of dy (${o.rank})`),U(o.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),U(u.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${u.rank}.`),pa("maxPoolGrad",a,i);const l={dy:o,input:u,output:c},d={filterSize:r,strides:s,pad:a,dimRoundingMode:i};return pe.runKernel(Kv,l,d)}const S9e=ye({maxPoolGrad_:C9e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N9e={kernelName:vg,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{filterSize:a,strides:i,pad:o}=n;return{x:()=>S9e(e,r,s,a,i,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const T9e={kernelName:Ig,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n,a=zt(s,r.shape),o=sr(r.shape,a)[1],u=fe(o);return{x:()=>{const l=r.shape.slice();a.forEach(p=>{l[p]=1});const d=be(e,l);return Nt(ce(d,Pu(r.shape,"float32")),u)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const E9e={kernelName:kg,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{axis:s}=r,[a,i]=t,o=zt(s,a.shape),u=kV(e,i,a,o);return{x:()=>u.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A9e={kernelName:Cg,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>ce(e,at(nb(n,r),"float32")),b:()=>ce(e,at(Ya(n,r),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $9e={kernelName:Sg,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:s}=n,a=s.map(i=>i[0]);return{x:()=>Yn(e,a,r.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R9e={kernelName:Ng,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Ot(n.shape,r.shape);return{a:()=>{const o=Xr(n.shape,s);return o.length>0?be(Ct(e,o),n.shape):e},b:()=>{const o=ce(e,vr(mI(Nt(n,r)))),u=Xr(r.shape,s);return u.length>0?be(Ct(o,u),r.shape):o}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _9e={kernelName:Tg,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Ot(n.shape,r.shape);return{a:()=>{const o=ce(e,at(r,"float32")),u=Xr(n.shape,s);return u.length>0?be(Ct(o,u),n.shape):o},b:()=>{const o=ce(e,at(n,"float32")),u=Xr(r.shape,s);return u.length>0?be(Ct(o,u),r.shape):o}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D9e={kernelName:k1,gradFunc:e=>({x:()=>vr(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F9e={kernelName:Eg,inputsToSave:["indices"],gradFunc:(e,t)=>{const n=t[0];return{indices:()=>ss(n.shape,"float32")}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M9e={kernelName:E1,gradFunc:e=>({x:()=>cn(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O9e={kernelName:A1,saveAllInputs:!0,gradFunc:(e,t,n)=>{const{axis:r}=n;return dd(e,r).map(a=>()=>a)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gD={kernelName:Ag,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:s}=n,a=s.map(i=>i[0]);return{x:()=>Yn(e,a,r.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L9e={kernelName:$g,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{const[n,r,s]=t,a=n,i=r,o=Ot(a.shape,i.shape);return{a:()=>{const l=at(i,"float32");let d=ce(e,ce(l,ud(a,_t(l,Sn(1)))));const h=Xr(a.shape,o);return h.length>0&&(d=Ct(d,h)),be(d,a.shape)},b:()=>{const l=Ya(a,0),d=Ws(l,_o(a),cn(a));let h=ce(e,ce(s,d));const p=Xr(i.shape,o);return p.length>0&&(h=Ct(h,p)),be(h,i.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const P9e={kernelName:Rg,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{const[n,r]=t,s=Ya(n,0);return{x:()=>Ws(s,e,ce(e,r)),alpha:()=>{let a=Ws(s,cn(e),ce(e,n));const i=Xr(r.shape,e.shape);return i.length>0&&(a=Ct(a,i)),be(a,r.shape)}}}};/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B9e(e,t,n){const r=e.shape.slice();r[n]=1;const s=be(t,r),a=pS(e,n,!0,!1),i=pS(e,n,!0,!0),o=ce(a,i);return ce(s,o)}function z9e(e,t,n){const r=e.shape.length,s=r-n.length,a=nr(n,r);let i=e;a!=null&&(i=un(e,a));const o=i.shape.slice(),c=o.splice(r-n.length,n.length).reduce((h,p)=>h*p,1);o.push(c);const l=i.reshape(o);let d=B9e(l,t,s);if(d=d.reshape(i.shape),a!=null){const h=Bo(a);d=un(d,h)}return d}const W9e={kernelName:_g,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n;let a=[];return s==null?a=r.shape.map((i,o)=>o):typeof s=="number"?a=[s]:a=s,{x:()=>z9e(r,e,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V9e={kernelName:ng,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Ot(n.shape,r.shape);return{a:()=>{const o=Nt(e,at(r,"float32")),u=Xr(n.shape,s);return u.length>0?be(Ct(o,u),n.shape):o},b:()=>{let o=ce(e,at(n,"float32"));const u=Xr(r.shape,s);u.length>0&&(o=be(Ct(o,u),r.shape));const c=rr(r);return vr(Nt(o,at(c,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U9e={kernelName:Dg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Nt(e,vr(rr(n)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G9e={kernelName:Lg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=ce(nb(n,6),j1(n));return{x:()=>ce(e,at(r,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H9e={kernelName:Fg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ce(e,at(j1(n),"float32"))}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j9e={kernelName:$1,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>be(e,n.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q9e={kernelName:Og,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,s={dy:e,images:r};return{images:()=>pe.runKernel(_1,s,n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const K9e={kernelName:Mg,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,s={dy:e,images:r};return{images:()=>pe.runKernel(R1,s,n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X9e={kernelName:Pg,gradFunc:(e,t,n)=>{const{dims:r}=n,s=zt(r,e.shape);return{x:()=>cd(e,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Q9e={kernelName:Bg,gradFunc:e=>({x:()=>cn(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y9e={kernelName:zg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>vr(Nt(e,ce(ud(n,1.5),2)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const J9e={kernelName:D1,inputsToSave:["condition"],gradFunc:(e,t)=>{const[n]=t;return{condition:()=>at(cn(n),"float32"),t:()=>ce(e,at(n,e.dtype)),e:()=>ce(e,at(GE(n),e.dtype))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z9e={kernelName:Wg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const r=Ya(n,Sn(0)),s=Sn(NI),a=Sn(TI),i=ce(e,a),o=ce(ce(e,s),Ro(at(n,"float32")));return Ws(r,i,o)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eLe={kernelName:Hg,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ce(e,ce(n,_t(Sn(1),n)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tLe={kernelName:Gg,gradFunc:e=>({x:()=>cn(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nLe={kernelName:Vg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ce(PE(at(n,"float32")),e)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rLe={kernelName:Ug,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ce(IW(at(n,"float32")),e)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sLe={kernelName:F1,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{begin:s,size:a}=n,i=r.shape,[o,u]=q1(r,s,a),c=[];for(let l=0;l<e.rank;l++)c.push([o[l],i[l]-o[l]-u[l]]);return{x:()=>qE(e,c)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aLe={kernelName:Xg,outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{dim:s}=n,a=!0,i=ce(e,r);return{logits:()=>_t(i,ce(Ct(i,[s],a),r))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iLe={kernelName:jg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ce(e,tb(n))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bD={kernelName:M1,gradFunc:(e,t,n)=>{const{blockShape:r,paddings:s}=n;return{x:()=>OE(e,r,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yD={kernelName:O1,gradFunc:(e,t,n)=>{const{axis:r}=n;return{x:()=>ia(e,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oLe={kernelName:qg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Nt(e,ce(Ss(at(n,"float32")),2))}}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lLe={kernelName:rI,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ce(e,ce(at(n,"float32"),2))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uLe={kernelName:Qg,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Sn(2);return{a:()=>ce(e,ce(s,_t(n,r))),b:()=>ce(e,ce(s,_t(r,n)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cLe={kernelName:Jh,gradFunc:e=>({x:()=>cn(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dLe={kernelName:Yg,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Ot(n.shape,r.shape);return{a:()=>{let o=e;const u=Xr(n.shape,s);return u.length>0&&(o=Ct(o,u)),be(o,n.shape)},b:()=>{let o=e;const u=Xr(r.shape,s);return u.length>0&&(o=Ct(o,u)),be(vr(o),r.shape)}}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hLe={kernelName:Kg,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,s=r.shape.slice(),{axis:a}=n;zt(a,r.shape).forEach(c=>{s[c]=1});const o=be(e,s),u=ce(o,Pu(r.shape,"float32"));return{x:()=>u}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pLe={kernelName:Jg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Nt(e,rr(PE(n)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fLe={kernelName:Zg,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ce(_t(Sn(1),rr(n)),e)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mLe={kernelName:Yh,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{reps:s}=n;return{x:()=>{let i=cn(r);if(r.rank===1)for(let o=0;o<s[0];++o)i=We(i,Yn(e,[o*r.shape[0]],[r.shape[0]]));else if(r.rank===2)for(let o=0;o<s[0];++o)for(let u=0;u<s[1];++u)i=We(i,Yn(e,[o*r.shape[0],u*r.shape[1]],[r.shape[0],r.shape[1]]));else if(r.rank===3)for(let o=0;o<s[0];++o)for(let u=0;u<s[1];++u)for(let c=0;c<s[2];++c)i=We(i,Yn(e,[o*r.shape[0],u*r.shape[1],c*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else if(r.rank===4)for(let o=0;o<s[0];++o)for(let u=0;u<s[1];++u)for(let c=0;c<s[2];++c)for(let l=0;l<s[3];++l)i=We(i,Yn(e,[o*r.shape[0],u*r.shape[1],c*r.shape[2],l*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);return i}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gLe={kernelName:Gl,gradFunc:(e,t,n)=>{const r=n,{perm:s}=r,a=Bo(s);return{x:()=>un(e,a)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bLe={kernelName:z1,gradFunc:(e,t,n)=>{const r=n,{axis:s}=r;return{value:()=>ul(e,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yLe={kernelName:aI,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>xLe(e,n)}}};function xLe(e,t){const n=Lu(t,cn(t)),r=WE(e,n);let s=ep(t,Sn(0,"int32"));const a=r.rank-s.rank;for(let o=0;o<a;++o)s=ta(s,o+1);s=ll(s,Pu(r.shape,"bool"));const i=cn(r);return Ws(s,r,i)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wLe={kernelName:W1,gradFunc:e=>({x:()=>cn(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vLe=[IV,yOe,xOe,wOe,vOe,IOe,kOe,COe,SOe,NOe,TOe,EOe,ROe,FOe,MOe,OOe,LOe,POe,BOe,zOe,WOe,VOe,GOe,UOe,qOe,KOe,XOe,QOe,YOe,JOe,V9e,ZOe,e9e,t9e,n9e,r9e,a9e,s9e,i9e,o9e,l9e,u9e,c9e,d9e,h9e,p9e,f9e,m9e,g9e,x9e,mD,mD,w9e,k9e,N9e,T9e,E9e,A9e,$9e,R9e,_9e,D9e,F9e,M9e,O9e,gD,gD,L9e,P9e,W9e,U9e,G9e,H9e,j9e,q9e,K9e,X9e,Q9e,Y9e,J9e,Z9e,eLe,tLe,nLe,rLe,sLe,aLe,iLe,bD,bD,yD,yD,oLe,uLe,lLe,cLe,dLe,hLe,pLe,fLe,mLe,gLe,bLe,yLe,wLe];for(const e of vLe)nDe(e);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.abs=function(){return this.throwIfDisposed(),Fs(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.acos=function(){return this.throwIfDisposed(),sFe(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.acosh=function(){return this.throwIfDisposed(),iFe(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.add=function(e){return this.throwIfDisposed(),We(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.all=function(e,t){return this.throwIfDisposed(),yW(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.any=function(e,t){return this.throwIfDisposed(),dS(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.argMax=function(e){return this.throwIfDisposed(),Ty(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.argMin=function(e){return this.throwIfDisposed(),dFe(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.asScalar=function(){return this.throwIfDisposed(),U(this.size===1,()=>"The array must have only 1 element."),be(this,[])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.asType=function(e){return this.throwIfDisposed(),at(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.as1D=function(){return this.throwIfDisposed(),be(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.as2D=function(e,t){return this.throwIfDisposed(),be(this,[e,t])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),be(this,[e,t,n])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),be(this,[e,t,n,r])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.as5D=function(e,t,n,r,s){return this.throwIfDisposed(),be(this,[e,t,n,r,s])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.asin=function(){return this.throwIfDisposed(),pFe(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.asinh=function(){return this.throwIfDisposed(),mFe(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.atan=function(){return this.throwIfDisposed(),bFe(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.atan2=function(e){return this.throwIfDisposed(),xFe(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.atanh=function(){return this.throwIfDisposed(),vFe(this)};Te().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),ME(this,e,t,n,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),OE(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.batchNorm=function(e,t,n,r,s){return this.throwIfDisposed(),dI(this,e,t,n,r,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.broadcastTo=function(e){return this.throwIfDisposed(),ry(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.cast=function(e){return this.throwIfDisposed(),at(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.ceil=function(){return this.throwIfDisposed(),KFe(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),Ka(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof Br&&(e=[e]),ia([this,...e],t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.conv1d=function(e,t,n,r,s,a){return this.throwIfDisposed(),xW(this,e,t,n,r,s,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.conv2dTranspose=function(e,t,n,r,s){return this.throwIfDisposed(),wW(this,e,t,n,r,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.conv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),ld(this,e,t,n,r,s,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.cos=function(){return this.throwIfDisposed(),PE(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.cosh=function(){return this.throwIfDisposed(),IW(this)};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),pS(this,e,t,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),kW(this,e,t,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),x6e(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.depthwiseConv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),BE(this,e,t,n,r,s,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.dilation2d=function(e,t,n,r,s){return this.throwIfDisposed(),I6e(this,e,t,n,r,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.divNoNan=function(e){return this.throwIfDisposed(),T6e(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.div=function(e){return this.throwIfDisposed(),Nt(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.dot=function(e){return this.throwIfDisposed(),A6e(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.elu=function(){return this.throwIfDisposed(),pI(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.equal=function(e){return this.throwIfDisposed(),$o(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.erf=function(){return this.throwIfDisposed(),CW(this)};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),W6e(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.exp=function(){return this.throwIfDisposed(),Ro(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.expandDims=function(e){return this.throwIfDisposed(),ta(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.expm1=function(){return this.throwIfDisposed(),H6e(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.fft=function(){return this.throwIfDisposed(),VW(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.flatten=function(){return this.throwIfDisposed(),be(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.floor=function(){return this.throwIfDisposed(),mI(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.floorDiv=function(e){return this.throwIfDisposed(),bW(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.gather=function(e,t,n){return this.throwIfDisposed(),WE(this,e,t,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.greaterEqual=function(e){return this.throwIfDisposed(),ep(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.greater=function(e){return this.throwIfDisposed(),Ya(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.ifft=function(){return this.throwIfDisposed(),fS(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.irfft=function(){return this.throwIfDisposed(),MMe(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.isFinite=function(){return this.throwIfDisposed(),e5e(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.isInf=function(){return this.throwIfDisposed(),n5e(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.isNaN=function(){return this.throwIfDisposed(),s5e(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.leakyRelu=function(e){return this.throwIfDisposed(),UE(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.lessEqual=function(e){return this.throwIfDisposed(),nb(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.less=function(e){return this.throwIfDisposed(),Px(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),u5e(this,e,t,n,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.logSigmoid=function(){return this.throwIfDisposed(),g5e(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.logSoftmax=function(e){return this.throwIfDisposed(),AW(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),$W(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.log=function(){return this.throwIfDisposed(),_o(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.log1p=function(){return this.throwIfDisposed(),EW(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.logicalAnd=function(e){return this.throwIfDisposed(),ll(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.logicalNot=function(){return this.throwIfDisposed(),GE(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.logicalOr=function(e){return this.throwIfDisposed(),RW(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.logicalXor=function(e){return this.throwIfDisposed(),C5e(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),Cn(this,e,t,n)};Te().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),HE(this,e,t,n,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.max=function(e,t){return this.throwIfDisposed(),Ui(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.maximum=function(e){return this.throwIfDisposed(),Lu(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.mean=function(e,t){return this.throwIfDisposed(),$r(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.min=function(e,t){return this.throwIfDisposed(),Lx(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.minimum=function(e){return this.throwIfDisposed(),$y(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),_5e(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.mod=function(e){return this.throwIfDisposed(),F5e(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.mul=function(e){return this.throwIfDisposed(),ce(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.neg=function(){return this.throwIfDisposed(),vr(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.norm=function(e,t,n){return this.throwIfDisposed(),fI(this,e,t,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.notEqual=function(e){return this.throwIfDisposed(),Bx(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),_W(this,e,t,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.onesLike=function(){return this.throwIfDisposed(),fi(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.pad=function(e,t){return this.throwIfDisposed(),qE(this,e,t)};Te().prototype.pool=function(e,t,n,r,s,a){return this.throwIfDisposed(),G5e(this,e,t,n,r,s,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.pow=function(e){return this.throwIfDisposed(),ud(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.prelu=function(e){return this.throwIfDisposed(),XE(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.prod=function(e,t){return this.throwIfDisposed(),q5e(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.reciprocal=function(){return this.throwIfDisposed(),mMe(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.relu=function(){return this.throwIfDisposed(),tp(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.relu6=function(){return this.throwIfDisposed(),FW(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.reshapeAs=function(e){return this.throwIfDisposed(),be(this,e.shape)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.reshape=function(e){return this.throwIfDisposed(),be(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),qW(this,e,t,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),KW(this,e,t,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.reverse=function(e){return this.throwIfDisposed(),cd(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.rfft=function(){return this.throwIfDisposed(),PMe(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.round=function(){return this.throwIfDisposed(),MW(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.rsqrt=function(){return this.throwIfDisposed(),OW(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.selu=function(){return this.throwIfDisposed(),LW(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.separableConv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),PW(this,e,t,n,r,s,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.sigmoid=function(){return this.throwIfDisposed(),tb(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.sign=function(){return this.throwIfDisposed(),CMe(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.sin=function(){return this.throwIfDisposed(),BW(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.sinh=function(){return this.throwIfDisposed(),zW(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.slice=function(e,t){return this.throwIfDisposed(),Yn(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.softmax=function(e){return this.throwIfDisposed(),ZE(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.softplus=function(){return this.throwIfDisposed(),U1(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),KE(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.split=function(e,t){return this.throwIfDisposed(),Ua(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.sqrt=function(){return this.throwIfDisposed(),Ss(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.square=function(){return this.throwIfDisposed(),rr(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.squaredDifference=function(e){return this.throwIfDisposed(),zMe(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.squeeze=function(e){return this.throwIfDisposed(),H1(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.stack=function(e,t){this.throwIfDisposed();const n=e instanceof Br?[this,e]:[this,...e];return ul(n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.step=function(e){return this.throwIfDisposed(),j1(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.stridedSlice=function(e,t,n,r,s,a,i,o){return this.throwIfDisposed(),HMe(this,e,t,n,r,s,a,i,o)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.sub=function(e){return this.throwIfDisposed(),_t(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.sum=function(e,t){return this.throwIfDisposed(),Ct(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.tan=function(){return this.throwIfDisposed(),qMe(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.tanh=function(){return this.throwIfDisposed(),cI(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.tile=function(e){return this.throwIfDisposed(),Pi(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.toBool=function(){return this.throwIfDisposed(),at(this,"bool")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.toFloat=function(){return this.throwIfDisposed(),at(this,"float32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.toInt=function(){return this.throwIfDisposed(),at(this,"int32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.topk=function(e,t){return this.throwIfDisposed(),QMe(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.transpose=function(e){return this.throwIfDisposed(),un(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.unique=function(e){return this.throwIfDisposed(),ZMe(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),HW(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.unstack=function(e){return this.throwIfDisposed(),dd(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.where=function(e,t){return this.throwIfDisposed(),Ws(e,this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Te().prototype.zerosLike=function(){return this.throwIfDisposed(),cn(this)};/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class po extends Error{constructor(t){super(t),Object.setPrototypeOf(this,po.prototype)}}class li extends Error{constructor(t){super(t),Object.setPrototypeOf(this,li.prototype)}}class le extends Error{constructor(t){super(t),Object.setPrototypeOf(this,le.prototype)}}class qt extends Error{constructor(t){super(t),Object.setPrototypeOf(this,qt.prototype)}}class OA extends Error{constructor(t){super(t),Object.setPrototypeOf(this,OA.prototype)}}/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class CV{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let n;return this.cache.has(t)&&(n=this.cache.get(t),this.cache.delete(t),this.cache.set(t,n)),n}put(t,n){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){const r=this.cache.keys().next().value;this.cache.delete(r)}this.cache.set(t,n)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);if(this.maxEntries>t)for(let n=0;n<this.maxEntries-t;n++){const r=this.cache.keys().next().value;this.cache.delete(r)}this.maxEntries=t}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function hd(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}else{const n=new Array(t);return n.fill(e),n}}function fo(e,t){if(!e)throw new OA(t)}function xD(e,t){let n=0;for(const r of e)r===t&&n++;return n}function na(e){return e.length===1?e[0]:e}function $n(e){return Array.isArray(e)?e:[e]}function Jo(e){const n=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return n[0]!=="_"?n:"private"+n}function Ic(e){return e.length<=1||e.indexOf("_")===-1?e:e.replace(/[_]+(\w|$)/g,(t,n)=>n.toUpperCase())}let ni={};function LA(e){if(e==null)return null;const t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function gS(e){if(!(e==null||typeof e!="object"))if(Array.isArray(e))e.forEach(t=>gS(t));else{const t=Object.keys(e);for(const n of t){const r=e[n];r!=null&&typeof r=="object"&&(!Array.isArray(r)&&r.type==="ndarray"&&typeof r.value=="number"?e[n]=r.value:gS(r))}}}function K1(e,t={},n={},r="object",s=!1){if(typeof e=="string"){const a=e;let i;if(a in n)i=n[a];else if(a in ni)i=ni[a];else if(i=t[a],i==null)throw new le(`Unknown ${r}: ${e}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}else{const a=e;if(a.className==null||a.config==null)throw new le(`${r}: Improper config format: ${JSON.stringify(a)}.
'className' and 'config' must set.`);const i=a.className;let o,u;if(i in n?[o,u]=n[i]:i in ni?[o,u]=ni.className:i in t&&([o,u]=t[i]),o==null)throw new le(`Unknown ${r}: ${i}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(u!=null){const c={};for(const p of Object.keys(ni))c[p]=ni[p];for(const p of Object.keys(n))c[p]=n[p];const l=a.config;l.customObjects=c;const d=Object.assign({},ni);for(const p of Object.keys(n))ni[p]=n[p];gS(a.config);const h=u(o,a.config,n,s);return ni=Object.assign({},d),h}else{const c=Object.assign({},ni);for(const d of Object.keys(n))ni[d]=n[d];const l=new o(a.config);return ni=Object.assign({},c),l}}}function ILe(e,t){return e<t?-1:e>t?1:0}function E2(e,t){return-1*ILe(e,t)}function ql(e){if(e==null)return e;const t=[];for(const n of e)t.indexOf(n)===-1&&t.push(n);return t}function kLe(e){if(e==null)throw new le(`Invalid value in obj: ${JSON.stringify(e)}`);for(const t in e)if(e.hasOwnProperty(t))return!1;return!0}function ap(e,t,n){if(n!=null&&e.indexOf(n)<0)throw new le(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function PA(e,t,n=0,r=1/0){return fo(n>=0),fo(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every(s=>typeof s===t)}function is(e,t){Array.isArray(e)?(U(e.length>0,()=>`${t} is unexpectedly an empty array.`),e.forEach((n,r)=>is(n,`element ${r+1} of ${t}`))):U(Number.isInteger(e)&&e>0,()=>`Expected ${t} to be a positive integer, but got ${SV(e)}.`)}function SV(e){return e===null?"null":Array.isArray(e)?"["+e.map(t=>SV(t)).join(",")+"]":typeof e=="string"?`"${e}"`:`${e}`}function CLe(e,t,n){let r=n!=null?n():ws(),s;return(...i)=>{const o=n!=null?n():ws();return o-r<t||(r=o,s=e(...i)),s}}function NV(e){return e==="relu"?"relu":e==="linear"?"linear":e==="elu"?"elu":null}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let SLe=0;function TV(){return SLe++}const A2={};function $I(e=""){return e in A2||(A2[e]=0),A2[e]+=1,e+A2[e].toString()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const NLe=["channelsFirst","channelsLast"],TLe=["nearest","bilinear"],ELe=["valid","same","causal"],ALe=["max","avg"],$Le=["sum","mul","concat","ave"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const gp=new Map;function Sr(e){ap(NLe,"DataFormat",e)}function RLe(e){ap(TLe,"InterpolationFormat",e)}function Ja(e){ap(ELe,"PaddingMode",e)}function EV(e){ap(ALe,"PoolMode",e)}const sy=[],wD="/";function Fc(e,t){sy.push(e);try{const n=t();return sy.pop(),n}catch(n){throw sy.pop(),n}}function _Le(){return sy.length===0?"":sy.join(wD)+wD}function AV(e){if(!RV(e))throw new Error("Not a valid tensor name: '"+e+"'");return _Le()+e}function $V(e){if(!RV(e))throw new Error("Not a valid tensor name: '"+e+"'");gp.has(e)||gp.set(e,0);const t=gp.get(e);if(gp.set(e,gp.get(e)+1),t>0){const n=`${e}_${t}`;return gp.set(n,1),n}else return e}const DLe=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function RV(e){return!!e.match(DLe)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function FLe(e){return e===parseInt(e.toString(),10)}function Kl(e,t,n){t==null&&(t=0),n==null&&(n=e.length);let r=1;for(let s=t;s<n;++s)r*=e[s];return r}function af(e){if(e.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r<t&&(t=r)}return t}function du(e){if(e.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r>t&&(t=r)}return t}function Xi(e,t){if(t<e)throw new le(`end (${t}) < begin (${e}) is forbidden.`);const n=[];for(let r=e;r<t;++r)n.push(r);return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let Sk;function Vr(){return Sk==null&&(Sk=EDe().epsilon()),Sk}function Qi(){return"channelsLast"}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Co(e,t){return at(e,t)}function X1(e,t=-1){const n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),be(e,n)}function MLe(e,t){return we(()=>{if(e.shape.length!==2)throw new le(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);const n=X1(e,1);return bS(n,[1,t,1])})}function OLe(e){const t=[Kl(e.shape)];return be(e,t)}function LLe(e){if(e.rank<=1)throw new le(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);const t=[e.shape[0],Kl(e.shape,1)];return be(e,t)}function Mc(e,t,n){return we(()=>{switch(e.rank){case 1:return YE(e,t,n);case 2:return WW(e,[t,0],[n,e.shape[1]]);case 3:return JE(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return Wx(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return Yn(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return Yn(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new le(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}})}function Nk(e,t,n){return we(()=>{switch(e.rank){case 1:return YE(e,t,n);case 2:return WW(e,[0,t],[e.shape[0],n]);case 3:return JE(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return Wx(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new le(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function $2(e,t,n,r){return we(()=>{switch(e.rank){case 1:return YE(e,t,n);case 2:switch(r){case 1:return Mc(e,t,n);case 2:return Nk(e,t,n);default:throw new le(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return Mc(e,t,n);case 2:return JE(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return Nk(e,t,n);default:throw new le(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return Mc(e,t,n);case 2:return Wx(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return Wx(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return Nk(e,t,n);default:throw new le(`The axis is not within the rank of the tensor ${r}`)}default:throw new le(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function BA(e,t=-1){let n;return t<0&&(n=e[0].rank,n!==0?t=n:t=0),t===e[0].rank&&(t=-1),ia(e,t)}function vD(e,t){switch(e.rank){case 1:return YFe([e,t]);case 2:return ZFe([e,t],0);case 3:return t6e([e,t],0);case 4:return r6e([e,t],0);default:throw new le(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function bS(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new le(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return Pi(e,t)}function RI(e,t=0,n=1,r,s){return dMe(e,t,n,r,s)}function So(e,t,n,r){if(e.rank<2||t.rank<2)throw new qt(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){const s=e.shape.slice(-1)[0],a=t.shape.slice(-2)[0];if(s!==a)throw new qt(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(e.rank===2&&t.rank===2)return oD({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?yS(e.rank,r,Qi()):null,activation:n});{const s=e.shape.slice(),a=s.pop();e=be(e,[-1,a]);const i=t.shape.slice(),o=i.pop(),u=i.pop(),c=[...i,o],l=Array.from({length:t.rank},(f,m)=>m===0?t.rank-2:m<=t.rank-2?m-1:m);t=be(un(t,l),[u,-1]);const d=[...s,...c];return be(oD({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?yS(e.rank,r,Qi()):null,activation:n}),d)}}function _V(e,t,n){return we(()=>(Array.isArray(t)?t=ka(t,"int32"):t=at(t,"int32"),WE(e,t,n)))}function Q1(e){return ce(e,e)}function yS(e,t,n){const r=t.shape;if(t.rank!==1&&t.rank!==e)throw new le(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(e===5){if(n==="channelsFirst")return r.length===1?be(t,[1,r[0],1,1,1]):be(t,[1,r[3],r[0],r[1],r[2]]);if(n==="channelsLast")return r.length===1?be(t,[1,1,1,1,r[0]]):be(t,[1].concat(r))}else if(e===4){if(n==="channelsFirst")return r.length===1?be(t,[1,r[0],1,1]):be(t,[1,r[2],r[0],r[1]]);if(n==="channelsLast")return r.length===1?be(t,[1,1,1,r[0]]):be(t,[1].concat(r))}else if(e===3){if(n==="channelsFirst")return r.length===1?be(t,[1,r[0],1]):be(t,[1,r[1],r[0]]);if(n==="channelsLast")return r.length===1?be(t,[1,1,r[0]]):be(t,[1].concat(r))}else if(e<3)return t;throw new le(`Unsupported input rank by biasAdd: ${t.rank}`)}function no(e,t,n){return we(()=>(n==null&&(n=Qi()),Sr(n),We(e,yS(e.rank,t,n))))}function PLe(e,t=1){if(t!==1)throw new qt(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return pI(e)}function BLe(e){return we(()=>Nt(e,We(Fs(e),1)))}function DV(e,t,n,r){return we(()=>i8e(e,t,n,r))}function zLe(e){return we(()=>{const t=We(.5,ce(.2,e));return Ka(t,0,1)})}function Y1(e,t,n=!1){return n?e():t()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const WLe=["fanIn","fanOut","fanAvg"],VLe=["normal","uniform","truncatedNormal"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function ULe(e){ap(WLe,"FanMode",e)}function GLe(e){ap(VLe,"Distribution",e)}class yi extends sb{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class FV extends yi{apply(t,n){return ss(t,n)}}FV.className="Zeros";Le(FV);class zA extends yi{apply(t,n){return Pu(t,n)}}zA.className="Ones";Le(zA);class MV extends yi{constructor(t){if(super(),typeof t!="object")throw new le(`Expected argument of type ConstantConfig but got ${t}`);if(t.value===void 0)throw new le(`config must have value set but got ${t}`);this.value=t.value}apply(t,n){return we(()=>ce(Sn(this.value),Pu(t,n)))}getConfig(){return{value:this.value}}}MV.className="Constant";Le(MV);class OV extends yi{constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,n){return G1(t,this.minval,this.maxval,n,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}OV.className="RandomUniform";Le(OV);class LV extends yi{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,n){if(n=n||"float32",n!=="float32"&&n!=="int32")throw new qt(`randomNormal does not support dType ${n}.`);return RI(t,this.mean,this.stddev,n,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}LV.className="RandomNormal";Le(LV);class PV extends yi{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,n){if(n=n||"float32",n!=="float32"&&n!=="int32")throw new qt(`truncatedNormal does not support dType ${n}.`);return GW(t,this.mean,this.stddev,n,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}PV.className="TruncatedNormal";Le(PV);class BV extends yi{constructor(t){super(),this.gain=t.gain!=null?t.gain:1}apply(t,n){return we(()=>{if(t.length!==2||t[0]!==t[1])throw new le("Identity matrix initializer can only be used for 2D square matrices.");return ce(this.gain,TW(t[0]))})}getConfig(){return{gain:this.gain}}}BV.className="Identity";Le(BV);function HLe(e,t="channelsLast"){let n,r;if(Sr(t),e.length===2)n=e[0],r=e[1];else if([3,4,5].indexOf(e.length)!==-1){if(t==="channelsFirst"){const s=Kl(e,2);n=e[1]*s,r=e[0]*s}else if(t==="channelsLast"){const s=Kl(e,0,e.length-2);n=e[e.length-2]*s,r=e[e.length-1]*s}}else{const s=Kl(e);n=Math.sqrt(s),r=Math.sqrt(s)}return[n,r]}class Ra extends yi{constructor(t){if(super(),t.scale<0)throw new le(`scale must be a positive float. Got: ${t.scale}`);this.scale=t.scale==null?1:t.scale,this.mode=t.mode==null?"fanIn":t.mode,ULe(this.mode),this.distribution=t.distribution==null?"normal":t.distribution,GLe(this.distribution),this.seed=t.seed}apply(t,n){const r=HLe(t),s=r[0],a=r[1];let i=this.scale;if(this.mode==="fanIn"?i/=Math.max(1,s):this.mode==="fanOut"?i/=Math.max(1,a):i/=Math.max(1,(s+a)/2),this.distribution==="normal"){const o=Math.sqrt(i);if(n=n||"float32",n!=="float32"&&n!=="int32")throw new qt(`${this.getClassName()} does not support dType ${n}.`);return GW(t,0,o,n,this.seed)}else{const o=Math.sqrt(3*i);return G1(t,-o,o,n,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}Ra.className="VarianceScaling";Le(Ra);class WA extends Ra{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return Ra.className}}WA.className="GlorotUniform";Le(WA);class VA extends Ra{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return Ra.className}}VA.className="GlorotNormal";Le(VA);class UA extends Ra{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return Ra.className}}UA.className="HeNormal";Le(UA);class GA extends Ra{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return Ra.className}}GA.className="HeUniform";Le(GA);class HA extends Ra{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return Ra.className}}HA.className="LeCunNormal";Le(HA);class jA extends Ra{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return Ra.className}}jA.className="LeCunUniform";Le(jA);class zV extends yi{constructor(t){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=t.gain==null?this.DEFAULT_GAIN:t.gain,this.seed=t.seed}apply(t,n){return we(()=>{if(t.length<2)throw new qt("Shape must be at least 2D.");if(n!=="int32"&&n!=="float32"&&n!==void 0)throw new TypeError(`Unsupported data type ${n}.`);n=n;const r=fe(t.slice(0,-1)),s=t[t.length-1],a=r*s;a>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${a}) elements: Slowness may result.`);const i=[Math.max(s,r),Math.min(s,r)],o=RI(i,0,1,n,this.seed),u=nOe.qr(o,!1);let c=u[0];const d=u[1].flatten().stridedSlice([0],[Math.min(s,r)*Math.min(s,r)],[Math.min(s,r)+1]);return c=ce(c,d.sign()),r<s&&(c=c.transpose()),ce(Sn(this.gain),c.reshape(t))})}getConfig(){return{gain:this.gain,seed:this.seed}}}zV.className="Orthogonal";Le(zV);const ID={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function kD(e,t={}){return K1(e,oi.getMap().classNameMap,t,"initializer")}function pr(e){return LA(e)}function or(e){if(typeof e=="string"){const t=e in ID?ID[e]:e;if(t==="GlorotNormal")return new VA;if(t==="GlorotUniform")return new WA;if(t==="HeNormal")return new UA;if(t==="HeUniform")return new GA;if(t==="LeCunNormal")return new HA;if(t==="LeCunUniform")return new jA;{const n={};return n.className=t,n.config={},kD(n)}}else return e instanceof yi?e:kD(e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function xS(e){return Array.isArray(e)&&Array.isArray(e[0])}function Vx(e){return e.length===0?[]:Array.isArray(e[0])?e:[e]}function Mt(e){let t;if(Array.isArray(e)){if(e.length!==1)throw new le(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function gn(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(e.length===1)return e=e,e[0];throw new le(`Expected exactly 1 Shape; got ${e.length}`)}else return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Ux(e){let t=0;for(const n of e)n.shape.length===0?t+=1:t+=n.shape.reduce((r,s)=>r*s);return t}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const CD="Variable";class jLe{constructor(t,n="float32",r=CD,s=!0,a=null){this.dtype=n??"float32",this.shape=t.shape,this.id=TV(),r=r??CD,this.originalName=AV(r),this.name=$V(this.originalName),this.trainable_=s,this.constraint=a,this.val=n8e(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),qLe(this.val,t),this.val.id!==t.id&&(this.val.assign(t),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function qLe(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}function wS(e){return e.map(t=>t.read())}function qA(e){e.forEach(t=>{t[0].write(t[1])})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Ur{constructor(t){this.dtype=t.dtype,this.shape=t.shape,t.shape!=null?this.ndim=t.shape.length:this.ndim=t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class Do{constructor(t,n,r,s,a,i,o){this.dtype=t,this.shape=n,this.sourceLayer=r,this.inputs=s,this.callArgs=a,this.outputTensorIndex=o,this.id=TV(),i!=null&&(this.originalName=AV(i),this.name=$V(this.originalName)),this.rank=n.length}}let KLe=0;class _I{constructor(t,n){this.callArgs=n,this.id=KLe++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const r of t.inboundLayers)r?.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const n of this.inboundLayers)n!=null?t.push(n.name):t.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let XLe=0;class Jt extends sb{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=XLe++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let n=t.name;if(!n){const r=this.getClassName();n=Jo(r)+"_"+$I(r)}if(this.name=n,this.trainable_=t.trainable==null?!0:t.trainable,t.inputShape!=null||t.batchInputShape!=null){let r;if(t.batchInputShape!=null)r=t.batchInputShape;else if(t.inputShape!=null){let a=null;t.batchSize!=null&&(a=t.batchSize),r=[a].concat(t.inputShape)}this.batchInputShape=r;let s=t.dtype;s==null&&(s=t.inputDType),s==null&&(s="float32"),this.dtype=s}t.weights!=null?this.initialWeights=t.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,n){return t.name+"_ib-"+n.toString()}getNodeAtIndex(t,n){if(this.inboundNodes.length===0)throw new li(`The layer has never been called and thus has no defined ${n}.`);if(this.inboundNodes.length<=t)throw new le(`Asked to get ${n} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return na(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return na(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new po(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new po(`Layer ${this.name} is not connected, no input to return.`);return na(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new po(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new po(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return na(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(n=>n.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){const n=$n(t);if(this.inputSpec==null||this.inputSpec.length===0)return;const r=$n(this.inputSpec);if(n.length!==r.length)throw new le(`Layer ${this.name} expects ${r.length} inputs, but it received ${n.length} input tensors. Input received: ${t}`);for(let s=0;s<n.length;s++){const a=n[s],i=r[s];if(i==null)continue;const o=a.rank;if(i.ndim!=null&&o!==i.ndim)throw new le(`Input ${s} is incompatible with layer ${this.name}: expected ndim=${i.ndim}, found ndim=${o}`);if(i.maxNDim!=null&&o>i.maxNDim)throw new le(`Input ${s} is incompatible with layer ${this.name}: expected max_ndim=${i.maxNDim}, found ndim=${o}`);if(i.minNDim!=null&&o<i.minNDim)throw new le(`Input ${s} is incompatible with layer ${this.name}: expected min_ndim=${i.minNDim}, found ndim=${o}.`);if(i.dtype!=null&&a.dtype!==i.dtype)throw new le(`Input ${s} is incompatible with layer ${this.name} : expected dtype=${i.dtype}, found dtype=${a.dtype}.`);if(i.axes){const u=a.shape;for(const c in i.axes){const l=Number(c),d=i.axes[c],h=l>=0?u[l]:u[u.length+l];if(d!=null&&[d,null].indexOf(h)===-1)throw new le(`Input ${s} is incompatible with layer ${this.name}: expected axis ${l} of input shape to have value ${d} but got shape ${u}.`)}}if(i.shape!=null)for(let u=0;u<i.shape.length;++u){const c=i.shape[u],l=a.shape[u];if(c!=null&&l!=null&&c!==l)throw new le(`Input ${s} is incompatible with layer ${this.name}: expected shape=${i.shape}, found shape=${a.shape}.`)}}}call(t,n){return t}invokeCallHook(t,n){this._callHook!=null&&this._callHook(t,n)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,n){n=n||{},this.assertNotDisposed();const r=$n(t),s=JLe(t),a=ZLe(t);if(s===a)throw new le("Arguments to apply() must be all SymbolicTensors or all Tensors");return Fc(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);const i=[];for(const o of $n(t))i.push(o.shape);this.build(na(i)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&a&&(this._refCount=1)}if(this.assertInputCompatibility(t),a){let i=this.call(t,n);this.supportsMasking&&this.setMaskMetadata(t,i);const o=$n(i),u=[];for(let c of o)r.indexOf(c)!==-1&&(c=c.clone()),u.push(c);if(i=na(u),this.activityRegularizer!=null)throw new qt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return i}else{const i=QLe(t),o=this.computeOutputShape(i);let u;const c=YLe(t);if(this.warnOnIncompatibleInputShape(Array.isArray(t)?i[0]:i),o!=null&&o.length>0&&Array.isArray(o[0])?u=o.map((l,d)=>new Do(c,l,this,$n(t),n,this.name,d)):u=new Do(c,o,this,$n(t),n,this.name),this.addInboundNode(t,u,null,null,i,o,n),this._refCount++,this.activityRegularizer!=null)throw new qt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return u}})}warnOnIncompatibleInputShape(t){if(this.batchInputShape!=null)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let n=!1;this.batchInputShape.forEach((r,s)=>{r!=null&&t[s]!=null&&t[s]!==r&&(n=!0)}),n&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new po(`The layer ${this.name} has never been called and thus has no defined output shape.`);const t=[];for(const n of this.inboundNodes){const r=JSON.stringify(n.outputShapes);t.indexOf(r)===-1&&t.push(r)}if(t.length===1){const n=this.inboundNodes[0].outputShapes;return Array.isArray(n)&&Array.isArray(n[0])&&n.length===1?n[0]:n}else throw new po(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new li(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return Ux(this.weights)}build(t){this.built=!0}getWeights(t=!1){return wS(t?this.trainableWeights:this.weights)}setWeights(t){we(()=>{const n=this.weights;if(n.length!==t.length)throw new le(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${n.length} weights. Provided weights: ${t}...`);if(n.length===0)return;const r=[],s=wS(n);for(let a=0;a<s.length;++a){const i=s[a],o=n[a],u=t[a];if(!Nn(i.shape,u.shape))throw new le(`Layer weight shape ${i.shape} not compatible with provided weight shape ${u.shape}`);r.push([o,u])}qA(r)})}addWeight(t,n,r,s,a,i,o,u){if(this._addedWeightNames.indexOf(t)!==-1)throw new le(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),r==null&&(r="float32"),this.fastWeightInitDuringBuild&&(s=u!=null?u():or("zeros"));const c=s.apply(n,r),l=new jLe(c,r,t,i,o);return c.dispose(),a!=null&&this.addLoss(()=>a.apply(l.read())),i==null&&(i=!0),i?this._trainableWeights.push(l):this._nonTrainableWeights.push(l),l}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){t==null||Array.isArray(t)&&t.length===0||(t=$n(t),this._losses!==void 0&&this._losses!==null&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,n){if(!this.supportsMasking){if(n!=null)if(Array.isArray(n))n.forEach(r=>{if(r!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return n}setMaskMetadata(t,n,r){if(!this.supportsMasking)return;const s=this.computeMask(t,r),a=$n(n),i=$n(s);if(a.length!==i.length)throw new Error(`${this.name} outputs ${a.length} tensors but ${a.length} masks for those tensors`);for(let o=0;o<a.length;o++)a[o].kerasMask=i[o]}addInboundNode(t,n,r,s,a,i,o=null){const u=$n(t);n=$n(n),r=$n(r),s=$n(s),a=Vx(a),i=Vx(i);const c=[],l=[],d=[];for(const h of u)c.push(h.sourceLayer),l.push(h.nodeIndex),d.push(h.tensorIndex);new _I({outboundLayer:this,inboundLayers:c,nodeIndices:l,tensorIndices:d,inputTensors:u,outputTensors:n,inputMasks:r,outputMasks:s,inputShapes:a,outputShapes:i},o);for(let h=0;h<n.length;h++)n[h].sourceLayer=this,n[h].nodeIndex=this.inboundNodes.length-1,n[h].tensorIndex=h}getConfig(){const t={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(t.batchInputShape=this.batchInputShape),this.dtype!=null&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return--this._refCount===0&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function QLe(e){e=$n(e);const t=[];for(const n of e)t.push(n.shape);return na(t)}function YLe(e){return"float32"}function WV(e,t,n){if((t==null||n!=null&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),t.inboundNodes.length===0)return[e];{const r=t.inboundNodes[n];if(r.inboundLayers.length===0)return r.inputTensors;{const s=[];for(let a=0;a<r.inboundLayers.length;a++){const i=r.inputTensors[a],o=r.inboundLayers[a],u=r.nodeIndices[a],c=WV(i,o,u);for(const l of c)s.indexOf(l)===-1&&s.push(l)}return s}}}function JLe(e){let t=!0;for(const n of $n(e))if(!(n instanceof Do)){t=!1;break}return t}function ZLe(e){let t=!0;for(const n of $n(e))if(n instanceof Do){t=!1;break}return t}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class J1 extends Jt{constructor(t){if(super({dtype:t.dtype,name:t.name!=null?t.name:$I("input").toString()}),t.batchSize==null&&(t.batchSize=null),t.sparse==null&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,t.inputShape!=null&&t.batchInputShape!=null)throw new le("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let n=t.batchInputShape;if(n==null){if(t.inputShape==null)throw new le("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");n=[t.batchSize].concat(t.inputShape)}else if(t.batchSize!=null)throw new le("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const r=t.dtype||"float32";this.batchInputShape=n,this.dtype=r,this.inputSpec=[{shape:n}];const s=new Do(this.dtype,this.batchInputShape,this,[],{},this.name);s.nodeIndex=0,s.tensorIndex=0,new _I({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[s],outputTensors:[s],inputMasks:[null],outputMasks:[null],inputShapes:[n],outputShapes:[n]})}apply(t,n){throw new le(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}J1.className="InputLayer";Le(J1);function ePe(e){if(e.batchShape==null&&e.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(e.batchShape!=null&&e.shape!=null)throw new le("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;e.shape!=null&&t==null&&(t=[null].concat(e.shape));let n=e.dtype;return n==null&&(n="float32"),new J1({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function tPe(e,t){if(e.dtype==null||e.dtype===t.dtype)return t;try{return at(t,e.dtype)}catch{throw new le(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}class Bl{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof Bl)for(const n in t.id2Value)this.id2Value[n]=t.id2Value[n],n in t.id2Mask&&(this.id2Mask[n]=t.id2Mask[n]);else{if(t==null)return;for(const n of t)this.add(n.key,n.value)}}add(t,n,r){if(this.id2Value[t.id]==null)this.id2Value[t.id]=tPe(t,n),this.name2Id[t.name]=t.id,r!=null&&(this.id2Mask[t.id]=r);else throw new le(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof Do){if(this.id2Value[t.id]==null)throw new le(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{const n=this.name2Id[t];if(n==null)throw new le(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[n]}}getMask(t){if(t instanceof Do){if(this.id2Value[t.id]==null)throw new le(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{const n=this.name2Id[t];if(n==null)throw new le(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[n]}}disposeMasks(){this.id2Mask!=null&&tn(this.id2Mask)}}const Gx=new CV,Hx=new CV;function nPe(e){Gx?.setMaxEntries(e),Hx?.setMaxEntries(e)}function Kb(e,t,n,r){const s=n==null?!1:n.training,a=Array.isArray(e),i=a?e:[e],o=i.map(f=>f.name),u=[],c=t.names();for(const f of o)c.indexOf(f)!==-1?u.push(t.getValue(f)):u.push(null);const l=o.join(",")+"|"+t.names().sort().join(",");let d=Gx.get(l),h;if(d==null){const f=rPe(i,t);d=f.sorted,h=f.recipientCounts,Gx.put(l,d),Hx.put(l,h)}h={},s||Object.assign(h,Hx.get(l));const p=new Bl(t);for(let f=0;f<d.length;++f){const m=d[f],g=m.sourceLayer;if(g instanceof J1)continue;const b=[],y=[],x=[];let w=!1;for(const E of m.inputs){const A=p.getValue(E),k=p.getMask(E);b.push(A),y.push(k),k!=null&&(w=!0),s||(h[E.name]--,h[E.name]===0&&!t.hasKey(E)&&o.indexOf(E.name)===-1&&!A.isDisposed&&E.sourceLayer.stateful!==!0&&x.push(A))}w&&(n=n||{},n.mask=y[0]);const v=$n(g.apply(b,n));let I=null;g.supportsMasking&&(I=g.computeMask(b,y));const N=aPe(m),T=Array.isArray(N)?N:[N];for(let E=0;E<T.length;++E){p.hasKey(T[E])||p.add(T[E],v[E],Array.isArray(I)?I[0]:I);const A=o.indexOf(T[E].name);A!==-1&&(u[A]=v[E])}s||tn(x)}return p.disposeMasks(),a?u:u[0]}function rPe(e,t){U(e!=null&&e.length>0,()=>"Expected at least one fetch, got none");let n=[],r={};if(e.length===1){const s=SD(e[0],t);n=s.sorted,r=s.recipientMap}else{const s=new Set;for(const a of e){const{sorted:i,recipientMap:o}=SD(a,t);for(const u of i)s.has(u.name)||(n.push(u),s.add(u.name));for(const u in o)r[u]==null&&(r[u]=new Set),o[u].forEach(c=>r[u].add(c))}}return{sorted:n,recipientCounts:sPe(r)}}function sPe(e){const t={};for(const n in e)t[n]=e[n].size;return t}function SD(e,t){const n=new Set,r=[],s={};for(const o of t.names())n.add(o);const a=[],i=[];for(a.push(e);a.length>0;){const o=a[a.length-1];if(n.has(o.name)){a.pop();continue}const u=i[i.length-1]===a.length-1;if(o.inputs.length===0||u)a.pop(),r.push(o),n.add(o.name),u&&i.pop();else{i.push(a.length-1);for(const c of o.inputs)s[c.name]==null&&(s[c.name]=new Set),s[c.name].add(o.name),!n.has(c.name)&&a.push(c)}}return{sorted:r,recipientMap:s}}function aPe(e){let t;if(e.sourceLayer.inboundNodes.length===1)t=e.sourceLayer.output;else{let n=null;for(let r=0;r<e.sourceLayer.inboundNodes.length;++r)for(const s of e.sourceLayer.inboundNodes[r].outputTensors)if(s.id===e.id){n=r;break}t=e.sourceLayer.getOutputAt(n)}return t}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iPe=ke();iPe.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,nPe);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function KA(e,t){return we(()=>Ss(Ct(ce(e,e),t,!0)))}class Z1 extends sb{getConfig(){return{}}}class VV extends Z1{constructor(t){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return we(()=>{const n=KA(t,this.axis),r=Ka(n,0,this.maxValue);return ce(t,Nt(r,We(Vr(),n)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}VV.className="MaxNorm";Le(VV);class UV extends Z1{constructor(t){super(),this.defaultAxis=0,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return we(()=>Nt(t,We(Vr(),KA(t,this.axis))))}getConfig(){return{axis:this.axis}}}UV.className="UnitNorm";Le(UV);class GV extends Z1{apply(t){return tp(t)}}GV.className="NonNeg";Le(GV);class HV extends Z1{constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=t.minValue!=null?t.minValue:this.defaultMinValue,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.rate=t.rate!=null?t.rate:this.defaultRate,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return we(()=>{const n=KA(t,this.axis),r=We(ce(this.rate,Ka(n,this.minValue,this.maxValue)),ce(1-this.rate,n));return ce(t,Nt(r,We(Vr(),n)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}HV.className="MinMaxNorm";Le(HV);const ND={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function qr(e){return LA(e)}function TD(e,t={}){return K1(e,oi.getMap().classNameMap,t,"constraint")}function Kr(e){if(e==null)return null;if(typeof e=="string"){const n={className:e in ND?ND[e]:e,config:{}};return TD(n)}else return e instanceof Z1?e:TD(e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function cc(e){if(e==null)return;const t=[],n=[],r=[];for(const s in e){const a=e[s];if(typeof a!="number"){const i=a;t.push(i.data()),n.push(s),r.push(i)}}if(t.length>0){const s=await Promise.all(t);for(let a=0;a<s.length;++a)e[n[a]]=s[a][0];tn(r)}}function jV(e){if(e!=null)for(const t in e){const n=e[t];typeof n!="number"&&n.dispose()}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var ED;(function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"})(ED||(ED={}));const oPe=125;class Dy{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,n){}async onEpochEnd(t,n){}async onBatchBegin(t,n){}async onBatchEnd(t,n){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}}class lPe{constructor(t,n=10){t==null&&(t=[]),this.callbacks=t,this.queueLength=n}append(t){this.callbacks.push(t)}setParams(t){for(const n of this.callbacks)n.setParams(t)}setModel(t){for(const n of this.callbacks)n.setModel(t)}async onEpochBegin(t,n){n==null&&(n={});for(const r of this.callbacks)await r.onEpochBegin(t,n)}async onEpochEnd(t,n){n==null&&(n={});for(const r of this.callbacks)await r.onEpochEnd(t,n)}async onBatchBegin(t,n){n==null&&(n={});for(const r of this.callbacks)await r.onBatchBegin(t,n)}async onBatchEnd(t,n){n==null&&(n={});for(const r of this.callbacks)await r.onBatchEnd(t,n)}async onTrainBegin(t){t==null&&(t={});for(const n of this.callbacks)await n.onTrainBegin(t)}async onTrainEnd(t){t==null&&(t={});for(const n of this.callbacks)await n.onTrainEnd(t)}}class uPe extends Dy{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,n){n==null&&(n={});const r=n.size==null?0:n.size;this.seen+=r;for(const s in n){const a=n[s];if(typeof a=="number")this.totals.hasOwnProperty(s)||(this.totals[s]=0),this.totals[s]=this.totals[s]+a*r;else{let i;s in this.totals?i=this.totals[s]:this.totals[s]=0;const o=we(()=>We(this.totals[s],ce(a,r)));this.totals[s]=o,i?.dispose()}}}async onEpochEnd(t,n){if(n!=null)for(const r of this.params.metrics)this.totals[r]!=null&&(typeof this.totals[r]=="number"?n[r]=this.totals[r]/this.seen:we(()=>{const s=ce(Nt(1,this.seen),this.totals[r]);n[r]=s,this.totals[r].dispose(),ko(n[r])}))}}class cPe extends Dy{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,n){n==null&&(n={}),this.epoch.push(t);for(const r in n)this.history[r]==null&&(this.history[r]=[]),this.history[r].push(n[r])}async syncData(){const t=[],n=[],r=[];for(const a in this.history){const i=this.history[a];for(let o=0;o<i.length;++o)if(typeof i[o]!="number"){const u=i[o];t.push(u.data()),n.push(a),r.push(o)}}const s=await Promise.all(t);for(let a=0;a<s.length;++a)this.history[n[a]][r[a]].dispose(),this.history[n[a]][r[a]]=s[a][0]}}class dPe extends Dy{constructor(t,n){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||uV,this.yieldEvery=n||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=oPe),this.yieldEvery==="never"&&t.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");ZC(this.yieldEvery)&&(this.maybeWait=CLe(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,n,r){const s=[];this.yield!=null&&(await cc(r),s.push(this.yield(t,n,r))),s.push(this.nextFrameFunc()),await Promise.all(s)}async onEpochBegin(t,n){this.currentEpoch=t,this.epochBegin!=null&&(await cc(n),await this.epochBegin(t,n))}async onEpochEnd(t,n){const r=[];this.epochEnd!=null&&(await cc(n),r.push(this.epochEnd(t,n))),this.yieldEvery==="epoch"&&r.push(this.nextFrameFunc()),await Promise.all(r)}async onBatchBegin(t,n){this.batchBegin!=null&&(await cc(n),await this.batchBegin(t,n))}async onBatchEnd(t,n){const r=[];this.batchEnd!=null&&(await cc(n),r.push(this.batchEnd(t,n))),this.yieldEvery==="batch"?r.push(this.nextFrameFunc()):ZC(this.yieldEvery)&&r.push(this.maybeWait(this.currentEpoch,t,n)),await Promise.all(r)}async onTrainBegin(t){this.trainBegin!=null&&(await cc(t),await this.trainBegin(t))}async onTrainEnd(t){this.trainEnd!=null&&(await cc(t),await this.trainEnd(t))}}function qV(e,t){return e==null&&(e={}),e instanceof Dy?[e]:Array.isArray(e)&&e[0]instanceof Dy?e:$n(e).map(r=>new dPe(r,t))}class si{constructor(){}static registerCallbackConstructor(t,n){U(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),si.checkForDuplicate(n),si.constructors[t]==null&&(si.constructors[t]=[]),si.constructors[t].push(n)}static checkForDuplicate(t){for(const n in si.constructors)si.constructors[+n].forEach(s=>{if(s===t)throw new le("Duplicate callback constructor.")})}static clear(){si.constructors={}}static createCallbacks(t){const n=[];for(const r in si.constructors){const s=+r;t>=s&&n.push(...si.constructors[s])}return n.map(r=>new r)}}si.constructors={};function KV(e,t,n,r,s,a,i,o,u){const c=new cPe,l=[new uPe,...si.createCallbacks(t)];e!=null&&l.push(...e),l.push(c);const d=new lPe(l);return d.setParams({epochs:n,initialEpoch:r,samples:s,steps:a,batchSize:i,verbose:t,doValidation:o,metrics:u}),{callbackList:d,history:c}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function al(e,t={},n=!1){return K1(e,oi.getMap().classNameMap,t,"layer",n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function jx(e,t){return we(()=>{e.dtype!=="float32"&&(e=at(e,"float32"));const n=Ct(Q1(e),t,!0),r=hI(n.shape,Vr()),s=Ss(Lu(n,r));return Nt(e,s)})}function DI(e,t){return we(()=>$r(Q1(_t(t,e)),-1))}function XA(e,t){return we(()=>$r(Fs(_t(t,e)),-1))}function QA(e,t){return we(()=>{const n=_t(e,t),r=Ka(Fs(e),Vr(),Number.MAX_VALUE),s=Fs(Nt(n,r));return ce(100,$r(s,-1))})}function hPe(e,t){return we(()=>{const n=Ka(t,Vr(),Number.MAX_VALUE),r=_o(We(1,n)),s=Ka(e,Vr(),Number.MAX_VALUE),a=_o(We(1,s));return $r(Q1(_t(r,a)),-1)})}function pPe(e,t){return we(()=>{const n=Lu(0,_t(1,ce(e,t)));return $r(Q1(n),-1)})}function fPe(e,t){return we(()=>{const n=Lu(0,_t(1,ce(e,t)));return $r(n,-1)})}function mPe(e,t){return we(()=>{const n=Ct(ce(e,t),-1),r=Ui(ce(_t(1,e),t),-1);return Lu(0,We(1,_t(r,n)))})}function gPe(e,t){return we(()=>{const n=Math.log(2),r=_t(t,e),s=_t(We(r,U1(ce(-2,r))),n);return $r(s,-1)})}function Fy(e,t,n=!1){return we(()=>{if(n)t=ZE(t);else{const r=Ct(t,t.shape.length-1,!0);t=Nt(t,r)}return t=Ka(t,Vr(),1-Vr()),vr(Ct(ce(at(e,"float32"),_o(t)),t.shape.length-1))})}function qx(e,t,n=!1){return we(()=>{const r=at(mI(OLe(e)),"int32");t=Ka(t,Vr(),1-Vr());const s=t.shape,a=be(_W(r,s[s.length-1]),s);return Fy(a,t,n)})}function bPe(e,t){if(!Nn(e.shape,t.shape))throw new le(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return we(()=>{const n=tp(t),r=vr(Fs(t));return We(_t(n,ce(t,e)),EW(Ro(r)))})}function FI(e,t){return we(()=>{let n;return n=Ka(t,Vr(),1-Vr()),n=_o(Nt(n,_t(1,n))),$r(bPe(e,n),-1)})}function yPe(e,t){return we(()=>{const n=Ka(e,Vr(),1),r=Ka(t,Vr(),1);return Ct(ce(e,_o(Nt(n,r))),-1)})}function xPe(e,t){return we(()=>{const n=_o(We(Vr(),t));return $r(_t(t,ce(e,n)),-1)})}function XV(e,t){return we(()=>{const n=jx(e,-1),r=jx(t,-1),s=ce(n,r);return vr(Ct(s,-1))})}const Kx={meanSquaredError:DI,meanAbsoluteError:XA,meanAbsolutePercentageError:QA,meanSquaredLogarithmicError:hPe,squaredHinge:pPe,hinge:fPe,categoricalHinge:mPe,logcosh:gPe,categoricalCrossentropy:Fy,sparseCategoricalCrossentropy:qx,binaryCrossentropy:FI,kullbackLeiblerDivergence:yPe,poisson:xPe,cosineProximity:XV};function Tk(e){if(typeof e=="string"){if(e in Kx)return Kx[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new le(t)}else return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function QV(e,t){return we(()=>{const n=ce(.5,fi(t)),r=Co(Ya(t,n),e.dtype);return $r($o(e,r),-1)})}function YV(e,t){return we(()=>Co($o(Ty(e,-1),Ty(t,-1)),"float32"))}function wPe(e,t){return we(()=>at(Ct(ll($o(e,1),$o(t,1))),"float32"))}function vPe(e,t){return we(()=>at(Ct(ll($o(e,0),$o(t,1))),"float32"))}function IPe(e,t){return we(()=>{const n=wPe(e,t),r=vPe(e,t),s=We(n,r);return at(Ws(Ya(s,0),Nt(n,s),0),"float32")})}function kPe(e,t){return FI(e,t)}function CPe(e,t){return e.rank===t.rank&&(e=H1(e,[e.rank-1])),t=Ty(t,-1),t.dtype!==e.dtype&&(t=at(t,e.dtype)),at($o(e,t),"float32")}const SPe=DI,NPe=DI,TPe=XA,EPe=XA,APe=QA,$Pe=QA,JV=Fy,RPe=XV,ZV=qx,Xx={binaryAccuracy:QV,categoricalAccuracy:YV,precision:IPe,categoricalCrossentropy:JV,sparseCategoricalCrossentropy:ZV,mse:SPe,MSE:NPe,mae:TPe,MAE:EPe,mape:APe,MAPE:$Pe,cosine:RPe};function _Pe(e){if(typeof e=="string"&&e in Xx)return Xx[e];if(typeof e!="string"&&e!=null)return e;throw new le(`Unknown metric ${e}`)}function R2(e){if(fo(e!==null,`Unknown LossOrMetricFn ${e}`),typeof e=="string")return e;{let t;for(const n of Object.keys(Kx))if(Kx[n]===e){t=n;break}if(t!==void 0)return t;for(const n of Object.keys(Xx))if(Xx[n]===e){t=n;break}return t!==void 0?t:e.name}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function DPe(e){const t={Adagrad:()=>mp.adagrad(.01),Adadelta:()=>mp.adadelta(1,.95,Vr()),Adam:()=>mp.adam(.001,.9,.999,Vr()),Adamax:()=>mp.adamax(.002,.9,.999,Vr(),0),RMSProp:()=>mp.rmsprop(.001,.9,0,Vr()),SGD:()=>mp.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new le(`Unknown Optimizer ${e}`)}/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const AD=1*1024*1024;function $D(e,t,n=!1){if(e==null||typeof e!="object"||Object.getPrototypeOf(e)!==Object.prototype||!vS(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const r=JSON.stringify(e);r.length>AD&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${AD}.`)}}function vS(e){if(e===null)return!0;if(typeof e=="object")if(Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);for(const n of t)if(typeof n!="string"||!vS(e[n]))return!1;return!0}else if(Array.isArray(e)){for(const t of e)if(!vS(t))return!1;return!0}else return!1;else{const t=typeof e;return t==="string"||t==="number"||t==="boolean"}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function FPe(e,t,n,r=console.log){const s=OPe(e),a=["Layer (type)","Input Shape","Output shape","Param #"];s?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map(l=>Math.floor(t*l)));let i;if(!s){a.push("Receives inputs"),i=[];for(const l in e.nodesByDepth)i.push(...e.nodesByDepth[l])}r("_".repeat(t)),Qx(a,n,r),r("=".repeat(t));const o=e.layers;for(let l=0;l<o.length;++l)s?LPe(o[l],n,r):PPe(o[l],n,i,r),r((l===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();const u=MPe(e),c=Ux(e.nonTrainableWeights);r(`Total params: ${u+c}`),r(`Trainable params: ${u}`),r(`Non-trainable params: ${c}`),r("_".repeat(t))}function MPe(e){let t;return e.collectedTrainableWeights!=null?t=Ux(e.collectedTrainableWeights):t=Ux(e.trainableWeights),t}function OPe(e){let t=!0;const n=[],r=[];for(const s in e.nodesByDepth)n.push(e.nodesByDepth[s]);for(const s of n){if(s.length>1||s.length===1&&s[0].inboundLayers.length>1){t=!1;break}r.push(...s)}if(t)for(const s of e.layers){let a=!1;for(const i of s.inboundNodes)if(r.indexOf(i)!==-1)if(a){t=!1;break}else a=!0;if(!t)break}return t}function Qx(e,t,n=console.log){let r="";for(let s=0;s<e.length;++s)s>0&&(r=r.slice(0,r.length-1)+" "),r+=e[s],r=r.slice(0,t[s]),r+=" ".repeat(t[s]-r.length);n(r)}function LPe(e,t,n){let r,s;try{s=e.inboundNodes.map(u=>JSON.stringify(u.inputShapes)).join(",")}catch{s="multiple"}try{r=JSON.stringify(e.outputShape)}catch{r="multiple"}const a=e.name,i=e.getClassName(),o=[`${a} (${i})`,s,r,e.countParams().toString()];Qx(o,t,n)}function PPe(e,t,n,r){let s,a;try{a=e.inboundNodes.map(d=>JSON.stringify(d.inputShapes)).join(",")}catch{a="multiple"}try{s=JSON.stringify(e.outputShape)}catch{s="multiple"}const i=[];for(const d of e.inboundNodes)if(!(n!=null&&n.length>0&&n.indexOf(d)===-1))for(let h=0;h<d.inboundLayers.length;++h){const p=d.inboundLayers[h].name,f=d.nodeIndices[h],m=d.tensorIndices[h];i.push(`${p}[${f}][${m}]`)}const o=e.name,u=e.getClassName(),c=i.length===0?"":i[0],l=[`${o} (${u})`,a,s,e.countParams().toString(),c];Qx(l,t,r);for(let d=1;d<i.length;++d)Qx(["","","","",i[d]],t,r)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function eU(e,t,n){return(e==="inboundNodes"||e==="outputLayers"||e==="inputLayers")&&t===0&&typeof n=="string"}function IS(e,t){if(e===null)return null;if(typeof e=="string")return Ic(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){const n=[],r=e.length;for(let s=0;s<r;++s){const a=e[s];eU(t,s,a)?n.push(a):n.push(IS(a,t))}return n}else{const n={};for(const r of Object.keys(e)){const s=e[r];if(r==="name"&&typeof s=="string")n[r]=s;else{const a=Ic(r);n[a]=IS(s,a)}}return n}}function kS(e,t){if(e==null)return null;if(typeof e=="string")return Jo(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){const n=[],r=e.length;for(let s=0;s<r;++s){const a=e[s];eU(t,s,a)?n.push(a):n.push(kS(a,t))}return n}else{const n={};for(const r of Object.keys(e)){const s=e[r],a=Jo(r);(r==="name"||r==="className")&&typeof s=="string"?n[a]=s:n[a]=kS(s,r)}return n}}/** @license See the LICENSE file. */const tU="4.22.0";/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const BPe=e=>{const t=Object.keys(e);if(t.length===0)return!1;const n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))};class Di extends Jt{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,this.name==null){const y=this.getClassName().toLowerCase();this.name=$I(y)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],ql(this.inputs).length!==this.inputs.length)throw new le(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(y=>y.name)}`);ql(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(y=>y.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const y of this.outputs){const x=y.sourceLayer,w=y.nodeIndex,v=y.tensorIndex;this.outputLayers.push(x),this.outputLayersNodeIndices.push(w),this.outputLayersTensorIndices.push(v)}for(const y of this.inputs){const x=y.sourceLayer,w=y.nodeIndex,v=y.tensorIndex;fo(w===0,"input layer has >1 nodes"),fo(v===0,"input layer has >1 tensors"),this.inputLayers.push(x),this.inputLayersNodeIndices.push(w),this.inputLayersTensorIndices.push(v)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let y=0;y<this.inputLayers.length;y++){const x=this.inputLayers[y];if(!(x instanceof J1))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${y} (0-based) originates from layer type ${x.getClassName()}.`);this.inputNames.push(x.name),this.feedInputShapes.push(x.batchInputShape),this.feedInputNames.push(x.name)}for(const y of this.outputLayers)this.outputNames.push(y.name);this.internalInputShapes=this.inputs.map(y=>y.shape),this.internalOutputShapes=this.outputs.map(y=>y.shape);const n={},r={},s={},a={},i={},o=[],u=(y,x,w,v,I,N)=>{(v==null||I==null||N==null)&&(v=y.sourceLayer,I=y.nodeIndex,N=y.tensorIndex);const T=v.inboundNodes[I];if(w.indexOf(T)!==-1)throw new li(`The tensor ${y.name} at layer "${v.name}" is part of a cycle.`);if(x.indexOf(T)!==-1)return;this.containerNodes.add(Di.nodeKey(v,I)),v.id in i||(i[v.id]=Object.keys(i).length),w.indexOf(T)===-1&&w.push(T);const E=T.inboundLayers.length;for(let A=0;A<E;A++){const k=T.inputTensors[A],C=T.inboundLayers[A],M=T.nodeIndices[A],L=T.tensorIndices[A];u(k,x,w,C,M,L)}for(x.push(T);w.indexOf(T)>=0;)w.splice(w.indexOf(T),1);o.push(T)},c=[],l=[];for(const y of this.outputs)u(y,c,l);const d=o.slice().reverse();for(const y of d){r[y.id]=y,y.id in n||(n[y.id]=0);let x=n[y.id];const w=s[y.outboundLayer.id]==null?0:s[y.outboundLayer.id];x=Math.max(x,w),s[y.outboundLayer.id]=x,a[y.outboundLayer.id]=y.outboundLayer,n[y.id]=x;for(let v=0;v<y.inboundLayers.length;v++){const I=y.inboundLayers[v],N=y.nodeIndices[v],T=I.inboundNodes[N],E=n[T.id]==null?0:n[T.id];n[T.id]=Math.max(x+1,E),r[T.id]=T}}const h={};for(const y in n){const x=n[y];x in h||(h[x]=[]),h[x].push(r[y])}const p={};for(const y in s){const x=s[y];x in p||(p[x]=[]),p[x].push(a[y])}let f=Object.keys(p).map(y=>parseInt(y,10)).sort(E2);this.layers=[];for(const y of f){const x=p[y];x.sort((w,v)=>{const I=i[w.id],N=i[v.id];return I<N?-1:I>N?1:0});for(const w of x)w instanceof Di&&this.internalContainerRefs.push(w),this.layers.push(w)}this.layersByDepth=p,f=Object.keys(h).map(y=>parseInt(y,10)).sort(E2);const m=this.inputs.slice(),g=[];for(const y of f)for(const x of h[y]){const w=x.outboundLayer;if(w!=null){for(const v of x.inputTensors)if(m.indexOf(v)===-1)throw new li(`Graph disconnected: cannot obtain value for tensor ${v} at layer "${w.name}". The following previous layers were accessed without issue: ${g}`);for(const v of x.outputTensors)m.push(v);g.push(w.name)}}this.nodesByDepth=h;const b=this.layers.map(y=>y.name);for(const y of b){const x=b.filter(w=>w===y).length;if(x!==1)throw new li(`The name "${y}" is used ${x} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(b))}this.outboundNodes=[],this.inboundNodes=[],new _I({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(y=>null),outputMasks:this.outputs.map(y=>null),inputShapes:this.inputs.map(y=>y.shape),outputShapes:this.outputs.map(y=>y.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const n of this.layers)t.numDisposedVariables+=n.dispose().numDisposedVariables;for(const n of this.internalContainerRefs)t.numDisposedVariables+=n.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(n=>{n._trainableWeights.forEach(r=>r.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new le("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const n of this.layers)t=t.concat(n.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const n of this.layers)t.push(...n.nonTrainableWeights);if(!this.trainable){const n=[];for(const r of this.layers)n.push(...r.trainableWeights);return n.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,n=!0){const r={};let s=0;const a=BPe(t);a&&this.parseWeights(t);for(const o of this.layers)for(const[u,c]of o.weights.entries()){const l=a?`${c.name.split("/").slice(0,-1).join("/")+"/"}${u}`:c.originalName;if(r[l]!=null)throw new le(`Duplicate weight name: ${l}`);r[l]=c,s++}const i=[];for(const o in t){let u=o;if(r[o]==null){const c=o.split("/");u=c.slice(0,-2).concat([c[c.length-1]]).join("/")}if(r[u]!=null)i.push([r[u],t[o]]);else if(n)throw new le(`Provided weight data has no target variable: ${o}`);delete r[u]}if(n){const o=[];for(const u in r)o.push(u);if(o.length>0)throw new le(`${o.length} of ${s} weights are not set: ${o}`)}qA(i)}parseWeights(t){for(const n in Object.keys(t)){const r=n.split("/"),s=["vars","layer_checkpoint_dependencies"],a=r.map(i=>i.startsWith("_")?i.slice(1):i).filter(i=>!s.includes(i)).join("/");a!==n&&(t[a]=t[n],delete t[n])}}updatedConfig(){const t=this.getConfig(),n={};return n.className=this.getClassName(),n.config=t,n.kerasVersion=`tfjs-layers ${tU}`,n.backend="TensorFlow.js",n}toJSON(t,n=!0){const r=kS(this.updatedConfig());return n?JSON.stringify(r):r}call(t,n){return we(()=>{t=$n(t);const r=new Bl;for(let s=0;s<this.inputs.length;++s)r.add(this.inputs[s],t[s]);return Kb(this.outputs,r,n)})}computeMask(t,n){return we(()=>{t=$n(t);let r;return n==null?r=hd(null,t.length):r=$n(n),this.runInternalGraph(t,r)[1]})}computeOutputShape(t){const n=Vx(t);if(n.length!==this.inputLayers.length)throw new le(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);const r={};for(let o=0;o<n.length;o++){const u=this.inputLayers[o],c=n[o],l=u.name+"_0_0";r[l]=c}const s=Object.keys(this.nodesByDepth).map(o=>parseInt(o,10)).sort(E2);if(s.length>1)for(const o of s){const u=this.nodesByDepth[o];for(const c of u){const l=c.outboundLayer;if(this.inputLayers.map(m=>m.id).indexOf(l.id)!==-1)continue;const d=[];for(let m=0;m<c.inboundLayers.length;m++){const g=c.inboundLayers[m],b=c.nodeIndices[m],y=c.tensorIndices[m],x=`${g.name}_${b}_${y}`,w=r[x];d.push(w)}const h=l.computeOutputShape(na(d)),p=Vx(h),f=l.inboundNodes.indexOf(c);for(let m=0;m<p.length;m++){const g=`${l.name}_${f}_${m}`;r[g]=p[m]}}}const a=[],i=[];for(let o=0;o<this.outputLayers.length;o++){const u=this.outputLayers[o],c=this.outputLayersNodeIndices[o],l=this.outputLayersTensorIndices[o],d=`${u.name}_${c}_${l}`;i.push(d)}for(let o=0;o<i.length;o++){const u=i[o];fo(u in r),a.push(r[u])}return na(a)}runInternalGraph(t,n){n==null&&(n=hd(null,t.length));const r={};for(let u=0;u<this.inputs.length;++u){const c=this.inputs[u],l=t[u],d=n[u];r[c.id]=[l,d]}const s=Object.keys(this.nodesByDepth).map(u=>parseInt(u,10)).sort(E2);for(const u of s){const c=this.nodesByDepth[u];for(const l of c){const d=l.outboundLayer,h=l.inputTensors,p=l.outputTensors,f=new Array;for(const m of h)m.id in r&&f.push(r[m.id]);if(f.length===h.length){let m={},g,b,y,x;if(l.callArgs!=null&&(m=l.callArgs),f.length===1){const[w,v]=f[0];m.mask==null&&(m.mask=v),y=$n(d.call(w,m)),x=$n(d.computeMask(w,v)),g=[w],b=[v]}else g=f.map(w=>w[0]),b=f.map(w=>w[1]),m.mask==null&&(m.mask=b),y=$n(d.call(g,m)),x=$n(d.computeMask(g,b));if(d.activityRegularizer)throw new qt("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let w=0;w<p.length;++w){const v=p[w],I=y[w],N=x[w];r[v.id]=[I,N]}}}}const a=[],i=[],o=[];for(const u of this.outputs){fo(u.id in r,`Could not compute output ${u.name} : ${u.id}`);const[c,l]=r[u.id];o.push(c.shape),a.push(c),i.push(l)}return[a,i,o]}buildNodeConversionMap(t){const n={};let r;for(const s of this.layers){r=s instanceof Di?1:0;for(let a=0;a<s.inboundNodes.length;a++){const i=Di.nodeKey(s,a);this.containerNodes.has(i)&&(n[i]=r,r+=1)}}return n}getLayer(t,n){if(n!=null)return this.findLayer(n);if(t==null)throw new le("Provide either a layer name or layer index");if(typeof t=="number")return this.findLayer(t);for(const r of this.layers)if(r.name===t)return r;throw new le(`No such layer: ${t}`)}findLayer(t){if(this.layers.length<=t)throw new le(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}calculateLosses(){return we(()=>{const t=[];for(const n of this.layers)for(let r=0;r<n.inboundNodes.length;++r){const s=Di.nodeKey(n,r);this.containerNodes.has(s)&&t.push(...n.calculateLosses())}return t})}getConfig(){const t={name:this.name},n=this.buildNodeConversionMap(this.layers),r=[];for(const i of this.layers){const o=i.getClassName(),u=i.getConfig(),c=[];for(let d=0;d<i.inboundNodes.length;d++){const h=i.inboundNodes[d],p=Di.nodeKey(i,d);let f={};if(this.containerNodes.has(p)){if(h.callArgs)try{JSON.stringify(h.callArgs),f=h.callArgs}catch{console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${h.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),f={}}if(h.inboundLayers.length>0){const m=[];for(let g=0;g<h.inboundLayers.length;g++){const b=h.inboundLayers[g],y=h.nodeIndices[g],x=h.tensorIndices[g],w=Di.nodeKey(b,y);let v=n[w];v==null&&(v=0),m.push([b.name,v,x,f])}c.push(m)}}}const l={};l.name=i.name,l.className=o,l.config=u,l.inboundNodes=c,r.push(l)}t.layers=r;const s=[];for(let i=0;i<this.inputLayers.length;i++){const o=this.inputLayers[i],u=this.inputLayersNodeIndices[i],c=Di.nodeKey(o,u);if(!this.containerNodes.has(c))continue;let l=n[c];l==null&&(l=0);const d=this.inputLayersTensorIndices[i];s.push([o.name,l,d])}t.inputLayers=s;const a=[];for(let i=0;i<this.outputLayers.length;i++){const o=this.outputLayers[i],u=this.outputLayersNodeIndices[i],c=Di.nodeKey(o,u);if(!this.containerNodes.has(c))continue;let l=n[c];l==null&&(l=0);const d=this.outputLayersTensorIndices[i];a.push([o.name,l,d])}return t.outputLayers=a,t}static fromConfig(t,n,r={},s=!1){const a={},i={};function o(g,b){g.name in i?i[g.name].push(b):i[g.name]=[b]}function u(g,b){const y=[];let x;for(const w of b){const v=w[0],I=w[1],N=w[2];if(x=w[3]==null?{}:w[3],!(v in a)){o(g,b);return}const T=a[v];if(T.inboundNodes.length<=I){o(g,b);return}const E=T.inboundNodes[I];y.push(E.outputTensors[N])}y.length>0&&g.apply(na(y),x)}function c(g){const b=g.name,y=al(g,n.customObjects!=null?n.customObjects:{});y.setFastWeightInitDuringBuild(s),a[b]=y,g.inboundNodes.forEach(w=>{if(!(w instanceof Array))throw new le(`Corrupted configuration, expected array for nodeData: ${w}`);o(y,w)})}const l=n.name,d=n.layers;for(const g of d)c(g);for(;!kLe(i);)for(const g of d){const b=a[g.name];if(b.name in i){const y=i[b.name];delete i[b.name];for(const x of y)u(b,x)}}const h=[],p=[],f=n.inputLayers;for(const g of f){const b=g[0],y=g[1],x=g[2];fo(b in a);const v=a[b].inboundNodes[y].outputTensors;h.push(v[x])}const m=n.outputLayers;for(const g of m){const b=g[0],y=g[1],x=g[2];fo(b in a);const v=a[b].inboundNodes[y].outputTensors;p.push(v[x])}return new t({inputs:h,outputs:p,name:l})}get stateful(){if(this._stateful)throw new le("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){we(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function zPe(e,t,n){const r=t.length;if(e==null||Array.isArray(e)&&e.length===0)return t.map(s=>null);if(r===1)return Array.isArray(e)&&e.length===1?e:typeof e=="object"&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}else if(typeof e=="object"&&Object.keys(e).length>0&&typeof e[Object.keys(e)[0]]=="object"){const s=[];return t.forEach(a=>{a in e?s.push(e[a]):s.push(null)}),s}else throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}function nU(e,t){return zPe(e,t,"classWeight")}async function rU(e,t,n,r){if(n!=null){const s=we(()=>{if(e.shape.length===1)return Dc(e);if(e.shape.length===2){if(e.shape[1]>1)return Ty(e,1);if(e.shape[1]===1)return be(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),a=Array.from(await s.data());tn(s);const i=[];return a.forEach(o=>{if(n[o]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${o} exists in the data but not in classWeight`);i.push(n[o])}),ka(i,"float32")}else return null}function WPe(e,t){return ce(e,t)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const VPe=32;function sU(e,t){let n,r;const s=t;n=s.xs,r=s.ys,U(n!=null&&r!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);const a=RD("input",e.inputNames,n),i=RD("output",e.outputNames,r),o=a[0].shape[0];U(a.length===e.inputs.length,()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${a.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`),U(i.length===e.outputs.length,()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`);for(let u=0;u<a.length;u++)U(a[u].shape[0]===o,()=>`Batch size mismatch: input ${e.inputNames[u]} has ${a[u].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);for(let u=0;u<i.length;u++)U(i[u].shape[0]===o,()=>`Batch size mismatch: output ${e.outputNames[u]} has ${i[u].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);return{xs:a,ys:i}}function RD(e,t,n){if(n instanceof Br)return[n];if(Array.isArray(n))return U(n.length===t.length,()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`),n;{const r=[];for(const s of t){if(n[s]==null)throw new le(`The feature data generated by the dataset lacks the required ${e} key '${s}'.`);r.push(n[s])}return r}}function UPe(e){if(e.length===3)throw new qt("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}async function GPe(e,t,n){const r=n.batchesPerEpoch!=null;if(U(e.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),U(n!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),U(n.epochs!=null&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),U(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),U(n.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{const s=n.validationData!=null;let a,i;if(s)if(_D(n.validationData))U(n.validationBatches==null||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{const g=UPe(n.validationData);a=g.xs,i=g.ys}const o=e.makeTrainFunction(),u=e.getDedupedMetricsNames();let c;s?c=u.slice().concat(u.map(g=>"val_"+g)):c=u.slice();const l=qV(n.callbacks,n.yieldEvery),d=n.verbose==null?1:n.verbose,{callbackList:h,history:p}=KV(l,d,n.epochs,null,null,HPe(t,n),null,s,c);h.setModel(e),e.history=p,await h.onTrainBegin(),e.stopTraining_=!1;let f=n.initialEpoch==null?0:n.initialEpoch,m=await t.iterator();for(;f<n.epochs;){const g={};await h.onEpochBegin(f);let b=0,y=0;for(r||(m=await t.iterator());!r||b<n.batchesPerEpoch;){const x=await m.next();if(r&&x.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${b} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(x.value!=null){const{xs:w,ys:v}=sU(e,x.value),I={};I.batch=y,I.size=w[0].shape[0],await h.onBatchBegin(y,I);const N=[];if(n.classWeight!=null){const A=nU(n.classWeight,e.outputNames);for(let k=0;k<A.length;++k)N.push(await rU(v[k],null,A[k]))}const T=w.concat(v).concat(N),E=o(T);tn(T);for(let A=0;A<u.length;++A){const k=u[A],C=E[A];I[k]=C,ko(C)}await h.onBatchEnd(y,I),jV(I),y++,b++}if(r?b>=n.batchesPerEpoch:x.done){if(s){let w;_D(n.validationData)?w=$n(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):w=$n(e.evaluate(a,i,{batchSize:n.validationBatchSize==null?VPe:n.validationBatchSize,verbose:0}));for(let v=0;v<e.metricsNames.length;++v)g[`val_${e.metricsNames[v]}`]=w[v]}break}if(e.stopTraining_)break}if(await h.onEpochEnd(f,g),f++,e.stopTraining_)break}return await h.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function HPe(e,t){let n=null;return t.batchesPerEpoch!=null?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}function _D(e){return typeof e.iterator=="function"}function jPe(e){return typeof e.next=="function"}async function qPe(e,t,n){n=n||{};const r=n.batches!=null,s=e.testFunction;let a=[];if(n.verbose>0)throw new qt("Verbose mode is not implemented yet.");U(!r||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);const i=jPe(t)?t:await t.iterator();let o=0,u=0;for(;!r||u<n.batches;){const c=await i.next();if(a=we(()=>{if(c.value){const{xs:l,ys:d}=sU(e,c.value),h=l.concat(d),p=we(()=>s(h));if(tn(h),u===0)for(let m=0;m<p.length;++m)a.push(Sn(0));const f=h[0].shape[0];for(let m=0;m<p.length;++m){const g=p[m],b=a[m];a[m]=we(()=>We(a[m],ce(f,g))),u>0&&tn(b)}tn(p),o+=f,++u}return a}),c.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let c=0;c<a.length;++c){const l=a[c];a[c]=Nt(a[c],o),tn(l)}return na(a)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Ek(e){U(e>0&&Number.isInteger(e),()=>`batchSize is required to be a positive integer, but got ${e}`)}function Db(e,t,n){return e==null?[null]:Array.isArray(e)?e.map(r=>Mc(r,t,n-t)):Mc(e,t,n-t)}function CS(e,t){return we(()=>e==null?null:Array.isArray(e)?e.map(n=>CS(n,t)):_V(e,t.dtype==="int32"?t:at(t,"int32")))}function Ak(e,t){const n=[];let r=0,s=null;for(;r<e;)s=r+t,s>=e&&(s=e),n.push([r,s]),r=s;return n}function aU(e){const t=[];e instanceof Br&&(e=[e]);for(let n=0;n<e.length;++n){const r=e[n];if(r.rank===1)t.push(X1(r,1));else{if(r.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function $i(e,t){if(e==null)return;const n=[];if(t instanceof Br)n.push(t.id);else if(Array.isArray(t))t.forEach(s=>n.push(s.id));else if(t!=null)for(const s in t){const a=t[s];n.push(a.id)}const r=[];if(e instanceof Br)n.indexOf(e.id)===-1&&r.push(e);else if(Array.isArray(e))e.forEach(s=>{n.indexOf(s.id)===-1&&r.push(s)});else if(e!=null)for(const s in e){const a=e[s];n.indexOf(a.id)===-1&&r.push(a)}r.forEach(s=>{s.isDisposed||s.dispose()})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function KPe(e){return e instanceof Br}function SS(e){return Array.isArray(e)}function DD(e){return!KPe(e)&&!SS(e)}function FD(e,t,n,r=!0,s=""){if(t==null||t.length===0){if(e!=null){let i=!1;if(SS(e)&&e.length>0)i=!0;else if(DD(e)){for(const o in e)if(e.hasOwnProperty(o)){i=!0;break}}else i=!0;if(i)throw new le(`Error when checking model ${s} expected no data, but got ${e}`)}return[]}if(e==null)return t.map(i=>null);let a;if(DD(e)){e=e,a=[];for(const i of t){if(e[i]==null)throw new le(`No data provided for "${i}". Need data for each key in: ${t}`);a.push(e[i])}}else if(SS(e)){if(e=e,e.length!==t.length)throw new le(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);a=e}else{if(e=e,t.length>1)throw new le(`The model ${s} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);a=[e]}if(a=aU(a),n!=null)for(let i=0;i<t.length;++i){if(n[i]==null)continue;const o=a[i];if(o.shape.length!==n[i].length)throw new le(`Error when checking ${s}: expected ${t[i]} to have ${n[i].length} dimension(s). but got array with shape ${o.shape}`);for(let u=0;u<n[i].length;++u){if(u===0&&!r)continue;const c=o.shape[u],l=n[i][u];if(l!=null&&l>=0&&c!==l)throw new le(`${s} expected a batch of elements where each example has shape [${n[i].slice(1,n[i].length)}] (i.e.,tensor shape [*,${n[i].slice(1,n[i].length)}]) but the ${s} received an input with ${o.shape[0]} examples, each with shape [${o.shape.slice(1,o.shape.length)}] (tensor shape [${o.shape}])`)}}return a}function XPe(e,t,n){const r=ql(e.map(a=>a.shape[0]));r.sort();const s=ql(t.map(a=>a.shape[0]));if(s.sort(),r.length>1)throw new le(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(a=>a.shape))}`);if(s.length>1)throw new le(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(a=>a.shape))}`);if(r.length>0&&s.length>0&&!Nn(r,s))throw new le(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${s[0]} target sample(s).`)}function QPe(e,t,n){const r=[DI,FI,Fy];for(let s=0;s<e.length;++s){const a=e[s],i=t[s],o=n[s];if(i!=null){if(i===Fy&&a.shape[a.shape.length-1]===1)throw new le(`You are passing a target array of shape ${a.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(r.indexOf(i)!==-1){const u=a.shape.slice(1),c=o.slice(1);for(let l=0;l<u.length;++l){const d=u[l],h=c[l];if(h!=null&&d!==h)throw new le(`A target Tensor with shape ${a.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function MD(e,t,n,r=!0,s=""){let a;if(Array.isArray(e)){if(e.length!==t.length)throw new le(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);a=e}else{if(t.length>1)throw new le(`The model expects ${t.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);a=[e]}if(n!=null)for(let i=0;i<t.length;++i){if(n[i]==null)continue;const o=a[i];if(o.shape.length!==n[i].length)throw new le(`Error when checking ${s}: expected ${t[i]} to have ${n[i].length} dimension(s), but got array with shape ${JSON.stringify(o.shape)}`);for(let u=0;u<n[i].length;++u){if(u===0&&!r)continue;const c=o.shape[u],l=n[i][u];if(l!=null&&l!==c)throw new le(`Error when checking ${s}: expected ${t[i]} to have shape ${JSON.stringify(n[i])} but got array with shape ${JSON.stringify(o.shape)}.`)}}}function YPe(e,t){if(e==null||Array.isArray(e)&&e.length===0)return t.map(r=>[]);let n;if(typeof e=="string"||typeof e=="function")n=[e];else if(Array.isArray(e)||typeof e=="object")n=e;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);if(Array.isArray(n))return t.map(r=>n);{const r=[];for(const s of t){let a=n.hasOwnProperty(s)?n[s]:[];Array.isArray(a)||(a=[a]),r.push(a)}return r}}const JPe="layers-model";class Rp extends Di{constructor(t){super(t),this.isTraining=!1}summary(t,n,r=console.log){if(!this.built)throw new le("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");FPe(this,t,n,r)}compile(t){if(t.loss==null&&(t.loss=[]),this.loss=t.loss,typeof t.optimizer=="string")this.optimizer_=DPe(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof Bu))throw new le("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let n=[];if(!Array.isArray(t.loss)&&typeof t.loss!="string"&&typeof t.loss!="function"){t.loss=t.loss;for(const i in t.loss)if(this.outputNames.indexOf(i)===-1)throw new le(`Unknown entry in loss dictionary: "${i}". Only expected the following keys: ${this.outputNames}`);for(const i of this.outputNames)t.loss[i]==null&&console.warn(`Output "${i}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${i} during training`),n.push(Tk(t.loss[i]))}else if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new le(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);n=t.loss.map(o=>Tk(o))}else{const i=Tk(t.loss);this.outputs.forEach(o=>{n.push(i)})}this.lossFunctions=n,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let i=0;i<this.outputs.length;++i){const o=this.internalOutputShapes[i],u=this.outputNames[i];this.feedOutputNames.push(u),this.feedOutputShapes.push(o),this.feedLossFns.push(this.lossFunctions[i])}const r=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Fc("loss",()=>{for(let i=0;i<this.outputs.length;++i){if(r.indexOf(i)!==-1)continue;const o=this.lossFunctions[i];this.outputs.length>1&&(this.metricsTensors.push([o,i]),this.metricsNames.push(this.outputNames[i]+"_loss"))}});const s=YPe(t.metrics,this.outputNames),a=(i,o,u)=>{this.outputNames.length>1&&(o=this.outputNames[i]+"_"+o),this.metricsNames.push(o),this.metricsTensors.push([u,i])};Fc("metric",()=>{for(let i=0;i<this.outputs.length;++i){if(r.indexOf(i)!==-1)continue;const o=s[i];(c=>{let d,h,p;for(const f of c){if(typeof f=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(f)!==-1){const g=this.internalOutputShapes[i];g[g.length-1]===1||this.lossFunctions[i]===FI?["accuracy","acc"].indexOf(f)!==-1?h=QV:["crossentropy","ce"].indexOf(f)!==-1&&(h=kPe):this.lossFunctions[i]===qx?["accuracy","acc"].indexOf(f)!==-1?h=CPe:["crossentropy","ce"].indexOf(f)!==-1&&(h=ZV):["accuracy","acc"].indexOf(f)!==-1?h=YV:["crossentropy","ce"].indexOf(f)!==-1&&(h=JV);let b;["accuracy","acc"].indexOf(f)!==-1?b="acc":["crossentropy","ce"].indexOf(f)!==-1&&(b="ce"),p=h,d=""+b}else p=_Pe(f),d=""+R2(f);let m;Fc(d,()=>{m=p}),a(i,d,m)}})(o)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,n,r={}){const s=r.batchSize==null?32:r.batchSize;Ek(s);const i=this.standardizeUserDataXY(t,n,!0,s);try{const o=i[0].concat(i[1]);this.makeTestFunction();const u=this.testFunction,c=this.testLoop(u,o,s,r.verbose,r.steps);return na(c)}finally{$i(i[0],t),$i(i[1],n)}}async evaluateDataset(t,n){return this.makeTestFunction(),qPe(this,t,n)}checkNumSamples(t,n,r,s="steps"){let a;if(r!=null){if(a=null,n!=null)throw new le(`If ${s} is set, batchSize must be null or undefined.Got batchSize = ${n}`)}else if(t!=null)Array.isArray(t)?a=t[0].shape[0]:a=t.shape[0];else throw new le(`Either the input data should have a defined shape, or ${s} shoud be specified.`);return a}execute(t,n){if(Array.isArray(n)&&n.length===0)throw new le("`outputs` is an empty Array, which is not allowed.");const r=Array.isArray(n),s=r?n:[n],a=this.retrieveSymbolicTensors(s),i=new Bl;if(t instanceof Br&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new le(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let u=0;u<this.inputs.length;++u)i.add(this.inputs[u],t[u])}else for(const u of this.inputs){const c=t[u.name];if(c==null)throw new le(`No value is provided for the model's input ${u.name}`);i.add(u,c)}const o=Kb(a,i);return r?o:o[0]}retrieveSymbolicTensors(t){const n=hd(null,t.length);let r=t.length;for(const s of this.layers){const a=Array.isArray(s.output)?s.output:[s.output],i=a.map(o=>o.name);for(let o=0;o<t.length;++o){const u=i.indexOf(t[o]);if(u!==-1&&(n[o]=a[u],r--),r===0)break}if(r===0)break}if(r>0){const s=[];throw n.forEach((a,i)=>{a==null&&s.push(t[i])}),new le(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(s)}`)}return n}predictLoop(t,n=32,r=!1){return we(()=>{const s=this.checkNumSamples(t);if(r)throw new qt("Verbose predictLoop() is not implemented yet.");const a=Ak(s,n),i=this.outputs.map(o=>[]);for(let o=0;o<a.length;++o)we(()=>{const c=a[o][0],l=a[o][1],d=Db(t,c,l),h=[];if(Array.isArray(d))for(let f=0;f<d.length;++f)h.push({key:this.inputs[f],value:d[f]});else h.push({key:this.inputs[0],value:d});const p=new Bl(h);return Kb(this.outputs,p)}).forEach((c,l)=>i[l].push(c));return na(i.map(o=>ia(o,0)))})}predict(t,n={}){const r=aU(t);MD(r,this.inputNames,this.feedInputShapes,!1);try{const s=n.batchSize==null?32:n.batchSize;return Ek(s),this.predictLoop(r,s)}finally{$i(r,t)}}predictOnBatch(t){MD(t,this.inputNames,this.feedInputShapes,!0);const n=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,n)}standardizeUserDataXY(t,n,r=!0,s){if(this.optimizer_==null)throw new li("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const a=[];for(let i=0;i<this.feedOutputShapes.length;++i){const o=this.feedOutputShapes[i];this.feedLossFns[i]===qx?a.push(o.slice(0,o.length-1).concat([1])):a.push(o)}if(t=FD(t,this.feedInputNames,this.feedInputShapes,!1,"input"),n=FD(n,this.feedOutputNames,a,!1,"target"),XPe(t,n),QPe(n,this.feedLossFns,this.feedOutputShapes),this.stateful&&s!=null&&s>0&&t[0].shape[0]%s!==0)throw new le(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${s}. Found: ${t[0].shape[0]} sample(s).`);return[t,n]}async standardizeUserData(t,n,r,s,a=!0,i){const[o,u]=this.standardizeUserDataXY(t,n,a,i);if(r!=null)throw new Error("sample weight is not supported yet.");let c=null;if(s!=null){const l=nU(s,this.outputNames);c=[];for(let d=0;d<l.length;++d)c.push(await rU(u[d],null,l[d]))}return[o,u,c]}testLoop(t,n,r,s=0,a){return we(()=>{const i=this.checkNumSamples(n,r,a,"steps"),o=[];if(s>0)throw new qt("Verbose mode is not implemented yet.");if(a!=null)throw new qt("steps mode in testLoop() is not implemented yet");{const u=Ak(i,r),c=ka(Xi(0,i));for(let l=0;l<u.length;++l){const d=u[l][0],h=u[l][1],p=Mc(c,d,h-d),f=CS(n,p),m=t(f);if(l===0)for(let g=0;g<m.length;++g)o.push(Sn(0));for(let g=0;g<m.length;++g){const b=m[g];o[g]=We(o[g],ce(h-d,b))}}for(let l=0;l<o.length;++l)o[l]=Nt(o[l],i)}return o})}getDedupedMetricsNames(){const t=this.metricsNames,n=[];for(let r=0;r<t.length;++r){const s=t[r];let a=s;if(xD(t,s)>1){const i=xD(t.slice(0,r),s);a+=`_${i}`}n.push(a)}return n}makeTrainFunction(){return t=>{const n=[],r=t.slice(0,this.inputs.length),s=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),i=[],o=()=>{const d=[];for(let m=0;m<this.inputs.length;++m)d.push({key:this.inputs[m],value:r[m]});const h=new Bl(d),p=Kb(this.outputs,h,{training:!0});let f;for(let m=0;m<this.lossFunctions.length;++m){const g=this.lossFunctions[m];let b=g(s[m],p[m]);a[m]!=null&&(b=WPe(b,a[m]));const y=$r(b);n.push(y),m===0?f=b:f=We(f,b)}for(let m=0;m<this.metricsTensors.length;++m){let g;if(this.outputs.length>1&&m<this.outputs.length)g=n[m];else{const b=this.metricsTensors[m][0],y=this.metricsTensors[m][1];g=$r(b(s[y],p[y]))}ko(g),i.push(g)}return f=$r(f),this.calculateLosses().forEach(m=>{f=We(f,m)}),f},u=this.collectedTrainableWeights.map(d=>d.read());return[this.optimizer_.minimize(o,!0,u)].concat(i)}}makeTestFunction(){this.testFunction=t=>we(()=>{const n=[];let r;const s=t.slice(0,this.inputs.length),a=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=[];for(let c=0;c<this.inputs.length;++c)i.push({key:this.inputs[c],value:s[c]});const o=new Bl(i),u=Kb(this.outputs,o);for(let c=0;c<this.lossFunctions.length;++c){const l=this.lossFunctions[c],d=$r(l(a[c],u[c]));c===0?r=d:r=We(r,d),n.push(r)}for(let c=0;c<this.metricsTensors.length;++c){const l=this.metricsTensors[c][0],d=this.metricsTensors[c][1],h=$r(l(a[d],u[d]));n.push(h)}return n})}async fit(t,n,r={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let s,a,i,o,u,c,l,d,h;try{const p=r.batchSize==null?32:r.batchSize;Ek(p);const m=await this.standardizeUserData(t,n,r.sampleWeight,r.classWeight,!1,p);s=m[0],a=m[1],h=m[2];let g=!1,b;if(r.validationData!=null&&r.validationData.length>0){if(g=!0,r.validationData.length===2)u=r.validationData[0],c=r.validationData[1];else throw r.validationData.length===3?new qt("validationData including sample weights is not supported yet."):new le(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${r.validationData} is invalid.`);const A=await this.standardizeUserData(u,c,null,null,!0,p);l=A[0],d=A[1],b=l.concat(d)}else if(r.validationSplit!=null&&r.validationSplit>0&&r.validationSplit<1){g=!0;const E=Math.floor(s[0].shape[0]*(1-r.validationSplit)),A=s[0].shape[0];l=Db(s,E,A),i=s,s=Db(s,0,E),d=Db(a,E,A),o=a,a=Db(a,0,E),b=l.concat(d)}else r.validationSteps!=null&&(g=!0);const y=s.concat(a).concat(h);this.checkTrainableWeightsConsistency();const x=this.makeTrainFunction(),w=this.getDedupedMetricsNames();let v,I;g?(this.makeTestFunction(),v=this.testFunction,I=w.slice().concat(w.map(E=>"val_"+E))):(v=null,b=[],I=w.slice());const N=qV(r.callbacks,r.yieldEvery);return await this.fitLoop(x,y,w,p,r.epochs,r.verbose,N,v,b,r.shuffle,I,r.initialEpoch,null,null)}finally{this.isTraining=!1,$i(s,t),$i(a,n),$i(i,t),$i(o,n),$i(l,u),$i(d,c),h!=null&&tn(h)}}async fitLoop(t,n,r,s,a,i,o,u,c,l,d,h,p,f){s==null&&(s=32),a==null&&(a=1),l==null&&(l=!0),h==null&&(h=0);let m=!1;if(u!=null&&c!=null&&(m=!0),f!=null&&(m=!0,p==null))throw new le("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const g=this.checkNumSamples(n,s,p,"steps_per_epoch");let b;g!=null&&(b=Xi(0,g)),i==null&&(i=1);const{callbackList:y,history:x}=KV(o,i,a,h,g,p,s,m,d);y.setModel(this),this.history=x,await y.onTrainBegin(),this.stopTraining_=!1;for(let w=h;w<a;++w){await y.onEpochBegin(w);const v={};if(p!=null)throw new qt("stepsPerEpoch mode is not implemented yet.");{if(l==="batch")throw new qt("batch shuffling is not implemneted yet");l&&L_e(b);const I=ka(b),N=Ak(g,s);for(let T=0;T<N.length;++T){const E={};if(await y.onBatchBegin(T,E),we(()=>{const A=N[T][0],k=N[T][1],C=Mc(I,A,k-A);E.batch=T,E.size=k-A;const M=CS(n,C),L=t(M);for(let O=0;O<r.length;++O){const B=r[O],G=L[O];E[B]=G,ko(G)}if(T===N.length-1&&m){const O=this.testLoop(u,c,s);for(let B=0;B<r.length;++B){const G=r[B],z=O[B];ko(z),v["val_"+G]=z}}}),await y.onBatchEnd(T,E),jV(E),this.stopTraining_)break}I.dispose()}if(await y.onEpochEnd(w,v),this.stopTraining_)break}return await y.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(t,n){return GPe(this,t,n)}async trainOnBatch(t,n){const r=await this.standardizeUserData(t,n),s=r[0],a=r[1],o=this.makeTrainFunction()(s.concat(a)),u=[];for(const c of o){const l=await c.data();u.push(l[0])}return tn(o),$i(r[0],t),$i(r[1],n),na(u)}getNamedWeights(t){const n=[],r=t!=null&&t.trainableOnly,s=r?this.trainableWeights:this.weights,a=this.getWeights(r);for(let i=0;i<s.length;++i)r&&!s[i].trainable||n.push({name:s[i].originalName,tensor:a[i]});return n}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){const t=super.dispose();if(t.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const n=H_().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=n-H_().numTensors}return t}getLossIdentifiers(){let t;if(typeof this.loss=="string")t=Jo(this.loss);else if(Array.isArray(this.loss)){for(const n of this.loss)if(typeof n!="string")throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map(n=>Jo(n))}else{const n=Object.keys(this.loss);t={};const r=this.loss;for(const s of n)if(typeof r[s]=="string")t[s]=Jo(r[s]);else throw new Error("Serialization of non-string loss is not supported.")}return t}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[Jo(R2(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(t=>Jo(R2(t)));{const t={};for(const n in this.metrics)t[n]=Jo(R2(this.metrics[n]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(t.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(t.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(t.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const n=IS(t.optimizer_config),r=al(n);let s;if(typeof t.loss=="string")s=Ic(t.loss);else if(Array.isArray(t.loss))s=t.loss.map(i=>Ic(i));else if(t.loss!=null){s={};for(const i in t.loss)s[i]=Ic(t.loss[i])}let a;if(Array.isArray(t.metrics))a=t.metrics.map(i=>Ic(i));else if(t.metrics!=null){a={};for(const i in t.metrics)a[i]=Ic(t.metrics[i])}this.compile({loss:s,metrics:a,optimizer:r})}async save(t,n){if(typeof t=="string"){const c=DDe(t);if(c.length===0)throw new le(`Cannot find any save handlers for URL '${t}'`);if(c.length>1)throw new le(`Found more than one (${c.length}) save handlers for URL '${t}'`);t=c[0]}if(t.save==null)throw new le("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const r=await X_(this.getNamedWeights(n)),o={modelTopology:this.toJSON(null,!1),format:JPe,generatedBy:`TensorFlow.js tfjs-layers v${tU}`,convertedBy:null};if((n==null?!1:n.includeOptimizer)&&this.optimizer!=null){o.trainingConfig=this.getTrainingConfig();const c="optimizer",{data:l,specs:d}=await X_(await this.optimizer.getWeights(),c);r.specs.push(...d),r.data=_De([r.data,l])}return this.userDefinedMetadata!=null&&($D(this.userDefinedMetadata,this.name,!0),o.userDefinedMetadata=this.userDefinedMetadata),o.weightData=r.data,o.weightSpecs=r.specs,t.save(o)}setUserDefinedMetadata(t){$D(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}}Rp.className="Model";Le(Rp);class iU extends Rp{}iU.className="Functional";Le(iU);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class My extends Rp{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=t.name!=null?t.name:$I("sequential_"),t.layers!=null)for(const n of t.layers)this.add(n)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(r=>r<0))throw new le(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){const n=t instanceof My||t instanceof Rp;let r;if(n){if(r=t,r.outputs.length!==1)throw new le("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(r.inputs.length!==1)throw new le("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null)throw new le("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const s=ePe({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(s)}if(n)this.outputs=r.outputs,this.inputs=r.inputs;else{if(t.inboundNodes.length!==1)throw new le(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(t.inboundNodes[0].outputTensors.length!==1)throw new le("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=WV(this.outputs[0])}this.inboundNodes=[],new _I({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:hd(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(s=>s.shape),outputShapes:this.outputs[0].shape})}else{const s=t.apply(this.outputs[0]);if(Array.isArray(s))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[s],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,n){return this.model==null&&this.build(),this.model.call(t,n)}build(t){if(gn(t),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Rp({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,n,r=console.log){this.built||this.build(),super.summary(t,n,r)}setWeights(t){this.model==null&&this.build(),this.model.setWeights(t)}evaluate(t,n,r={}){if(!this.built)throw new li("The model needs to be compiled before being used.");return this.model.evaluate(t,n,r)}async evaluateDataset(t,n){if(!this.built)throw new li("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,n)}predict(t,n={}){return this.model==null&&this.build(),this.model.predict(t,n)}predictOnBatch(t){return this.model==null&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,n,r={}){if(!this.built)throw new li("The model needs to be compiled before being used.");return this.model.fit(t,n,r)}async fitDataset(t,n){if(!this.built)throw new li("The model needs to be compiled before being used.");return this.model.fitDataset(t,n)}async trainOnBatch(t,n){return this.model.trainOnBatch(t,n)}static fromConfig(t,n,r={},s=!1){let a,i={};if(n instanceof Array){if(n[0].className==null||n[0].className==="Merge")throw new le("Legacy serialization format not supported yet.");a=n}else U(n.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),a=n.layers,delete n.layers,i=n;const o=new t(i);if(!(o instanceof My))throw new qt(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(const u of a){const l=al(u,void 0,s);s&&l.setFastWeightInitDuringBuild(!0),o.add(l)}return o}set stopTraining(t){if(this.model==null)throw new le("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(this.model==null)throw new le("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const t=[];for(const n of this.layers){const r={};r.className=n.getClassName(),r.config=n.getConfig(),t.push(r)}return{name:this.name,layers:t}}}My.className="Sequential";Le(My);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let As=class extends sb{getConfig(){return{}}};class oU extends As{apply(t,n=1){return PLe(t,n)}}oU.className="elu";Le(oU);class lU extends As{apply(t){return LW(t)}}lU.className="selu";Le(lU);class uU extends As{apply(t){return tp(t)}}uU.className="relu";Le(uU);class cU extends As{apply(t){return we(()=>$y(6,tp(t)))}}cU.className="relu6";Le(cU);class dU extends As{apply(t){return t}}dU.className="linear";Le(dU);class hU extends As{apply(t){return tb(t)}}hU.className="sigmoid";Le(hU);class pU extends As{apply(t){return zLe(t)}}pU.className="hardSigmoid";Le(pU);class fU extends As{apply(t){return U1(t)}}fU.className="softplus";Le(fU);class mU extends As{apply(t){return BLe(t)}}mU.className="softsign";Le(mU);class gU extends As{apply(t){return cI(t)}}gU.className="tanh";Le(gU);let YA=class extends As{apply(t,n=-1){return ZE(t,n)}};YA.className="softmax";Le(YA);class bU extends As{apply(t,n=-1){return AW(t,n)}}bU.className="logSoftmax";Le(bU);class yU extends As{apply(t){return we(()=>we(()=>{const n=Math.sqrt(2),r=ce(.5,We(1,CW(Nt(t,n))));return ce(t,r)}))}}yU.className="gelu";Le(yU);class xU extends As{apply(t){return we(()=>ce(.5,ce(t,We(1,cI(ce(Ss(Nt(2,Math.PI)),We(t,ce(.044715,ud(t,3)))))))))}}xU.className="gelu_new";Le(xU);class wU extends As{apply(t){return we(()=>ce(t,cI(U1(t))))}}wU.className="mish";Le(wU);class vU extends As{apply(t,n=1){return we(()=>ce(tb(ce(t,n)),t))}}vU.className="swish";Le(vU);function hu(e){return e.getClassName()}function $k(e,t={}){return K1(e,oi.getMap().classNameMap,t,"activation")}function pu(e){if(e==null){const t={};return t.className="linear",t.config={},$k(t)}if(typeof e=="string"){const t={};return t.className=e,t.config={},$k(t)}else return e instanceof As?e:$k(e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function ZPe(e){if(e!=null&&typeof e!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}class IU extends sb{}class kU extends IU{constructor(t){super(),ZPe(t),this.l1=t==null||t.l1==null?.01:t.l1,this.l2=t==null||t.l2==null?.01:t.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(t){return we(()=>{let n=ss([1]);return this.hasL1&&(n=We(n,Ct(ce(this.l1,Fs(t))))),this.hasL2&&(n=We(n,Ct(ce(this.l2,Q1(t))))),be(n,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,n){return new t({l1:n.l1,l2:n.l2})}}kU.className="L1L2";Le(kU);const OD={l1l2:"L1L2"};function Hn(e){return LA(e)}function LD(e,t={}){return K1(e,oi.getMap().classNameMap,t,"regularizer")}function ur(e){if(e==null)return null;if(typeof e=="string"){const n={className:e in OD?OD[e]:e,config:{}};return LD(n)}else return e instanceof IU?e:LD(e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class CU extends Jt{constructor(t){super(t??{}),this.supportsMasking=!0,t!=null&&(this.maxValue=t.maxValue)}call(t,n){t=Mt(t);let r=tp(t);return this.maxValue!=null&&(r=Ka(r,0,this.maxValue)),r}computeOutputShape(t){return t}getConfig(){const t={maxValue:this.maxValue},n=super.getConfig();return Object.assign(t,n),t}}CU.className="ReLU";Le(CU);class SU extends Jt{constructor(t){super(t??{}),this.DEFAULT_ALPHA=.3,t==null&&(t={}),this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,n){const r=Mt(t);return UE(r,this.alpha)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},n=super.getConfig();return Object.assign(t,n),t}}SU.className="LeakyReLU";Le(SU);class NU extends Jt{constructor(t){if(super(t??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",t==null&&(t={}),this.supportsMasking=!0,this.alphaInitializer=or(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=ur(t.alphaRegularizer),this.alphaConstraint=Kr(t.alphaConstraint),t.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else if(typeof t.sharedAxes=="number")this.sharedAxes=[t.sharedAxes];else throw new le(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`)}build(t){t=gn(t);const n=t.slice(1);if(this.sharedAxes!=null)for(const s of this.sharedAxes)n[s-1]=1;this.alpha=this.addWeight("alpha",n,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const r={};if(this.sharedAxes!=null)for(let s=1;s<t.length;++s)r[s]=t[s];this.inputSpec=[new Ur({ndim:t.length,axes:r})],this.built=!0}call(t,n){return t=Mt(t),XE(t,this.alpha.read())}getConfig(){const t={alphaInitializer:pr(this.alphaInitializer),alphaRegularizer:Hn(this.alphaRegularizer),alphaConstraint:qr(this.alphaConstraint),sharedAxes:this.sharedAxes},n=super.getConfig();return Object.assign(t,n),t}}NU.className="PReLU";Le(NU);let TU=class extends Jt{constructor(t){if(super(t??{}),this.DEFAULT_ALPHA=1,t==null&&(t={}),t.alpha!=null&&t.alpha!==this.DEFAULT_ALPHA)throw new qt(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,n){const r=Mt(t);return pI(r)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},n=super.getConfig();return Object.assign(t,n),t}};TU.className="ELU";Le(TU);class EU extends Jt{constructor(t){super(t??{}),this.DEFAULT_THETA=1,t==null&&(t={}),this.theta=t.theta==null?this.DEFAULT_THETA:t.theta}call(t,n){const r=Mt(t);return ce(r,at(Ya(r,this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){const t={theta:this.theta},n=super.getConfig();return Object.assign(t,n),t}}EU.className="ThresholdedReLU";Le(EU);class AU extends Jt{constructor(t){super(t??{}),this.DEFAULT_AXIS=1,t==null&&(t={}),this.softmax=new YA().apply,this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis}call(t,n){return we(()=>{let r=Mt(t);const s=n.mask;if(s!=null){const a=ce(_t(Pu(r.shape),at(s,r.dtype)),Sn(-1e9));r=We(r,a)}return this.axis instanceof Array?this.axis.length>1?Ro(_t(r,$W(r,this.axis,!0))):this.softmax(r,this.axis[0]):this.softmax(r,this.axis)})}computeOutputShape(t){return t}getConfig(){const t={axis:this.axis},n=super.getConfig();return Object.assign(t,n),t}}AU.className="Softmax";Le(AU);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function _p(e,t,n){if(typeof e=="number")return hd(e,t);if(e.length!==t)throw new le(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let r=0;r<t;++r){const s=e[r];if(!FLe(s))throw new le(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${s}`)}return e}function Gi(e,t,n,r,s=1){if(e==null)return e;const a=t+(t-1)*(s-1);let i;return n==="same"?i=e:i=e-a+1,Math.floor((i+r-1)/r)}function mo(e,t,n,r){if(e==null)return null;if(r==="valid")e=e*t+du([n-t,0]);else if(r==="same")e=e*t;else throw new le(`Unsupport padding mode: ${r}.`);return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function JA(e,t){return we(()=>(Sr(t),t==="channelsFirst"?un(e,[0,2,3,1]):e))}function $U(e,t){return we(()=>(Sr(t),t==="channelsFirst"?un(e,[0,2,3,4,1]):e))}function eBe(e,t,n,r=1,s="valid",a,i=1){return we(()=>{if(a==null&&(a=Qi()),Sr(a),e.shape.length!==3)throw new le(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(t.shape.length!==3)throw new le(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(n!=null&&n.shape.length!==1)throw new le(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);if(a==="channelsFirst"&&(e=un(e,[0,2,1])),s==="causal")throw new qt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=xW(e,t,r,s==="same"?"same":"valid","NWC",i);return n!=null&&(o=no(o,n)),o})}function PD(e,t,n,r=[1,1],s="valid",a,i,o=null){return we(()=>{if(a==null&&(a=Qi()),Sr(a),e.rank!==3&&e.rank!==4)throw new le(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(t.rank!==3&&t.rank!==4)throw new le(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let u=JA(e,a);if(s==="causal")throw new qt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return u=u8e({x:u,filter:t,strides:r,pad:s==="same"?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),a==="channelsFirst"&&(u=un(u,[0,3,1,2])),u})}function tBe(e,t,n,r=[1,1,1],s="valid",a,i){return we(()=>{if(a==null&&(a=Qi()),Sr(a),e.rank!==4&&e.rank!==5)throw new le(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(t.rank!==4&&t.rank!==5)throw new le(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=$U(e,a);if(s==="causal")throw new qt("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=u6e(o,t,r,s==="same"?"same":"valid","NDHWC",i),n!=null&&(o=no(o,n)),a==="channelsFirst"&&(o=un(o,[0,4,1,2,3])),o})}class MI extends Jt{constructor(t,n){if(super(n),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",MI.verifyArgs(n),this.rank=t,is(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new qt(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=_p(n.kernelSize,t,"kernelSize"),this.strides=_p(n.strides==null?1:n.strides,t,"strides"),this.padding=n.padding==null?"valid":n.padding,Ja(this.padding),this.dataFormat=n.dataFormat==null?"channelsLast":n.dataFormat,Sr(this.dataFormat),this.activation=pu(n.activation),this.useBias=n.useBias==null?!0:n.useBias,this.biasInitializer=or(n.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Kr(n.biasConstraint),this.biasRegularizer=ur(n.biasRegularizer),this.activityRegularizer=ur(n.activityRegularizer),this.dilationRate=_p(n.dilationRate==null?1:n.dilationRate,t,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new le(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new le(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new le(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(t){if(fo("kernelSize"in t,"required key 'kernelSize' not in config"),typeof t.kernelSize!="number"&&!PA(t.kernelSize,"number",1,3))throw new le(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:hu(this.activation),useBias:this.useBias,biasInitializer:pr(this.biasInitializer),biasRegularizer:Hn(this.biasRegularizer),activityRegularizer:Hn(this.activityRegularizer),biasConstraint:qr(this.biasConstraint)},n=super.getConfig();return Object.assign(t,n),t}}class ab extends MI{constructor(t,n){super(t,n),this.kernel=null,ab.verifyArgs(n),this.filters=n.filters,is(this.filters,"filters"),this.kernelInitializer=or(n.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Kr(n.kernelConstraint),this.kernelRegularizer=ur(n.kernelRegularizer)}build(t){t=gn(t);const n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null)throw new le(`The channel dimension of the input should be defined. Found ${t[n]}`);const r=t[n],s=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[n]:r}}],this.built=!0}call(t,n){return we(()=>{t=Mt(t);let r;const s=this.bias==null?null:this.bias.read(),a=NV(this.activation.getClassName());if(a!=null&&this.rank===2)r=PD(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate,a);else{if(this.rank===1)r=eBe(t,this.kernel.read(),s,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)r=PD(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)r=tBe(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new qt("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(r=this.activation.apply(r))}return r})}computeOutputShape(t){t=gn(t);const n=[],r=this.dataFormat==="channelsLast"?t.slice(1,t.length-1):t.slice(2);for(let a=0;a<r.length;++a){const i=Gi(r[a],this.kernelSize[a],this.padding,this.strides[a],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[a]);n.push(i)}let s=[t[0]];return this.dataFormat==="channelsLast"?(s=s.concat(n),s.push(this.filters)):(s.push(this.filters),s=s.concat(n)),s}getConfig(){const t={filters:this.filters,kernelInitializer:pr(this.kernelInitializer),kernelRegularizer:Hn(this.kernelRegularizer),kernelConstraint:qr(this.kernelConstraint)},n=super.getConfig();return Object.assign(t,n),t}static verifyArgs(t){if(!("filters"in t)||typeof t.filters!="number"||t.filters<1)throw new le(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}}class e2 extends ab{constructor(t){super(2,t),e2.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!PA(t.kernelSize,"number",1,2))throw new le(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}}e2.className="Conv2D";Le(e2);class t2 extends ab{constructor(t){super(3,t),t2.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3)))throw new le(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}}t2.className="Conv3D";Le(t2);class RU extends e2{constructor(t){if(super(t),this.inputSpec=[new Ur({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new le(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=gn(t),t.length!==4)throw new le("Input should have rank 4; Received input shape: "+JSON.stringify(t));const n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null)throw new le("The channel dimension of the inputs should be defined. Found `None`.");const r=t[n],s=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Ur({ndim:4,axes:{[n]:r}})],this.built=!0}call(t,n){return we(()=>{let r=Mt(t);if(r.shape.length!==4)throw new le(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);const s=r.shape,a=s[0];let i,o;this.dataFormat==="channelsFirst"?(i=2,o=3):(i=1,o=2);const u=s[i],c=s[o],l=this.kernelSize[0],d=this.kernelSize[1],h=this.strides[0],p=this.strides[1],f=mo(u,h,l,this.padding),m=mo(c,p,d,this.padding),g=[a,f,m,this.filters];this.dataFormat!=="channelsLast"&&(r=un(r,[0,2,3,1]));let b=wW(r,this.kernel.read(),g,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(b=un(b,[0,3,1,2])),this.bias!=null&&(b=no(b,this.bias.read(),this.dataFormat)),this.activation!=null&&(b=this.activation.apply(b)),b})}computeOutputShape(t){t=gn(t);const n=t.slice();let r,s,a;this.dataFormat==="channelsFirst"?(r=1,s=2,a=3):(r=3,s=1,a=2);const i=this.kernelSize[0],o=this.kernelSize[1],u=this.strides[0],c=this.strides[1];return n[r]=this.filters,n[s]=mo(n[s],u,i,this.padding),n[a]=mo(n[a],c,o,this.padding),n}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}RU.className="Conv2DTranspose";Le(RU);class _U extends t2{constructor(t){if(super(t),this.inputSpec=[new Ur({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new le(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=gn(t),t.length!==5)throw new le("Input should have rank 5; Received input shape: "+JSON.stringify(t));const n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null)throw new le("The channel dimension of the inputs should be defined. Found `None`.");const r=t[n],s=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Ur({ndim:5,axes:{[n]:r}})],this.built=!0}call(t,n){return we(()=>{let r=Mt(t);if(r.shape.length!==5)throw new le(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);const s=r.shape,a=s[0];let i,o,u;this.dataFormat==="channelsFirst"?(u=2,i=3,o=4):(u=1,i=2,o=3);const c=s[u],l=s[i],d=s[o],h=this.kernelSize[0],p=this.kernelSize[1],f=this.kernelSize[2],m=this.strides[0],g=this.strides[1],b=this.strides[2],y=mo(c,m,h,this.padding),x=mo(l,g,p,this.padding),w=mo(d,b,f,this.padding),v=[a,y,x,w,this.filters];this.dataFormat!=="channelsLast"&&(r=un(r,[0,2,3,4,1]));let I=h6e(r,this.kernel.read(),v,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(I=un(I,[0,4,1,2,3])),this.bias!==null&&(I=no(I,this.bias.read(),this.dataFormat)),this.activation!==null&&(I=this.activation.apply(I)),I})}computeOutputShape(t){t=gn(t);const n=t.slice();let r,s,a,i;this.dataFormat==="channelsFirst"?(r=1,s=2,a=3,i=4):(r=4,s=1,a=2,i=3);const o=this.kernelSize[0],u=this.kernelSize[1],c=this.kernelSize[2],l=this.strides[0],d=this.strides[1],h=this.strides[2];return n[r]=this.filters,n[s]=mo(n[s],l,o,this.padding),n[a]=mo(n[a],d,u,this.padding),n[i]=mo(n[i],h,c,this.padding),n}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}_U.className="Conv3DTranspose";Le(_U);class DU extends ab{constructor(t,n){if(super(t,n),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,n.filters==null)throw new le("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(n.kernelInitializer!=null||n.kernelRegularizer!=null||n.kernelConstraint!=null)throw new le("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(n.padding!=null&&n.padding!=="same"&&n.padding!=="valid")throw new le(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(n.padding)}`);this.depthMultiplier=n.depthMultiplier==null?1:n.depthMultiplier,this.depthwiseInitializer=or(n.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=ur(n.depthwiseRegularizer),this.depthwiseConstraint=Kr(n.depthwiseConstraint),this.pointwiseInitializer=or(n.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=ur(n.pointwiseRegularizer),this.pointwiseConstraint=Kr(n.pointwiseConstraint)}build(t){if(t=gn(t),t.length<this.rank+2)throw new le(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(t)}`);const n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null||t[n]<0)throw new le(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[n])}`);const r=t[n],s=this.kernelSize.concat([r,this.depthMultiplier]),a=[];for(let o=0;o<this.rank;++o)a.push(1);a.push(r*this.depthMultiplier,this.filters);const i=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",s,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,i,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,i,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,i,this.biasConstraint):this.bias=null,this.inputSpec=[new Ur({ndim:this.rank+2,axes:{[n]:r}})],this.built=!0}call(t,n){return we(()=>{t=Mt(t);let r;if(this.rank===1)throw new qt("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(t=un(t,[0,2,3,1])),r=PW(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(r=no(r,this.bias.read(),this.dataFormat)),this.activation!=null&&(r=this.activation.apply(r)),this.dataFormat==="channelsFirst"&&(r=un(r,[0,3,1,2])),r})}getConfig(){const t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=pr(this.depthwiseInitializer),t.pointwiseInitializer=pr(this.pointwiseInitializer),t.depthwiseRegularizer=Hn(this.depthwiseRegularizer),t.pointwiseRegularizer=Hn(this.pointwiseRegularizer),t.depthwiseConstraint=qr(this.depthwiseConstraint),t.pointwiseConstraint=qr(this.pointwiseConstraint),t}}DU.className="SeparableConv";class FU extends DU{constructor(t){super(2,t)}}FU.className="SeparableConv2D";Le(FU);class OI extends ab{constructor(t){super(1,t),OI.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){const t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!PA(t.kernelSize,"number",1,1))throw new le(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}}OI.className="Conv1D";Le(OI);class MU extends Jt{constructor(t){super(t),typeof t.cropping=="number"?this.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]:typeof t.cropping[0]=="number"?this.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:this.cropping=t.cropping,this.dataFormat=t.dataFormat===void 0?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return this.dataFormat==="channelsFirst"?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,n){return we(()=>{if(t=Mt(t),this.dataFormat==="channelsLast"){const r=$2(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return $2(r,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const r=$2(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return $2(r,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const t={cropping:this.cropping,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(t,n),t}}MU.className="Cropping2D";Le(MU);class OU extends Jt{constructor(t){super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=t.size==null?this.DEFAULT_SIZE:t.size,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Sr(this.dataFormat),this.interpolation=t.interpolation==null?"nearest":t.interpolation,RLe(this.interpolation)}computeOutputShape(t){if(this.dataFormat==="channelsFirst"){const n=t[2]==null?null:this.size[0]*t[2],r=t[3]==null?null:this.size[1]*t[3];return[t[0],t[1],n,r]}else{const n=t[1]==null?null:this.size[0]*t[1],r=t[2]==null?null:this.size[1]*t[2];return[t[0],n,r,t[3]]}}call(t,n){return we(()=>{let r=Mt(t);const s=r.shape;if(this.dataFormat==="channelsFirst"){r=un(r,[0,2,3,1]);const a=this.size[0]*s[2],i=this.size[1]*s[3],o=this.interpolation==="nearest"?tl.resizeNearestNeighbor(r,[a,i]):tl.resizeBilinear(r,[a,i]);return un(o,[0,3,1,2])}else{const a=this.size[0]*s[1],i=this.size[1]*s[2];return this.interpolation==="nearest"?tl.resizeNearestNeighbor(r,[a,i]):tl.resizeBilinear(r,[a,i])}})}getConfig(){const t={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},n=super.getConfig();return Object.assign(t,n),t}}OU.className="UpSampling2D";Le(OU);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function nBe(e,t,n=[1,1],r="valid",s,a){return we(()=>{s==null&&(s=Qi()),Sr(s);let i=JA(e,s);if(e.rank!==4)throw new le(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(t.rank!==4)throw new le(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=BE(i,t,n,r==="same"?"same":"valid","NHWC",a),s==="channelsFirst"&&(i=un(i,[0,3,1,2])),i})}class LU extends MI{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=or(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Kr(t.depthwiseConstraint),this.depthwiseRegularizer=ur(t.depthwiseRegularizer)}build(t){if(t=gn(t),t.length<4)throw new le(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);const n=this.dataFormat==="channelsFirst"?1:3;if(t[n]==null||t[n]<0)throw new le(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[n]}).`);const r=t[n],s=[this.kernelSize[0],this.kernelSize[1],r,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",s,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[r*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,n){return we(()=>{t=Mt(t);let r=nBe(t,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(r=no(r,this.bias.read(),this.dataFormat)),this.activation!=null&&(r=this.activation.apply(r)),r})}computeOutputShape(t){t=gn(t);const n=this.dataFormat==="channelsFirst"?t[2]:t[1],r=this.dataFormat==="channelsFirst"?t[3]:t[2],s=this.dataFormat==="channelsFirst"?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,a=Gi(n,this.kernelSize[0],this.padding,this.strides[0]),i=Gi(r,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[t[0],s,a,i]:[t[0],a,i,s]}getConfig(){const t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=pr(this.depthwiseInitializer),t.depthwiseRegularizer=Hn(this.depthwiseRegularizer),t.depthwiseConstraint=qr(this.depthwiseRegularizer),t}}LU.className="DepthwiseConv2D";Le(LU);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function PU(e,t,n,r){if(Array.isArray(e)){if(t!=null||n!=null)throw new le("When inputs is an array, neither initialState or constants should be provided");r!=null&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function s(a){return a==null||Array.isArray(a)?a:[a]}return t=s(t),n=s(n),{inputs:e,initialState:t,constants:n}}function BU(e,t,n,r=!1,s,a,i=!1,o=!1){return we(()=>{const u=t.shape.length;if(u<3)throw new le(`Input should be at least 3D, but is ${u}D.`);const c=[1,0].concat(Xi(2,u));t=un(t,c),i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),s!=null&&(s=at(at(s,"bool"),"float32"),s.rank===u-1&&(s=ta(s,-1)),s=un(s,c)),r&&(t=cd(t,0),s!=null&&(s=cd(s,0)));const l=[];let d,h=n;const p=t.shape[0],f=dd(t);let m;s!=null&&(m=dd(s));for(let b=0;b<p;++b){const y=f[b],x=we(()=>e(y,h));if(s==null)d=x[0],h=x[1];else{const w=we(()=>{const v=m[b],I=_t(fi(v),v),N=We(ce(x[0],v),ce(h[0],I)),T=h.map((E,A)=>We(ce(x[1][A],v),ce(E,I)));return{output:N,newStates:T}});d=w.output,h=w.newStates}o&&l.push(d)}let g;return o&&(g=ul(l,1)),[d,g,h]})}class zu extends Jt{constructor(t){super(t);let n;if(t.cell==null)throw new le("cell property is missing for the constructor of RNN.");if(Array.isArray(t.cell)?n=new t$({cells:t.cell}):n=t.cell,n.stateSize==null)throw new le("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=n,this.returnSequences=t.returnSequences==null?!1:t.returnSequences,this.returnState=t.returnState==null?!1:t.returnState,this.goBackwards=t.goBackwards==null?!1:t.goBackwards,this._stateful=t.stateful==null?!1:t.stateful,this.unroll=t.unroll==null?!1:t.unroll,this.supportsMasking=!0,this.inputSpec=[new Ur({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return Xi(0,t).map(n=>null)}else return this.states_}setStates(t){this.states_=t}computeOutputShape(t){xS(t)&&(t=t[0]),t=t;let n=this.cell.stateSize;Array.isArray(n)||(n=[n]);const r=n[0];let s;if(this.returnSequences?s=[t[0],t[1],r]:s=[t[0],r],this.returnState){const a=[];for(const i of n)a.push([t[0],i]);return[s].concat(a)}else return s}computeMask(t,n){return we(()=>{Array.isArray(n)&&(n=n[0]);const r=this.returnSequences?n:null;if(this.returnState){const s=this.states.map(a=>null);return[r].concat(s)}else return r})}get states(){if(this.states_==null){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,n=[];for(let r=0;r<t;++r)n.push(null);return n}else return this.states_}set states(t){this.states_=t}build(t){if(this.numConstants!=null)throw new qt("Constants support is not implemented in RNN yet.");xS(t)&&(t=t[0]),t=t;const n=this.stateful?t[0]:null,r=t.slice(2);this.inputSpec[0]=new Ur({shape:[n,null,...r]});const s=[t[0]].concat(t.slice(2));this.cell.build(s);let a;if(Array.isArray(this.cell.stateSize)?a=this.cell.stateSize:a=[this.cell.stateSize],this.stateSpec!=null){if(!Nn(this.stateSpec.map(i=>i.shape[i.shape.length-1]),a))throw new le(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(i=>new Ur({shape:[null,i]}));this.stateful&&this.resetStates()}resetStates(t,n=!1){we(()=>{if(!this.stateful)throw new po("Cannot call resetStates() on an RNN Layer that is not stateful.");const r=this.inputSpec[0].shape[0];if(r==null)throw new le("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>ss([r,s])):this.states_=[ss([r,this.cell.stateSize])];else if(t==null)tn(this.states_),this.keptStates!=null&&(tn(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>ss([r,s])):this.states_[0]=ss([r,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new le(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);n===!0?this.keptStates.push(this.states_.slice()):tn(this.states_);for(let s=0;s<this.states_.length;++s){const a=t[s],i=Array.isArray(this.cell.stateSize)?this.cell.stateSize[s]:this.cell.stateSize,o=[r,i];if(!Nn(a.shape,o))throw new le(`State ${s} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${a.shape}`);this.states_[s]=a}}this.states_=this.states_.map(s=>ko(s.clone()))})}apply(t,n){let r=n==null?null:n.initialState,s=n==null?null:n.constants;n==null&&(n={});const a=PU(t,r,s,this.numConstants);t=a.inputs,r=a.initialState,s=a.constants;let i=[],o=[];if(r!=null){n.initialState=r,i=i.concat(r),this.stateSpec=[];for(const c of r)this.stateSpec.push(new Ur({shape:c.shape}));o=o.concat(this.stateSpec)}if(s!=null&&(n.constants=s,i=i.concat(s),this.numConstants=s.length),i[0]instanceof Do){const c=[t].concat(i),l=this.inputSpec.concat(o),d=this.inputSpec;this.inputSpec=l;const h=super.apply(c,n);return this.inputSpec=d,h}else return super.apply(t,n)}call(t,n){return we(()=>{const r=n==null?null:n.mask,s=n==null?null:n.training;let a=n==null?null:n.initialState;t=Mt(t),a==null&&(this.stateful?a=this.states_:a=this.getInitialState(t));const i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(a.length!==i)throw new le(`RNN Layer has ${i} state(s) but was passed ${a.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const o={training:s},c=BU((f,m)=>{const g=this.cell.call([f].concat(m),o);return[g[0],g.slice(1)]},t,a,this.goBackwards,r,null,this.unroll,this.returnSequences),l=c[0],d=c[1],h=c[2];this.stateful&&this.resetStates(h,s);const p=this.returnSequences?d:l;return this.returnState?[p].concat(h):p})}getInitialState(t){return we(()=>{let n=ss(t.shape);return n=Ct(n,[1,2]),n=X1(n),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(r=>r>1?bS(n,[1,r]):n):this.cell.stateSize>1?[bS(n,[1,this.cell.stateSize])]:[n]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){const t=super.getConfig(),n={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(n.numConstants=this.numConstants);const r=this.cell.getConfig();return this.getClassName()===zu.className&&(n.cell={className:this.cell.getClassName(),config:r}),Object.assign(Object.assign(Object.assign({},r),t),n)}static fromConfig(t,n,r={}){const s=n.cell,a=al(s,r);return new t(Object.assign(n,{cell:a}))}}zu.className="RNN";Le(zu);class LI extends Jt{}class ZA extends LI{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,is(this.units,"units"),this.activation=pu(t.activation==null?this.DEFAULT_ACTIVATION:t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=or(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=or(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=or(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=ur(t.kernelRegularizer),this.recurrentRegularizer=ur(t.recurrentRegularizer),this.biasRegularizer=ur(t.biasRegularizer),this.kernelConstraint=Kr(t.kernelConstraint),this.recurrentConstraint=Kr(t.recurrentConstraint),this.biasConstraint=Kr(t.biasConstraint),this.dropout=af([1,du([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=af([1,du([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=gn(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,n){return we(()=>{if(t=t,t.length!==2)throw new le(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);let r=t[1];t=t[0];const s=n.training==null?!1:n.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=fu({ones:()=>fi(t),rate:this.dropout,training:s,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=fu({ones:()=>fi(r),rate:this.recurrentDropout,training:s,dropoutFunc:this.dropoutFunc}));let a;const i=this.dropoutMask,o=this.recurrentDropoutMask;i!=null?a=So(ce(t,i),this.kernel.read()):a=So(t,this.kernel.read()),this.bias!=null&&(a=no(a,this.bias.read())),o!=null&&(r=ce(r,o));let u=We(a,So(r,this.recurrentKernel.read()));return this.activation!=null&&(u=this.activation.apply(u)),[u,u]})}getConfig(){const t=super.getConfig(),n={units:this.units,activation:hu(this.activation),useBias:this.useBias,kernelInitializer:pr(this.kernelInitializer),recurrentInitializer:pr(this.recurrentInitializer),biasInitializer:pr(this.biasInitializer),kernelRegularizer:Hn(this.kernelRegularizer),recurrentRegularizer:Hn(this.recurrentRegularizer),biasRegularizer:Hn(this.biasRegularizer),activityRegularizer:Hn(this.activityRegularizer),kernelConstraint:qr(this.kernelConstraint),recurrentConstraint:qr(this.recurrentConstraint),biasConstraint:qr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},t),n)}}ZA.className="SimpleRNNCell";Le(ZA);class zU extends zu{constructor(t){t.cell=new ZA(t),super(t)}call(t,n){return we(()=>{this.cell.dropoutMask!=null&&(tn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(tn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const r=n==null?null:n.mask,s=n==null?null:n.training,a=n==null?null:n.initialState;return super.call(t,{mask:r,training:s,initialState:a})})}static fromConfig(t,n){return new t(n)}}zU.className="SimpleRNN";Le(zU);class e$ extends LI{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new le("GRUCell does not support reset_after parameter set to true.");this.units=t.units,is(this.units,"units"),this.activation=pu(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=pu(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=or(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=or(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=or(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=ur(t.kernelRegularizer),this.recurrentRegularizer=ur(t.recurrentRegularizer),this.biasRegularizer=ur(t.biasRegularizer),this.kernelConstraint=Kr(t.kernelConstraint),this.recurrentConstraint=Kr(t.recurrentConstraint),this.biasConstraint=Kr(t.biasConstraint),this.dropout=af([1,du([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=af([1,du([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=gn(t);const n=t[t.length-1];this.kernel=this.addWeight("kernel",[n,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,n){return we(()=>{if(t=t,t.length!==2)throw new le(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);const r=n.training==null?!1:n.training;let s=t[1];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=fu({ones:()=>fi(t),rate:this.dropout,training:r,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=fu({ones:()=>fi(s),rate:this.recurrentDropout,training:r,count:3,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,i=this.recurrentDropoutMask;let o,u,c;0<this.dropout&&this.dropout<1&&(t=ce(t,a[0]));let l=So(t,this.kernel.read());this.useBias&&(l=no(l,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(s=ce(s,i[0]));const d=this.recurrentKernel.read(),[h,p]=Ua(d,[2*this.units,this.units],d.rank-1),f=So(s,h),[m,g,b]=Ua(l,3,l.rank-1),[y,x]=Ua(f,2,f.rank-1);o=this.recurrentActivation.apply(We(m,y)),u=this.recurrentActivation.apply(We(g,x));const w=So(ce(u,s),p);c=this.activation.apply(We(b,w));const v=We(ce(o,s),ce(We(1,vr(o)),c));return[v,v]})}getConfig(){const t=super.getConfig(),n={units:this.units,activation:hu(this.activation),recurrentActivation:hu(this.recurrentActivation),useBias:this.useBias,kernelInitializer:pr(this.kernelInitializer),recurrentInitializer:pr(this.recurrentInitializer),biasInitializer:pr(this.biasInitializer),kernelRegularizer:Hn(this.kernelRegularizer),recurrentRegularizer:Hn(this.recurrentRegularizer),biasRegularizer:Hn(this.biasRegularizer),activityRegularizer:Hn(this.activityRegularizer),kernelConstraint:qr(this.kernelConstraint),recurrentConstraint:qr(this.recurrentConstraint),biasConstraint:qr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},t),n)}}e$.className="GRUCell";Le(e$);class WU extends zu{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new e$(t),super(t)}call(t,n){return we(()=>{this.cell.dropoutMask!=null&&(tn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(tn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const r=n==null?null:n.mask,s=n==null?null:n.training,a=n==null?null:n.initialState;return super.call(t,{mask:r,training:s,initialState:a})})}static fromConfig(t,n){return n.implmentation===0&&(n.implementation=1),new t(n)}}WU.className="GRU";Le(WU);class PI extends LI{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,is(this.units,"units"),this.activation=pu(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=pu(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=or(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=or(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=or(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=ur(t.kernelRegularizer),this.recurrentRegularizer=ur(t.recurrentRegularizer),this.biasRegularizer=ur(t.biasRegularizer),this.kernelConstraint=Kr(t.kernelConstraint),this.recurrentConstraint=Kr(t.recurrentConstraint),this.biasConstraint=Kr(t.biasConstraint),this.dropout=af([1,du([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=af([1,du([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var n;t=gn(t);const r=t[t.length-1];this.kernel=this.addWeight("kernel",[r,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let s;if(this.useBias){if(this.unitForgetBias){const a=this.biasInitializer,i=this.units;s=new(n=class extends yi{apply(u,c){const l=a.apply([i]),d=new zA().apply([i]),h=a.apply([i*2]);return vD(vD(l,d),h)}},n.className="CustomInit",n)}else s=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,s,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,n){return we(()=>{const r=n.training==null?!1:n.training;if(t=t,t.length!==3)throw new le(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let s=t[1];const a=t[2];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=fu({ones:()=>fi(t),rate:this.dropout,training:r,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=fu({ones:()=>fi(s),rate:this.recurrentDropout,training:r,count:4,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,o=this.recurrentDropoutMask;let u,c,l,d;0<this.dropout&&this.dropout<1&&(t=ce(t,i[0]));let h=So(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(s=ce(s,o[0])),h=We(h,So(s,this.recurrentKernel.read())),this.useBias&&(h=no(h,this.bias.read()));const[p,f,m,g]=Ua(h,4,h.rank-1);u=this.recurrentActivation.apply(p),c=this.recurrentActivation.apply(f),l=We(ce(c,a),ce(u,this.activation.apply(m))),d=this.recurrentActivation.apply(g);const b=ce(d,this.activation.apply(l));return[b,b,l]})}getConfig(){const t=super.getConfig(),n={units:this.units,activation:hu(this.activation),recurrentActivation:hu(this.recurrentActivation),useBias:this.useBias,kernelInitializer:pr(this.kernelInitializer),recurrentInitializer:pr(this.recurrentInitializer),biasInitializer:pr(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Hn(this.kernelRegularizer),recurrentRegularizer:Hn(this.recurrentRegularizer),biasRegularizer:Hn(this.biasRegularizer),activityRegularizer:Hn(this.activityRegularizer),kernelConstraint:qr(this.kernelConstraint),recurrentConstraint:qr(this.recurrentConstraint),biasConstraint:qr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},t),n)}}PI.className="LSTMCell";Le(PI);class VU extends zu{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new PI(t),super(t)}call(t,n){return we(()=>{this.cell.dropoutMask!=null&&(tn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(tn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const r=n==null?null:n.mask,s=n==null?null:n.training,a=n==null?null:n.initialState;return super.call(t,{mask:r,training:s,initialState:a})})}static fromConfig(t,n){return n.implmentation===0&&(n.implementation=1),new t(n)}}VU.className="LSTM";Le(VU);class t$ extends LI{constructor(t){super(t),this.cells=t.cells}get stateSize(){const t=[];for(const n of this.cells.slice().reverse())Array.isArray(n.stateSize)?t.push(...n.stateSize):t.push(n.stateSize);return t}call(t,n){return we(()=>{t=t;let r=t.slice(1);const s=[];for(const o of this.cells.slice().reverse())Array.isArray(o.stateSize)?s.push(r.splice(0,o.stateSize.length)):s.push(r.splice(0,1));s.reverse();const a=[];let i;for(let o=0;o<this.cells.length;++o){const u=this.cells[o];r=s[o],o===0?i=[t[0]].concat(r):i=[i[0]].concat(r),i=u.call(i,n),a.push(i.slice(1))}r=[];for(const o of a.slice().reverse())r.push(...o);return[i[0]].concat(r)})}build(t){xS(t)&&(t=t[0]),t=t;let n;this.cells.forEach((r,s)=>{Fc(`RNNCell_${s}`,()=>{r.build(t),Array.isArray(r.stateSize)?n=r.stateSize[0]:n=r.stateSize,t=[t[0],n]})}),this.built=!0}getConfig(){const t=super.getConfig(),n=a=>({className:a.getClassName(),config:a.getConfig()}),s={cells:this.cells.map(n)};return Object.assign(Object.assign({},t),s)}static fromConfig(t,n,r={}){const s=[];for(const a of n.cells)s.push(al(a,r));return new t({cells:s})}get trainableWeights(){if(!this.trainable)return[];const t=[];for(const n of this.cells)t.push(...n.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const n of this.cells)t.push(...n.nonTrainableWeights);if(!this.trainable){const n=[];for(const r of this.cells)n.push(...r.trainableWeights);return n.concat(t)}return t}getWeights(){const t=[];for(const n of this.cells)t.push(...n.weights);return wS(t)}setWeights(t){const n=[];for(const r of this.cells){const s=r.weights.length,a=t.splice(s);for(let i=0;i<r.weights.length;++i)n.push([r.weights[i],a[i]])}qA(n)}}t$.className="StackedRNNCells";Le(t$);function fu(e){const{ones:t,rate:n,training:r=!1,count:s=1,dropoutFunc:a}=e,i=()=>a!=null?a(t(),n):DV(t(),n),o=()=>Y1(i,t,r);return!s||s<=1?ko(o().clone()):Array(s).fill(void 0).map(o).map(c=>ko(c.clone()))}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var rBe=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(e!=null&&typeof Object.getOwnPropertySymbols=="function")for(var s=0,r=Object.getOwnPropertySymbols(e);s<r.length;s++)t.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(e,r[s])&&(n[r[s]]=e[r[s]]);return n};class UU extends zu{constructor(t){if(t.unroll)throw new qt("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new qt("It is not possible at the moment to stack convolutional cells.");super(t),this.inputSpec=[new Ur({ndim:5})]}call(t,n){return we(()=>{if(this.cell.dropoutMask!=null&&(tn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(tn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),n&&n.constants)throw new le("ConvRNN2D cell does not support constants");const r=n==null?null:n.mask,s=n==null?null:n.training,a=n==null?null:n.initialState;return super.call(t,{mask:r,training:s,initialState:a})})}computeOutputShape(t){let n=this.computeSingleOutputShape(t);return this.returnSequences||(n=[n[0],...n.slice(2)]),this.returnState&&(n=[n,...Array(2).fill([t[0],...n.slice(-3)])]),n}getInitialState(t){return we(()=>{const{stateSize:n}=this.cell,r=t.shape,s=this.computeSingleOutputShape(r),a=[s[0],...s.slice(2)],i=ss(a);return Array.isArray(n)?Array(n.length).fill(i):[i]})}resetStates(t,n=!1){we(()=>{if(!this.stateful)throw new po("Cannot call resetStates() on an RNN Layer that is not stateful.");const r=this.inputSpec[0].shape,s=this.computeSingleOutputShape(r),a=[s[0],...s.slice(2)];if(r[0]==null)throw new le("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>ss(a)):this.states_=[ss(a)];else if(t==null)tn(this.states_),this.keptStates!=null&&(tn(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>ss(a)):this.states_[0]=ss(a);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new le(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);n?this.keptStates.push(this.states_.slice()):tn(this.states_);for(let o=0;o<this.states_.length;++o){const u=t[o],c=a;if(!Nn(u.shape,c))throw new le(`State ${o} is incompatible with layer ${this.name}: expected shape=${c}, received shape=${u.shape}`);this.states_[o]=u}}this.states_=this.states_.map(o=>ko(o.clone()))})}computeSingleOutputShape(t){const{dataFormat:n,filters:r,kernelSize:s,padding:a,strides:i,dilationRate:o}=this.cell,u=n==="channelsFirst",c=t[u?3:2],l=t[u?4:3],d=Gi(c,s[0],a,i[0],o[0]),h=Gi(l,s[1],a,i[1],o[1]);return[...t.slice(0,2),...u?[r,d,h]:[d,h,r]]}}UU.className="ConvRNN2D";class n$ extends PI{constructor(t){const{filters:n,kernelSize:r,strides:s,padding:a,dataFormat:i,dilationRate:o}=t;super(Object.assign(Object.assign({},t),{units:n})),this.filters=n,is(this.filters,"filters"),this.kernelSize=_p(r,2,"kernelSize"),this.kernelSize.forEach(u=>is(u,"kernelSize")),this.strides=_p(s||1,2,"strides"),this.strides.forEach(u=>is(u,"strides")),this.padding=a||"valid",Ja(this.padding),this.dataFormat=i||"channelsLast",Sr(this.dataFormat),this.dilationRate=_p(o||1,2,"dilationRate"),this.dilationRate.forEach(u=>is(u,"dilationRate"))}build(t){var n;t=gn(t);const r=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[r]==null)throw new le(`The channel dimension of the input should be defined. Found ${t[r]}`);const s=t[r],a=4,i=this.kernelSize.concat([s,this.filters*a]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const o=this.kernelSize.concat([this.filters,this.filters*a]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",o,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let u;if(this.unitForgetBias){const c=this.biasInitializer,l=this.filters;u=new(n=class extends yi{apply(h,p){const f=c.apply([l]),m=Pu([l]),g=c.apply([l*2]);return BA([f,m,g])}},n.className="CustomInit",n)}else u=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*a],null,u,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,n){return we(()=>{if(t.length!==3)throw new le(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);const r=n.training||!1,s=t[0],a=t[1],i=t[2],o=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=fu({ones:()=>fi(s),rate:this.dropout,training:r,count:o,dropoutFunc:this.dropoutFunc}));const u=this.dropoutMask,c=(Q,K,ee)=>!K||!K[ee]?Q:ce(K[ee],Q);let l=c(s,u,0),d=c(s,u,1),h=c(s,u,2),p=c(s,u,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=fu({ones:()=>fi(a),rate:this.recurrentDropout,training:r,count:o,dropoutFunc:this.dropoutFunc}));const f=this.recurrentDropoutMask;let m=c(a,f,0),g=c(a,f,1),b=c(a,f,2),y=c(a,f,3);const x=3,[w,v,I,N]=Ua(this.kernel.read(),o,x),[T,E,A,k]=this.useBias?Ua(this.bias.read(),o):[null,null,null,null];l=this.inputConv(l,w,T,this.padding),d=this.inputConv(d,v,E,this.padding),h=this.inputConv(h,I,A,this.padding),p=this.inputConv(p,N,k,this.padding);const[C,M,L,O]=Ua(this.recurrentKernel.read(),o,x);m=this.recurrentConv(m,C),g=this.recurrentConv(g,M),b=this.recurrentConv(b,L),y=this.recurrentConv(y,O);const B=this.recurrentActivation.apply(We(l,m)),G=this.recurrentActivation.apply(We(d,g)),z=We(ce(G,i),ce(B,this.activation.apply(We(h,b)))),q=ce(this.recurrentActivation.apply(We(p,y)),this.activation.apply(z));return[q,q,z]})}getConfig(){const t=super.getConfig(),{units:n}=t,r=rBe(t,["units"]),s={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},r),s)}inputConv(t,n,r,s){const a=ld(t,n,this.strides,s||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return r?no(a,r,this.dataFormat):a}recurrentConv(t,n){return ld(t,n,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}n$.className="ConvLSTM2DCell";Le(n$);class GU extends UU{constructor(t){const n=new n$(t);super(Object.assign(Object.assign({},t),{cell:n}))}static fromConfig(t,n){return new t(n)}}GU.className="ConvLSTM2D";Le(GU);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class r$ extends Jt{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(this.noiseShape==null)return this.noiseShape;const n=t.shape,r=[];for(let s=0;s<this.noiseShape.length;++s)r.push(this.noiseShape[s]==null?n[s]:this.noiseShape[s]);return r}call(t,n){return we(()=>{this.invokeCallHook(t,n);const r=Mt(t);if(0<this.rate&&this.rate<1){const s=n.training==null?!1:n.training,a=this.getNoiseShape(r);return Y1(()=>DV(r,this.rate,a,this.seed),()=>r,s)}return t})}getConfig(){const t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},n=super.getConfig();return Object.assign(t,n),t}dispose(){return super.dispose()}}r$.className="Dropout";Le(r$);class HU extends r${constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){const n=t.shape;return[n[0],1,n[2]]}}HU.className="SpatialDropout1D";Le(HU);class jU extends Jt{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.batchInputShape==null&&t.inputShape==null&&t.inputDim!=null){let n=null;t.batchSize!=null&&(n=t.batchSize),this.batchInputShape=[n,t.inputDim]}this.units=t.units,is(this.units,"units"),this.activation=pu(t.activation),t.useBias!=null&&(this.useBias=t.useBias),this.kernelInitializer=or(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=or(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Kr(t.kernelConstraint),this.biasConstraint=Kr(t.biasConstraint),this.kernelRegularizer=ur(t.kernelRegularizer),this.biasRegularizer=ur(t.biasRegularizer),this.activityRegularizer=ur(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){t=gn(t);const n=t[t.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[n,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:n}}],this.built=!0}computeOutputShape(t){t=gn(t);const n=t.slice();return n[n.length-1]=this.units,n}call(t,n){return we(()=>{this.invokeCallHook(t,n);const r=Mt(t),s=NV(this.activation.getClassName());let a;return s!=null?a=So(r,this.kernel.read(),s,this.bias?this.bias.read():null):(a=So(r,this.kernel.read()),this.bias!=null&&(a=no(a,this.bias.read())),this.activation!=null&&(a=this.activation.apply(a))),a})}getConfig(){const t={units:this.units,activation:hu(this.activation),useBias:this.useBias,kernelInitializer:pr(this.kernelInitializer),biasInitializer:pr(this.biasInitializer),kernelRegularizer:Hn(this.kernelRegularizer),biasRegularizer:Hn(this.biasRegularizer),activityRegularizer:Hn(this.activityRegularizer),kernelConstraint:qr(this.kernelConstraint),biasConstraint:qr(this.biasConstraint)},n=super.getConfig();return Object.assign(t,n),t}}jU.className="Dense";Le(jU);class qU extends Jt{constructor(t){t=t||{},super(t),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=gn(t);for(const n of t.slice(1))if(n==null)throw new le(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],Kl(t,1)]}call(t,n){return we(()=>{this.invokeCallHook(t,n);let r=Mt(t);if(this.dataFormat==="channelsFirst"&&r.rank>1){const s=[0];for(let a=2;a<r.rank;++a)s.push(a);s.push(1),r=un(r,s)}return LLe(r)})}getConfig(){const t={};this.dataFormat!=null&&(t.dataFormat=this.dataFormat);const n=super.getConfig();return Object.assign(t,n),t}}qU.className="Flatten";Le(qU);class KU extends Jt{constructor(t){super(t),this.supportsMasking=!0,this.activation=pu(t.activation)}call(t,n){return we(()=>{this.invokeCallHook(t,n);const r=Mt(t);return this.activation.apply(r)})}getConfig(){const t={activation:hu(this.activation)},n=super.getConfig();return Object.assign(t,n),t}}KU.className="Activation";Le(KU);class XU extends Jt{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,n){return we(()=>(t=Mt(t),MLe(t,this.n)))}getConfig(){const t={n:this.n},n=super.getConfig();return Object.assign(t,n),t}}XU.className="RepeatVector";Le(XU);class QU extends Jt{constructor(t){super(t),this.targetShape=t.targetShape;for(let n=0;n<this.targetShape.length;++n)this.isUnknown(this.targetShape[n])&&(this.targetShape[n]=null)}isUnknown(t){return t<0||t==null}fixUnknownDimension(t,n){const r="Total size of new array must be unchanged.",s=n.slice();let a=1,i=null;for(let u=0;u<s.length;++u){const c=s[u];if(this.isUnknown(c))if(i===null)i=u;else throw new le("Can only specifiy one unknown dimension.");else a*=c}const o=Kl(t);if(i!==null){if(a===0||o%a!==0)throw new le(r);s[i]=o/a}else if(o!==a)throw new le(r);return s}computeOutputShape(t){let n=!1;for(let r=0;r<t.length;++r)if(this.isUnknown(t[r])){n=!0;break}return n?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,n){return we(()=>{this.invokeCallHook(t,n);const r=Mt(t),s=r.shape,a=s.slice(0,1).concat(this.fixUnknownDimension(s.slice(1),this.targetShape));return be(r,a)})}getConfig(){const t={targetShape:this.targetShape},n=super.getConfig();return Object.assign(t,n),t}}QU.className="Reshape";Le(QU);class YU extends Jt{constructor(t){if(super(t),t.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);const n=Xi(1,t.dims.length+1);if(!Nn(t.dims.slice().sort(),n))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Ur({ndim:this.dims.length+1})]}computeOutputShape(t){t=gn(t);const n=t.slice();return this.dims.forEach((r,s)=>{n[s+1]=t[r]}),n}call(t,n){return un(Mt(t),this.dimsIncludingBatch)}getConfig(){const t={dims:this.dims},n=super.getConfig();return Object.assign(t,n),t}}YU.className="Permute";Le(YU);class JU extends Jt{constructor(t){super(t??{}),this.supportsMasking=!0,t!=null?this.maskValue=t.maskValue==null?0:t.maskValue:this.maskValue=0}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),n={maskValue:this.maskValue};return Object.assign(n,t),n}computeMask(t,n){const r=Mt(t);return dS(Bx(r,this.maskValue),-1)}call(t,n){return we(()=>{this.invokeCallHook(t,n);const r=Mt(t),i=dS(Bx(r,this.maskValue),-1,!0);return ce(r,at(i,r.dtype))})}}JU.className="Masking";Le(JU);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class ZU extends Jt{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",t.batchInputShape==null&&t.inputShape==null){let n=null;t.batchSize!=null&&(n=t.batchSize),t.inputLength==null?this.batchInputShape=[n,null]:this.batchInputShape=[n].concat($n(t.inputLength))}this.inputDim=t.inputDim,is(this.inputDim,"inputDim"),this.outputDim=t.outputDim,is(this.outputDim,"outputDim"),this.embeddingsInitializer=or(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=ur(t.embeddingsRegularizer),this.activityRegularizer=ur(t.activityRegularizer),this.embeddingsConstraint=Kr(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,n){return we(()=>this.maskZero?(t=Mt(t),Bx(t,cn(t))):null)}computeOutputShape(t){if(t=gn(t),this.inputLength==null)return[...t,this.outputDim];const n=$n(this.inputLength);if(n.length!==t.length-1)throw new le(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);{let r=0;for(let s=0;s<n.length;++s){const a=n[s],i=t[s+1];if(a!=null&&i!=null&&a!==i)throw new le(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);a==null&&(n[r]=i),r++}}return[t[0],...n,this.outputDim]}call(t,n){return we(()=>{this.invokeCallHook(t,n);let r=Mt(t);r.dtype!=="int32"&&(r=Co(r,"int32"));const s=_V(this.embeddings.read(),be(r,[r.size]));return be(s,gn(this.computeOutputShape(r.shape)))})}getConfig(){const t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:pr(this.embeddingsInitializer),embeddingsRegularizer:Hn(this.embeddingsRegularizer),activityRegularizer:Hn(this.activityRegularizer),embeddingsConstraint:qr(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},n=super.getConfig();return Object.assign(t,n),t}}ZU.className="Embedding";Le(ZU);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class ip extends Jt{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new qt}computeElementwiseOpOutputShape(t,n){if(t==null||n==null)return null;if(t.length<n.length)return this.computeElementwiseOpOutputShape(n,t);if(n.length===0)return t;const r=t.slice(0,t.length-n.length);for(let s=0;s<n.length;++s){const a=t[t.length-n.length+s],i=n[s];if(a==null||i==null||a<0||i<0)r.push(null);else if(a===1)r.push(i);else if(i===1)r.push(a);else{if(a!==i)throw new le("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(n));r.push(a)}}return r}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[gn(t)]),t=t,t.length<2)throw new le(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let n=[];for(const a of t)a!=null&&a[0]!==null&&n.push(a[0]);if(n=ql(n),n.length>1)throw new le(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let r=t[0]==null?null:t[0].slice(1);for(let a=1;a<t.length;++a){const i=t[a]==null?null:t[a].slice(1);r=this.computeElementwiseOpOutputShape(r,i)}const s=t.map(a=>a.length);t.indexOf(null)===-1&&ql(s).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(t,n){return we(()=>{if(t=t,this.reshapeRequired){const r=[],s=t.map(a=>a.rank);if(s.indexOf(null)===-1){const a=du(s);for(let i of t){const o=i.rank;for(let u=0;u<a-o;++u)i=X1(i,1);r.push(i)}return this.mergeFunction(r)}else{let a=!1;for(const u of t){const c=u.rank;if(c==null){const l=u.shape,d=l[0],h=l.slice(1).concat([d]);let p=be(u,[d].concat(Kl(l.slice(1))));p=un(p,[1,0]),p=be(p,h),r.push(p),a=!0}else if(c>1){const l=Xi(1,c).concat([0]);r.push(un(u,l)),a=!0}else r.push(u)}let i=this.mergeFunction(r);const o=i.rank;if(a){if(o==null){const u=i.shape,c=u.length,l=u[c-1],d=[l].concat(u.slice(0,u.length-1));i=be(un(be(i,[-1,l]),[1,0]),d)}else if(o>1){const u=[o-1].concat(Xi(0,o-1));i=un(i,u)}}return i}}else return this.mergeFunction(t)})}computeOutputShape(t){t=t;let n;t[0]==null?n=null:n=t[0].slice(1);for(let s=1;s<t.length;++s){const a=t[s]==null?null:t[s].slice(1);n=this.computeElementwiseOpOutputShape(n,a)}let r=[];for(const s of t)s!=null&&s[0]!==null&&r.push(s[0]);return r=ql(r),r.length===1?n=r.concat(n):n=[null].concat(n),n}computeMask(t,n){return we(()=>{if(n==null)return null;if(!Array.isArray(n))throw new le("`mask` should be an Array");if(!Array.isArray(t))throw new le("`inputs` should be an Array");if(n.length!==t.length)throw new le(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${n.length})`);if(n.every(s=>s==null))return null;n=n.map(s=>s==null?s:ta(s,0));let r=n[0];for(let s=1;s<n.length-1;++s)r=ll(r,n[s]);return r})}}class eG extends ip{constructor(t){super(t)}mergeFunction(t){return we(()=>{let n=t[0].clone();for(let r=1;r<t.length;++r)n=We(n,t[r]);return n})}}eG.className="Add";Le(eG);class tG extends ip{constructor(t){super(t)}mergeFunction(t){return we(()=>{let n=t[0].clone();for(let r=1;r<t.length;++r)n=ce(n,t[r]);return n})}}tG.className="Multiply";Le(tG);class nG extends ip{constructor(t){super(t)}mergeFunction(t){return we(()=>{let n=t[0].clone();for(let r=1;r<t.length;++r)n=We(n,t[r]);return ce(1/t.length,n)})}}nG.className="Average";Le(nG);class rG extends ip{constructor(t){super(t)}mergeFunction(t){return we(()=>{let n=t[0];for(let r=1;r<t.length;++r)n=Lu(n,t[r]);return n})}}rG.className="Maximum";Le(rG);class sG extends ip{constructor(t){super(t)}mergeFunction(t){return we(()=>{let n=t[0];for(let r=1;r<t.length;++r)n=$y(n,t[r]);return n})}}sG.className="Minimum";Le(sG);class aG extends ip{constructor(t){super(t),this.DEFAULT_AXIS=-1,t==null&&(t={}),this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!(Array.isArray(t)&&Array.isArray(t[0]))||t.length===1)throw new le("A `Concatenate` layer should be called on a list of at least 2 inputs");t=t;let n=!0;for(const s of t)if(s!=null){n=!1;break}if(n)return;const r=[];for(let s=0;s<t.length;++s){const a=t[s].slice();a.splice(this.axis,1);let i=!1;for(const o of r)if(Nn(o,a)){i=!0;break}i||r.push(a)}if(r.length>1)throw new le("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return we(()=>BA(t,this.axis))}computeOutputShape(t){if(!(Array.isArray(t)&&Array.isArray(t[0])))throw new le("A `Concatenate` layer should be called on a list of inputs.");const n=t,r=n[0].slice(),s=this.axis<0?r.length+this.axis:this.axis;for(const a of n.slice(1)){if(r[s]==null||a[s]==null){r[s]=null;break}r[s]+=a[s]}return r}computeMask(t,n){if(n==null)return null;if(!Array.isArray(n))throw new le("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new le("`inputs` should be an array for Concatenate");if(n.length!==t.length)throw new le(`Mismatch in the length of mask (${n.length}) and the legnth of inputs (${t.length})`);return we(()=>{let r=!0;if(n.forEach(i=>{if(i!=null){r=!1;return}}),r)return null;const s=[];for(let i=0;i<t.length;++i)n[i]==null?s.push(at(fi(t[i]),"bool")):n[i].rank<t[i].rank?s.push(ta(n[i],-1)):s.push(n[i]);const a=ia(s,this.axis);return yW(a,-1,!1)})}getConfig(){const t={axis:this.axis},n=super.getConfig();return Object.assign(t,n),t}}aG.className="Concatenate";Le(aG);function Fb(e,t){for(;e<0;)e+=t;return e}function sBe(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new qt("batchDot is not implemented for tensors of 4D or higher rank yet");if(U(e.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`),U(e.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof n=="number"&&(n=[n,n]),e.dtype==="complex64"||t.dtype==="complex64")throw new qt("batchDot is not implemented for complex64-type Tensors yet.");const r=e.shape.length,s=t.shape.length;n==null&&(n=[r-1,s-2]);const a=n;return we(()=>{let i;if(r>s){i=r-s;const u=[];for(let c=0;c<i;++c)u.push(1);t=be(t,t.shape.concat(u))}else if(s>r){i=s-r;const u=[];for(let c=0;c<i;++c)u.push(1);e=be(e,e.shape.concat(u))}else i=0;let o;if(e.shape.length===2&&t.shape.length===2)a[0]===a[1]?o=Ct(ce(e,t),a[0]):o=Ct(ce(un(e,[1,0]),t),a[1]);else{const u=a[0]!==e.shape.length-1,c=a[1]===t.shape.length-1;o=Cn(e,t,u,c)}if(i>0){let u;r>s?u=r+s-3:u=r-1;const c=[];for(let l=u;l<u+i;++l)c.push(l);o=H1(o,c)}return o.shape.length===1&&(o=ta(o,1)),o})}class iG extends ip{constructor(t){super(t),this.axes=t.axes,this.normalize=t.normalize==null?!1:t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){U(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const n=t[0],r=t[1];if(n.length>3||r.length>3)throw new qt("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(n,r);if(n[s[0]]!==r[s[1]])throw new le(`Dimension incompatibility: ${n[s[0]]} !== ${r[s[1]]}`)}mergeFunction(t){if(t.length!==2)throw new le(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let n=t[0],r=t[1],s;return Array.isArray(this.axes)?s=this.axes.map((a,i)=>Fb(a,t[i].shape.length)):s=[Fb(this.axes,n.shape.length),Fb(this.axes,r.shape.length)],this.normalize&&(n=jx(n,s[0]),r=jx(r,s[1])),sBe(n,r,s)}interpretAxes(t,n){let r;return Array.isArray(this.axes)?r=this.axes:r=[Fb(this.axes,t.length),Fb(this.axes,n.length)],r}computeOutputShape(t){U(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const n=t[0].slice(),r=t[1].slice();if(n.length>3||r.length>3)throw new qt("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(n,r);n.splice(s[0],1),r.splice(s[1],1),r.splice(0,1);const a=n.concat(r);return a.length===1&&a.push(1),a}computeMask(t,n){return null}getConfig(){const t={axes:this.axes,normalize:this.normalize},n=super.getConfig();return Object.assign(t,n),t}}iG.className="Dot";Le(iG);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class oG extends Jt{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),n={stddev:this.stddev};return Object.assign(n,t),n}call(t,n){return we(()=>{this.invokeCallHook(t,n);const r=Mt(t);return Y1(()=>We(RI(r.shape,0,this.stddev),r),()=>r,n.training||!1)})}}oG.className="GaussianNoise";Le(oG);class lG extends Jt{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),n={rate:this.rate};return Object.assign(n,t),n}call(t,n){return we(()=>{this.invokeCallHook(t,n);const r=Mt(t);return this.rate>0&&this.rate<1?Y1(()=>{const a=Math.sqrt(this.rate/(1-this.rate));return ce(r,RI(r.shape,1,a))},()=>r,n.training||!1):r})}}lG.className="GaussianDropout";Le(lG);class uG extends Jt{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||Mt(t).shape}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),n={rate:this.rate};return Object.assign(n,t),n}call(t,n){return we(()=>{if(this.rate<1&&this.rate>0){const r=this._getNoiseShape(t);return Y1(()=>{const a=Mt(t),o=-1.6732632423543772*1.0507009873554805;let u=ep(G1(r),this.rate);u=Co(u,"float32");const c=((1-this.rate)*(1+this.rate*o**2))**-.5,l=-c*o*this.rate,d=We(ce(a,u),ce(We(u,-1),o));return We(ce(d,c),l)},()=>Mt(t),n.training||!1)}return t})}}uG.className="AlphaDropout";Le(uG);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Oy(e,t,n,r,s,a=.001){let i;if(e.rank===2)i=BFe(e,t,n,r,s,a);else if(e.rank===3)i=WFe(e,t,n,r,s,a);else if(e.rank===4)i=UFe(e,t,n,r,s,a);else throw new qt(`batchNormalization is not implemented for array of rank ${e.rank} yet`);return i}function aBe(e,t,n,r,s=.001){return we(()=>{const a=jE(e,r),i=a.mean,o=a.variance;return[Oy(e,i,o,n,t,s),i,o]})}function iBe(e,t,n,r,s=.001){return we(()=>{const a=jE(e,r),i=a.mean,o=a.variance,u=[];for(const f of Xi(0,e.rank))r.indexOf(f)!==-1?u.push(1):u.push(e.shape[f]);const c=be(i,u),l=be(o,u),d=t==null?null:be(t,u),h=n==null?null:be(n,u);return[Oy(e,c,l,h,d,s),i,o]})}function oBe(e,t,n,r,s=.001){return Nn(r.slice().sort(),Xi(0,e.rank-1))?aBe(e,t,n,r,s):iBe(e,t,n,r,s)}class cG extends Jt{constructor(t){t==null&&(t={}),super(t),this.supportsMasking=!0,this.axis=t.axis==null?-1:t.axis,this.momentum=t.momentum==null?.99:t.momentum,this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=or(t.betaInitializer||"zeros"),this.gammaInitializer=or(t.gammaInitializer||"ones"),this.movingMeanInitializer=or(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=or(t.movingVarianceInitializer||"ones"),this.betaConstraint=Kr(t.betaConstraint),this.gammaConstraint=Kr(t.gammaConstraint),this.betaRegularizer=ur(t.betaRegularizer),this.gammaRegularizer=ur(t.gammaRegularizer)}build(t){t=gn(t);const n=this.axis>=0?this.axis:this.axis+t.length,r=t[n];if(r==null)throw new le(`Axis ${n} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);this.inputSpec=[new Ur({ndim:t.length,axes:{[n]:r}})];const s=[r];this.scale&&(this.gamma=this.addWeight("gamma",s,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",s,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",s,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",s,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,n){return we(()=>{const r=n.training==null?!1:n.training,s=Mt(t),a=s.shape,i=a.length,o=Xi(0,i),u=this.axis>=0?this.axis:this.axis+i;o.splice(u,1);const c=hd(1,i);c[u]=a[u];const l=o.slice();l.sort();const d=!Nn(l,Xi(0,i).slice(0,i-1)),h=()=>{if(d){const y=be(this.movingMean.read(),c),x=be(this.movingVariance.read(),c),w=this.center?be(this.beta.read(),c):null,v=this.scale?be(this.gamma.read(),c):null;return Oy(s,y,x,w,v,this.epsilon)}else return Oy(s,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!r)return h();const[p,f,m]=oBe(s,this.gamma.read(),this.beta.read(),o,this.epsilon),g=(y,x,w)=>{we(()=>{const v=1-w,I=y.read(),N=ce(_t(I,x),v);y.write(_t(I,N))})};return(()=>{g(this.movingMean,f,this.momentum),g(this.movingVariance,m,this.momentum)})(),p})}getConfig(){const t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:pr(this.betaInitializer),gammaInitializer:pr(this.gammaInitializer),movingMeanInitializer:pr(this.movingMeanInitializer),movingVarianceInitializer:pr(this.movingVarianceInitializer),betaRegularizer:Hn(this.betaRegularizer),gammaRegularizer:Hn(this.gammaRegularizer),betaConstraint:qr(this.betaConstraint),gammaConstraint:qr(this.gammaConstraint)},n=super.getConfig();return Object.assign(t,n),t}}cG.className="BatchNormalization";Le(cG);class dG extends Jt{constructor(t){if(t==null&&(t={}),super(t),this.axis=t.axis==null?-1:t.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const n of this.axis)if(!Number.isInteger(n))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=or(t.betaInitializer||"zeros"),this.gammaInitializer=or(t.gammaInitializer||"ones"),this.betaRegularizer=ur(t.betaRegularizer),this.gammaRegularizer=ur(t.gammaRegularizer),this.supportsMasking=!0}build(t){t=gn(t);const n=t.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let a=0;a<this.axis.length;++a)this.axis[a]<0&&(this.axis[a]+=n);for(const a of this.axis)if(a<0||a>=n)throw new Error(`Invalid axis: ${a}`);if(this.axis.length!==ql(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const r=this.axis.map(a=>t[a]),s=!0;this.scale?this.gamma=this.addWeight("gamma",r,"float32",this.gammaInitializer,this.gammaRegularizer,s):this.gamma=null,this.center?this.beta=this.addWeight("beta",r,"float32",this.betaInitializer,this.betaRegularizer,s):this.beta=null,this.built=!0}call(t,n){const r=Mt(t),s=r.shape,a=s.length;return we(()=>{let{mean:o,variance:u}=jE(r,this.axis,!0);const c=hd(1,a);for(const m of this.axis)c[m]=s[m];const l=m=>m!=null&&m.shape.length!==a?be(m,c):m;let d=this.scale?l(this.gamma.read()):null,h=this.center?l(this.beta.read()):null;const p=[],f=[];for(let m=0;m<a;++m)this.axis.indexOf(m)!==-1?(p.push(s[m]),f.push(1)):(p.push(1),f.push(s[m]));return o=Pi(o,p),u=Pi(u,p),d!=null&&(d=Pi(d,f)),h!=null&&(h=Pi(h,f)),Oy(r,o,u,h,d,this.epsilon)})}getConfig(){const t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:pr(this.betaInitializer),gammaInitializer:pr(this.gammaInitializer),betaRegularizer:Hn(this.betaRegularizer),gammaRegularizer:Hn(this.gammaRegularizer)},n=super.getConfig();return Object.assign(t,n),t}}dG.className="LayerNormalization";Le(dG);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function lBe(e,t,n){return we(()=>{if(e.rank!==4)throw new le(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new le("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(n==null&&(n=Qi()),n!=="channelsLast"&&n!=="channelsFirst")throw new le(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return n==="channelsFirst"?r=[[0,0],[0,0],t[0],t[1]]:r=[[0,0],t[0],t[1],[0,0]],qE(e,r)})}class hG extends Jt{constructor(t){if(t==null&&(t={}),super(t),this.dataFormat=t.dataFormat==null?Qi():t.dataFormat,t.padding==null)this.padding=[[1,1],[1,1]];else if(typeof t.padding=="number")this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,t.padding.length!==2)throw new le(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);let n,r;if(typeof t.padding[0]=="number")n=[t.padding[0],t.padding[0]],r=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,t.padding[0].length!==2)throw new le(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);if(n=t.padding[0],t.padding[1].length!==2)throw new le(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);r=t.padding[1]}this.padding=[n,r]}this.inputSpec=[new Ur({ndim:4})]}computeOutputShape(t){t=gn(t);let n,r;return this.dataFormat==="channelsFirst"?(t[2]!=null&&t[2]>=0?n=t[2]+this.padding[0][0]+this.padding[0][1]:n=null,t[3]!=null&&t[3]>=0?r=t[3]+this.padding[1][0]+this.padding[1][1]:r=null,[t[0],t[1],n,r]):(t[1]!=null&&t[1]>=0?n=t[1]+this.padding[0][0]+this.padding[0][1]:n=null,t[2]!=null&&t[2]>=0?r=t[2]+this.padding[1][0]+this.padding[1][1]:r=null,[t[0],n,r,t[3]])}call(t,n){return we(()=>lBe(Mt(t),this.padding,this.dataFormat))}getConfig(){const t={padding:this.padding,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(t,n),t}}hG.className="ZeroPadding2D";Le(hG);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function BI(e,t,n,r,s,a){return we(()=>{Sr(s),EV(a),Ja(r),n==null&&(n=[1,1]),r==null&&(r="valid"),s==null&&(s=Qi()),a==null&&(a="max"),e=JA(e,s);let i;const o=r==="same"?"same":"valid";return a==="max"?i=HE(e,t,n,o):i=ME(e,t,n,o),s==="channelsFirst"&&(i=un(i,[0,3,1,2])),i})}function pG(e,t,n,r,s,a){return we(()=>{Sr(s),EV(a),Ja(r),n==null&&(n=[1,1,1]),r==null&&(r="valid"),s==null&&(s=Qi()),a==null&&(a="max"),e=$U(e,s);let i;const o=r==="same"?"same":"valid";return a==="max"?i=T5e(e,t,n,o):i=AFe(e,t,n,o),s==="channelsFirst"&&(i=un(i,[0,4,1,2,3])),i})}class fG extends Jt{constructor(t){if(t.poolSize==null&&(t.poolSize=2),super(t),typeof t.poolSize=="number")this.poolSize=[t.poolSize];else if(Array.isArray(t.poolSize)&&t.poolSize.length===1&&typeof t.poolSize[0]=="number")this.poolSize=t.poolSize;else throw new le(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);if(is(this.poolSize,"poolSize"),t.strides==null)this.strides=this.poolSize;else if(typeof t.strides=="number")this.strides=[t.strides];else if(Array.isArray(t.strides)&&t.strides.length===1&&typeof t.strides[0]=="number")this.strides=t.strides;else throw new le(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);is(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,Ja(this.padding),this.inputSpec=[new Ur({ndim:3})]}computeOutputShape(t){t=gn(t);const n=Gi(t[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],n,t[2]]}call(t,n){return we(()=>{this.invokeCallHook(t,n),t=X1(Mt(t),2);const r=this.poolingFunction(Mt(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return H1(r,[2])})}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},n=super.getConfig();return Object.assign(t,n),t}}class mG extends fG{constructor(t){super(t)}poolingFunction(t,n,r,s,a){return Sr(a),Ja(s),BI(t,n,r,s,a,"max")}}mG.className="MaxPooling1D";Le(mG);class gG extends fG{constructor(t){super(t)}poolingFunction(t,n,r,s,a){return Sr(a),Ja(s),BI(t,n,r,s,a,"avg")}}gG.className="AveragePooling1D";Le(gG);class bG extends Jt{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==2)throw new le(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];is(this.poolSize,"poolSize"),is(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Sr(this.dataFormat),Ja(this.padding),this.inputSpec=[new Ur({ndim:4})]}computeOutputShape(t){t=gn(t);let n=this.dataFormat==="channelsFirst"?t[2]:t[1],r=this.dataFormat==="channelsFirst"?t[3]:t[2];return n=Gi(n,this.poolSize[0],this.padding,this.strides[0]),r=Gi(r,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[t[0],t[1],n,r]:[t[0],n,r,t[3]]}call(t,n){return we(()=>(this.invokeCallHook(t,n),this.poolingFunction(Mt(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(t,n),t}}class yG extends bG{constructor(t){super(t)}poolingFunction(t,n,r,s,a){return Sr(a),Ja(s),BI(t,n,r,s,a,"max")}}yG.className="MaxPooling2D";Le(yG);class xG extends bG{constructor(t){super(t)}poolingFunction(t,n,r,s,a){return Sr(a),Ja(s),BI(t,n,r,s,a,"avg")}}xG.className="AveragePooling2D";Le(xG);class wG extends Jt{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==3)throw new le(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];is(this.poolSize,"poolSize"),is(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Sr(this.dataFormat),Ja(this.padding),this.inputSpec=[new Ur({ndim:5})]}computeOutputShape(t){t=gn(t);let n=this.dataFormat==="channelsFirst"?t[2]:t[1],r=this.dataFormat==="channelsFirst"?t[3]:t[2],s=this.dataFormat==="channelsFirst"?t[4]:t[3];return n=Gi(n,this.poolSize[0],this.padding,this.strides[0]),r=Gi(r,this.poolSize[1],this.padding,this.strides[1]),s=Gi(s,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[t[0],t[1],n,r,s]:[t[0],n,r,s,t[4]]}call(t,n){return we(()=>(this.invokeCallHook(t,n),this.poolingFunction(Mt(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(t,n),t}}class vG extends wG{constructor(t){super(t)}poolingFunction(t,n,r,s,a){return Sr(a),Ja(s),pG(t,n,r,s,a,"max")}}vG.className="MaxPooling3D";Le(vG);class IG extends wG{constructor(t){super(t)}poolingFunction(t,n,r,s,a){return Sr(a),Ja(s),pG(t,n,r,s,a,"avg")}}IG.className="AveragePooling3D";Le(IG);class kG extends Jt{constructor(t){super(t),this.inputSpec=[new Ur({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,n){throw new qt}}class CG extends kG{constructor(t){super(t||{})}call(t,n){return we(()=>{const r=Mt(t);return $r(r,1)})}}CG.className="GlobalAveragePooling1D";Le(CG);class SG extends kG{constructor(t){super(t||{})}call(t,n){return we(()=>{const r=Mt(t);return Ui(r,1)})}}SG.className="GlobalMaxPooling1D";Le(SG);class NG extends Jt{constructor(t){super(t),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Sr(this.dataFormat),this.inputSpec=[new Ur({ndim:4})]}computeOutputShape(t){return t=t,this.dataFormat==="channelsLast"?[t[0],t[3]]:[t[0],t[1]]}call(t,n){throw new qt}getConfig(){const t={dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(t,n),t}}class TG extends NG{call(t,n){return we(()=>{const r=Mt(t);return this.dataFormat==="channelsLast"?$r(r,[1,2]):$r(r,[2,3])})}}TG.className="GlobalAveragePooling2D";Le(TG);class EG extends NG{call(t,n){return we(()=>{const r=Mt(t);return this.dataFormat==="channelsLast"?Ui(r,[1,2]):Ui(r,[2,3])})}}EG.className="GlobalMaxPooling2D";Le(EG);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class AG extends Jt{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(t){this.layer!=null&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},n=super.getConfig();return Object.assign(t,n),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,n,r={}){const s=n.layer,a=al(s,r);delete n.layer;const i={layer:a};return Object.assign(i,n),new t(i)}}class $G extends AG{constructor(t){super(t),this.supportsMasking=!0}build(t){if(t=gn(t),t.length<3)throw new le(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);this.inputSpec=[{shape:t}];const n=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(n),this.layer.built=!0),super.build(t)}computeOutputShape(t){t=gn(t);const n=[t[0]].concat(t.slice(2)),r=this.layer.computeOutputShape(n),s=t[1];return[r[0],s].concat(r.slice(1))}call(t,n){return we(()=>(t=Mt(t),BU((i,o)=>[Mt(this.layer.call(i,n)),[]],t,[],!1,null,null,!1,!0)[1]))}}$G.className="TimeDistributed";Le($G);function uBe(e){ap($Le,"BidirectionalMergeMode",e)}const cBe="concat";class RG extends AG{constructor(t){super(t);const n=t.layer.getConfig(),r={};r.className=t.layer.getClassName(),r.config=n,this.forwardLayer=al(r),n.goBackwards=n.goBackwards!==!0;const s={};if(s.className=t.layer.getClassName(),s.config=n,this.backwardLayer=al(s),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=t.mergeMode===void 0?cBe:t.mergeMode,uBe(this.mergeMode),t.weights)throw new qt("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,this.forwardLayer!=null&&(this.forwardLayer.trainable=t),this.backwardLayer!=null&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){const n=t.length,r=Math.floor(n/2);this.forwardLayer.setWeights(t.slice(0,r)),this.backwardLayer.setWeights(t.slice(r))}computeOutputShape(t){let n=this.forwardLayer.computeOutputShape(t);Array.isArray(n)&&Array.isArray(n[0])||(n=[n]),n=n;let r,s,a;return this.returnState&&(a=n.slice(1)),r=n[0],r=r,this.mergeMode==="concat"?(r[r.length-1]*=2,s=[r]):this.mergeMode==null?s=[r,r.slice()]:s=[r],this.returnState?this.mergeMode==null?s.concat(a).concat(a.slice()):[r].concat(a).concat(a.slice()):na(s)}apply(t,n){let r=n==null?null:n.initialState,s=n==null?null:n.constants;n==null&&(n={});const a=PU(t,r,s,this.numConstants);if(t=a.inputs,r=a.initialState,s=a.constants,Array.isArray(t)&&(r=t.slice(1),t=t[0]),(r==null||r.length===0)&&s==null)return super.apply(t,n);const i=[],o=[];if(r!=null){const c=r.length;if(c%2>0)throw new le("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");n.initialState=r,i.push(...r);const l=r.map(d=>new Ur({shape:d.shape}));this.forwardLayer.stateSpec=l.slice(0,c/2),this.backwardLayer.stateSpec=l.slice(c/2),o.push(...l)}if(s!=null)throw new qt("Support for constants in Bidirectional layers is not implemented yet.");const u=i[0]instanceof Do;for(const c of i)if(c instanceof Do!==u)throw new le("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(u){const c=[t].concat(i),l=this.inputSpec.concat(o),d=this.inputSpec;this.inputSpec=l;const h=super.apply(c,n);return this.inputSpec=d,h}else return super.apply(t,n)}call(t,n){return we(()=>{const r=n.initialState;let s,a;if(r==null)s=this.forwardLayer.call(t,n),a=this.backwardLayer.call(t,n);else{const u=r.slice(0,r.length/2),c=r.slice(r.length/2);s=this.forwardLayer.call(t,Object.assign(n,{initialState:u})),a=this.backwardLayer.call(t,Object.assign(n,{initialState:c}))}let i;this.returnState&&(Array.isArray(s)&&(i=s.slice(1).concat(a.slice(1))),s=s[0],a=a[0]),this.returnSequences&&(a=cd(a,1));let o;return this.mergeMode==="concat"?o=BA([s,a]):this.mergeMode==="sum"?o=We(s,a):this.mergeMode==="ave"?o=ce(.5,We(s,a)):this.mergeMode==="mul"?o=ce(s,a):this.mergeMode==null&&(o=[s,a]),this.returnState?this.mergeMode==null?o.concat(i):[o].concat(i):o})}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){Fc(this.forwardLayer.name,()=>{this.forwardLayer.build(t)}),Fc(this.backwardLayer.name,()=>{this.backwardLayer.build(t)}),this.built=!0}computeMask(t,n){Array.isArray(n)&&(n=n[0]);let r;if(this.returnSequences?this.mergeMode==null?r=[n,n]:r=n:this.mergeMode==null?r=[null,null]:r=null,this.returnState){const a=this.forwardLayer.states.map(i=>null);return Array.isArray(r)?r.concat(a).concat(a):[r].concat(a).concat(a)}else return r}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(t),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){const t={mergeMode:this.mergeMode},n=super.getConfig();return Object.assign(t,n),t}static fromConfig(t,n){const r=al(n.layer);if(delete n.layer,n.numConstants!=null)throw new qt("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const s=n;return s.layer=r,new t(s)}}RG.className="Bidirectional";Le(RG);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class _G extends Jt{constructor(t){super(t),this.scale=t.scale,t.offset?this.offset=t.offset:this.offset=0}getConfig(){const t={scale:this.scale,offset:this.offset},n=super.getConfig();return Object.assign(t,n),t}call(t,n){return we(()=>(t=Mt(t),t.dtype!=="float32"&&(t=Co(t,"float32")),We(ce(t,this.scale),this.offset)))}}_G.className="Rescaling";Le(_G);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const{resizeBilinear:dBe,cropAndResize:hBe}=tl;class DG extends Jt{constructor(t){super(t),this.height=t.height,this.width=t.width}centerCrop(t,n,r,s,a,i,o,u){return we(()=>{let c,l=!1;const d=n/i,h=r/o,p=(s+n)/i,f=(a+r)/o,m=[d,h,p,f],g=[];t.rank===3?(l=!0,c=ul([t])):c=t;for(let v=0;v<c.shape[0];v++)g.push(m);const b=RE(g,[g.length,4]),y=Ry(0,g.length,1,"int32"),w=hBe(c,b,y,[s,a],"nearest");return Co(l?Mt(dd(w)):w,u)})}upsize(t,n,r,s){return we(()=>{const a=dBe(t,[n,r]);return Co(a,s)})}call(t,n){return we(()=>{const r=Mt(t),s=r.dtype,a=r.shape,i=a[a.length-3],o=a[a.length-2];let u=0;i!==this.height&&(u=Math.floor((i-this.height)/2));let c=0;return o!==this.width&&(c=Math.floor((o-this.width)/2),c===0&&(c=1)),u>=0&&c>=0?this.centerCrop(r,u,c,this.height,this.width,i,o,s):this.upsize(t,this.height,this.width,s)})}getConfig(){const t={height:this.height,width:this.width},n=super.getConfig();return Object.assign(t,n),t}computeOutputShape(t){t=gn(t);const n=t.length-3,r=t.length-2;return t[n]=this.height,t[r]=this.width,t}}DG.className="CenterCrop";Le(DG);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function pBe(e,t,n,r){let s=Mt(e);if(s.dtype!=="int32"&&(s=Co(s,"int32")),t==="int")return s;const a=s.shape;if(s.rank===0&&(s=ta(s,-1)),t==="oneHot"&&s.shape[s.shape.length-1]!==1&&(s=ta(s,-1)),s.rank>2)throw new le(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${a} which would result in output rank ${s.rank}.`);const i=["multiHot","oneHot"].includes(t),o=s;let u;if(typeof r<"u"&&t==="count"?u=J_(o,r,n,i):u=J_(o,[],n,i),t!=="tfIdf")return u;if(r)return ce(u,r);throw new le("When outputMode is 'tfIdf', weights must be provided.")}/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class FG extends Jt{constructor(t){super(t),this.numTokens=t.numTokens,t.outputMode?this.outputMode=t.outputMode:this.outputMode="multiHot"}getConfig(){const t={numTokens:this.numTokens,outputMode:this.outputMode},n=super.getConfig();return Object.assign(t,n),t}computeOutputShape(t){return t=gn(t),t==null?[this.numTokens]:this.outputMode==="oneHot"&&t[t.length-1]!==1?(t.push(this.numTokens),t):(t[t.length-1]=this.numTokens,t)}call(t,n){return we(()=>{t=Mt(t),t.dtype!=="int32"&&(t=Co(t,"int32"));let r;if(typeof n.countWeights<"u"){if(this.outputMode!=="count")throw new le(`countWeights is not used when outputMode !== count.
              Received countWeights=${n.countWeights}`);r=Mt(n.countWeights)}const s=Ui(t),a=Lx(t),i=Ya(this.numTokens,s).bufferSync().get(0),o=ep(a,0).bufferSync().get(0);if(!(i&&o))throw new le(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return pBe(t,this.outputMode,this.numTokens,r)})}}FG.className="CategoryEncoding";Le(FG);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const fBe=["bilinear","nearest"],BD=new Set(fBe);class MG extends Jt{constructor(t){if(super(t),this.height=t.height,this.width=t.width,t.interpolation)if(BD.has(t.interpolation))this.interpolation=t.interpolation;else throw new le(`Invalid interpolation parameter: ${t.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!t.cropToAspectRatio}computeOutputShape(t){t=gn(t);const n=t[2];return[this.height,this.width,n]}getConfig(){const t={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},n=super.getConfig();return Object.assign(t,n),t}call(t,n){return we(()=>{const r=[this.height,this.width];if(this.interpolation==="bilinear")return tl.resizeBilinear(t,r,!this.cropToAspectRatio);if(this.interpolation==="nearest")return tl.resizeNearestNeighbor(t,r,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...BD]} are supported`)})}}MG.className="Resizing";Le(MG);/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class OG{constructor(t){this.seed=t}next(){if(this.seed!==void 0)return this.seed++}}OG.className="RandomSeed";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class LG extends Jt{constructor(t){super(t),this.randomGenerator=new OG(t.seed)}getConfig(){const t={seed:this.randomGenerator.seed},n=super.getConfig();return Object.assign(t,n),t}}LG.className="BaseRandomLayer";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const mBe=["bilinear","nearest"],zD=new Set(mBe);class PG extends LG{constructor(t){super(t);const{factor:n,interpolation:r="bilinear"}=t;if(this.factor=n,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new le(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new le(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new le(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(r)if(zD.has(r))this.interpolation=r;else throw new le(`Invalid interpolation parameter: ${r} is not implemented`)}getConfig(){const t={factor:this.factor,interpolation:this.interpolation},n=super.getConfig();return Object.assign(t,n),t}computeOutputShape(t){t=gn(t);const n=t[2];return[this.imgHeight,-1,n]}call(t,n){return we(()=>{const r=Mt(t);this.imgHeight=r.shape[r.shape.length-3];const s=r.shape[r.shape.length-2];this.widthFactor=G1([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let a=this.widthFactor.dataSync()[0]*s;a=Math.round(a);const i=[this.imgHeight,a];switch(this.interpolation){case"bilinear":return tl.resizeBilinear(t,i);case"nearest":return tl.resizeNearestNeighbor(t,i);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...zD]} are supported`)}})}}PG.className="RandomWidth";Le(PG);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gBe=ke();gBe.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var WD;(function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"})(WD||(WD={}));var VD;(function(e){(function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"})(e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))})(VD||(VD={}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var UD;(function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"})(UD||(UD={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gt(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&U(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bBe=jW;class zI extends Pv{nextDataId(){return zI.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new sE(this,Fi())}write(t,n,r){this.firstUse&&(this.firstUse=!1,ke().get("IS_NODE")&&Oa(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const s={id:this.nextDataId()};return this.data.set(s,{values:t,dtype:r,refCount:1}),s}makeTensorInfo(t,n,r){let s;if(n==="string"&&r!=null&&r.length>0&&K0(r[0])){const a=r.map(i=>jl(i));s=this.write(a,t,n)}else s=this.write(r,t,n);return{dataId:s,shape:t,dtype:n}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){const n=this.data.get(t);n.refCount++}decRef(t){if(this.data.has(t)){const n=this.data.get(t);n.refCount--}}move(t,n,r,s,a){this.data.set(t,{values:n,dtype:s,refCount:a})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){const{dtype:n,complexTensorInfos:r}=this.data.get(t);if(n==="complex64"){const s=this.readSync(r.real.dataId),a=this.readSync(r.imag.dataId);return cl(s,a)}return U_e(this.data.get(t).values,n)}bufferSync(t){const n=this.readSync(t.dataId);if(t.dtype==="string")try{const r=n.map(s=>cu(s));return Yt(t.shape,t.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Yt(t.shape,t.dtype,n)}makeOutput(t,n,r){return Fi().makeTensorFromTensorInfo(this.makeTensorInfo(n,r,t),this)}disposeData(t,n=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!n&&this.data.get(t).refCount>0)return!1;const{complexTensorInfos:r}=this.data.get(t);r!=null&&(this.disposeData(r.real.dataId,!0),this.disposeData(r.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){const n=ws();return t(),{kernelMs:ws()-n}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){gt([t],"where");const n=this.readSync(t.dataId);return bBe(t.shape,n)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}zI.nextDataId=0;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BG(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}const yBe=e=>{const{x:t}=e.inputs,n=e.backend;gt(t,"abs");let r=new Float32Array(fe(t.shape));const s=n.data.get(t.dataId).values;return r=BG(s),n.makeOutput(r,t.shape,t.dtype)},xBe={kernelName:X0,backendName:"cpu",kernelFunc:yBe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nr(e){return(t,n,r,s,a)=>{const i=Ot(t,n),o=i.length,u=ot(i),c=fe(i),l=ks(a,c),d=t.length,h=n.length,p=ot(t),f=ot(n),m=rf(t,i),g=rf(n,i);if(m.length+g.length===0)for(let b=0;b<l.length;++b)l[b]=e(r[b%r.length],s[b%s.length]);else for(let b=0;b<l.length;++b){const y=Om(b,o,u),x=y.slice(-d);m.forEach(N=>x[N]=0);const w=Io(x,d,p),v=y.slice(-h);g.forEach(N=>v[N]=0);const I=Io(v,h,f);l[b]=e(r[w],s[I])}return[l,i]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function va(e){const{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,o=n.makeTensorInfo(r.shape,"complex64"),u=n.data.get(o.dataId);return u.complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",a),imag:n.makeTensorInfo(s.shape,"float32",i)},o}const wBe={kernelName:dE,backendName:"cpu",kernelFunc:va};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yx(e,t,n="float32"){if(n==="complex64"){const s=Yx(e,t,"float32"),a=Yx(e,t,"float32");return va({inputs:{real:s,imag:a},backend:e})}const r=Cs(fe(t),n);return e.makeTensorInfo(t,n,r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fo(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const vBe={kernelName:dg,backendName:"cpu",kernelFunc:Fo};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pd(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.real,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}const IBe={kernelName:vE,backendName:"cpu",kernelFunc:pd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zG(e,t,n,r){if(r==="int32"){const s=Int32Array.from(e);return[t,"int32",s]}if(r==="bool"){const s=Zh([0],n),[a,i]=Nr((o,u)=>o!==u?1:0)(t,[],e,s,"bool");return[i,"bool",a]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}function mu(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dtype:a}=r;if(a==="complex64"){if(s.dtype==="complex64")return Fo({inputs:{x:s},backend:n});const l=Yx(n,s.shape,s.dtype),d=mu({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),h=va({inputs:{real:d,imag:l},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(d),h}if(s.dtype==="complex64"){const l=pd({inputs:{input:s},backend:n}),d=mu({inputs:{x:l},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(l),d}if(!zz(s.dtype,a)){const l=Fo({inputs:{x:s},backend:n});return{dataId:l.dataId,shape:l.shape,dtype:a}}const i=n.data.get(s.dataId).values,[o,u,c]=zG(i,s.shape,s.dtype,a);return n.makeTensorInfo(o,u,c)}const kBe={kernelName:jm,backendName:"cpu",kernelFunc:mu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yr(e,t,n,r){return n==null?({inputs:s,backend:a})=>{const{a:i,b:o}=s,u=a;gt([i,o],e);const c=u.data.get(i.dataId).values,l=u.data.get(o.dataId).values,d=i.dtype==="string"?dl(c):c,h=i.dtype==="string"?dl(l):l,p=r||i.dtype,[f,m]=t(i.shape,o.shape,d,h,p);return u.makeTensorInfo(m,p,f)}:({inputs:s,backend:a})=>{const{a:i,b:o}=s,u=a;if(i.dtype==="complex64"||o.dtype==="complex64"){const c=mu({inputs:{x:i},backend:u,attrs:{dtype:"complex64"}}),l=u.data.get(c.dataId),d=l.complexTensorInfos.real,h=l.complexTensorInfos.imag,p=u.data.get(d.dataId).values,f=u.data.get(h.dataId).values,m=mu({inputs:{x:o},backend:u,attrs:{dtype:"complex64"}}),g=u.data.get(m.dataId),b=g.complexTensorInfos.real,y=g.complexTensorInfos.imag,x=u.data.get(b.dataId).values,w=u.data.get(y.dataId).values,[v,I,N]=n(i.shape,o.shape,p,f,x,w),T=u.makeTensorInfo(N,"float32",v),E=u.makeTensorInfo(N,"float32",I),A=va({inputs:{real:T,imag:E},backend:u});return u.disposeIntermediateTensorInfo(c),u.disposeIntermediateTensorInfo(m),u.disposeIntermediateTensorInfo(T),u.disposeIntermediateTensorInfo(E),A}else{const c=u.data.get(i.dataId).values,l=u.data.get(o.dataId).values,d=r||i.dtype,[h,p]=t(i.shape,o.shape,c,l,d);return u.makeTensorInfo(p,d,h)}}}function s$(e){return(t,n,r,s,a,i)=>{const o=Ot(t,n),u=fe(o),c=o.length,l=ot(o),d=ks("float32",u),h=ks("float32",u),p=rf(t,o),f=rf(n,o),m=cl(r,s),g=cl(a,i),b=t.length,y=ot(t),x=n.length,w=ot(n);if(p.length+f.length===0)for(let v=0;v<d.length;v++){const I=v%m.length,N=v%g.length,T=e(m[I*2],m[I*2+1],g[N*2],g[N*2+1]);d[v]=T.real,h[v]=T.imag}else for(let v=0;v<d.length;v++){const I=Om(v,c,l),N=I.slice(-b);p.forEach(C=>N[C]=0);const T=Io(N,b,y),E=I.slice(-x);f.forEach(C=>E[C]=0);const A=Io(E,x,w),k=e(m[T*2],m[T*2+1],g[A*2],g[A*2+1]);d[v]=k.real,h[v]=k.imag}return[d,h,o]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WG=Nr(((e,t)=>e+t)),CBe=s$(((e,t,n,r)=>({real:e+n,imag:t+r}))),of=Yr(Xh,WG,CBe),SBe={kernelName:Xh,backendName:"cpu",kernelFunc:of};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a$(e,t,n,r,s){const a=fe(r),i=Cs(s,n);for(let o=0;o<e.length;o++){const u=e[o];if(u<0)throw new Error("Input x must be non-negative!");u>=s||(a>0?i[u]+=t[o]:i[u]+=1)}return i}function VG(e,t,n,r=!1){const s=e.shape[0],a=e.shape[1],i=Yt([s,n],t.dtype);for(let o=0;o<s;o++)for(let u=0;u<a;u++){const c=e.get(o,u);if(c<0)throw new Error("Input x must be non-negative!");c>=n||(r?i.set(1,o,c):t.size>0?i.set(i.get(o,c)+t.get(o,u),o,c):i.set(i.get(o,c)+1,o,c))}return i}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UG=Nr(((e,t)=>e&t)),NBe=Yr(Vv,UG),TBe={kernelName:Vv,backendName:"cpu",kernelFunc:NBe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wo(e){return(t,n,r)=>{const s=wr(n,t.length);for(let a=0;a<t.length;++a)s[a]=e(t[a],r);return s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fn(e,t,n){const r=Wo(t);return Wu(e,r,n)}function Wu(e,t,n){return({inputs:r,attrs:s,backend:a})=>{const{x:i}=r;gt(i,e);const o=a,u=o.data.get(i.dataId).values;let c;if(i.dtype==="string"){if(!Array.isArray(u))throw new Error("String tensor's value was not an instance of Array");c=dl(u)}else c=u;const l=n||i.dtype,d=t(c,l,s);return o.makeTensorInfo(i.shape,l,d)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GG=Wo(e=>Math.ceil(e)),EBe=Wu(qm,GG),ABe={kernelName:qm,backendName:"cpu",kernelFunc:EBe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i$(e,t,n,r){const s=wr(n,fe(t));if(r&&n!=="string"){let a=0;e.forEach(i=>{const o=fe(i.shape);s.set(i.vals,a),a+=o})}else{let a=0;e.forEach(i=>{const o=n==="string"?dl(i.vals):i.vals;let u=0;for(let c=0;c<i.shape[0];++c){const l=c*t[1]+a;for(let d=0;d<i.shape[1];++d)s[l+d]=o[u++]}a+=i.shape[1]})}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HG=Nr((e,t)=>e===t?1:0),jG=Yr(d1,HG,null,"bool"),$Be={kernelName:d1,backendName:"cpu",kernelFunc:jG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qG=Wo(e=>Math.exp(e)),KG=Wu(ag,qG,"float32"),RBe={kernelName:ag,backendName:"cpu",kernelFunc:KG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XG=Wo(e=>Math.expm1(e)),_Be=Wu(ig,XG),DBe={kernelName:ig,backendName:"cpu",kernelFunc:_Be};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QG=Wo(e=>Math.floor(e)),FBe=Wu(og,QG),MBe={kernelName:og,backendName:"cpu",kernelFunc:FBe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YG=Nr((e,t)=>Math.floor(e/t)),OBe=Yr(lg,YG,null,"int32"),LBe={kernelName:lg,backendName:"cpu",kernelFunc:OBe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JG(e,t,n,r,s,a,i,o,u){const c=Yt([r,a],n);for(let l=0;l<r;l++){const d=[];let h=0;for(let p=0;p<s;p++){const f=e[l*s+p];h+=f*i[p],d.push(f)}if(h<0||h>=u/a)throw new Error(`Invalid indices: ${d} does not index into ${o}`);for(let p=0;p<a;p++)c.values[l*a+p]=t.get(...t.indexToLoc(h*a+p))}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZG(e,t,n){const r=Yt(n,e.dtype);for(let s=0;s<r.size;++s){const i=r.indexToLoc(s).slice(),o=i[0],u=i[2],c=t.locToIndex([o,u]);i[2]=t.values[c];const l=e.locToIndex(i);0<=l&&l<e.values.length&&(r.values[s]=e.values[l])}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eH=Nr((e,t)=>e>t?1:0),PBe=Yr(m1,eH,null,"bool"),BBe={kernelName:m1,backendName:"cpu",kernelFunc:PBe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tH=Nr((e,t)=>e>=t?1:0),zBe=Yr(cg,tH,null,"bool"),WBe={kernelName:cg,backendName:"cpu",kernelFunc:zBe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nH=Nr((e,t)=>e<t?1:0),VBe=Yr(g1,nH,null,"bool"),UBe={kernelName:g1,backendName:"cpu",kernelFunc:VBe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rH=Nr((e,t)=>e<=t?1:0),GBe=Yr(b1,rH,null,"bool"),HBe={kernelName:b1,backendName:"cpu",kernelFunc:GBe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sH(e,t,n){const r=(t-e)/(n-1),s=Cs(n,"float32");s[0]=e;for(let a=1;a<s.length;a++)s[a]=s[a-1]+r;return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aH=Wo(e=>Math.log(e)),jBe=Wu(gg,aH),qBe={kernelName:gg,backendName:"cpu",kernelFunc:jBe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iH(e,t,n,r){const s=ks(r,fe(n));for(let a=0;a<s.length;++a){const i=a*t;let o=e[i];for(let u=0;u<t;++u){const c=e[i+u];(Number.isNaN(c)||c>o)&&(o=c)}s[a]=o}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oH=Nr(((e,t)=>Math.max(e,t))),KBe=Yr(wg,oH),XBe={kernelName:wg,backendName:"cpu",kernelFunc:KBe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lH=Nr(((e,t)=>Math.min(e,t))),QBe=Yr(Cg,lH),YBe={kernelName:Cg,backendName:"cpu",kernelFunc:QBe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o$=Nr(((e,t)=>e*t)),JBe=s$(((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n}))),WI=Yr(Tg,o$,JBe),ZBe={kernelName:Tg,backendName:"cpu",kernelFunc:WI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uH(e,t,n){const r=Mu(-1,n);return o$([],t,r,e,n)}function eze(e){const{inputs:t,backend:n}=e,{x:r}=t;gt(r,"neg");const s=n.data.get(r.dataId).values,[a,i]=uH(s,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,a)}const tze={kernelName:k1,backendName:"cpu",kernelFunc:eze};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cH=Nr(((e,t)=>e!==t?1:0)),nze=Yr(C1,cH,null,"bool"),rze={kernelName:C1,backendName:"cpu",kernelFunc:nze};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l$(e,t,n,r,s){const a=t.length,i=fe(t),o=ot(t),u=ot(s),c=ks(n,fe(s));for(let l=0;l<i;++l){const d=Om(l,a,o),h=new Array(d.length);for(let f=0;f<h.length;f++)h[f]=d[r[f]];const p=Io(h,a,u);c[p]=e[l]}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ha(e){const{inputs:t,attrs:n,backend:r}=e,{x:s}=t,{perm:a}=n;gt(s,"transpose");const i=s.shape.length,o=new Array(i);for(let d=0;d<o.length;d++)o[d]=s.shape[a[d]];const u=r.data.get(s.dataId).values,c=l$(u,s.shape,s.dtype,a,o);return{dataId:r.write(c,o,s.dtype),shape:o,dtype:s.dtype}}const sze={kernelName:Gl,backendName:"cpu",kernelFunc:ha};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dH(e,t,n,r){const[s,a]=sr(e,r),i=$a(t,"int32"),o=Cs(fe(s),i),u=fe(a);for(let c=0;c<o.length;++c){const l=c*u;let d=1;for(let h=0;h<u;++h)d*=n[l+h];o[c]=d}return{outVals:o,outShape:s,outDtype:i}}function aze(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;gt(s,"prod");const o=s.shape.length,u=zt(a,s.shape),c=nr(u,o);let l=u,d=s;const h=[];c!=null&&(d=ha({inputs:{x:s},backend:n,attrs:{perm:c}}),h.push(d),l=qn(l.length,o));const p=n.data.get(d.dataId).values,{outVals:f,outShape:m,outDtype:g}=dH(d.shape,d.dtype,p,l);let b=m;return i&&(b=jn(m,u)),h.forEach(y=>n.disposeIntermediateTensorInfo(y)),n.makeTensorInfo(b,g,f)}const ize={kernelName:_g,backendName:"cpu",kernelFunc:aze};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oze(e,t,n){e.forEach((r,s)=>{if(r<0||r>=n){const a=Om(s,t.length,ot(t)).join(",");throw new Error(`indices[${a}] = ${r} is not in [0, ${n})`)}})}function lze(e,t){for(let n=0;n<e.length;++n){const r=e[n],s=n===e.length-1?t:e[n+1].length;if(r.length===0)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let a=1;a<r.length;++a)if(r[a-1]>r[a])throw new Error("Ragged splits must be sorted in ascending order")}}function uze(e,t,n,r){const s=[];let a=0;const i=t.length-1+n.length,o=new Array(i).fill(null).map(()=>[0]);lze(n,r);let u=1;for(let c=0;c<t.length-1;++c){u*=t[c];const l=t[c+1];for(let d=1;d<u+1;++d)o[c].push(d*l)}for(let c=0;c<e.length;++c){let l=e[c],d=e[c]+1;for(let h=0;h<n.length;++h){const p=n[h],f=h+t.length-1;if(f>=0){const m=o[f],g=m[m.length-1]-p[l];for(let b=l;b<d;++b)o[f].push(p[b+1]+g)}l=p[l],d=p[d]}d!==l&&(s.push([l,d]),a+=d-l)}return{outSplits:o,valueSlices:s,numValues:a}}function cze(e){const t=[];for(let n=0;n<e.length;++n){const r=e[n].length,s=wr("int32",r);t.push(s),e[n].forEach((a,i)=>s[i]=a)}return t}function GD(e,t){const n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function dze(e,t,n,r,s,a){const i=GD(t,2)[1],o=GD(a,2)[1];let u=0;for(const c of n)for(let l=c[0];l<c[1];++l){for(let d=0;d<r;++d)s[u*o+d]=e[l*i+d];++u}}function hze(e,t,n,r,s){const a=t.slice();a[0]=s;const i=wr(n,fe(a)),o=e.length,u=o===0?0:o/t[0];return dze(e,t,r,u,i,a),[i,a]}function hH(e,t,n,r,s,a,i,o){if(e.length===0)throw new Error("paramsNestedSplits must be non empty");if(t[0].length===0)throw new Error("Split tensors must not be scalars");const u=t[0][0]-1;if(oze(a,i,u),r.length===0)throw new Error("params.rank must be nonzero");const c=r[0],{outSplits:l,valueSlices:d,numValues:h}=uze(a,i,e,c),p=cze(l),f=hze(n,r,s,d,h);return[p,f[0],f[1]]}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HD=2147483647;function pH(e,t,n,r,s,a,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(s.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");const o=t.length===0,u=s.length===0,c=i.length===0,l=[];o||l.push(t[0]),u||l.push(s[0]),c||l.push(i[0]);for(let g=1;g<l.length;++g)if(l[g]!==l[g-1])throw new Error("starts, limits, and deltas must have the same shape");const d=l.length===0?1:l[0],h=wr("int32",d+1);h[0]=0;for(let g=0;g<d;++g){const b=o?e[0]:e[g],y=u?r[0]:r[g],x=c?a[0]:a[g];if(x===0)throw new Error("Requires delta != 0");let w;if(x>0&&y<b||x<0&&y>b)w=0;else if(w=Math.ceil(Math.abs((y-b)/x)),w>HD)throw new Error(`Requires ((limit - start) / delta) <= ${HD}`);h[g+1]=h[g]+w}const p=h[d],f=wr(n,p);let m=0;for(let g=0;g<d;++g){const b=h[g+1]-h[g];let y=o?e[0]:e[g];const x=c?a[0]:a[g];for(let w=0;w<b;++w)f[m++]=y,y+=x}return[h,f]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ri=Li;class Jx{constructor(t,n,r,s,a,i,o,u,c,l){this.shape=t,this.shapeShape=n,this.values=r,this.valuesShape=s,this.valuesDType=a,this.defaultValue=i,this.defaultValueShape=o,this.rowPartitionValues=u,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=dV(l),this.raggedRank=hV(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===ri.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===ri.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){const n=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case ri.VALUE_ROWIDS:return Jx.getMaxWidthValueRowID(n);case ri.ROW_SPLITS:return Jx.getMaxWidthRowSplit(n);default:throw new Error(`Cannot handle partition type ${ri[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){const n=t.length;if(n===0||n===1)return 0;let r=0;for(let s=0;s<n-1;++s){const a=t[s+1]-t[s];a>r&&(r=a)}return r}static getMaxWidthValueRowID(t){const n=t.length;if(n===0)return 0;let r=0,s=t[0],a=0;for(let i=1;i<n;++i){const o=t[i];o!==s&&(s=o,a=Math.max(i-r,a),r=i)}return Math.max(n-r,a)}tensorShapeFromTensor(t,n,r=!0){if(n.length===0){if(t[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return qD(t,r)}calculateOutputSize(t){const n=this.valuesShape,r=this.defaultValueShape;pV(r,n);const s=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=cV(this.raggedRank,s,n);i[0]<0&&(i[0]=t);for(let o=1;o<=this.raggedRank;++o)i[o]<0&&(i[o]=this.getMaxWidth(o));return i}calculateFirstParentOutputIndex(t,n,r){const s=Math.min(t,r),a=[];let i=0;for(let o=0;o<s;++o,i+=n)a.push(i);for(let o=s;o<t;++o)a.push(-1);return U(a.length===t,()=>"Final length of result must be equal to firstDimension."),a}calculateOutputIndexRowSplit(t,n,r,s){const a=t.length,i=[];for(let o=0;o<a-1;++o){const u=t[o+1]-t[o];let c=Math.min(s,u),l=n[o];l===-1&&(c=0);for(let d=0;d<c;++d)i.push(l),l+=r;for(let d=0;d<u-c;++d)i.push(-1)}if(a>0&&i.length!==t[a-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(t,n,r,s){const a=t.length,i=[];if(a===0)return[];let o=0,u=t[0];if(u>=n.length)throw new Error(`Got currentValueRowId=${u}, which is not less than ${n.length}`);let c=n[u];i.push(c);for(let l=1;l<a;++l){const d=t[l];if(d===u)c>=0&&(++o,o<s?c+=r:c=-1);else{if(o=0,u=d,d>=n.length)throw new Error(`Got nextValueRowId=${d} which is not less than ${n.length}`);c=n[d]}i.push(c)}if(i.length!==t.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(t,n,r,s){const a=this.getRowPartitionTensor(t),i=this.getRowPartitionTypeByDimension(t);switch(i){case ri.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(a,n,r,s);case ri.ROW_SPLITS:if(a.length-1>n.length)throw new Error(`Row partition size is greater than output size: ${a.length-1} > ${n.length}`);return this.calculateOutputIndexRowSplit(a,n,r,s);default:throw new Error(`Unsupported partition type: ${ri[i]}`)}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const n=this.rowPartitionTypes[0];switch(n){case ri.FIRST_DIM_SIZE:return t[0];case ri.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case ri.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${ri[n]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const n=this.getFirstDimensionSize(),r=this.calculateOutputSize(n),s=new Array(this.raggedRank+1);s[s.length-1]=1;for(let u=s.length-2;u>=0;--u)s[u]=s[u+1]*r[u+1];const a=qD(r,!1),i=wr(this.valuesDType,fe(a));if(s[0]*r[0]>0){let u=this.calculateFirstParentOutputIndex(n,s[0],r[0]);for(let c=1;c<=this.raggedRank;++c)u=this.calculateOutputIndex(c-1,u,s[c],r[c]);this.setOutput(this.raggedRank,u,i,a)}return[a,i]}setOutput(t,n,r,s){if(r.length===0)return;const a=this.values,i=r;let o=s.slice();o=o.slice(t+1);const u=fe(o),c=n.length;let l=this.defaultValue;if(l.length!==u&&l.length!==1){const f=this.defaultValueShape;we(()=>{const m=be(l,f);l=ry(m,o).dataSync()})}let d=0,h=0,p=0;for(let f=0;f<=c;++f){let m=f<c?n[f]:-1;if(m===p){++p;continue}if(h<p){const g=a.subarray(d*u),b=i.subarray(h*u),y=(p-h)*u;jD(b,g,y)}if(f>=c){const g=r.length;m=Math.floor(g/u)}if(m>p)if(this.defaultValue.length===1)i.subarray(p*u,m*u).fill(this.defaultValue[0]),p=m;else for(;m>p;){const g=i.slice(p*u);jD(g,l,u),++p}m<0?(d=f+1,h=p):(d=f,h=p,p=h+1)}}}function jD(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function qD(e,t){const n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function fH(e,t,n,r,s,a,i,o,u,c){return new Jx(e,t,n,r,s,a,i,o,u,c).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u$(e,t,n,r){const s=e===t,a=e<t&&n<0,i=t<e&&n>1;if(s||a||i)return Cs(0,r);const o=Math.abs(Math.ceil((t-e)/n)),u=Cs(o,r);t<e&&n===1&&(n=-1),u[0]=e;for(let c=1;c<u.length;c++)u[c]=u[c-1]+n;return u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mH=Wo(e=>1/Math.sqrt(e)),pze=Wu(zg,mH),fze={kernelName:zg,backendName:"cpu",kernelFunc:pze};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tc(e,t,n,r,s,a,i,o,u,c){const l=[r/s,s],d=e.values,h=t.values;if(r===0)return Yt(n,t.dtype);const p=u instanceof ms?u:Yt(l,t.dtype);typeof u=="string"||typeof u=="number"?p.values.fill(u):typeof u=="boolean"&&p.values.fill(+u);for(let f=0;f<a;f++){const m=[];let g=0;for(let b=0;b<i;b++){const y=d[f*i+b];m.push(y),g+=y*o[b]}if(g<0||g>=r/s)throw new Error(`Invalid indices: ${m} does not index into ${n}`);for(let b=0;b<s;b++)c?p.values[g*s+b]+=h[f*s+b]:p.values[g*s+b]=t.rank===0?h[0]:h[f*s+b]}return p}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mze=Wo(e=>1/(1+Math.exp(-e))),gH=Fn(Hg,e=>1/(1+Math.exp(-e))),gze={kernelName:Hg,backendName:"cpu",kernelFunc:gH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zx(e,t,n,r,s){const a=yI(r,t,n),i=fe(n),o=ot(r);if(a){const d=xI(t,o);return s==="string"?e.slice(d,d+i):e.subarray(d,d+i)}const u=s==="string"?dl(e):e,c=Yt(r,s,u),l=Yt(n,s);for(let d=0;d<l.size;++d){const h=l.indexToLoc(d),p=h.map((f,m)=>f+t[m]);l.set(c.get(...p),...h)}return s==="string"?MA(l.values):l.values}function fd(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,size:i}=r;gt(s,"slice");const[o,u]=q1(s,a,i);cA(s,o,u);const c=n.data.get(s.dataId).values,l=Zx(c,o,u,s.shape,s.dtype);return n.makeTensorInfo(u,s.dtype,l)}const bze={kernelName:F1,backendName:"cpu",kernelFunc:fd};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bH(e,t,n,r,s,a,i){const o=t[0],u=a[0],c=new Array(u),l=new Array(o),d=t[1];if(u===0){if(o!==0)throw new Error(CA(o));const g=wr(n,0),b=wr(s,0);return[g,[0,d],b,c,l]}let h=!0,p=0;const f=new Array(u).fill(0);for(let g=0;g<o;++g){const b=e[g*d];if(b<0)throw new Error(SA(g,b));if(b>=u)throw new Error(NA(g,b,u));++f[b],h=h&&b>=p,p=b}let m=!0;for(let g=0;g<u;++g){const b=f[g]===0;c[g]=b,m=m&&!b,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&h){const g=e,b=r;for(let y=0;y<o;++y)l[y]=y;return[g,[o,d],b,c,l]}else{const g=f[u-1],b=wr(n,g*d),y=wr(s,g),x=new Array(u).fill(0);for(let w=0;w<o;++w){const v=e[w*d],I=x[v],N=(v===0?0:f[v-1])+I;x[v]++;for(let T=0;T<d;++T)b[N*d+T]=e[w*d+T];y[N]=r[w],l[w]=N}for(let w=0;w<u;++w)if(x[w]===0){const I=w===0?0:f[w-1];b[I*d+0]=w;for(let N=1;N<d;++N)b[I*d+N]=0;y[I]=i}return[b,[g,d],y,c,l]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yH(e,t,n,r,s){const a=fe(r),i=t[0],o=s.length,u=[];let c=1,l=-1;for(let g=0;g<o;++g){const b=s[g];if(b===-1){if(l!==-1)throw new Error(TA(l,g));l=g,u.push(1)}else{if(b<0)throw new Error(EA(g,b));c*=b,u.push(b)}}if(l!==-1){if(c<=0)throw new Error(AA());const g=Math.trunc(a/c);if(c*g!==a)throw new Error($A(r,u));u[l]=g}if(fe(u)!==a)throw new Error(RA(r,u));const h=r.length,p=[];if(h>0){p[h-1]=1;for(let g=h-2;g>=0;--g)p[g]=p[g+1]*r[g+1]}const f=[];if(o>0){f[o-1]=1;for(let g=o-2;g>=0;--g)f[g]=f[g+1]*u[g+1]}const m=wr(n,i*o);for(let g=0;g<i;++g){let b=0;for(let y=0;y<h;++y)b+=e[g*h+y]*p[y];for(let y=0;y<o;++y)m[g*o+y]=Math.trunc(b/f[y]),b%=f[y]}return[m,[i,o],u]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c$(e,t,n,r,s,a=!1,i=0){const o=r.length,u=[t[0],e.length/t[0]],c=u[1],d=o>0?s[o-1]+1:0;if(d<0)throw new Error(_y());const h=t.slice();h[0]=d;const p=h.reduce((x,w)=>x*w,1),f=wr(n,p);if(o===0)return d>0&&f.fill(i),[f,h];if(d<=0)throw new Error(_y());let m=0,g=1,b=0,y=s[m];for(;;){let x=0;if(g<o){if(x=s[g],y===x){++g;continue}if(y>=x)throw new Error(_A())}if(y<0||y>=d)throw new Error(DA(y,d));y>b&&f.fill(i,b*c,y*c);for(let w=m;w<g;++w){const v=r[w];if(v<0||v>=u[0])throw new Error(FA(w,r[w],u[0]));for(let I=0;I<c;I++)f[y*c+I]+=e[v*c+I]}if(a)for(let w=0;w<c;w++)f[y*c+w]/=g-m;if(m=g,++g,b=y+1,y=x,g>o)break}return b<d&&f.fill(i,b*c,d*c),[f,h]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yze=Wo(e=>Math.sqrt(e)),xze=Fn(qg,e=>Math.sqrt(e)),wze={kernelName:qg,backendName:"cpu",kernelFunc:xze};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xH=Nr(((e,t)=>{const n=e-t;return n*n})),vze=Yr(Qg,xH),Ize={kernelName:Qg,backendName:"cpu",kernelFunc:vze};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wH=Wo((e,t)=>{const{pattern:n,replaceGlobal:r,rewrite:s}=t;return e.replace(new RegExp(n,r?"g":""),s)}),kze=Wu(SE,wH),Cze={kernelName:SE,backendName:"cpu",kernelFunc:kze};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vH(e,t,n,r){const s=Yt(e,t.dtype);for(let a=0;a<s.size;a++){const i=s.indexToLoc(a),o=new Array(i.length);for(let u=0;u<o.length;u++)o[u]=i[u]*n[u]+r[u];s.set(t.get(...o),...i)}return s}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Sze{constructor(t,n,r,s,a,i){this.separator=jl(t),this.nGramWidths=n,this.leftPad=jl(r),this.rightPad=jl(s),this.padWidth=a,this.preserveShort=i}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,n){const r=this.getPadWidth(n);return Math.max(0,t+2*r-n+1)}createNGrams(t,n,r,s,a,i){for(let o=0;o<a;++o){const u=this.getPadWidth(i),c=Math.max(0,u-o),l=Math.max(0,u-(a-(o+1))),d=i-(c+l),h=n+(c>0?0:o-u);let p=0;p+=c*this.leftPad.length;for(let y=0;y<d;++y)p+=t[h+y].length;p+=l*this.rightPad.length;const f=c+l+d-1;p+=f*this.separator.length,r[s+o]=new Uint8Array(p);const m=r[s+o];let g=0;const b=y=>y.forEach(x=>m[g++]=x);for(let y=0;y<c;++y)b(this.leftPad),b(this.separator);for(let y=0;y<d-1;++y)b(t[h+y]),b(this.separator);if(d>0){b(t[h+d-1]);for(let y=0;y<l;++y)b(this.separator),b(this.rightPad)}else{for(let y=0;y<l-1;++y)b(this.rightPad),b(this.separator);b(this.rightPad)}}}compute(t,n){const r=t.length,s=n.length;if(s>0){let u=n[0];if(u!==0)throw new Error(`First split value must be 0, got ${u}`);for(let c=1;c<s;++c){let l=n[c]>=u;if(l=l&&n[c]<=r,!l)throw new Error(`Invalid split value ${n[c]}, must be in [${u}, ${r}]`);u=n[c]}if(u!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${u}`)}const a=s-1,i=wr("int32",s);if(r===0||s===0){const u=new Array(r);for(let c=0;c<=a;++c)i[c]=0;return[u,i]}i[0]=0;for(let u=1;u<=a;++u){const c=n[u]-n[u-1];let l=0;this.nGramWidths.forEach(d=>{l+=this.getNumNGrams(c,d)}),this.preserveShort&&c>0&&l===0&&(l=1),i[u]=i[u-1]+l}const o=new Array(i[a]);for(let u=0;u<a;++u){const c=n[u];let l=i[u];if(this.nGramWidths.forEach(d=>{const h=n[u+1]-n[u],p=this.getNumNGrams(h,d);this.createNGrams(t,c,o,l,p,d),l+=p}),this.preserveShort&&l===i[u]){const d=n[u+1]-n[u];if(d===0)continue;const h=d+2*this.padWidth;this.createNGrams(t,c,o,l,1,h)}}return[o,i]}}function d$(e,t,n,r,s,a,i,o){return new Sze(n,r,s,a,i,o).compute(e,t)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nze(e,t,n,r){if(!e.length)return;if(t.length===0){for(let a=0;a<e.length;++a)r.push(e.subarray(a,a+1));return}if(t.length===1){const a=t[0];let i=e.indexOf(a);for(;i!==-1;){const o=e.subarray(0,i);(!n||o.length!==0)&&r.push(o),e=e.subarray(i+1),i=e.indexOf(a)}(!n||e.length!==0)&&r.push(e);return}let s=0;for(let a=0;a<e.length+1;a++)if(a===e.length||t.indexOf(e[a])!==-1){const i=e.subarray(s,a);(!n||i.length!==0)&&r.push(i),s=a+1}}function h$(e,t,n){const r=e.length,s=[];let a=0,i=0;const o=new Array(r);for(let h=0;h<r;++h){const p=s.length;Nze(e[h],t,n,s);const f=s.length-p;o[h]=f,a+=f,i=Math.max(i,f)}const u=wr("int32",a*2),c=new Array(a),l=[r,i];let d=0;for(let h=0;h<r;++h)for(let p=0;p<o[h];++p)u[d*2]=h,u[d*2+1]=p,c[d]=s[d],++d;return[u,c,l]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p$(e,t){const n=wr("int32",e.length);for(let r=0;r<e.length;++r)n[r]=uDe(e[r]).modulo(t).getLowBitsUnsigned();return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IH=Nr(((e,t)=>e-t)),Tze=s$(((e,t,n,r)=>({real:e-n,imag:t-r}))),f$=Yr(Yg,IH,Tze),Eze={kernelName:Yg,backendName:"cpu",kernelFunc:f$};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kH(e,t){const n=new Array(e.rank);for(let s=0;s<n.length;s++)n[s]=e.shape[s]*t[s];const r=Yt(n,e.dtype);for(let s=0;s<r.values.length;++s){const a=r.indexToLoc(s),i=new Array(e.rank);for(let u=0;u<i.length;u++)i[u]=a[u]%e.shape[u];const o=e.locToIndex(i);r.values[s]=e.values[o]}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xb=(e,t)=>{const n=t.value-e.value;return n===0?e.index-t.index:n};function CH(e,t,n=0,r=e.length-1){for(;r>n;){if(r-n>600){const o=r-n+1,u=t-n+1,c=Math.log(o),l=.5*Math.exp(2*c/3),d=.5*Math.sqrt(c*l*(o-l)/o)*Math.sign(u-o/2),h=Math.max(n,Math.floor(t-u*l/o+d)),p=Math.min(r,Math.floor(t+(o-u)*l/o+d));CH(e,t,h,p)}const s=e[t];let a=n,i=r;for(vp(e,n,t),Xb(e[r],s)>0&&vp(e,n,r);a<i;){for(vp(e,a,i),a++,i--;Xb(e[a],s)<0;)a=a+1;for(;Xb(e[i],s)>0;)i=i-1}Xb(e[n],s)===0?vp(e,n,i):(i=i+1,vp(e,i,r)),i<=t&&(n=i+1),t<=i&&(r=i-1)}}function SH(e,t,n,r,s){const a=t[t.length-1],[i,o]=[e.length/a,a],u=ks(n,i*r),c=ks("int32",i*r);for(let d=0;d<i;d++){const h=d*o,p=e.subarray(h,h+o);let f=new Array(p.length);p.forEach((y,x)=>f[x]={value:y,index:x}),r<f.length&&(CH(f,r),f=f.slice(0,r)),s&&f.sort(Xb);const m=d*r,g=u.subarray(m,m+r),b=c.subarray(m,m+r);for(let y=0;y<r;y++)g[y]=f[y].value,b[y]=f[y].index}const l=t.slice();return l[l.length-1]=r,[Yt(l,n,u),Yt(l,"int32",c)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m$(e,t,n,r){const s=zt(t,n)[0],a=[1,n[0],1];for(let f=0;f<s;f++)a[0]*=n[f];a[1]=n[s];for(let f=s+1;f<n.length;f++)a[2]*=n[f];const i=new Map,o=new Int32Array(n[s]),u=new ms(a,r,e),c=[],l=a[0]===1&&a[2]===1;for(let f=0;f<n[s];f++){let m;if(l)m=e[f].toString();else{const b=[];for(let y=0;y<a[0];y++)for(let x=0;x<a[2];x++)b.push(u.get(y,f,x));m=b.join(",")}const g=i.get(m);if(g!=null)o[f]=g;else{const b=i.size;i.set(m,b),o[f]=b,c.push(f)}}const d=a.slice();d[1]=i.size;const h=new ms(d,r);c.forEach((f,m)=>{for(let g=0;g<a[0];g++)for(let b=0;b<a[2];b++)h.set(u.get(g,f,b),g,m,b)});const p=n.slice();return p[s]=d[1],{outputValues:h.values,outputShape:p,indices:o}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Aze=Object.freeze(Object.defineProperty({__proto__:null,addImpl:WG,bincountImpl:a$,bincountReduceImpl:VG,bitwiseAndImpl:UG,castImpl:zG,ceilImpl:GG,concatImpl:i$,equalImpl:HG,expImpl:qG,expm1Impl:XG,floorDivImpl:YG,floorImpl:QG,gatherNdImpl:JG,gatherV2Impl:ZG,greaterEqualImpl:tH,greaterImpl:eH,lessEqualImpl:rH,lessImpl:nH,linSpaceImpl:sH,logImpl:aH,maxImpl:iH,maximumImpl:oH,minimumImpl:lH,multiplyImpl:o$,negImpl:uH,notEqualImpl:cH,prodImpl:dH,raggedGatherImpl:hH,raggedRangeImpl:pH,raggedTensorToTensorImpl:fH,rangeImpl:u$,rsqrtImpl:mH,scatterImpl:Tc,sigmoidImpl:mze,simpleAbsImpl:BG,sliceImpl:Zx,sparseFillEmptyRowsImpl:bH,sparseReshapeImpl:yH,sparseSegmentReductionImpl:c$,sqrtImpl:yze,squaredDifferenceImpl:xH,staticRegexReplaceImpl:wH,stridedSliceImpl:vH,stringNGramsImpl:d$,stringSplitImpl:h$,stringToHashBucketFastImpl:p$,subImpl:IH,tileImpl:kH,topKImpl:SH,transposeImpl:l$,uniqueImpl:m$},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_E("cpu",()=>new zI,1);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NH=Fn(rg,e=>e>=0?e:Math.exp(e)-1),$ze={kernelName:rg,backendName:"cpu",kernelFunc:NH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TH(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:a}=r;gt([s],"leakyRelu");const i=fe(s.shape),o=n.data.get(s.dataId).values,u=ks("float32",i);for(let c=0;c<o.length;c++)u[c]=o[c]<0?a*o[c]:o[c];return n.makeTensorInfo(s.shape,"float32",u)}const Rze={kernelName:mg,backendName:"cpu",kernelFunc:TH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _ze=Nr((e,t)=>e<0?t*e:e);function EH(e){const{inputs:t,backend:n}=e,{x:r,alpha:s}=t;gt([r,s],"prelu");const a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,[o,u]=_ze(r.shape,s.shape,a,i,"float32");return n.makeTensorInfo(u,"float32",o)}const Dze={kernelName:Rg,backendName:"cpu",kernelFunc:EH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AH=Fn(Fg,e=>Math.max(0,e)),Fze={kernelName:Fg,backendName:"cpu",kernelFunc:AH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $H=Fn(Lg,e=>Math.min(Math.max(0,e),6)),Mze={kernelName:Lg,backendName:"cpu",kernelFunc:$H};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ew(e,t,n,r,s){if(n==="linear")return Fo({inputs:{x:t},backend:e});if(n==="relu")return AH({inputs:{x:t},backend:e});if(n==="elu")return NH({inputs:{x:t},backend:e});if(n==="relu6")return $H({inputs:{x:t},backend:e});if(n==="prelu")return EH({inputs:{x:t,alpha:r},backend:e});if(n==="leakyrelu")return TH({inputs:{x:t},backend:e,attrs:{alpha:s}});if(n==="sigmoid")return gH({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function er(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:a}=r,i=fe(s.shape),o=iE(a,i),u=fe(o);U(i===u,()=>`The new shape (${o}) has ${u} elements and the old shape (${s.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),n.incRef(s.dataId);const c=n.data.get(s.dataId);if(c.complexTensorInfos!=null){const l=c.complexTensorInfos.real,d=c.complexTensorInfos.imag;l.shape=o,d.shape=o}return{dataId:s.dataId,shape:o,dtype:s.dtype}}const Oze={kernelName:$1,backendName:"cpu",kernelFunc:er};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RH(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:o}=r;gt([s,a],"matMul");const u=s.shape.length,c=a.shape.length,l=i?s.shape[u-2]:s.shape[u-1],d=o?a.shape[c-1]:a.shape[c-2],h=i?s.shape[u-1]:s.shape[u-2],p=o?a.shape[c-2]:a.shape[c-1],f=s.shape.slice(0,-2),m=a.shape.slice(0,-2),g=fe(f),b=fe(m),x=Ot(s.shape.slice(0,-2),a.shape.slice(0,-2)).concat([h,p]);U(l===d,()=>`Error in matMul: inner shapes (${l}) and (${d}) of Tensors with shapes ${s.shape} and ${a.shape} and transposeA=${i} and transposeB=${o} must match.`);const w=i?[g,l,h]:[g,h,l],v=o?[b,p,d]:[b,d,p],I=er({inputs:{x:s},backend:n,attrs:{shape:w}}),N=er({inputs:{x:a},backend:n,attrs:{shape:v}}),T=i?I.shape[1]:I.shape[2],E=i?I.shape[2]:I.shape[1],A=o?N.shape[1]:N.shape[2],k=Math.max(g,b),C=n.data.get(I.dataId).values,M=n.data.get(N.dataId).values,L=ot(I.shape),O=ot(N.shape),[B,G,z]=i?[L[0],1,L[1]]:[L[0],L[1],1],[q,Q,K]=o?[1,O[1],O[0]]:[O[1],1,O[0]],ee=E*A,Y=Yt([k,E,A],I.dtype),de=Y.values,ue=n.blockSize;for(let Ie=0;Ie<k;Ie++){const Ee=Ie%g,ve=Ie%b;for(let Ae=0;Ae<E;Ae+=ue){const Be=Math.min(Ae+ue,E);for(let Ue=0;Ue<A;Ue+=ue){const qe=Math.min(Ue+ue,A);for(let ut=0;ut<T;ut+=ue){const nt=Math.min(ut+ue,T);for(let rt=Ae;rt<Be;rt++)for(let ze=Ue;ze<qe;ze++){let ct=0;for(let ht=ut;ht<nt;ht++){const yn=C[Ee*B+rt*G+ht*z],St=M[ht*q+ze*Q+ve*K];ct+=yn*St}de[Ie*ee+(rt*A+ze)]+=ct}}}}}return n.disposeIntermediateTensorInfo(I),n.disposeIntermediateTensorInfo(N),n.makeTensorInfo(x,Y.dtype,Y.values)}const Lze={kernelName:Hm,backendName:"cpu",kernelFunc:RH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pze(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:o}=t,{transposeA:u,transposeB:c,activation:l,leakyreluAlpha:d}=r;let h,p,f;const m=[];h=RH({inputs:{a:s,b:a},attrs:{transposeA:u,transposeB:c},backend:n}),i&&(p=of({inputs:{a:h,b:i},backend:n}),m.push(h),h=p),l&&(f=ew(n,h,l,o,d),m.push(h),h=f);for(const b of m)n.disposeIntermediateTensorInfo(b);return h}const Bze={kernelName:Zp,backendName:"cpu",kernelFunc:Pze};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zze=Fn(Lm,e=>Math.acos(e)),Wze={kernelName:Lm,backendName:"cpu",kernelFunc:zze};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vze=Fn(Pm,e=>Math.acosh(e)),Uze={kernelName:Pm,backendName:"cpu",kernelFunc:Vze};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gze(e){const{inputs:t,backend:n}=e,r=t;gt(t,"addN");const s=r.map(o=>n.data.get(o.dataId).values),a=Yt(r[0].shape,r[0].dtype),i=a.values;for(let o=0;o<r.length;o++){const u=s[o];for(let c=0;c<i.length;c++)i[c]+=u[c]}return n.makeTensorInfo(a.shape,a.dtype,a.values)}const Hze={kernelName:Q0,backendName:"cpu",kernelFunc:Gze};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jze(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;gt(s,"all");const o=zt(a,s.shape);let u=o;const c=nr(u,s.shape.length);let l=s;c!=null&&(l=ha({inputs:{x:s},backend:n,attrs:{perm:c}}),u=qn(u.length,s.shape.length)),tr("all",u,l.shape.length);const[d,h]=sr(l.shape,u),p=fe(h),f=Cs(fe(d),l.dtype),m=n.data.get(l.dataId).values;for(let b=0;b<f.length;++b){const y=b*p;let x=m[y];for(let w=0;w<p;++w){const v=m[y+w];x=x&&v}f[b]=x}c!=null&&n.disposeIntermediateTensorInfo(l);const g=n.makeTensorInfo(d,l.dtype,f);if(i){const b=jn(d,o),y=er({inputs:{x:g},backend:n,attrs:{shape:b}});return n.disposeIntermediateTensorInfo(g),y}return g}const qze={kernelName:Y0,backendName:"cpu",kernelFunc:jze};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kze(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;gt(s,"any");const o=zt(a,s.shape);let u=o;const c=nr(u,s.shape.length);let l=s;c!=null&&(l=ha({inputs:{x:s},backend:n,attrs:{perm:c}}),u=qn(u.length,s.shape.length)),tr("any",u,l.shape.length);const[d,h]=sr(l.shape,u),p=fe(h),f=Cs(fe(d),l.dtype),m=n.data.get(l.dataId).values;for(let b=0;b<f.length;++b){const y=b*p;let x=m[y];for(let w=0;w<p;++w){const v=m[y+w];x=x||v}f[b]=x}c!=null&&n.disposeIntermediateTensorInfo(l);const g=n.makeTensorInfo(d,l.dtype,f);if(i){const b=jn(d,o),y=er({inputs:{x:g},backend:n,attrs:{shape:b}});return n.disposeIntermediateTensorInfo(g),y}return g}const Xze={kernelName:J0,backendName:"cpu",kernelFunc:Kze};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qze(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;gt(s,"argMax");let i=zt(a,s.shape);const o=nr(i,s.shape.length);let u=s;const c=[];o!=null&&(u=ha({inputs:{x:s},backend:n,attrs:{perm:o}}),c.push(u),i=qn(i.length,u.shape.length)),i=[i[0]],tr("argMax",i,u.shape.length);const[l,d]=sr(u.shape,i),h=fe(l),p=Cs(h,"int32"),f=fe(d),m=n.data.get(u.dataId).values;for(let g=0;g<p.length;++g){const b=g*f;let y=m[b],x=0;for(let w=0;w<f;++w){const v=m[b+w];v>y&&(y=v,x=w)}p[g]=x}return c.forEach(g=>n.disposeIntermediateTensorInfo(g)),n.makeTensorInfo(l,"int32",p)}const Yze={kernelName:Z0,backendName:"cpu",kernelFunc:Qze};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jze(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;gt(s,"argMin");let i=zt(a,s.shape);const o=nr(i,s.shape.length);let u=s;const c=[];o!=null&&(u=ha({inputs:{x:s},backend:n,attrs:{perm:o}}),c.push(u),i=qn(i.length,u.shape.length)),i=[i[0]],tr("argMin",i,u.shape.length);const[l,d]=sr(u.shape,i),h=fe(l),p=Cs(h,"int32"),f=fe(d),m=n.data.get(u.dataId).values;for(let g=0;g<p.length;++g){const b=g*f;let y=m[b],x=0;for(let w=0;w<f;++w){const v=m[b+w];v<y&&(y=v,x=w)}p[g]=x}return c.forEach(g=>n.disposeIntermediateTensorInfo(g)),n.makeTensorInfo(l,"int32",p)}const Zze={kernelName:e1,backendName:"cpu",kernelFunc:Jze};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eWe=Fn(Bm,e=>Math.asin(e)),tWe={kernelName:Bm,backendName:"cpu",kernelFunc:eWe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nWe=Fn(zm,e=>Math.asinh(e)),rWe={kernelName:zm,backendName:"cpu",kernelFunc:nWe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sWe=Fn(Wm,e=>Math.atan(e)),aWe={kernelName:Wm,backendName:"cpu",kernelFunc:sWe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iWe=Nr((e,t)=>Math.atan2(e,t)),oWe=Yr(Um,iWe),lWe={kernelName:Um,backendName:"cpu",kernelFunc:oWe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uWe=Fn(Vm,e=>Math.atanh(e)),cWe={kernelName:Vm,backendName:"cpu",kernelFunc:uWe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g$(e,t,n,r,s,a){const i=s.strideHeight,o=s.strideWidth,u=s.dilationHeight,c=s.dilationWidth,l=s.effectiveFilterHeight,d=s.effectiveFilterWidth,h=s.padInfo.top,p=s.padInfo.left,f=a==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=Yt(s.outShape,n),g=m.values,b=s.outShape[1]*s.outShape[2]*s.outShape[3],y=s.outShape[2]*s.outShape[3],x=s.outShape[3];for(let w=0;w<s.batchSize;++w){const v=w*b,I=w*r[0];for(let N=0;N<s.inChannels;++N)for(let T=0;T<s.outHeight;++T){const E=T*i-h,A=Math.max(0,E),k=Math.min(s.inHeight,l+E),C=v+T*y;for(let M=0;M<s.outWidth;++M){const L=M*o-p,O=Math.max(0,L),B=Math.min(s.inWidth,d+L);let G=f,z=0,q=0;for(let K=A;K<k;K+=u){const ee=I+K*r[1];for(let Y=O;Y<B;Y+=c){const de=ee+Y*r[2],ue=e[de+N];a==="max"&&ue>G?G=ue:a==="avg"&&(z+=ue,q++)}if(isNaN(G))break}const Q=C+M*x+N;g[Q]=a==="avg"?z/q:G}}}return m}function _H(e,t,n,r,s=!1,a=!1){const i=Yt(r.outShape,"int32"),o=r.strideHeight,u=r.strideWidth,c=r.dilationHeight,l=r.dilationWidth,d=r.effectiveFilterHeight,h=r.effectiveFilterWidth,p=r.padInfo.top,f=r.padInfo.left,m=Yt(t,n,e);for(let g=0;g<r.batchSize;++g)for(let b=0;b<r.inChannels;++b)for(let y=0;y<r.outHeight;++y){const x=y*o-p;let w=x;for(;w<0;)w+=c;const v=Math.min(r.inHeight,d+x);for(let I=0;I<r.outWidth;++I){const N=I*u-f;let T=N;for(;T<0;)T+=l;const E=Math.min(r.inWidth,h+N);let A=Number.NEGATIVE_INFINITY,k=-1;for(let C=w;C<v;C+=c){const M=C-x;for(let L=T;L<E;L+=l){const O=L-N,B=m.get(g,C,L,b);B>A&&(A=B,s?k=a?((g*r.inHeight+C)*r.inWidth+L)*r.inChannels+b:(C*r.inWidth+L)*r.inChannels+b:k=M*h+O)}}i.set(k,g,y,I,b)}}return i}function DH(e,t,n,r,s,a){const i=s.strideDepth,o=s.strideHeight,u=s.strideWidth,c=s.dilationDepth,l=s.dilationHeight,d=s.dilationWidth,h=s.effectiveFilterDepth,p=s.effectiveFilterHeight,f=s.effectiveFilterWidth,m=s.padInfo.front,g=s.padInfo.top,b=s.padInfo.left,y=a==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=Yt(s.outShape,n),w=x.values,v=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],I=s.outShape[2]*s.outShape[3]*s.outShape[4],N=s.outShape[3]*s.outShape[4],T=s.outShape[4];for(let E=0;E<s.batchSize;++E){const A=E*v,k=E*r[0];for(let C=0;C<s.inChannels;++C)for(let M=0;M<s.outDepth;++M){const L=M*i-m;let O=L;for(;O<0;)O+=c;const B=Math.min(s.inDepth,h+L),G=A+M*I;for(let z=0;z<s.outHeight;++z){const q=z*o-g;let Q=q;for(;Q<0;)Q+=l;const K=Math.min(s.inHeight,p+q),ee=G+z*N;for(let Y=0;Y<s.outWidth;++Y){const de=Y*u-b;let ue=de;for(;ue<0;)ue+=d;const Ie=Math.min(s.inWidth,f+de),Ee=ee+Y*T;let ve=y,Ae=0,Be=0;for(let qe=O;qe<B;qe+=c){const ut=k+qe*r[1];for(let nt=Q;nt<K;nt+=l){const rt=ut+nt*r[2];for(let ze=ue;ze<Ie;ze+=d){const ct=rt+ze*r[3],ht=e[ct+C];if(a==="max"&&ht>ve?ve=ht:a==="avg"&&(Ae+=ht,Be++),isNaN(ve))break}if(isNaN(ve))break}if(isNaN(ve))break}const Ue=Ee+C;w[Ue]=a==="avg"?Ae/Math.max(Be,1):ve}}}}return x}function dWe(e,t){const n=Yt(t.outShape,"int32"),r=t.strideDepth,s=t.strideHeight,a=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,u=t.dilationWidth,c=t.effectiveFilterDepth,l=t.effectiveFilterHeight,d=t.effectiveFilterWidth,h=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let b=0;b<t.outDepth;++b){const y=b*r-h;let x=y;for(;x<0;)x+=i;const w=Math.min(t.inDepth,c+y);for(let v=0;v<t.outHeight;++v){const I=v*s-p;let N=I;for(;N<0;)N+=o;const T=Math.min(t.inHeight,l+I);for(let E=0;E<t.outWidth;++E){const A=E*a-f;let k=A;for(;k<0;)k+=u;const C=Math.min(t.inWidth,d+A);let M=Number.NEGATIVE_INFINITY,L=-1;for(let O=x;O<w;O+=i){const B=O-y;for(let G=N;G<T;G+=o){const z=G-I;for(let q=k;q<C;q+=u){const Q=q-A,K=e.get(m,O,G,q,g);K>=M&&(M=K,L=B*l*d+z*l+Q)}}}n.set(L,m,b,v,E,g)}}}return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hWe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;gt(s,"avgPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:u}=r,c=1;U(bs(i,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const l=Es(s.shape,a,i,c,o,u);let d;if(l.filterWidth===1&&l.filterHeight===1&&Nn(l.inShape,l.outShape))d=Fo({inputs:{x:s},backend:n});else{const h=n.data.get(s.dataId).values,p=ot(s.shape),f=g$(h,s.shape,s.dtype,p,l,"avg");d=n.makeTensorInfo(l.outShape,s.dtype,f.values)}return d}const pWe={kernelName:Gm,backendName:"cpu",kernelFunc:hWe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fWe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:u,dataFormat:c}=r;gt(s,"avgPool3d");const l=Qa(s.shape,a,i,1,o,u,c),d=n.data.get(s.dataId).values,h=DH(d,s.shape,s.dtype,ot(s.shape),l,"avg");return n.makeTensorInfo(h.shape,"float32",h.values)}const mWe={kernelName:t1,backendName:"cpu",kernelFunc:fWe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gWe(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:u,dimRoundingMode:c}=r;gt([s,a],"avgPool3DGrad");const l=Qa(a.shape,i,o,1,u,c),d=l.strideDepth,h=l.strideHeight,p=l.strideWidth,f=l.filterDepth,m=l.filterHeight,g=l.filterWidth,b=l.dilationDepth,y=l.dilationHeight,x=l.dilationWidth,w=l.effectiveFilterDepth,v=l.effectiveFilterHeight,I=l.effectiveFilterWidth,N=w-1-l.padInfo.front,T=I-1-l.padInfo.left,E=v-1-l.padInfo.top,A=Yt(a.shape,"float32"),k=1/(f*m*g),C=n.bufferSync(s);for(let M=0;M<l.batchSize;++M)for(let L=0;L<l.inChannels;++L)for(let O=0;O<l.inDepth;++O)for(let B=0;B<l.inHeight;++B)for(let G=0;G<l.inWidth;++G){const z=O-N,q=B-E,Q=G-T;let K=0;for(let ee=0;ee<w;ee+=b){const Y=(z+ee)/d;if(!(Y<0||Y>=l.outDepth||Math.floor(Y)!==Y))for(let de=0;de<v;de+=y){const ue=(q+de)/h;if(!(ue<0||ue>=l.outHeight||Math.floor(ue)!==ue))for(let Ie=0;Ie<I;Ie+=x){const Ee=(Q+Ie)/p;if(Ee<0||Ee>=l.outWidth||Math.floor(Ee)!==Ee)continue;const ve=C.get(M,Y,ue,Ee,L);K+=ve}}}A.set(K*k,M,O,B,G,L)}return n.makeTensorInfo(A.shape,A.dtype,A.values)}const bWe={kernelName:Wv,backendName:"cpu",kernelFunc:gWe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yWe(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a;gt([s,a],"avgPoolGrad");const{filterSize:o,strides:u,pad:c}=r,l=Es(i.shape,o,u,1,c),d=l.strideHeight,h=l.strideWidth,p=l.filterHeight,f=l.filterWidth,m=l.dilationHeight,g=l.dilationWidth,b=l.effectiveFilterHeight,y=l.effectiveFilterWidth,x=y-1-l.padInfo.left,w=b-1-l.padInfo.top,v=Yt(i.shape,"float32"),I=1/(p*f),N=n.data.get(s.dataId).values,T=Yt(s.shape,"float32",N);for(let E=0;E<l.batchSize;++E)for(let A=0;A<l.inChannels;++A)for(let k=0;k<l.inHeight;++k)for(let C=0;C<l.inWidth;++C){const M=k-w,L=C-x;let O=0;for(let B=0;B<b;B+=m){const G=(M+B)/d;if(!(G<0||G>=l.outHeight||Math.floor(G)!==G))for(let z=0;z<y;z+=g){const q=(L+z)/h;if(q<0||q>=l.outWidth||Math.floor(q)!==q)continue;const Q=T.get(E,G,q,A);O+=Q}}v.set(O*I,E,k,C,A)}return n.makeTensorInfo(v.shape,v.dtype,v.values)}const xWe={kernelName:zv,backendName:"cpu",kernelFunc:yWe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wWe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,scale:a,offset:i,mean:o,variance:u}=t;U(o.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),U(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),U(a==null||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),gt([s,o,u,a,i],"batchNorm");let{varianceEpsilon:c}=r;c==null&&(c=.001);const l=n.data.get(s.dataId).values,d=n.data.get(o.dataId).values,h=n.data.get(u.dataId).values,p=a?n.data.get(a.dataId).values:new Float32Array([1]),f=i?n.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(l.length),g=f.length,b=p.length,y=h.length,x=d.length;let w=0,v=0,I=0,N=0;for(let T=0;T<l.length;++T)m[T]=f[w++]+(l[T]-d[v++])*p[I++]/Math.sqrt(h[N++]+c),w>=g&&(w=0),v>=x&&(v=0),I>=b&&(I=0),N>=y&&(N=0);return n.makeTensorInfo(s.shape,s.dtype,m)}const vWe={kernelName:ug,backendName:"cpu",kernelFunc:wWe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IWe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:i}=r;gt([s],"batchToSpaceND");const o=a.reduce((b,y)=>b*y),u=np(s.shape,a,o),c=rp(u.length,a.length),l=sp(s.shape,a,o),d=CI(i,a.length),h=SI(l,i,a.length),p=er({inputs:{x:s},backend:n,attrs:{shape:u}}),f=ha({inputs:{x:p},backend:n,attrs:{perm:c}}),m=er({inputs:{x:f},backend:n,attrs:{shape:l}}),g=fd({inputs:{x:m},backend:n,attrs:{begin:d,size:h}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}const kWe={kernelName:n1,backendName:"cpu",kernelFunc:IWe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CWe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i}=r,o=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,c=a$(o,u,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,c)}const SWe={kernelName:r1,backendName:"cpu",kernelFunc:CWe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NWe(e){const{inputs:t,backend:n}=e,{s0:r,s1:s}=t,a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,o=Ot(Array.from(a),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}const TWe={kernelName:cE,backendName:"cpu",kernelFunc:NWe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EWe=Fn(Qh,(e,t)=>{const n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e}),AWe={kernelName:Qh,backendName:"cpu",kernelFunc:EWe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $We=e=>{const{x:t}=e.inputs,n=e.backend,r=new Float32Array(fe(t.shape)),s=n.data.get(t.dataId),a=s.complexTensorInfos.real,i=s.complexTensorInfos.imag,o=n.data.get(a.dataId).values,u=n.data.get(i.dataId).values;for(let c=0;c<o.length;c++){const l=o[c],d=u[c];r[c]=Math.hypot(l,d)}return n.makeOutput(r,t.shape,"float32")},RWe={kernelName:Uv,backendName:"cpu",kernelFunc:$We};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lf(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.imag,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}const _We={kernelName:xE,backendName:"cpu",kernelFunc:lf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uf(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,a=zt(s,t[0].shape)[0],i=t.map(m=>m.shape);vI(i,a);let o=Ga(t.map(m=>m.shape),a);if(fe(o)===0)return n.makeTensorInfo(o,t[0].dtype,[]);const u=t.filter(m=>fe(m.shape)>0);if(u.length===1)return Fo({inputs:{x:u[0]},backend:n});if(u[0].dtype==="complex64"){const m=u.map(w=>pd({inputs:{input:w},backend:n})),g=u.map(w=>lf({inputs:{input:w},backend:n})),b=uf({inputs:m,backend:n,attrs:{axis:a}}),y=uf({inputs:g,backend:n,attrs:{axis:a}}),x=va({inputs:{real:b,imag:y},backend:n});return m.forEach(w=>n.disposeIntermediateTensorInfo(w)),g.forEach(w=>n.disposeIntermediateTensorInfo(w)),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(y),x}const c=u.map(m=>{const b=[-1,fe(m.shape.slice(a))];return er({inputs:{x:m},backend:n,attrs:{shape:b}})}),l=c.map(m=>({vals:n.data.get(m.dataId).values,shape:m.shape}));o=Ga(c.map(m=>m.shape),1);const d=c[0].shape[0]===1,h=i$(l,o,t[0].dtype,d),p=Ga(u.map(m=>m.shape),a),f=n.makeTensorInfo(p,t[0].dtype,h);return c.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}const DWe={kernelName:s1,backendName:"cpu",kernelFunc:uf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FH(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dataFormat:u,dilations:c,dimRoundingMode:l}=r;gt([s,a],"conv2d");const d=to(u),h=yr(s.shape,a.shape,i,c,o,l,!1,d),p=h.filterHeight,f=h.filterWidth,m=h.dilationHeight,g=h.dilationWidth,b=h.padInfo.left,y=h.padInfo.top,x=h.dataFormat==="channelsLast",w=new ms(h.outShape,s.dtype),v=ot(s.shape),I=ot(a.shape),N=v[0],T=x?v[1]:v[2],E=x?v[2]:1,A=x?1:v[1],k=w.strides[0],C=x?w.strides[1]:w.strides[2],M=x?w.strides[2]:1,L=x?1:w.strides[1],O=n.data.get(s.dataId).values,B=n.data.get(a.dataId).values,G=w.values;for(let z=0;z<h.batchSize;++z){const q=z*N,Q=z*k;for(let K=0;K<h.outHeight;++K){const ee=Q+K*C,Y=K*h.strideHeight-y;for(let de=0;de<p;++de){const ue=Y+de*m;if(ue<0||ue>=h.inHeight)continue;const Ie=de*I[0],Ee=q+ue*T;for(let ve=0;ve<h.outWidth;++ve){const Ae=ee+ve*M,Be=ve*h.strideWidth-b;for(let Ue=0;Ue<f;++Ue){const qe=Be+Ue*g;if(qe<0||qe>=h.inWidth)continue;const ut=Ie+Ue*I[1],nt=Ee+qe*E;let rt=ut;for(let ze=0;ze<h.inChannels;++ze){const ct=O[nt+ze*A];for(let ht=0;ht<h.outChannels;++ht)G[Ae+ht*L]+=ct*B[rt+ht];rt+=h.outChannels}}}}}}return n.makeTensorInfo(w.shape,w.dtype,G)}const FWe={kernelName:Km,backendName:"cpu",kernelFunc:FH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MWe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,dataFormat:u,dimRoundingMode:c,filterShape:l}=r;gt([s,a],"conv2dBackpropFilter");const d=to(u),h=yr(s.shape,l,i,1,o,c,!1,d),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=h,b=h.dataFormat==="channelsLast",y=new ms(h.filterShape,"float32"),x=h.padInfo.left,w=h.padInfo.top,v=n.data.get(s.dataId).values,I=n.data.get(a.dataId).values,N=new ms(s.shape,s.dtype,v),T=new ms(a.shape,a.dtype,I);for(let E=0;E<m;++E){const A=Math.max(0,Math.ceil((w-E)/p)),k=Math.min(h.outHeight,(h.inHeight+w-E)/p);for(let C=0;C<g;++C){const M=Math.max(0,Math.ceil((x-C)/f)),L=Math.min(h.outWidth,(h.inWidth+x-C)/f);for(let O=0;O<h.inChannels;++O)for(let B=0;B<h.outChannels;++B){let G=0;for(let z=0;z<h.batchSize;++z)for(let q=A;q<k;++q){const Q=E+q*p-w;for(let K=M;K<L;++K){const ee=C+K*f-x;b?G+=N.get(z,Q,ee,O)*T.get(z,q,K,B):G+=N.get(z,O,Q,ee)*T.get(z,B,q,K)}}y.set(G,E,C,O,B)}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}const OWe={kernelName:hE,backendName:"cpu",kernelFunc:MWe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LWe(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{inputShape:i,strides:o,pad:u,dataFormat:c,dimRoundingMode:l}=r;gt([s,a],"conv2dBackpropInput");const d=ot(a.shape),h=ot(s.shape);let p=to(c);const f=yr(i,a.shape,o,1,u,l,!1,p),m=new ms(f.inShape,"float32"),g=m.values,b=n.data.get(s.dataId).values,y=n.data.get(a.dataId).values,[x,w,v]=d,{batchSize:I,filterHeight:N,filterWidth:T,inChannels:E,inHeight:A,inWidth:k,outChannels:C,outHeight:M,outWidth:L,strideHeight:O,strideWidth:B}=f;p=f.dataFormat;const G=N-1-f.padInfo.top,z=T-1-f.padInfo.left,q=p==="channelsLast",Q=m.strides[0],K=q?m.strides[1]:m.strides[2],ee=q?m.strides[2]:1,Y=q?1:m.strides[1],de=h[0],ue=q?h[1]:h[2],Ie=q?h[2]:1,Ee=q?1:h[1];for(let ve=0;ve<I;++ve)for(let Ae=0;Ae<E;++Ae)for(let Be=0;Be<A;++Be){const Ue=Be-G,qe=Math.max(0,Math.ceil(Ue/O)),ut=Math.min(M,(N+Ue)/O);for(let nt=0;nt<k;++nt){const rt=nt-z,ze=Math.max(0,Math.ceil(rt/B)),ct=Math.min(L,(T+rt)/B);let ht=0;for(let St=qe;St<ut;++St){const pn=St*O-Ue;for(let jt=ze;jt<ct;++jt){const nn=jt*B-rt,wn=de*ve+ue*St+Ie*jt,Tt=x*(N-1-pn)+w*(T-1-nn)+v*Ae;for(let vn=0;vn<C;++vn){const Kt=b[wn+Ee*vn],an=y[Tt+vn];ht+=Kt*an}}}const yn=Q*ve+K*Be+ee*nt+Y*Ae;g[yn]=ht}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}const PWe={kernelName:Xm,backendName:"cpu",kernelFunc:LWe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BWe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:u}=r;gt([s,a],"conv3d");const c=eo(s.shape,a.shape,i,u,o),{filterDepth:l,filterHeight:d,filterWidth:h,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=c,b=g.front,y=g.left,x=g.top,w=new ms(c.outShape,s.dtype),v=n.data.get(s.dataId).values,I=n.data.get(a.dataId).values,N=w.values,T=ot(s.shape),E=ot(a.shape);for(let A=0;A<c.batchSize;++A){const k=A*T[0],C=A*w.strides[0];for(let M=0;M<c.outDepth;++M){const L=C+M*w.strides[1],O=M*c.strideDepth-b;for(let B=0;B<l;++B){const G=O+B*p;if(G<0||G>=c.inDepth)continue;const z=B*E[0],q=k+G*T[1];for(let Q=0;Q<c.outHeight;++Q){const K=L+Q*w.strides[2],ee=Q*c.strideHeight-x;for(let Y=0;Y<d;++Y){const de=ee+Y*f;if(de<0||de>=c.inHeight)continue;const ue=z+Y*E[1],Ie=q+de*T[2];for(let Ee=0;Ee<c.outWidth;++Ee){const ve=K+Ee*c.outChannels,Ae=Ee*c.strideWidth-y;for(let Be=0;Be<h;++Be){const Ue=Ae+Be*m;if(Ue<0||Ue>=c.inWidth)continue;const qe=ue+Be*E[2],ut=Ie+Ue*c.inChannels;let nt=qe;for(let rt=0;rt<c.inChannels;++rt){const ze=v[ut+rt];for(let ct=0;ct<c.outChannels;++ct)N[ve+ct]+=ze*I[nt+ct];nt+=c.outChannels}}}}}}}}return n.makeTensorInfo(w.shape,w.dtype,w.values)}const zWe={kernelName:Qm,backendName:"cpu",kernelFunc:BWe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WWe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,filterShape:u}=r;gt([s,a],"conv3dBackpropFilterV2");const c=ot(s.shape),l=ot(a.shape),d=eo(s.shape,u,i,1,o),h=d.strideDepth,p=d.strideHeight,f=d.strideWidth,m=d.filterDepth,g=d.filterHeight,b=d.filterWidth,y=new ms(d.filterShape,"float32"),x=y.values,[w,v,I,N]=y.strides,T=n.data.get(a.dataId).values,[E,A,k,C]=l,M=n.data.get(s.dataId).values,[L,O,B,G]=c,z=d.padInfo.front,q=d.padInfo.left,Q=d.padInfo.top;for(let K=0;K<m;++K){const ee=Math.max(0,Math.ceil((z-K)/h)),Y=Math.min(d.outDepth,(d.inDepth+z-K)/h),de=K*w;for(let ue=0;ue<g;++ue){const Ie=Math.max(0,Math.ceil((Q-ue)/p)),Ee=Math.min(d.outHeight,(d.inHeight+Q-ue)/p),ve=ue*v+de;for(let Ae=0;Ae<b;++Ae){const Be=Math.max(0,Math.ceil((q-Ae)/f)),Ue=Math.min(d.outWidth,(d.inWidth+q-Ae)/f),qe=Ae*I+ve;for(let ut=0;ut<d.inChannels;++ut){const nt=ut*N+qe;for(let rt=0;rt<d.outChannels;++rt){let ze=0;for(let ct=0;ct<d.batchSize;++ct){const ht=ct*L,yn=ct*E;for(let St=ee;St<Y;++St){const jt=(K+St*h-z)*O+ht,nn=St*A+yn;for(let wn=Ie;wn<Ee;++wn){const vn=(ue+wn*p-Q)*B+jt,Kt=wn*k+nn;for(let an=Be;an<Ue;++an){const Re=(Ae+an*f-q)*G+vn,re=an*C+Kt;ze+=M[Re+ut]*T[re+rt]}}}}x[nt+rt]=ze}}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}const VWe={kernelName:a1,backendName:"cpu",kernelFunc:WWe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UWe(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:i,strides:o,inputShape:u}=r;gt([s],"conv3dBackpropInputV2");const c=ot(s.shape),l=ot(a.shape),d=eo(u,a.shape,o,1,i),h=new ms(d.inShape,"float32"),p=h.values,[f,m,g,b]=h.strides,y=n.data.get(s.dataId).values,[x,w,v,I]=c,N=n.data.get(a.dataId).values,[T,E,A,k]=l,{batchSize:C,filterDepth:M,filterHeight:L,filterWidth:O,inChannels:B,inDepth:G,inHeight:z,inWidth:q,outChannels:Q,outDepth:K,outHeight:ee,outWidth:Y,strideDepth:de,strideHeight:ue,strideWidth:Ie}=d,Ee=M-1-d.padInfo.front,ve=L-1-d.padInfo.top,Ae=O-1-d.padInfo.left;for(let Be=0;Be<C;++Be)for(let Ue=0;Ue<B;++Ue)for(let qe=0;qe<G;++qe){const ut=qe-Ee,nt=Math.max(0,Math.ceil(ut/de)),rt=Math.min(K,(M+ut)/de);for(let ze=0;ze<z;++ze){const ct=ze-ve,ht=Math.max(0,Math.ceil(ct/ue)),yn=Math.min(ee,(L+ct)/ue);for(let St=0;St<q;++St){const pn=St-Ae,jt=Math.max(0,Math.ceil(pn/Ie)),nn=Math.min(Y,(O+pn)/Ie);let wn=0;for(let Tt=nt;Tt<rt;++Tt){const vn=Tt*de-ut;for(let Kt=ht;Kt<yn;++Kt){const an=Kt*ue-ct;for(let xr=jt;xr<nn;++xr){const Re=xr*Ie-pn,re=x*Be+w*Tt+v*Kt+I*xr,$e=T*(M-1-vn)+E*(L-1-an)+A*(O-1-Re)+k*Ue;for(let Oe=0;Oe<Q;++Oe){const tt=y[re+Oe],Ke=N[$e+Oe];wn+=tt*Ke}}}}p[f*Be+m*qe+g*ze+b*St+Ue]=wn}}}return n.makeTensorInfo(h.shape,h.dtype,h.values)}const GWe={kernelName:i1,backendName:"cpu",kernelFunc:UWe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HWe=Fn(Ym,e=>Math.cos(e)),jWe={kernelName:Ym,backendName:"cpu",kernelFunc:HWe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qWe=Fn(Jm,e=>Math.cosh(e)),KWe={kernelName:Jm,backendName:"cpu",kernelFunc:qWe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XWe(e){const{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:i}=t,{cropSize:o,method:u,extrapolationValue:c}=r,[l,d,h,p]=s.shape,f=a.shape[0],[m,g]=o,b=Yt([f,m,g,p],"float32"),y=n.data.get(a.dataId).values,x=n.data.get(i.dataId).values,w=n.data.get(s.dataId).values,v=ot(s.shape),I=ot(b.shape);for(let N=0;N<f;N++){const T=N*4,E=y[T],A=y[T+1],k=y[T+2],C=y[T+3],M=x[N];if(M>=l)continue;const L=m>1?(k-E)*(d-1)/(m-1):0,O=g>1?(C-A)*(h-1)/(g-1):0;for(let B=0;B<m;B++){const G=m>1?E*(d-1)+B*L:.5*(E+k)*(d-1);if(G<0||G>d-1){for(let z=0;z<g;z++)for(let q=0;q<p;q++){const Q=q+z*I[2]+B*I[1]+N*I[0];b.values[Q]=c}continue}if(u==="bilinear"){const z=Math.floor(G),q=Math.ceil(G),Q=G-z;for(let K=0;K<g;K++){const ee=g>1?A*(h-1)+K*O:.5*(A+C)*(h-1);if(ee<0||ee>h-1){for(let Ie=0;Ie<p;Ie++){const Ee=Ie+K*I[2]+B*I[1]+N*I[0];b.values[Ee]=c}continue}const Y=Math.floor(ee),de=Math.ceil(ee),ue=ee-Y;for(let Ie=0;Ie<p;Ie++){let Ee=Ie+Y*v[2]+z*v[1]+M*v[0];const ve=w[Ee];Ee=Ie+de*v[2]+z*v[1]+M*v[0];const Ae=w[Ee];Ee=Ie+Y*v[2]+q*v[1]+M*v[0];const Be=w[Ee];Ee=Ie+de*v[2]+q*v[1]+M*v[0];const Ue=w[Ee],qe=ve+(Ae-ve)*ue,ut=Be+(Ue-Be)*ue;Ee=Ie+K*I[2]+B*I[1]+N*I[0],b.values[Ee]=qe+(ut-qe)*Q}}}else for(let z=0;z<g;++z){const q=g>1?A*(h-1)+z*O:.5*(A+C)*(h-1);if(q<0||q>h-1){for(let ee=0;ee<p;ee++){const Y=ee+z*I[2]+B*I[1]+N*I[0];b.values[Y]=c}continue}const Q=Math.round(q),K=Math.round(G);for(let ee=0;ee<p;ee++){const Y=ee+Q*v[2]+K*v[1]+M*v[0],de=ee+z*I[2]+B*I[1]+N*I[0];b.values[de]=w[Y]}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}const QWe={kernelName:l1,backendName:"cpu",kernelFunc:XWe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YWe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;gt(s,"cumprod");const u=nr([a],s.shape.length);let c=s;u!=null&&(c=ha({inputs:{x:s},backend:n,attrs:{perm:u}}));const l=qn(1,s.shape.length)[0];if(l!==c.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${l}`);const d=$a(c.dtype,"int32"),h=oE(fe(c.shape),d),p=n.data.get(c.dataId).values,f=c.shape[c.shape.length-1],m=o?(b,y)=>b+f-y-1:(b,y)=>b+y;for(let b=0;b<p.length;b+=f)for(let y=0;y<f;y++){const x=m(b,y);if(y===0)h[x]=i?1:p[x];else{const w=m(b,y-1);h[x]=i?p[w]*h[w]:p[x]*h[w]}}const g=n.makeTensorInfo(c.shape,d,h);if(u!=null){const b=Bo(u),y=ha({inputs:{x:g},backend:n,attrs:{perm:b}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(c),y}return g}const JWe={kernelName:o1,backendName:"cpu",kernelFunc:YWe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZWe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;gt(s,"cumsum");const u=nr([a],s.shape.length);let c=s;u!=null&&(c=ha({inputs:{x:s},backend:n,attrs:{perm:u}}));const l=qn(1,s.shape.length)[0];if(l!==c.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${l}`);const d=$a(c.dtype,"int32"),h=Cs(fe(c.shape),d),p=n.data.get(c.dataId).values,f=c.shape[c.shape.length-1],m=o?(b,y)=>b+f-y-1:(b,y)=>b+y;for(let b=0;b<p.length;b+=f)for(let y=0;y<f;y++){const x=m(b,y);if(y===0)h[x]=i?0:p[x];else{const w=m(b,y-1);h[x]=i?p[w]+h[w]:p[x]+h[w]}}const g=n.makeTensorInfo(c.shape,d,h);if(u!=null){const b=Bo(u),y=ha({inputs:{x:g},backend:n,attrs:{perm:b}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(c),y}return g}const eVe={kernelName:Zm,backendName:"cpu",kernelFunc:ZWe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tVe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i,binaryOutput:o}=r;if(s.shape.length===1){const u=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,l=a$(u,c,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,l)}else if(s.shape.length===2){const u=n.bufferSync(s),c=n.bufferSync(a),l=VG(u,c,i,o);return n.makeTensorInfo(l.shape,a.dtype,l.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}const nVe={kernelName:Gv,backendName:"cpu",kernelFunc:tVe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rVe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:i}=r;U(i==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);const o=s.shape[0],u=s.shape[1],c=s.shape[2],l=s.shape[3],d=u*a,h=c*a,p=l/(a*a),f=n.data.get(s.dataId).values,m=new Float32Array(o*d*h*p);let g=0;for(let b=0;b<o;++b)for(let y=0;y<d;++y){const x=Math.floor(y/a),w=y%a;for(let v=0;v<h;++v){const I=Math.floor(v/a),N=v%a,T=(w*a+N)*p;for(let E=0;E<p;++E){const k=E+T+l*(I+c*(x+u*b));m[g++]=f[k]}}}return n.makeTensorInfo([o,d,h,p],s.dtype,m)}const sVe={kernelName:u1,backendName:"cpu",kernelFunc:rVe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MH(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:u,dimRoundingMode:c}=r;gt([s,a],"depthwiseConv2DNative");const l=ot(s.shape),d=ot(a.shape);let h=u;h==null&&(h=[1,1]),U(bs(i,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${h}'`);const p=yr(s.shape,a.shape,i,h,o,c,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:b,padInfo:y}=p,x=y.left,w=y.top,v=p.outChannels/p.inChannels,I=new ms(p.outShape,s.dtype),N=n.data.get(s.dataId).values,T=n.data.get(a.dataId).values,E=I.values;for(let A=0;A<p.batchSize;++A){const k=A*l[0],C=A*I.strides[0];for(let M=0;M<p.outHeight;++M){const L=C+M*I.strides[1],O=M*p.strideHeight-w;for(let B=0;B<f;++B){const G=O+B*g;if(G<0||G>=p.inHeight)continue;const z=B*d[0],q=k+G*l[1];for(let Q=0;Q<p.outWidth;++Q){const K=L+Q*I.strides[2],ee=Q*p.strideWidth-x;for(let Y=0;Y<m;++Y){const de=ee+Y*b;if(de<0||de>=p.inWidth)continue;const ue=z+Y*d[1],Ie=q+de*p.inChannels;let Ee=K,ve=ue;for(let Ae=0;Ae<p.inChannels;++Ae){const Be=N[Ie+Ae];for(let Ue=0;Ue<v;++Ue)E[Ee+Ue]+=Be*T[ve+Ue];Ee+=v,ve+=v}}}}}}return n.makeTensorInfo(I.shape,I.dtype,I.values)}const aVe={kernelName:eg,backendName:"cpu",kernelFunc:MH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iVe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,dilations:o,pad:u,dimRoundingMode:c,filterShape:l}=r;gt([s,a],"depthwiseConv2dNativeBackpropFilter");const d=yr(s.shape,l,i,o,u,c,!0),{strideHeight:h,strideWidth:p,filterHeight:f,filterWidth:m}=d,g=new ms(d.filterShape,"float32"),b=d.padInfo.left,y=d.padInfo.top,x=d.outChannels/d.inChannels,w=n.data.get(s.dataId).values,v=new ms(s.shape,s.dtype,w),I=n.data.get(a.dataId).values,N=new ms(a.shape,a.dtype,I);for(let T=0;T<f;++T){const E=Math.max(0,Math.ceil((y-T)/h)),A=Math.min(d.outHeight,(d.inHeight+y-T)/h);for(let k=0;k<m;++k){const C=Math.max(0,Math.ceil((b-k)/p)),M=Math.min(d.outWidth,(d.inWidth+b-k)/p);for(let L=0;L<d.outChannels;++L){const O=Math.trunc(L/x),B=L%x;let G=0;for(let z=0;z<d.batchSize;++z)for(let q=E;q<A;++q){const Q=T+q*h-y;for(let K=C;K<M;++K){const ee=k+K*p-b;G+=v.get(z,Q,ee,O)*N.get(z,q,K,L)}}g.set(G,T,k,O,B)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}const oVe={kernelName:pE,backendName:"cpu",kernelFunc:iVe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lVe(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{strides:i,dilations:o,pad:u,dimRoundingMode:c,inputShape:l}=r;gt([s,a],"depthwiseConv2DNativeBackpropInput");const d=ot(s.shape),h=ot(a.shape),p=yr(l,a.shape,i,o,u,c,!0),f=new ms(p.inShape,"float32"),m=f.values,[g,b,y]=f.strides,x=n.data.get(s.dataId).values,[w,v,I]=d,N=n.data.get(a.dataId).values,[T,E,A]=h,{batchSize:k,filterHeight:C,filterWidth:M,inChannels:L,inHeight:O,inWidth:B,outChannels:G,outHeight:z,outWidth:q,strideHeight:Q,strideWidth:K}=p,ee=C-1-p.padInfo.top,Y=M-1-p.padInfo.left,de=G/L;for(let ue=0;ue<k;++ue)for(let Ie=0;Ie<L;++Ie)for(let Ee=0;Ee<O;++Ee){const ve=Ee-ee,Ae=Math.max(0,Math.ceil(ve/Q)),Be=Math.min(z,(C+ve)/Q);for(let Ue=0;Ue<B;++Ue){const qe=Ue-Y,ut=Math.max(0,Math.ceil(qe/K)),nt=Math.min(q,(M+qe)/K);let rt=0;for(let ze=Ae;ze<Be;++ze){const ct=ze*Q-ve;for(let ht=ut;ht<nt;++ht){const yn=ht*K-qe,St=w*ue+v*ze+I*ht,pn=T*(C-1-ct)+E*(M-1-yn)+A*Ie;for(let jt=0;jt<de;++jt){const nn=Ie*de+jt,wn=x[St+nn],Tt=N[pn+jt];rt+=wn*Tt}}}m[g*ue+b*Ee+y*Ue+Ie]=rt}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}const uVe={kernelName:fE,backendName:"cpu",kernelFunc:lVe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cVe(e){const{inputs:t,backend:n}=e,{x:r}=t,s=fe(r.shape),a=n.data.get(r.dataId).values,i=Yt([s,s],r.dtype),o=i.values;for(let c=0;c<a.length;c++)o[c*s+c]=a[c];const u=[...r.shape,...r.shape];return n.makeTensorInfo(u,i.dtype,i.values)}const dVe={kernelName:mE,backendName:"cpu",kernelFunc:cVe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hVe={kernelName:tg,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,filter:s}=e,{strides:a,pad:i,dilations:o}=n,u=t,c=u.data.get(r.dataId).values,l=r.shape.length,d=u.data.get(s.dataId).values,h=s.shape.length,{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:b,outWidth:y,padInfo:x,strideHeight:w,strideWidth:v,filterHeight:I,filterWidth:N,dilationHeight:T,dilationWidth:E,outShape:A}=Ou(r.shape,s.shape,a,i,"NHWC",o),k=fe(A),C=A.length,M=wr(r.dtype,k);for(let O=0;O<p;++O)for(let B=0;B<b;++B){const G=B*w-x.top;for(let z=0;z<y;++z){const q=z*v-x.left;for(let Q=0;Q<g;++Q){let K=Number.MIN_SAFE_INTEGER;for(let Y=0;Y<I;++Y){const de=G+Y*T;if(de>=0&&de<f)for(let ue=0;ue<N;++ue){const Ie=q+ue*E;if(Ie>=0&&Ie<m){const Ee=Io([O,de,Ie,Q],l,ot(r.shape)),ve=Io([Y,ue,Q],h,ot(s.shape)),Ae=c[Ee]+d[ve];Ae>K&&(K=Ae)}}}const ee=Io([O,B,z,Q],C,ot(A));M[ee]=K}}}return{dataId:u.write(Zh(M,r.dtype),A,r.dtype),shape:A,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pVe={kernelName:Ny,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,filter:s,dy:a}=e,{strides:i,pad:o,dilations:u}=n,c=t,l=Vi(r.shape,c.data.get(r.dataId).values),d=Vi(s.shape,c.data.get(s.dataId).values),{batchSize:h,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:b,padInfo:y,strideHeight:x,strideWidth:w,filterHeight:v,filterWidth:I,dilationHeight:N,dilationWidth:T,outShape:E}=Ou(r.shape,s.shape,i,o,"NHWC",u);U(a.rank===E.length,()=>`Error in ${Ny}, dy must have the same rank as output ${E.length}, but got ${a.rank}`);const A=Vi(E,c.data.get(a.dataId).values),k=Vz(s.shape,s.dtype);for(let M=0;M<h;++M)for(let L=0;L<g;++L){const O=L*x-y.top;for(let B=0;B<b;++B){const G=B*w-y.left;for(let z=0;z<m;++z){let q=Number.MIN_SAFE_INTEGER,Q=0,K=0;for(let ee=0;ee<v;++ee){const Y=O+ee*N;if(Y>=0&&Y<p)for(let de=0;de<I;++de){const ue=G+de*T;if(ue>=0&&ue<f){const Ie=l[M][Y][ue][z]+d[ee][de][z];Ie>q&&(q=Ie,Q=ee,K=de)}}}k[Q][K][z]+=A[M][L][B][z]}}}return{dataId:c.write(Zh(k,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fVe={kernelName:Sy,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,filter:s,dy:a}=e,{strides:i,pad:o,dilations:u}=n,c=t,l=Vi(r.shape,c.data.get(r.dataId).values),d=Vi(s.shape,c.data.get(s.dataId).values),{batchSize:h,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:b,padInfo:y,strideHeight:x,strideWidth:w,filterHeight:v,filterWidth:I,dilationHeight:N,dilationWidth:T,outShape:E}=Ou(r.shape,s.shape,i,o,"NHWC",u);U(a.rank===E.length,()=>`Error in ${Sy}, dy must have the same rank as output ${E.length}, but got ${a.rank}`);const A=Vi(E,c.data.get(a.dataId).values),k=Vz(r.shape,r.dtype);for(let M=0;M<h;++M)for(let L=0;L<g;++L){const O=L*x-y.top;for(let B=0;B<b;++B){const G=B*w-y.left;for(let z=0;z<m;++z){let q=Number.MIN_SAFE_INTEGER,Q=O<0?0:O,K=G<0?0:G;for(let ee=0;ee<v;++ee){const Y=O+ee*N;if(Y>=0&&Y<p)for(let de=0;de<I;++de){const ue=G+de*T;if(ue>=0&&ue<f){const Ie=l[M][Y][ue][z]+d[ee][de][z];Ie>q&&(q=Ie,Q=Y,K=ue)}}}k[M][Q][K][z]+=A[M][L][B][z]}}}return{dataId:c.write(Zh(k,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mVe(e){const{inputs:t,backend:n,attrs:r}=e,{image:s}=t,{canvas:a,options:i}=r,{contextOptions:o,imageOptions:u}=i||{},c=u?.alpha||1,l=o?.contextType||"2d";if(l!=="2d")throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);const d=a.getContext(l,o?.contextAttributes||{});if(d==null)throw new Error(`Could not get the context with ${l} type.`);const[h,p]=s.shape.slice(0,2),f=s.shape.length===2?1:s.shape[2],m=n.data.get(s.dataId).values,g=s.dtype==="float32"?255:1,b=new Uint8ClampedArray(p*h*4);for(let x=0;x<h*p;++x){const w=[0,0,0,255*c];for(let I=0;I<f;I++){const N=m[x*f+I];if(s.dtype==="float32"){if(N<0||N>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${N}.`)}else if(s.dtype==="int32"&&(N<0||N>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${N}.`);f===1?(w[0]=N*g,w[1]=N*g,w[2]=N*g):w[I]=N*g}const v=x*4;b[v+0]=Math.round(w[0]),b[v+1]=Math.round(w[1]),b[v+2]=Math.round(w[2]),b[v+3]=Math.round(w[3])}a.width=p,a.height=h;const y=new ImageData(b,p,h);return d.putImageData(y,0,0),s}const gVe={kernelName:Y_e,backendName:"cpu",kernelFunc:mVe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n2(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;gt(s,"sum");let o;s.dtype==="bool"?o=mu({inputs:{x:s},backend:n,attrs:{dtype:"int32"}}):o=Fo({inputs:{x:s},backend:n});const u=o.shape.length,c=zt(a,o.shape),l=nr(c,u);let d=c,h=o;l!=null&&(h=ha({inputs:{x:o},backend:n,attrs:{perm:l}}),d=qn(d.length,u)),tr("sum",d,h.shape.length);const[p,f]=sr(h.shape,d),m=$a(h.dtype,"int32");let g=Yx(n,p,m);const b=fe(f),y=n.data.get(g.dataId).values,x=n.data.get(h.dataId).values;for(let w=0;w<y.length;++w){const v=w*b;let I=0;for(let N=0;N<b;++N)I+=x[v+N];y[w]=I}if(i){const w=jn(g.shape,c),v=g;g=er({inputs:{x:g},backend:n,attrs:{shape:w}}),n.disposeIntermediateTensorInfo(v)}return n.disposeIntermediateTensorInfo(o),l!=null&&n.disposeIntermediateTensorInfo(h),g}const bVe={kernelName:Kg,backendName:"cpu",kernelFunc:n2};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yVe(e){const{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,a=t,{allDims:i,summedDims:o,idDims:u}=xA(s,a.length);vA(i.length,u,a);const{path:c,steps:l}=IA(o,u),d=l.length;let h=null,p=i.length;const f=[];for(let m=0;m<d;++m){for(const g of l[m]){const{permutationIndices:b,expandDims:y}=wA(p,u[g]);let x;kA(b)?x=a[g]:(x=ha({inputs:{x:a[g]},backend:n,attrs:{perm:b}}),f.push(x));const w=x.shape.slice();for(let v=0;v<y.length;++v)w.splice(y[v],0,1);Nn(x.shape,w)||(x=er({inputs:{x},backend:n,attrs:{shape:w}}),f.push(x)),h===null?h=x:(h=WI({inputs:{a:x,b:h},backend:n}),f.push(h))}m<d-1&&(c[m]>=0&&(h=n2({inputs:{x:h},backend:n,attrs:{axis:c[m]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(const m of f)m!==h&&n.disposeIntermediateTensorInfo(m);return h}const xVe={kernelName:gE,backendName:"cpu",kernelFunc:yVe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wVe(e){const{inputs:t,backend:n}=e,{dy:r,y:s}=t;gt([r,s],"eluGrad");const a=new Float32Array(fe(s.shape)),i=n.data.get(s.dataId).values,o=n.data.get(r.dataId).values;for(let u=0;u<i.length;++u){const c=i[u];c>=0?a[u]=o[u]:a[u]=o[u]*(c+1)}return n.makeTensorInfo(s.shape,"float32",a)}const vVe={kernelName:c1,backendName:"cpu",kernelFunc:wVe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IVe=hA,kVe=pA,CVe=fA,SVe=mA,NVe=gA,TVe=bA,EVe=Fn(sg,e=>{const t=Math.sign(e),n=Math.abs(e),r=1/(1+IVe*n);return t*(1-((((TVe*r+NVe)*r+SVe)*r+CVe)*r+kVe)*r*Math.exp(-n*n))}),AVe={kernelName:sg,backendName:"cpu",kernelFunc:EVe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tw(e){const{inputs:t,backend:n,attrs:r}=e,{input:s}=t,{dim:a}=r,i=s.shape.length,o=s.shape.slice();let u=a;return a<0&&(U(-(i+1)<=a,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+a+1),o.splice(u,0,1),er({inputs:{x:s},backend:n,attrs:{shape:o}})}const $Ve={kernelName:h1,backendName:"cpu",kernelFunc:tw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RVe=Nr((e,t)=>e/t),b$=Yr(ng,RVe),NS={kernelName:ng,backendName:"cpu",kernelFunc:b$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OH(e,t,n){const r=e.shape,s=r[0],a=r[1],i=n.data.get(e.dataId),o=i.complexTensorInfos.real,u=i.complexTensorInfos.imag,c=[s,a],l=fe(c),d=ks("float32",l),h=ks("float32",l);for(let g=0;g<s;g++){const b=fd({inputs:{x:o},backend:n,attrs:{begin:[g,0],size:[1,a]}}),y=fd({inputs:{x:u},backend:n,attrs:{begin:[g,0],size:[1,a]}}),x=va({inputs:{real:b,imag:y},backend:n}),{real:w,imag:v}=_Ve(x,t,n),I=cl(w,v);for(let N=0;N<a;N++){const T=yA(I,N);d[g*a+N]=T.real,h[g*a+N]=T.imag}n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(x)}const p=n.makeTensorInfo(c,"float32",d),f=n.makeTensorInfo(c,"float32",h),m=va({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}function _Ve(e,t,n){const r=fe(e.shape),s=n.data.get(e.dataId),a=n.data.get(s.complexTensorInfos.real.dataId).values,i=n.data.get(s.complexTensorInfos.imag.dataId).values;if(DVe(r)){const o=TS(a,i,r,t,n),u=[e.shape[0],e.shape[1]];if(t){const c=n.makeTensorInfo(u,"float32",o.real),l=n.makeTensorInfo(u,"float32",o.imag),d=n.makeTensorInfo([],"float32",Mu(r,"float32")),h=Fo({inputs:{x:d},backend:n}),p=NS.kernelFunc({inputs:{a:c,b:d},backend:n}),f=NS.kernelFunc({inputs:{a:l,b:h},backend:n}),m=n.data.get(p.dataId).values,g=n.data.get(f.dataId).values;return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),{real:m,imag:g}}return o}else{const o=cl(a,i),u=FVe(o,r,t);return fV(u)}}function DVe(e){return(e&e-1)===0}function TS(e,t,n,r,s){if(n===1)return{real:e,imag:t};const a=cl(e,t),i=n/2,o=mV(a),u=o.real,c=o.imag,l=[u.length],d=s.makeTensorInfo(l,"float32",u),h=s.makeTensorInfo(l,"float32",c),p=va({inputs:{real:d,imag:h},backend:s}),f=gV(a),m=f.real,g=f.imag,b=[m.length],y=s.makeTensorInfo(b,"float32",m),x=s.makeTensorInfo(b,"float32",g),w=va({inputs:{real:y,imag:x},backend:s}),v=TS(u,c,i,r,s),I=v.real,N=v.imag,T=[I.length],E=s.makeTensorInfo(T,"float32",I),A=s.makeTensorInfo(T,"float32",N),k=va({inputs:{real:E,imag:A},backend:s}),C=TS(m,g,i,r,s),M=C.real,L=C.imag,O=[M.length],B=s.makeTensorInfo(O,"float32",M),G=s.makeTensorInfo(O,"float32",L),z=va({inputs:{real:B,imag:G},backend:s}),q=yV(n,r),Q=[q.real.length],K=s.makeTensorInfo(Q,"float32",q.real),ee=s.makeTensorInfo(Q,"float32",q.imag),Y=va({inputs:{real:K,imag:ee},backend:s}),de=WI({inputs:{a:Y,b:z},backend:s}),ue=of({inputs:{a:k,b:de},backend:s}),Ie=f$({inputs:{a:k,b:de},backend:s}),Ee=pd({inputs:{input:ue},backend:s}),ve=pd({inputs:{input:Ie},backend:s}),Ae=lf({inputs:{input:ue},backend:s}),Be=lf({inputs:{input:Ie},backend:s}),Ue=uf({inputs:[Ee,ve],backend:s,attrs:{axis:0}}),qe=uf({inputs:[Ae,Be],backend:s,attrs:{axis:0}}),ut=s.data.get(Ue.dataId).values,nt=s.data.get(qe.dataId).values;return s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(p),s.disposeIntermediateTensorInfo(y),s.disposeIntermediateTensorInfo(x),s.disposeIntermediateTensorInfo(w),s.disposeIntermediateTensorInfo(E),s.disposeIntermediateTensorInfo(A),s.disposeIntermediateTensorInfo(k),s.disposeIntermediateTensorInfo(B),s.disposeIntermediateTensorInfo(G),s.disposeIntermediateTensorInfo(z),s.disposeIntermediateTensorInfo(K),s.disposeIntermediateTensorInfo(ee),s.disposeIntermediateTensorInfo(Y),s.disposeIntermediateTensorInfo(de),s.disposeIntermediateTensorInfo(ue),s.disposeIntermediateTensorInfo(Ie),s.disposeIntermediateTensorInfo(Ee),s.disposeIntermediateTensorInfo(Ae),s.disposeIntermediateTensorInfo(ve),s.disposeIntermediateTensorInfo(Be),s.disposeIntermediateTensorInfo(Ue),s.disposeIntermediateTensorInfo(qe),{real:ut,imag:nt}}function FVe(e,t,n){const r=new Float32Array(t*2);for(let s=0;s<t;s++){let a=0,i=0;for(let o=0;o<t;o++){const u=xV(s*o,t,n),c=yA(e,o);a+=c.real*u.real-c.imag*u.imag,i+=c.real*u.imag+c.imag*u.real}n&&(a/=t,i/=t),bV(r,a,i,s)}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MVe(e){const{inputs:t,backend:n}=e,{input:r}=t,s=fe(r.shape),a=r.shape[r.shape.length-1],i=s/a,o=er({inputs:{x:r},backend:n,attrs:{shape:[i,a]}}),u=OH(o,!1,n),c=er({inputs:{x:u},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),c}const OVe={kernelName:bE,backendName:"cpu",kernelFunc:MVe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y$(e){const{backend:t,attrs:n}=e,{shape:r,value:s,dtype:a}=n,i=a||Kh(s),o=wr(i,fe(r));return PVe(o,s,i),t.makeTensorInfo(r,i,o)}const LVe={kernelName:Hv,backendName:"cpu",kernelFunc:y$};function PVe(e,t,n){e.fill(t)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BVe={kernelName:p1,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,s=n,a=ks(r.dtype,fe(r.shape)),[i,o,u,c]=r.shape,l=s.data.get(r.dataId).values;for(let h=0;h<i;h++){const p=h*u*o*c;for(let f=0;f<o;f++){const m=f*(u*c);for(let g=0;g<u;g++){const b=g*c;for(let y=0;y<c;y++){const x=Math.round(u-g-1),w=p+m+b+y;let v=l[w];if(x>=0&&x<u){const I=x*c,N=p+m+I+y;v=l[N]}a[w]=v}}}}return{dataId:s.write(a,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zVe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:u,pad:c,dataFormat:l,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r;let m=FH({inputs:{x:s,filter:a},backend:n,attrs:{strides:u,pad:c,dataFormat:l,dilations:d,dimRoundingMode:h}});if(i){const g=m;if(l==="NCHW"&&i.shape.length===1&&i.shape[0]!==1){const b=er({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=of({inputs:{a:m,b},backend:n}),n.disposeIntermediateTensorInfo(b)}else m=of({inputs:{a:m,b:i},backend:n});n.disposeIntermediateTensorInfo(g)}if(p){const g=m;if(l==="NCHW"&&p==="prelu"&&o.shape.length===1&&o.shape[0]!==1){const b=er({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=ew(n,m,p,b,f),n.disposeIntermediateTensorInfo(b)}else m=ew(n,m,p,o,f);n.disposeIntermediateTensorInfo(g)}return m}const WVe={kernelName:ef,backendName:"cpu",kernelFunc:zVe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VVe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:u,pad:c,dataFormat:l,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r;let m=MH({inputs:{x:s,filter:a},backend:n,attrs:{strides:u,pad:c,dataFormat:l,dilations:d,dimRoundingMode:h}});if(i){const g=m;m=of({inputs:{a:m,b:i},backend:n}),n.disposeIntermediateTensorInfo(g)}if(p){const g=m;m=ew(n,m,p,o,f),n.disposeIntermediateTensorInfo(g)}return m}const UVe={kernelName:iI,backendName:"cpu",kernelFunc:VVe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GVe(e){const{inputs:t,backend:n}=e,{params:r,indices:s}=t,a=fe(r.shape),i=s.shape,o=i[i.length-1],[u,c,l,d]=gI(r,s);if(c===0)return n.makeTensorInfo(u,r.dtype,[]);const h=n.data.get(s.dataId).values,p=n.bufferSync(r),f=JG(h,p,r.dtype,c,o,l,d,r.shape,a);return n.makeTensorInfo(u,r.dtype,f.values)}const HVe={kernelName:jv,backendName:"cpu",kernelFunc:GVe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jVe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,indices:a}=t,{axis:i,batchDims:o}=r;gt([s,a],"gatherV2");const u=zt(i,s.shape)[0],c=n.data.get(a.dataId).values,l=s.shape[u];for(let w=0;w<c.length;++w){const v=c[w];U(v<=l-1&&v>=0,()=>`GatherV2: the index value ${v} is not in [0, ${l-1}]`)}let d=o;o==null&&(d=0);const h=fe(a.shape),p=AI(s,a,u,d),f=er({inputs:{x:s},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=er({inputs:{x:a},backend:n,attrs:{shape:[p.batchSize,h/p.batchSize]}}),g=[p.batchSize,p.outerSize,h/p.batchSize,p.sliceSize],b=n.bufferSync(m),y=n.bufferSync(f),x=ZG(y,b,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(p.outputShape,x.dtype,x.values)}const qVe={kernelName:f1,backendName:"cpu",kernelFunc:jVe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KVe(e){const{inputs:t,backend:n}=e,{input:r}=t,s=fe(r.shape),a=r.shape[r.shape.length-1],i=s/a,o=er({inputs:{x:r},backend:n,attrs:{shape:[i,a]}}),u=OH(o,!0,n),c=er({inputs:{x:u},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),c}const XVe={kernelName:yE,backendName:"cpu",kernelFunc:KVe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QVe=Fn(hg,e=>Number.isFinite(e)?1:0,"bool"),YVe={kernelName:hg,backendName:"cpu",kernelFunc:QVe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JVe=Fn(pg,e=>Math.abs(e)===1/0?1:0,"bool"),ZVe={kernelName:pg,backendName:"cpu",kernelFunc:JVe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eUe=Fn(fg,e=>Number.isNaN(e)?1:0,"bool"),tUe={kernelName:fg,backendName:"cpu",kernelFunc:eUe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nUe(e){const{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,i=sH(r,s,a);return t.makeTensorInfo([i.length],"float32",i)}const rUe={kernelName:qv,backendName:"cpu",kernelFunc:nUe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sUe=Fn(bg,e=>Math.log1p(e)),aUe={kernelName:bg,backendName:"cpu",kernelFunc:sUe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iUe=Nr((e,t)=>e&&t),oUe=Yr(y1,iUe,null,"bool"),lUe={kernelName:y1,backendName:"cpu",kernelFunc:oUe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uUe=Fn(x1,e=>e?0:1,"bool"),cUe={kernelName:x1,backendName:"cpu",kernelFunc:uUe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dUe=Nr((e,t)=>e||t),hUe=Yr(w1,dUe,null,"bool"),pUe={kernelName:w1,backendName:"cpu",kernelFunc:hUe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fUe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:i,alpha:o,beta:u}=r;gt(s,"LRN");const c=s.shape[3],l=c-1,d=n.data.get(s.dataId).values,h=fe(s.shape),p=new Float32Array(h);function f(m){const g=m%c;let b=m-g+Math.max(0,g-a);const y=m-g+Math.min(g+a,l);let x=0;for(;b<=y;b++){const w=d[b];x+=w*w}return x}for(let m=0;m<h;m++){const g=f(m),b=d[m]*Math.pow(i+o*g,-u);p[m]=b}return n.makeTensorInfo(s.shape,s.dtype,p)}const mUe={kernelName:yg,backendName:"cpu",kernelFunc:fUe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gUe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:i}=t,{depthRadius:o,bias:u,alpha:c,beta:l}=r;gt(i,"LRNGrad");const d=fe(i.shape),h=i.shape[3],p=n.data.get(i.dataId).values,f=n.data.get(s.dataId).values,m=n.data.get(a.dataId).values,g=new Float32Array(d),b=d;for(let y=0;y<b;y++){const x=y%h,w=y-x+Math.max(0,x-o),v=y-x+Math.min(h,x+o+1);let I=0;for(let N=w;N<v;N++)I+=Math.pow(f[N],2);I=c*I+u;for(let N=w;N<v;N++){let T=-2*c*l*f[N]*m[y]/I;y===N&&(T+=Math.pow(I,-l)),T*=p[y],g[N]+=T}}return n.makeTensorInfo(i.shape,s.dtype,g)}const bUe={kernelName:v1,backendName:"cpu",kernelFunc:gUe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LH(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:a,keepDims:i}=r,o=n;let u=s.shape;const c=u.length,l=zt(a,u);let d=l;const h=nr(d,c);let p=o.data.get(s.dataId).values;if(h!=null){const w=new Array(c);for(let v=0;v<w.length;v++)w[v]=u[h[v]];p=l$(p,u,s.dtype,h,w),d=qn(d.length,c),u=w}gt(s,"max"),tr("max",d,c);const[f,m]=sr(u,d),g=fe(m),b=iH(p,g,f,s.dtype),y=o.write(b,f,s.dtype);let x=f;return i&&(x=jn(f,l)),{dataId:y,shape:x,dtype:s.dtype}}const yUe={kernelName:xg,backendName:"cpu",kernelFunc:LH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xUe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;gt(s,"maxPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:u}=r,c=1;U(bs(i,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const l=Es(s.shape,a,i,c,o,u);let d;if(l.filterWidth===1&&l.filterHeight===1&&Nn(l.inShape,l.outShape))d=Fo({inputs:{x:s},backend:n});else{const h=n.data.get(s.dataId).values,p=ot(s.shape),f=g$(h,s.shape,s.dtype,p,l,"max");d=n.makeTensorInfo(l.outShape,s.dtype,f.values)}return d}const wUe={kernelName:vg,backendName:"cpu",kernelFunc:xUe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vUe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:u,dataFormat:c}=r;gt(s,"maxPool3d");const l=Qa(s.shape,a,i,1,o,u,c),d=n.data.get(s.dataId).values,h=DH(d,s.shape,s.dtype,ot(s.shape),l,"max");return n.makeTensorInfo(h.shape,"float32",h.values)}const IUe={kernelName:I1,backendName:"cpu",kernelFunc:vUe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kUe(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:u,dimRoundingMode:c}=r;gt([s,a],"maxPool3DGrad");const l=Qa(a.shape,i,o,1,u,c),d=n.bufferSync(a),h=dWe(d,l),p=l.strideDepth,f=l.strideHeight,m=l.strideWidth,g=l.dilationDepth,b=l.dilationHeight,y=l.dilationWidth,x=l.effectiveFilterDepth,w=l.effectiveFilterHeight,v=l.effectiveFilterWidth,I=x-1-l.padInfo.front,N=v-1-l.padInfo.left,T=w-1-l.padInfo.top,E=Yt(a.shape,"float32"),A=n.bufferSync(s);for(let k=0;k<l.batchSize;++k)for(let C=0;C<l.inChannels;++C)for(let M=0;M<l.inDepth;++M)for(let L=0;L<l.inHeight;++L)for(let O=0;O<l.inWidth;++O){const B=M-I,G=L-T,z=O-N;let q=0;for(let Q=0;Q<x;Q+=g){const K=(B+Q)/p;if(!(K<0||K>=l.outDepth||Math.floor(K)!==K))for(let ee=0;ee<w;ee+=b){const Y=(G+ee)/f;if(!(Y<0||Y>=l.outHeight||Math.floor(Y)!==Y))for(let de=0;de<v;de+=y){const ue=(z+de)/m;if(ue<0||ue>=l.outWidth||Math.floor(ue)!==ue)continue;const Ie=x*w*v-1-h.get(k,K,Y,ue,C),Ee=Q*w*v+ee*v+de,ve=Ie===Ee?1:0;if(ve===0)continue;const Ae=A.get(k,K,Y,ue,C);q+=Ae*ve}}}E.set(q,k,M,L,O,C)}return n.makeTensorInfo(E.shape,E.dtype,E.values)}const CUe={kernelName:Xv,backendName:"cpu",kernelFunc:kUe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SUe(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a,output:i}=t,o=a;gt([a,i],"maxPoolGrad");const{filterSize:u,strides:c,pad:l,dimRoundingMode:d}=r,h=Es(o.shape,u,c,1,l,d),p=n.data.get(o.dataId).values,f=Yt(h.outShape,o.dtype,_H(p,o.shape,o.dtype,h).values),m=h.strideHeight,g=h.strideWidth,b=h.dilationHeight,y=h.dilationWidth,x=h.effectiveFilterHeight,w=h.effectiveFilterWidth,v=w-1-h.padInfo.left,I=x-1-h.padInfo.top,N=Yt(o.shape,"float32"),T=n.data.get(s.dataId).values,E=Yt(s.shape,"float32",T);for(let A=0;A<h.batchSize;++A)for(let k=0;k<h.inChannels;++k)for(let C=0;C<h.inHeight;++C)for(let M=0;M<h.inWidth;++M){const L=C-I,O=M-v;let B=0;for(let G=0;G<x;G+=b){const z=(L+G)/m;if(!(z<0||z>=h.outHeight||Math.floor(z)!==z))for(let q=0;q<w;q+=y){const Q=(O+q)/g;if(Q<0||Q>=h.outWidth||Math.floor(Q)!==Q)continue;const K=x*w-1-f.get(A,z,Q,k),ee=G*w+q,Y=K===ee?1:0;if(Y===0)continue;const de=E.get(A,z,Q,k);B+=de*Y}}N.set(B,A,C,M,k)}return n.makeTensorInfo(N.shape,N.dtype,N.values)}const NUe={kernelName:Kv,backendName:"cpu",kernelFunc:SUe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TUe(e,t,n,r,s){const a=ot(t),i=g$(e,t,n,a,s,"max"),o=_H(e,t,n,s,!0,r);return[i.values,o.values]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EUe={kernelName:wE,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{filterSize:s,strides:a,pad:i,includeBatchInIndex:o}=t,u=n;gt(r,"MaxPoolWithArgmax");const c=u.data.get(r.dataId).values,l=Es(r.shape,s,a,[1,1],i),[d,h]=TUe(c,r.shape,r.dtype,o,l),p=u.write(d,l.outShape,r.dtype),f=u.write(h,l.outShape,r.dtype);return[{dataId:p,shape:l.outShape,dtype:r.dtype},{dataId:f,shape:l.outShape,dtype:"int32"}]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AUe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=zt(a,s.shape),c=sr(s.shape,o)[1],l=fe(c),d=[],h=n.makeTensorInfo([],"float32",new Float32Array([l]));d.push(h);const p=mu({inputs:{x:s},backend:n,attrs:{dtype:"float32"}});d.push(p);const f=b$({inputs:{a:p,b:h},backend:n});d.push(f);const m=n2({inputs:{x:f},backend:n,attrs:{axis:a,keepDims:i}});return d.forEach(g=>n.disposeIntermediateTensorInfo(g)),m}const $Ue={kernelName:Ig,backendName:"cpu",kernelFunc:AUe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RUe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;gt(s,"min");const o=zt(a,s.shape);let u=o;const c=nr(u,s.shape.length);let l=s;c!=null&&(l=ha({inputs:{x:s},backend:n,attrs:{perm:c}}),u=qn(u.length,s.shape.length)),tr("min",u,l.shape.length);const[d,h]=sr(l.shape,u),p=fe(h),f=Cs(fe(d),l.dtype),m=n.data.get(l.dataId).values;for(let b=0;b<f.length;++b){const y=b*p;let x=m[y];for(let w=0;w<p;++w){const v=m[y+w];(Number.isNaN(v)||v<x)&&(x=v)}f[b]=x}c!=null&&n.disposeIntermediateTensorInfo(l);const g=n.makeTensorInfo(d,l.dtype,f);if(i){const b=jn(d,o),y=er({inputs:{x:g},backend:n,attrs:{shape:b}});return n.disposeIntermediateTensorInfo(g),y}return g}const _Ue={kernelName:kg,backendName:"cpu",kernelFunc:RUe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DUe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,mode:i}=r;gt(s,"mirrorPad");const o=a.map((x,w)=>x[0]+s.shape[w]+x[1]),u=a.map(x=>x[0]),c=a.map((x,w)=>x[0]+s.shape[w]),l=i==="reflect"?0:1,d=n.data.get(s.dataId).values,h=s.shape.length,p=ot(s.shape),f=fe(o),m=o.length,g=ot(o),b=ks(s.dtype,f);for(let x=0;x<f;x++){let w=Om(x,m,g);for(let I=0;I<m;I++)w[I]<u[I]?w[I]=u[I]*2-w[I]-l:w[I]>=c[I]&&(w[I]=(c[I]-1)*2-w[I]+l);w=w.map((I,N)=>I-u[N]);const v=Io(w,h,p);b[x]=d[v]}return{dataId:n.write(b,o,s.dtype),shape:o,dtype:s.dtype}}const FUe={kernelName:Sg,backendName:"cpu",kernelFunc:DUe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MUe=Nr(((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t})),OUe=Yr(Ng,MUe),LUe={kernelName:Ng,backendName:"cpu",kernelFunc:OUe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PH(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:a}=r,i=s.shape.length;let o=a;if(o===-1&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);const u=zt([o],s.shape),c=LH({inputs:{x:s},backend:n,attrs:{reductionIndices:u,keepDims:!1}}),l=jn(c.shape,u),d=er({inputs:{x:c},backend:n,attrs:{shape:l}}),h=f$({inputs:{a:s,b:d},backend:n}),p=KG({inputs:{x:h},backend:n}),f=n2({inputs:{x:p},backend:n,attrs:{axis:u,keepDims:!1}}),m=er({inputs:{x:f},backend:n,attrs:{shape:l}}),g=b$({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}const PUe={kernelName:Xg,backendName:"cpu",kernelFunc:PH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BUe(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:i,normalized:o}=r;gt(s,"multinomial");const u=o?s:PH({inputs:{logits:s},backend:n,attrs:{dim:-1}}),c=u.shape[0],l=u.shape[1],d=n.data.get(u.dataId).values,h=[c,a],p=Cs(fe(h),"int32");for(let f=0;f<c;++f){const m=f*l,g=new Float32Array(l-1);g[0]=d[m];for(let x=1;x<g.length;++x)g[x]=g[x-1]+d[m+x];const b=QE.alea(i.toString()),y=f*a;for(let x=0;x<a;++x){const w=b();p[y+x]=g.length;for(let v=0;v<g.length;v++)if(w<g[v]){p[y+x]=v;break}}}return o||n.disposeIntermediateTensorInfo(u),n.makeTensorInfo(h,"int32",p)}const zUe={kernelName:Qv,backendName:"cpu",kernelFunc:BUe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WUe=aA;function VUe(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u}=r;gt(s,"NonMaxSuppression");const c=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,{selectedIndices:d}=WUe(c,l,i,o,u);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}const UUe={kernelName:S1,backendName:"cpu",kernelFunc:VUe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GUe=iA;function HUe(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u,padToMaxOutputSize:c}=r;gt(s,"NonMaxSuppressionPadded");const l=n.data.get(s.dataId).values,d=n.data.get(a.dataId).values,{selectedIndices:h,validOutputs:p}=GUe(l,d,i,o,u,c);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}const jUe={kernelName:N1,backendName:"cpu",kernelFunc:HUe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qUe=oA;function KUe(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u,softNmsSigma:c}=r;gt(s,"NonMaxSuppressionWithScore");const l=n.data.get(s.dataId).values,d=n.data.get(a.dataId).values,h=i,p=o,f=u,m=c,{selectedIndices:g,selectedScores:b}=qUe(l,d,h,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}const XUe={kernelName:T1,backendName:"cpu",kernelFunc:KUe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QUe(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{dtype:a,depth:i,onValue:o,offValue:u}=r;gt(s,"oneHot");const c=fe(s.shape),l=new Float32Array(c*i);l.fill(u);const d=n.data.get(s.dataId).values;for(let h=0;h<c;++h)d[h]>=0&&d[h]<i&&(l[h*i+d[h]]=o);return n.makeTensorInfo([...s.shape,i],a,l)}const YUe={kernelName:Eg,backendName:"cpu",kernelFunc:QUe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nw(e){const{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(r.dtype==="complex64"){const s=pd({inputs:{input:r},backend:n}),a=nw({inputs:{x:s},backend:n}),i=lf({inputs:{input:r},backend:n}),o=nw({inputs:{x:i},backend:n}),u=va({inputs:{real:a,imag:o},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),u}else return y$({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const JUe={kernelName:W1,backendName:"cpu",kernelFunc:nw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BH(e){const{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(r.dtype==="complex64"){const s=pd({inputs:{input:r},backend:n}),a=BH({inputs:{x:s},backend:n}),i=lf({inputs:{input:r},backend:n}),o=nw({inputs:{x:i},backend:n}),u=va({inputs:{real:a,imag:o},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),u}else return y$({backend:n,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}const ZUe={kernelName:E1,backendName:"cpu",kernelFunc:BH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zH(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(t.length===1)return tw({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const a=t[0].shape,i=t[0].dtype;t.forEach(l=>{Bv(a,l.shape,"All tensors passed to stack must have matching shapes"),U(i===l.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],u=t.map(l=>{const d=tw({inputs:{input:l},backend:n,attrs:{dim:s}});return o.push(d),d}),c=uf({inputs:u,backend:n,attrs:{axis:s}});return o.forEach(l=>n.disposeIntermediateTensorInfo(l)),c}const eGe={kernelName:A1,backendName:"cpu",kernelFunc:zH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tGe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,constantValue:i}=r;gt(s,"pad");const o=a.map((y,x)=>y[0]+s.shape[x]+y[1]),u=a.map(y=>y[0]),c=n.data.get(s.dataId).values,l=fe(s.shape),d=s.shape.length,h=ot(s.shape),p=fe(o),f=o.length,m=ot(o),g=ks(s.dtype,p);i!==0&&g.fill(i);for(let y=0;y<l;y++){const w=Om(y,d,h).map((I,N)=>I+u[N]),v=Io(w,f,m);g[v]=c[y]}return{dataId:n.write(g,o,s.dtype),shape:o,dtype:s.dtype}}const WH={kernelName:Ag,backendName:"cpu",kernelFunc:tGe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nGe=Nr((e,t)=>Math.pow(e,t)),rGe=Yr($g,nGe),sGe={kernelName:$g,backendName:"cpu",kernelFunc:rGe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aGe(e){const{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:s,paramsDenseValues:a,indices:i}=t,{outputRaggedRank:o}=r,u=s.map(b=>n.data.get(b.dataId).values),c=s.map(b=>b.shape),l=n.data.get(a.dataId).values,d=n.data.get(i.dataId).values,[h,p,f]=hH(u,c,l,a.shape,a.dtype,d,i.shape),m=h.map(b=>n.makeTensorInfo([b.length],"int32",b)),g=n.makeTensorInfo(f,a.dtype,p);return m.concat([g])}const iGe={kernelName:Hz,backendName:"cpu",kernelFunc:aGe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oGe(e){const{inputs:t,backend:n}=e,{starts:r,limits:s,deltas:a}=t,i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,[c,l]=pH(i,r.shape,r.dtype,o,s.shape,u,a.shape),d=n.makeTensorInfo([c.length],"int32",c),h=n.makeTensorInfo([l.length],r.dtype,l);return[d,h]}const lGe={kernelName:jz,backendName:"cpu",kernelFunc:oGe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uGe(e){const{inputs:t,backend:n,attrs:r}=e,{shape:s,values:a,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:u}=r,c=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,d=n.data.get(i.dataId).values,h=o.map(g=>n.data.get(g.dataId).values),p=o.map(g=>g.shape),[f,m]=fH(c,s.shape,l,a.shape,a.dtype,d,i.shape,h,p,u);return n.makeTensorInfo(f,a.dtype,m)}const cGe={kernelName:qz,backendName:"cpu",kernelFunc:uGe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dGe(e){const{backend:t,attrs:n}=e,{start:r,stop:s,dtype:a,step:i}=n,o=u$(r,s,i,a);return t.makeTensorInfo([o.length],a,o)}const hGe={kernelName:Yv,backendName:"cpu",kernelFunc:dGe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pGe=Fn(Dg,e=>1/e),fGe={kernelName:Dg,backendName:"cpu",kernelFunc:pGe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mGe(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r;gt(s,"resizeBilinear");const u=ot(s.shape),[c,l]=o,[d,h,p,f]=s.shape,m=n.data.get(s.dataId).values,g=new Float32Array(fe([d,c,l,f])),b=[a&&c>1?h-1:h,a&&l>1?p-1:p],y=[a&&c>1?c-1:c,a&&l>1?l-1:l];let x=0;const w=b[0]/y[0],v=b[1]/y[1];for(let I=0;I<d;I++)for(let N=0;N<c;N++){let T;i?T=w*(N+.5)-.5:T=w*N;const E=Math.max(0,Math.floor(T)),A=T-E,k=Math.min(h-1,Math.ceil(T)),C=I*u[0]+E*u[1],M=I*u[0]+k*u[1];for(let L=0;L<l;L++){let O;i?O=v*(L+.5)-.5:O=v*L;const B=Math.max(0,Math.floor(O)),G=O-B,z=Math.min(p-1,Math.ceil(O)),q=C+B*u[2],Q=M+B*u[2],K=C+z*u[2],ee=M+z*u[2];for(let Y=0;Y<f;Y++){const de=m[q+Y],ue=m[Q+Y],Ie=m[K+Y],Ee=m[ee+Y],ve=de+(Ie-de)*G,Ae=ue+(Ee-ue)*G,Be=ve+(Ae-ve)*A;g[x++]=Be}}}return n.makeTensorInfo([d,c,l,f],"float32",g)}const gGe={kernelName:Og,backendName:"cpu",kernelFunc:mGe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bGe(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r;gt([a,s],"resizeBilinearGrad");const o=ot(s.shape),[u,c,l,d]=s.shape,[,h,p]=a.shape,f=new Float32Array(u*c*l*d),m=[i&&h>1?c-1:c,i&&p>1?l-1:l],g=[i&&h>1?h-1:h,i&&p>1?p-1:p],b=m[0]/g[0],y=m[1]/g[1],x=n.data.get(a.dataId).values;let w=0;for(let v=0;v<u;v++){const I=v*o[0];for(let N=0;N<h;N++){const T=N*b,E=Math.floor(T),A=Math.min(Math.ceil(T),c-1),k=I+E*o[1],C=I+A*o[1],M=T-E,L=1-M;for(let O=0;O<p;O++){const B=O*y,G=Math.floor(B),z=Math.min(Math.ceil(B),l-1),q=B-G,Q=1-q,K=k+G*o[2],ee=k+z*o[2],Y=C+G*o[2],de=C+z*o[2],ue=L*Q,Ie=L*q,Ee=M*Q,ve=M*q;for(let Ae=0;Ae<d;Ae++){const Be=x[w++];f[K+Ae]+=Be*ue,f[ee+Ae]+=Be*Ie,f[Y+Ae]+=Be*Ee,f[de+Ae]+=Be*ve}}}}return n.makeTensorInfo([u,l,c,d],"float32",f)}const yGe={kernelName:_1,backendName:"cpu",kernelFunc:bGe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xGe(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r;gt(s,"resizeNearestNeighbor");const u=ot(s.shape),[c,l]=o,[d,h,p,f]=s.shape,m=n.data.get(s.dataId).values,g=new Float32Array(d*c*l*f),b=[a&&c>1?h-1:h,a&&l>1?p-1:p],y=[a&&c>1?c-1:c,a&&l>1?l-1:l],x=b[0]/y[0],w=b[1]/y[1];let v=0;for(let I=0;I<d;I++){const N=I*u[0];for(let T=0;T<c;T++){const E=i?x*(T+.5):x*T;let A=Math.min(h-1,a?Math.round(E):Math.floor(E));i&&(A=Math.max(0,A));const k=N+A*u[1];for(let C=0;C<l;C++){const M=i?w*(C+.5):w*C;let L=Math.min(p-1,a?Math.round(M):Math.floor(M));i&&(L=Math.max(0,L));const O=k+L*u[2];for(let B=0;B<f;B++){const G=m[O+B];g[v++]=G}}}}return n.makeTensorInfo([d,c,l,f],s.dtype,g)}const wGe={kernelName:Mg,backendName:"cpu",kernelFunc:xGe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vGe(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r;gt([a,s],"resizeNearestNeighborGrad");const o=ot(s.shape),u=ot(a.shape),[c,l,d,h]=s.shape,[,p,f]=a.shape,m=new Float32Array(c*l*d*h),g=n.data.get(a.dataId).values,b=[i&&p>1?l-1:l,i&&f>1?d-1:d],y=[i&&p>1?p-1:p,i&&f>1?f-1:f],x=b[0]/y[0],w=b[1]/y[1],v=1/x,I=1/w,N=Math.ceil(v)*2+2,T=Math.ceil(I)*2+2;for(let E=0;E<c;E++){const A=E*o[0];for(let k=0;k<l;k++){const C=A+k*o[1],M=Math.floor(k*v),L=Math.floor(M-N/2);for(let O=0;O<d;O++){const B=C+O*o[2],G=Math.floor(O*I),z=Math.floor(G-T/2);for(let q=0;q<h;q++){let Q=0;for(let K=0;K<N;K++){const ee=K+L;if(ee<0||ee>=p)continue;const Y=A+ee*u[1],de=ee*x,ue=Math.min(l-1,i?Math.round(de):Math.floor(de));if(k===ue)for(let Ie=0;Ie<T;Ie++){const Ee=Ie+z;if(Ee<0||Ee>=f)continue;const ve=Y+Ee*u[2],Ae=Ee*w,Be=Math.min(d-1,i?Math.round(Ae):Math.floor(Ae));O===Be&&(Q+=g[ve+q])}}m[B+q]=Q}}}}return n.makeTensorInfo(s.shape,s.dtype,m)}const IGe={kernelName:R1,backendName:"cpu",kernelFunc:vGe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kGe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r;gt(s,"reverse");const i=s.shape.length,o=zt(a,s.shape);if(i===0)return Fo({inputs:{x:s},backend:n});const u=new ms(s.shape,s.dtype),c=n.bufferSync(s);for(let l=0;l<u.size;l++){const d=u.indexToLoc(l),h=d.slice();o.forEach(p=>h[p]=s.shape[p]-1-h[p]),u.set(c.get(...h),...d)}return n.makeTensorInfo(u.shape,u.dtype,u.values)}const CGe={kernelName:Pg,backendName:"cpu",kernelFunc:kGe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SGe={kernelName:V1,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,{radians:s,fillValue:a,center:i}=t,o=n,u=ks(r.dtype,fe(r.shape)),[c,l,d,h]=r.shape,[p,f]=kI(i,l,d),m=255,g=Math.sin(s),b=Math.cos(s),y=o.data.get(r.dataId).values;for(let w=0;w<c;w++){const v=w*d*l*h;for(let I=0;I<l;I++){const N=I*(d*h);for(let T=0;T<d;T++){const E=T*h;for(let A=0;A<h;A++){const k=[c,I,T,A],C=k[2],M=k[1];let L=(C-p)*b-(M-f)*g,O=(C-p)*g+(M-f)*b;L=Math.round(L+p),O=Math.round(O+f);let B=a;if(typeof a!="number"&&(A===3?B=m:B=a[A]),L>=0&&L<d&&O>=0&&O<l){const z=O*(d*h),q=L*h,Q=v+z+q+A;B=y[Q]}const G=v+N+E+A;u[G]=B}}}}return{dataId:o.write(u,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NGe=Fn(Bg,e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1}),TGe={kernelName:Bg,backendName:"cpu",kernelFunc:NGe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EGe(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:a}=t,{shape:i}=r,{sliceRank:o,numUpdates:u,sliceSize:c,strides:l,outputSize:d}=zo(a,s,i),h=!0,p=n.bufferSync(s),f=n.bufferSync(a),m=Tc(p,f,i,d,c,u,o,l,0,h);return n.makeTensorInfo(i,m.dtype,m.values)}const AGe={kernelName:Jv,backendName:"cpu",kernelFunc:EGe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Ge(e,t){let n=0,r=e.length,s=0;for(;n<r;)s=Math.floor((n+r)/2),e[s]<t?n=s+1:r=s;return r}function RGe(e,t){let n=0,r=e.length,s=0;for(;n<r;)s=Math.floor((n+r)/2),e[s]<=t?n=s+1:r=s;return r}function _Ge(e,t,n,r,s,a){const i=wr("int32",n*s);for(let o=0;o<n;++o){const u=e.slice(o*r,(o+1)*r),c=o*s;for(let l=0;l<s;++l)i[c+l]=a==="left"?$Ge(u,t[l+c]):RGe(u,t[l+c])}return i}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DGe(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:s,values:a}=t,{side:i}=r,o=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,c=_Ge(o,u,s.shape[0],s.shape[1],a.shape[1],i);return n.makeTensorInfo(a.shape,"int32",c)}const FGe={kernelName:eI,backendName:"cpu",kernelFunc:DGe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MGe(e){const{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t;gt([r,s,a],"select");const i=r.shape.length,o=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,l=$a(s.dtype,a.dtype),d=Cs(fe(s.shape),l);let h=0;const p=i===0||i>1||s.shape.length===1?1:fe(s.shape.slice(1));for(let f=0;f<o.length;f++)for(let m=0;m<p;m++)o[f]===1?d[h++]=u[f]:d[h++]=c[f];return n.makeTensorInfo(s.shape,l,d)}const OGe={kernelName:D1,backendName:"cpu",kernelFunc:MGe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LGe=NI,PGe=TI,BGe=Fn(Wg,e=>e>=0?PGe*e:LGe*(Math.exp(e)-1)),zGe={kernelName:Wg,backendName:"cpu",kernelFunc:BGe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WGe=Fn(Gg,e=>e<0?-1:e>0?1:0),VGe={kernelName:Gg,backendName:"cpu",kernelFunc:WGe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UGe=Fn(Vg,e=>Math.sin(e)),GGe={kernelName:Vg,backendName:"cpu",kernelFunc:UGe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HGe=Fn(Ug,e=>Math.sinh(e)),jGe={kernelName:Ug,backendName:"cpu",kernelFunc:HGe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qGe=11920928955078125e-23,KD=Math.log(qGe)+2,KGe=Fn(jg,e=>{const t=e>-KD,n=e<KD,r=Math.exp(e);let s;return n?s=r:t?s=e:s=Math.log(1+r),s}),XGe={kernelName:jg,backendName:"cpu",kernelFunc:KGe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QGe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:i}=r;gt([s],"spaceToBatchND");const o=fe(a),u=[[0,0]];u.push(...i);for(let I=1+a.length;I<s.shape.length;++I)u.push([0,0]);const c=WH.kernelFunc({inputs:{x:s},backend:n,attrs:{paddings:u,constantValue:0}}),l=np(c.shape,a,o,!1),d=rp(l.length,a.length,!1),h=sp(c.shape,a,o,!1),m=er({inputs:{x:c},backend:n,attrs:{shape:l}}),y=ha({inputs:{x:m},backend:n,attrs:{perm:d}}),v=er({inputs:{x:y},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),v}const YGe={kernelName:M1,backendName:"cpu",kernelFunc:QGe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JGe(e){const{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:a,defaultValue:i}=t;if(a.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${a.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${s.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);const o=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,l=n.data.get(i.dataId).values[0],[d,h,p,f,m]=bH(o,r.shape,r.dtype,u,s.dtype,c,l);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([h[0]],s.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}const ZGe={kernelName:IE,backendName:"cpu",kernelFunc:JGe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eHe(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:a}=t;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${s.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const i=Array.from(n.data.get(s.dataId).values),o=n.data.get(r.dataId).values,u=Array.from(n.data.get(a.dataId).values),[c,l,d]=yH(o,r.shape,r.dtype,i,u);return[n.makeTensorInfo(l,r.dtype,c),n.makeTensorInfo([d.length],a.dtype,new Int32Array(d))]}const tHe={kernelName:tI,backendName:"cpu",kernelFunc:eHe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nHe(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${a.shape}`);if(s.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,[c,l]=c$(i,r.shape,r.dtype,o,u,!0);return n.makeTensorInfo(l,r.dtype,c)}const rHe={kernelName:kE,backendName:"cpu",kernelFunc:nHe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sHe(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${a.shape}`);if(s.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,[c,l]=c$(i,r.shape,r.dtype,o,u);return n.makeTensorInfo(l,r.dtype,c)}const aHe={kernelName:CE,backendName:"cpu",kernelFunc:sHe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iHe(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:u,numUpdates:c,sliceSize:l,strides:d,outputSize:h}=zo(a,s,o),p=!1,f=n.bufferSync(s);let m;switch(a.dtype){case"bool":{const g=n.bufferSync(a),b=!!n.data.get(i.dataId).values[0];m=Tc(f,g,o,h,l,c,u,d,b,p);break}case"float32":{const g=n.bufferSync(a),b=n.data.get(i.dataId).values[0];m=Tc(f,g,o,h,l,c,u,d,b,p);break}case"int32":{const g=n.bufferSync(a),b=n.data.get(i.dataId).values[0];m=Tc(f,g,o,h,l,c,u,d,b,p);break}case"string":{const g=n.bufferSync(a),b=cu(n.data.get(i.dataId).values[0]);m=Tc(f,g,o,h,l,c,u,d,b,p);break}default:throw new Error(`Unsupported type ${a.dtype}`)}return n.makeTensorInfo(o,m.dtype,m.values)}const oHe={kernelName:nI,backendName:"cpu",kernelFunc:iHe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lHe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:i}=r,o=zt(i,s.shape)[0],u=EI(s,a,o),c=new Array(s.shape.length).fill(0),l=s.shape.slice();return u.map(d=>{const h=[...l];h[o]=d;const p=fd({inputs:{x:s},backend:n,attrs:{begin:c,size:h}});return c[o]+=d,p})}const uHe={kernelName:O1,backendName:"cpu",kernelFunc:lHe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cHe={kernelName:rI,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{const{x:n}=e,r=t;gt(n,"square");const s=r.data.get(n.dataId).values,a=new Float32Array(s.length);for(let o=0;o<s.length;++o){const u=s[o];a[o]=u*u}return{dataId:r.write(a,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dHe=Fn(Jh,(e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha}),hHe={kernelName:Jh,backendName:"cpu",kernelFunc:dHe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pHe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,end:i,strides:o,beginMask:u,endMask:c,ellipsisMask:l,newAxisMask:d,shrinkAxisMask:h}=r;gt(s,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:b,begin:y,end:x,strides:w}=wI(s.shape,a,i,o,u,c,l,d,h);let v;if(m)v=er({inputs:{x:s},backend:n,attrs:{shape:f}});else if(g||b){U(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const I=bI(y,x,w),N=fd({inputs:{x:s},backend:n,attrs:{begin:y,size:I}});v=er({inputs:{x:N},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(N)}else{const I=n.bufferSync(s),N=vH(p,I,w,y);v=n.makeTensorInfo(f,N.dtype,N.values)}return v}const fHe={kernelName:L1,backendName:"cpu",kernelFunc:pHe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mHe(e){const{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:a,leftPad:i,rightPad:o,padWidth:u,preserveShortSequences:c}=r,{data:l,dataSplits:d}=t,h=n.data.get(l.dataId).values,p=n.data.get(d.dataId).values,[f,m]=d$(h,p,s,a,i,o,u,c);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}const gHe={kernelName:NE,backendName:"cpu",kernelFunc:mHe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bHe(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:a,delimiter:i}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(a.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=n.data.get(a.dataId).values,u=n.data.get(i.dataId).values[0],[c,l,d]=h$(o,u,s),h=l.length;return[n.makeTensorInfo([h,2],"int32",c),n.makeTensorInfo([h],"string",l),n.makeTensorInfo([2],"int32",new Int32Array(d))]}const yHe={kernelName:TE,backendName:"cpu",kernelFunc:bHe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xHe(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:a}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=n.data.get(a.dataId).values,o=p$(i,s);return n.makeTensorInfo(a.shape,"int32",o)}const wHe={kernelName:EE,backendName:"cpu",kernelFunc:xHe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vHe=Fn(Jg,e=>Math.tan(e)),IHe={kernelName:Jg,backendName:"cpu",kernelFunc:vHe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kHe=Fn(Zg,e=>Math.tanh(e)),CHe={kernelName:Zg,backendName:"cpu",kernelFunc:kHe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SHe(e){const{inputs:t,backend:n}=e,{tensor:r,indices:s,updates:a}=t,{sliceRank:i,numUpdates:o,sliceSize:u,strides:c,outputSize:l}=zo(a,s,r.shape),d=!1,h=n.bufferSync(s),p=n.bufferSync(a),f=n.bufferSync(r),m=Tc(h,p,r.shape,l,u,o,i,c,f,d);return n.makeTensorInfo(r.shape,m.dtype,m.values)}const NHe={kernelName:Zv,backendName:"cpu",kernelFunc:SHe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function THe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:a}=r;gt(s,"tile");const i=kH(n.bufferSync(s),a);return n.makeTensorInfo(i.shape,i.dtype,i.values)}const EHe={kernelName:Yh,backendName:"cpu",kernelFunc:THe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AHe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:a,sorted:i}=r;gt(s,"topk");const o=n.data.get(s.dataId).values,[u,c]=SH(o,s.shape,s.dtype,a,i);return[n.makeTensorInfo(u.shape,u.dtype,u.values),n.makeTensorInfo(c.shape,c.dtype,c.values)]}const $He={kernelName:P1,backendName:"cpu",kernelFunc:AHe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RHe(e){const{inputs:t,attrs:n,backend:r}=e,{image:s,transforms:a}=t,{interpolation:i,fillMode:o,fillValue:u,outputShape:c}=n,[l,d,h,p]=s.shape,[f,m]=c??[d,h],g=[l,f,m,p],b=ot(s.shape),y=b[0],x=b[1],w=b[2],v=ot(g),I=v[0],N=v[1],T=v[2],E=ks(s.dtype,fe(g));E.fill(u);const A=r.data.get(s.dataId).values,k=r.data.get(a.dataId).values;for(let M=0;M<l;++M){const L=a.shape[0]===1?k:k.subarray(M*8,M*8+8);for(let O=0;O<f;++O)for(let B=0;B<m;++B)for(let G=0;G<p;++G){let z;const q=L[6]*B+L[7]*O+1;if(q===0)continue;const Q=(L[0]*B+L[1]*O+L[2])/q,K=(L[3]*B+L[4]*O+L[5])/q,ee=XD(Q,h,o),Y=XD(K,d,o);switch(i){case"nearest":z=LHe(A,d,h,y,x,w,M,Y,ee,G,u);break;case"bilinear":z=PHe(A,d,h,y,x,w,M,Y,ee,G,u);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}const de=M*I+O*N+B*T+G;E[de]=z}return r.makeTensorInfo(g,s.dtype,E)}return{dataId:r.write(E,g,s.dtype),shape:s.shape,dtype:s.dtype}}const _He={kernelName:B1,backendName:"cpu",kernelFunc:RHe};function XD(e,t,n){switch(n){case"reflect":return DHe(e,t);case"wrap":return FHe(e,t);case"nearest":return OHe(e,t);case"constant":default:return MHe(e)}}function DHe(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const r=2*t;n<r&&(n=r*Math.trunc(-n/r)+n),n=n<-t?n+r:-n-1}else if(n>t-1)if(t<=1)n=0;else{const r=2*t;n-=r*Math.trunc(n/r),n>=t&&(n=r-n-1)}return nd(0,n,t-1)}function FHe(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const r=t-1;n+=t*(Math.trunc(-n/r)+1)}else if(n>t-1)if(t<=1)n=0;else{const r=t-1;n-=t*Math.trunc(n/r)}return nd(0,n,t-1)}function MHe(e,t){return e}function OHe(e,t){return nd(0,e,t-1)}function Qb(e,t,n,r,s,a,i,o,u,c,l){const d=i*r+o*s+u*a+c;return 0<=o&&o<t&&0<=u&&u<n?e[d]:l}function LHe(e,t,n,r,s,a,i,o,u,c,l){const d=Math.round(o),h=Math.round(u);return Qb(e,t,n,r,s,a,i,d,h,c,l)}function PHe(e,t,n,r,s,a,i,o,u,c,l){const d=Math.floor(o),h=Math.floor(u),p=d+1,f=h+1,m=(f-u)*Qb(e,t,n,r,s,a,i,d,h,c,l)+(u-h)*Qb(e,t,n,r,s,a,i,d,f,c,l),g=(f-u)*Qb(e,t,n,r,s,a,i,p,h,c,l)+(u-h)*Qb(e,t,n,r,s,a,i,p,f,c,l);return(p-o)*m+(o-d)*g}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BHe(e){const{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t;gt(a,"unique");const i=r.data.get(a.dataId).values,{outputValues:o,outputShape:u,indices:c}=m$(i,s,a.shape,a.dtype);return[r.makeTensorInfo(u,a.dtype,o),r.makeTensorInfo([c.length],"int32",c)]}const zHe={kernelName:sI,backendName:"cpu",kernelFunc:BHe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WHe(e){const{inputs:t,backend:n,attrs:r}=e,{value:s}=t;let{axis:a}=r;a<0&&(a+=s.shape.length);const i=s.shape.length,o=s.shape[a],u=new Array(i-1);let c=0;for(let p=0;p<i;p++)p!==a&&(u[c++]=s.shape[p]);const l=new Array(i).fill(0),d=s.shape.slice();d[a]=1;const h=new Array(o);for(let p=0;p<h.length;p++){l[a]=p;const f=fd({inputs:{x:s},backend:n,attrs:{begin:l,size:d}});h[p]=er({inputs:{x:f},backend:n,attrs:{shape:u}}),n.disposeIntermediateTensorInfo(f)}return h}const VHe={kernelName:z1,backendName:"cpu",kernelFunc:WHe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UHe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:a}=t,{numSegments:i}=r;gt(s,"unsortedSegmentSum");const o=s.shape.length,u=a.shape.length,c=[],l=[],d=o-u;let h=a;for(let f=0;f<d;++f){const m=tw({inputs:{input:h},backend:n,attrs:{dim:f+1}});h=m,l.push(m)}for(let f=0;f<i;++f){const m=Mu(f,"int32"),g=n.makeTensorInfo([],"int32",m),b=jG({inputs:{a:g,b:h},backend:n}),y=mu({inputs:{x:b},backend:n,attrs:{dtype:"float32"}}),x=WI({inputs:{a:y,b:s},backend:n}),w=n2({inputs:{x},backend:n,attrs:{axis:0,keepDims:!1}});c.push(w),l.push(g),l.push(b),l.push(y),l.push(x),l.push(w)}const p=zH({inputs:c,backend:n,attrs:{axis:0}});return l.forEach(f=>n.disposeIntermediateTensorInfo(f)),p}const GHe={kernelName:aI,backendName:"cpu",kernelFunc:UHe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HHe=[Bze,xBe,Wze,Uze,SBe,Hze,qze,Xze,Yze,Zze,tWe,rWe,aWe,lWe,cWe,pWe,mWe,bWe,xWe,Lze,vWe,kWe,SWe,TBe,TWe,kBe,ABe,AWe,wBe,RWe,DWe,FWe,OWe,PWe,zWe,VWe,GWe,jWe,KWe,QWe,JWe,eVe,nVe,sVe,aVe,oVe,uVe,dVe,hVe,pVe,fVe,gVe,xVe,$ze,vVe,$Be,AVe,RBe,$Ve,DBe,OVe,LVe,BVe,MBe,LBe,WVe,UVe,HVe,qVe,BBe,WBe,vBe,XVe,_We,YVe,ZVe,tUe,Rze,UBe,HBe,rUe,qBe,aUe,lUe,cUe,pUe,mUe,bUe,yUe,XBe,wUe,IUe,CUe,NUe,EUe,$Ue,_Ue,YBe,FUe,LUe,zUe,ZBe,tze,UUe,jUe,XUe,rze,YUe,ZUe,eGe,WH,sGe,Dze,ize,iGe,lGe,cGe,hGe,IBe,NS,fGe,Fze,Mze,Oze,gGe,yGe,wGe,IGe,CGe,SGe,TGe,fze,AGe,FGe,OGe,zGe,gze,VGe,GGe,jGe,bze,PUe,XGe,YGe,ZGe,tHe,rHe,aHe,oHe,uHe,wze,cHe,Ize,Cze,hHe,fHe,gHe,yHe,wHe,Eze,bVe,IHe,CHe,NHe,EHe,$He,_He,sze,zHe,VHe,GHe,JUe];for(const e of HHe)AE(e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kc={},_2={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function jHe(e,t){kc[e]=t}function Yi(e,t){if(!(e in kc)||t!=null){const r=KHe(e,t);if(r!==null)kc[e]=r;else return console.log("Could not get context for WebGL version",e),null}const n=kc[e];return n==null||n.isContextLost()?(delete kc[e],Yi(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),kc[e])}function qHe(e){if(!ke().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&e===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function KHe(e,t){if(e!==1&&e!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=t??qHe(e);return n.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete kc[e]},!1),ke().getBool("SOFTWARE_WEBGL_ENABLED")&&(_2.failIfMajorPerformanceCaveat=!1),e===1?n.getContext("webgl",_2)||n.getContext("experimental-webgl",_2):n.getContext("webgl2",_2)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Ly;(function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"})(Ly||(Ly={}));var Wa;(function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"})(Wa||(Wa={}));var ps;(function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(ps||(ps={}));function r2(e,t){return[t,e]}function XHe(e,t){return e*t}function D2(e){const t=fe(e),n=Math.ceil(t/4);return JC(n)}function ib(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function QHe(e,t){const[n,r]=ib(e,t);return n*r*4}function x$(e,t){const n=e;let r,s,a,i,o,u,c,l,d,h;return ke().getNumber("WEBGL_VERSION")===2?(r=n.R32F,s=n.R16F,a=n.RGBA16F,i=n.RGBA32F,o=n.RED,c=4,l=1,d=n.HALF_FLOAT,h=n.FLOAT,u=n.RGBA8):(r=e.RGBA,s=e.RGBA,a=e.RGBA,i=n.RGBA,o=e.RGBA,c=4,l=4,d=t!=null?t.HALF_FLOAT_OES:null,h=e.FLOAT,u=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:i,textureFormatFloat:o,downloadTextureFormat:u,downloadUnpackNumChannels:c,defaultNumChannels:l,textureTypeHalfFloat:d,textureTypeFloat:h}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function st(e,t){const n=t();return ke().getBool("DEBUG")&&YHe(e),n}function YHe(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+tje(e,t))}const JHe=596e-10,ZHe=65504;function eje(e){return!!(ke().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||e===0||JHe<Math.abs(e)&&Math.abs(e)<ZHe)}function tje(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function F2(e,t){return vl(e,()=>e.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function nje(e,t){const n=vl(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(st(e,()=>e.shaderSource(n,t)),st(e,()=>e.compileShader(n)),e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function rje(e,t){const n=vl(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(st(e,()=>e.shaderSource(n,t)),st(e,()=>e.compileShader(n)),ke().get("ENGINE_COMPILE_ONLY"))return n;if(e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw VH(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}const sje=/ERROR: [0-9]+:([0-9]+):/g;function VH(e,t){const n=sje.exec(t);if(n==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(e);return}const r=+n[1],s=e.split(`
`),a=s.length.toString().length+2,i=s.map((d,h)=>Ap((h+1).toString(),a)+d);let o=0;for(let d=0;d<i.length;d++)o=Math.max(i[d].length,o);const u=i.slice(0,r-1),c=i.slice(r-1,r),l=i.slice(r);console.log(u.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${Ap(c[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(l.join(`
`))}function aje(e){return vl(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}function ije(e,t){if(st(e,()=>e.linkProgram(t)),!ke().get("ENGINE_COMPILE_ONLY")&&e.getProgramParameter(t,e.LINK_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function Rk(e,t){if(st(e,()=>e.validateProgram(t)),e.getProgramParameter(t,e.VALIDATE_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function oje(e,t){const n=vl(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return st(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),st(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function lje(e,t){const n=vl(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return st(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)),st(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function uje(e){return vl(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}function cje(e,t){const n=ke().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){const r=`[${e}x${t}]`;throw new Error("Requested texture size "+r+" is invalid.")}if(e>n||t>n){const r=`[${e}x${t}]`,s=`[${n}x${n}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+s+".")}}function dje(e){return vl(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function QD(e,t,n,r,s,a,i){const o=e.getAttribLocation(t,n);return o===-1?!1:(st(e,()=>e.bindBuffer(e.ARRAY_BUFFER,r)),st(e,()=>e.vertexAttribPointer(o,s,e.FLOAT,!1,a,i)),st(e,()=>e.enableVertexAttribArray(o)),!0)}function hje(e,t,n){bje(e,n),st(e,()=>e.activeTexture(e.TEXTURE0+n)),st(e,()=>e.bindTexture(e.TEXTURE_2D,t))}function pje(e,t,n){return vl(e,()=>e.getUniformLocation(t,n),'uniform "'+n+'" not present in program.')}function fje(e,t,n){return e.getUniformLocation(t,n)}function mje(e,t,n,r){st(e,()=>hje(e,t,r)),st(e,()=>e.uniform1i(n,r))}function _k(e,t,n){st(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),st(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function YD(e,t){st(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),st(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function M2(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+gje(e,t))}function gje(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function vl(e,t,n){const r=st(e,()=>t());if(r==null)throw new Error(n);return r}function bje(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){const s=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${s}.`)}}function cf(e,t=2){return fe(e.slice(0,e.length-t))}function df(e){if(e.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function O2(e){let t=[1,1,1];return e.length===0||e.length===1&&e[0]===1||(t=[cf(e),...df(e)]),t}function yje(e,t=!1){let n=ke().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=ke().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&ke().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),t&&(n=n*2,r=r*2,e=e.map((o,u)=>u>=e.length-2?aE(e[u]):e[u]),e.length===1&&(e=[2,e[0]])),e.length!==2&&(e=Fu(e).newShape);let s=fe(e),a=null;e.length<=1&&s<=n?a=[1,s]:e.length===2&&e[0]<=n&&e[1]<=n?a=e:e.length===3&&e[0]*e[1]<=n&&e[2]<=n?a=[e[0]*e[1],e[2]]:e.length===3&&e[0]<=n&&e[1]*e[2]<=n?a=[e[0],e[1]*e[2]]:e.length===4&&e[0]*e[1]*e[2]<=n&&e[3]<=n?a=[e[0]*e[1]*e[2],e[3]]:e.length===4&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(a=[e[0],e[1]*e[2]*e[3]]);const i=a!=null&&Math.max(...a)>r&&Math.min(...a)<=(t?2:1)&&Math.min(...a)>0;if(a==null||i)if(t){const o=cf(e);let u=2,c=2;e.length&&([u,c]=df(e)),s=o*(u/2)*(c/2),a=JC(s).map(l=>l*2)}else a=JC(s);return a}function L2(e){return e%2===0}function rw(e,t){if(e=e.slice(-2),t=t.slice(-2),Nn(e,t)||!e.length||!t.length||e[0]===0||e[1]===0||t[0]===0||t[1]===0)return!0;if(e.length!==t.length){const n=e[e.length-1],r=t[t.length-1];if(n===r||L2(n)&&L2(r)&&(e[0]===1||t[0]===1))return!0}return e[1]===t[1]&&L2(e[0])&&L2(t[0])}let Dk,Fk;function xje(e){if(Dk==null){const t=Yi(e);Dk=t.getParameter(t.MAX_TEXTURE_SIZE)}return Dk}function wje(e){if(Fk==null){const t=Yi(e);Fk=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Fk)}function vje(e){if(e===0)return 0;let t;const n=Yi(e);return ui(n,"EXT_disjoint_timer_query_webgl2")&&e===2?t=2:ui(n,"EXT_disjoint_timer_query")?t=1:t=0,t}function ui(e,t){return e.getExtension(t)!=null}function JD(e){try{if(Yi(e)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function Ije(e){if(e===0)return!1;const t=Yi(e);if(e===1){if(!ui(t,"OES_texture_float"))return!1}else if(!ui(t,"EXT_color_buffer_float"))return!1;return ES(t)}function kje(e){if(e===0)return!1;const t=Yi(e);if(e===1){if(!ui(t,"OES_texture_float")||!ui(t,"WEBGL_color_buffer_float"))return!1}else{if(ui(t,"EXT_color_buffer_float"))return ES(t);const r="EXT_color_buffer_half_float";if(ui(t,r)){const s=t.getExtension(r);return Cje(t,s)}return!1}return ES(t)}function ES(e){const t=x$(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const i=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(a),i}function Cje(e,t){const n=x$(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r),e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const i=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,i),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);const o=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(i),o}function Sje(e){return e!==2?!1:Yi(e).fenceSync!=null}function s2(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&U(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xt=ke();xt.registerFlag("HAS_WEBGL",()=>xt.getNumber("WEBGL_VERSION")>0);xt.registerFlag("WEBGL_VERSION",()=>JD(2)?2:JD(1)?1:0);xt.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);xt.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>xt.get("WEBGL_VERSION")===2);xt.registerFlag("WEBGL_CPU_FORWARD",()=>!0);xt.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);xt.registerFlag("WEBGL_PACK",()=>xt.getBool("HAS_WEBGL"));xt.registerFlag("WEBGL_PACK_NORMALIZATION",()=>xt.getBool("WEBGL_PACK"));xt.registerFlag("WEBGL_PACK_CLIP",()=>xt.getBool("WEBGL_PACK"));xt.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>xt.getBool("WEBGL_PACK"));xt.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>xt.getBool("WEBGL_PACK"));xt.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>xt.getBool("WEBGL_PACK"));xt.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>xt.getBool("WEBGL_PACK"));xt.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>xt.getBool("WEBGL_PACK"));xt.registerFlag("WEBGL_PACK_REDUCE",()=>xt.getBool("WEBGL_PACK"));xt.registerFlag("WEBGL_LAZILY_UNPACK",()=>xt.getBool("WEBGL_PACK"));xt.registerFlag("WEBGL_CONV_IM2COL",()=>xt.getBool("WEBGL_PACK"));xt.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>xt.getBool("WEBGL_PACK"));xt.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>xje(xt.getNumber("WEBGL_VERSION")));xt.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>wje(xt.getNumber("WEBGL_VERSION")));xt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const e=xt.getNumber("WEBGL_VERSION");return e===0?0:vje(e)});xt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>xt.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!iW());xt.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>Ije(xt.getNumber("WEBGL_VERSION")));xt.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>xt.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:xt.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));xt.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>kje(xt.getNumber("WEBGL_VERSION")));xt.registerFlag("WEBGL_FENCE_API_ENABLED",()=>Sje(xt.getNumber("WEBGL_VERSION")));xt.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>xt.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);xt.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,e=>{if(typeof e!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&e!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)});xt.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>iW()?1:-1,e=>{if(typeof e!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);if(e<0&&e!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)});xt.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);xt.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);xt.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);xt.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);xt.registerFlag("WEBGL_EXP_CONV",()=>!1);xt.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>xt.getBool("IS_TEST"));xt.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);xt.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);xt.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);xt.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ys(){let e,t,n,r,s,a,i,o,u,c;return ke().getNumber("WEBGL_VERSION")===2?(e="#version 300 es",t="in",n="out",r="in",s="texture",a="outputColor",i="out vec4 outputColor;",o=ke().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",u="",c=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(e="",t="attribute",n="varying",r="varying",s="texture2D",a="gl_FragColor",i="",o=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,u=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,c=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:s,output:a,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:u,defineRound:c}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function op(e,t,n="index"){const r=ot(t);return r.map((s,a)=>{const i=`int ${e[a]} = ${n} / ${s}`,o=a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * ${s}`:`index -= ${e[a]} * ${s}`;return`${i}; ${o};`}).join("")}function VI(e,t,n="index"){const r=ot(t);return r.map((s,a)=>{const i=`int ${e[a]} = ${n} / outShapeStrides[${a}]`,o=a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * outShapeStrides[${a}]`:`index -= ${e[a]} * outShapeStrides[${a}]`;return`${i}; ${o};`}).join("")}function Nje(e,t){const n=e.length,r=e.map(a=>`${t}[${a}]`),s=new Array(n-1);s[n-2]=r[n-1];for(let a=n-3;a>=0;--a)s[a]=`(${s[a+1]} * ${r[a+1]})`;return s}function Tje(e,t,n="index"){const r=e.map((a,i)=>i),s=Nje(r,t);return s.map((a,i)=>{const o=`int ${e[i]} = ${n} / ${s[i]}`,u=i===s.length-1?`int ${e[i+1]} = ${n} - ${e[i]} * ${s[i]}`:`index -= ${e[i]} * ${s[i]}`;return`${o}; ${u};`}).join("")}function w$(e){const t=ot(e).map(n=>n.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function v$(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const UH=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:GH}=bOe;function Eje(e,t,n){const r=[];if(e.forEach(p=>{const f=fe(p.shapeInfo.logicalShape);if(p.shapeInfo.isUniform?r.push(`uniform float ${p.name}${f>1?`[${f}]`:""};`):(r.push(`uniform sampler2D ${p.name};`),r.push(`uniform int offset${p.name};`)),n.enableShapeUniforms){const{uniformShape:m}=I$(n.packedInputs,p.shapeInfo.logicalShape,p.shapeInfo.texShape);switch(m.length){case 1:r.push(`uniform int ${p.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${p.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${p.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${p.name}Shape;`);break}r.push(`uniform ivec2 ${p.name}TexShape;`)}}),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(p=>{r.push(`uniform ${p.type} ${p.name}${p.arrayIndex?`[${p.arrayIndex}]`:""};`)});const s=r.join(`
`),a=e.map(p=>Aje(p,t,n.packedInputs,n.enableShapeUniforms)).join(`
`),i=t.texShape,o=Ys(),u=_je(o);let c,l,d=Mje(o);return t.isPacked?(c=$je(t.logicalShape,i,n.enableShapeUniforms),l=Fje(o)):(c=Rje(t.logicalShape,i,n.enableShapeUniforms),l=Dje(o)),n.packedInputs&&(d+=Bje),[d,u,l,s,c,a,n.userCode].join(`
`)}function ob(e,t=!1){const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return Yje(e,t);case 1:return Zje(e,t);case 2:return tqe(e,t);case 3:return rqe(e,t);case 4:return aqe(e,t);case 5:return iqe(e);case 6:return oqe(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function HH(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return Qje(e);case 1:return Jje(e,t);case 2:return eqe(e,t);case 3:return nqe(e,t);default:return sqe(e,t)}}function Aje(e,t,n=!1,r){let s="";n?s+=HH(e,r):s+=ob(e,r);const a=e.shapeInfo.logicalShape,i=t.logicalShape;return a.length<=i.length&&(n?s+=lqe(e,t):s+=uqe(e,t)),s}function $je(e,t,n){switch(e.length){case 0:return jH();case 1:return zje(e,t,n);case 2:return Kje(e,t,n);case 3:return Vje(e,t,n);default:return Gje(e,t,n)}}function Rje(e,t,n){switch(e.length){case 0:return jH();case 1:return Wje(e,t,n);case 2:return Xje(e,t,n);case 3:return Uje(e,t,n);case 4:return Hje(e,t,n);case 5:return jje(e,t);case 6:return qje(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}function _je(e){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${e.texture2D}(textureSampler, uv).r;
    }
  `}function Dje(e){return`
    void setOutput(float val) {
      ${e.output} = vec4(val, 0, 0, 0);
    }
  `}function Fje(e){return`
    void setOutput(vec4 val) {
      ${e.output} = val;
    }
  `}function Mje(e){return`${e.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${e.varyingFs} vec2 resultUV;
    ${e.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${e.defineSpecialNaN}
    ${e.defineSpecialInf}
    ${e.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${Oje}
    ${Lje}
    ${Pje}
  `}const Oje=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Lje=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Pje=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Bje=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function jH(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function zje(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return r[0]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `}function Wje(e,t,n){return t[0]===1?n?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?n?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function Vje(e,t,n){if(n)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[2]/2),a=s*Math.ceil(e[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec3(b, r, c);
    }
  `}function Uje(e,t,n){if(n)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${VI(["r","c","d"],e)}
    return ivec3(r, c, d);
  }
`;const r=op(["r","c","d"],e);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `}function Gje(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[e.length-1]/2),a=s*Math.ceil(e[e.length-2]/2);let i=a,o="",u="b, r, c";for(let c=2;c<e.length-1;c++)i*=e[e.length-c-1],o=`
      int b${c} = index / ${i};
      index -= b${c} * ${i};
    `+o,u=`b${c}, `+u;return`
    ivec${e.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${o}

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec${e.length}(${u});
    }
  `}function Hje(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${VI(["r","c","d","d2"],e)}
      return ivec4(r, c, d, d2);
    }
  `;const r=op(["r","c","d","d2"],e);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `}function jje(e,t){const n=op(["r","c","d","d2","d3"],e);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function qje(e,t){const n=op(["r","c","d","d2","d3","d4"],e);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function Kje(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(Nn(e,t))return n?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;const s=Math.ceil(e[1]/2);return n?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec2(r, c);
    }
  `}function Xje(e,t,n){return Nn(e,t)?n?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:e[1]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:e[0]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:n?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${e[1]};
      int c = index - r * ${e[1]};
      return ivec2(r, c);
    }
  `}function lp(e){return`offset${e}`}function Qje(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=Ys();return`
    vec4 ${n}() {
      return ${r.texture2D}(${t}, halfCR);
    }
  `}function Yje(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;const[s,a]=e.shapeInfo.texShape;if(s===1&&a===1)return`
      float ${r}() {
        return sampleTexture(${n}, halfCR);
      }
    `;const i=lp(n);if(t)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});
      return sampleTexture(${n}, uv);
    }
  `;const[o,u]=e.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${o}, ${u}, ${i});
      return sampleTexture(${n}, uv);
    }
  `}function Jje(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape,a=Ys();if(t)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${a.texture2D}(${n}, uv);
    }
  `;const i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${a.texture2D}(${n}, uv);
    }
  `}function Zje(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${lb(e)}
      }
    `;const s=e.shapeInfo.texShape,a=s[0],i=s[1];if(i===1&&a===1)return`
      float ${r}(int index) {
        return sampleTexture(${n}, halfCR);
      }
    `;const o=lp(n);return i===1?t?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${a}.0);
        return sampleTexture(${n}, uv);
      }
    `:a===1?t?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${n}, uv);
      }
    `:t?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${a}, ${i}, index + ${o});
      return sampleTexture(${n}, uv);
    }
  `}function eqe(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,i=a[0],o=a[1],u=Ys();if(a!=null&&Nn(n,a))return t?`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${u.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);

        return ${u.texture2D}(${r}, uv);
      }
    `;if(t)return`
    vec4 ${s}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${u.texture2D}(${r}, uv);
    }
  `;const c=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],l=Math.ceil(n[1]/2);return`
    vec4 ${s}(int row, int col) {
      vec2 uv = packedUVfrom2D(${l}, ${c[0]}, ${c[1]}, row, col);
      return ${u.texture2D}(${r}, uv);
    }
  `}function tqe(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape;if(a!=null&&Nn(n,a)){if(t)return`
      float ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;const h=a[0],p=a[1];return`
    float ${s}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${p}.0, ${h}.0);
      return sampleTexture(${r}, uv);
    }
  `}const{newShape:i,keptDims:o}=Fu(n),u=i;if(u.length<n.length){const h=ub(e,u),p=["row","col"];return`
      ${ob(h,t)}
      float ${s}(int row, int col) {
        return ${s}(${cb(p,o)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${s}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));
        ${lb(e)}
      }
    `;const c=a[0],l=a[1],d=lp(r);return l===1?t?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);
      return sampleTexture(${r}, uv);
    }
  `:c===1?t?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${l}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `:t?`
      float ${s}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${d};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `:`
  float ${s}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n[1]} + col + ${d};
    vec2 uv = uvFromFlat(${c}, ${l}, index);
    return sampleTexture(${r}, uv);
  }
`}function nqe(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];if(n[0]===1){const h=n.slice(1),p=[1,2],f=ub(e,h),m=["b","row","col"];return`
        ${HH(f,t)}
        vec4 ${s}(int b, int row, int col) {
          return ${s}(${cb(m,p)});
        }
      `}const o=Ys();if(t)return`
    vec4 ${s}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${o.texture2D}(${r}, uv);
    }
  `;const u=i[0],c=i[1],l=Math.ceil(n[2]/2),d=l*Math.ceil(n[1]/2);return`
    vec4 ${s}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${u}, ${c}, ${d}, ${l}, b, row, col);
      return ${o.texture2D}(${r}, uv);
    }
  `}function rqe(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=n[1]*n[2],i=n[2],{newShape:o,keptDims:u}=Fu(n),c=o;if(c.length<n.length){const m=ub(e,c),g=["row","col","depth"];return`
        ${ob(m,t)}
        float ${s}(int row, int col, int depth) {
          return ${s}(${cb(g,u)});
        }
      `}if(e.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${a}, ${i}, 1)));
        ${lb(e)}
      }
    `;const l=e.shapeInfo.texShape,d=l[0],h=l[1],p=e.shapeInfo.flatOffset;if(h===a&&p==null)return t?`
      float ${s}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
        float ${s}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${h}.0, ${d}.0);
          return sampleTexture(${r}, uv);
        }
      `;if(h===i&&p==null)return t?`
      float ${s}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${d}.0);
      return sampleTexture(${r}, uv);
    }
  `;const f=lp(r);return t?`
    float ${s}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${f};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `:`
      float ${s}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${a} + col * ${i} + depth + ${f};
        vec2 uv = uvFromFlat(${d}, ${h}, index);
        return sampleTexture(${r}, uv);
      }
  `}function sqe(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=Ys();if(t)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${n}, uv);
    }
  `;const a=e.shapeInfo.logicalShape,i=a.length,o=e.shapeInfo.texShape,u=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],c=u[0],l=u[1],d=Math.ceil(a[i-1]/2);let h=d*Math.ceil(a[i-2]/2),p="int b, int row, int col",f=`b * ${h} + (row / 2) * ${d} + (col / 2)`;for(let m=2;m<i-1;m++)p=`int b${m}, `+p,h*=a[i-m-1],f=`b${m} * ${h} + `+f;return`
    vec4 ${r}(${p}) {
      int index = ${f};
      int texR = index / ${l};
      int texC = index - texR * ${l};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${l}, ${c});
      return ${s.texture2D}(${n}, uv);
    }
  `}function aqe(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=n[3],i=n[2]*a,o=n[1]*i,{newShape:u,keptDims:c}=Fu(n);if(u.length<n.length){const y=ub(e,u),x=["row","col","depth","depth2"];return`
      ${ob(y,t)}
      float ${s}(int row, int col, int depth, int depth2) {
        return ${s}(${cb(x,c)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${o}, ${i}, ${a}, 1)));
        ${lb(e)}
      }
    `;const l=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1],f=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(p===o&&l==null)return t?`
      float ${s}(int row, int col, int depth, int depth2) {
        ${f}
        ${m}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${a}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${h}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(p===a&&l==null)return t?`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n[1]*n[2]}, ${n[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${h}.0);
        return sampleTexture(${r}, uv);
      }
    `;const b=lp(r);return t?`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${f}
      ${m}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${b});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${i} +
          depth * ${a} + depth2;
      vec2 uv = uvFromFlat(${h}, ${p}, index + ${b});
      return sampleTexture(${r}, uv);
    }
  `}function iqe(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[4],a=t[3]*s,i=t[2]*a,o=t[1]*i,{newShape:u,keptDims:c}=Fu(t);if(u.length<t.length){const m=ub(e,u),g=["row","col","depth","depth2","depth3"];return`
      ${ob(m)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${cb(g,c)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${o}, ${i}, ${a}, ${s})) +
          depth3;
        ${lb(e)}
      }
    `;const l=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1];if(p===o&&l==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${a}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${h}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(p===s&&l==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${h}.0);
        return sampleTexture(${n}, uv);
      }
    `;const f=lp(n);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${i} + depth * ${a} +
          depth2 * ${s} + depth3 + ${f};
      vec2 uv = uvFromFlat(${h}, ${p}, index);
      return sampleTexture(${n}, uv);
    }
  `}function oqe(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:s,keptDims:a}=Fu(t);if(s.length<t.length){const g=ub(e,s),b=["row","col","depth","depth2","depth3","depth4"];return`
      ${ob(g)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${cb(b,a)});
      }
    `}const i=t[5],o=t[4]*i,u=t[3]*o,c=t[2]*u,l=t[1]*c;if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${l}, ${c}, ${u}, ${o})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${lb(e)}
      }
    `;const d=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,p=h[0],f=h[1];if(f===l&&d==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${c}, ${u}, ${o}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(f===i&&d==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;const m=lp(n);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${l} + col * ${c} + depth * ${u} +
          depth2 * ${o} + depth3 * ${i} + depth4 + ${m};
      vec2 uv = uvFromFlat(${p}, ${f}, index);
      return sampleTexture(${n}, uv);
    }
  `}function lb(e){const t=e.name,n=fe(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`
    for (int i = 0; i < ${n}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function lqe(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,o=GH(e.shapeInfo.logicalShape,t.logicalShape),u=Vn(i),c=i-a;let l;const d=["x","y","z","w","u","v"];a===0?l="":i<2&&o.length>=1?l="coords = 0;":l=o.map(y=>`coords.${d[y+c]} = 0;`).join(`
`);let h="";i<2&&a>0?h="coords":h=e.shapeInfo.logicalShape.map((y,x)=>`coords.${d[x+c]}`).join(", ");let p="return outputValue;";const m=fe(e.shapeInfo.logicalShape)===1,b=fe(t.logicalShape)===1;if(a===1&&!m&&!b)p=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(m&&!b)i===1?p=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:p=`
        return vec4(outputValue.x);
      `;else if(o.length){const y=a-2,x=a-1;o.indexOf(y)>-1&&o.indexOf(x)>-1?p="return vec4(outputValue.x);":o.indexOf(y)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(x)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${s}() {
      ${u} coords = getOutputCoords();
      ${l}
      vec4 outputValue = get${r}(${h});
      ${p}
    }
  `}function uqe(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=t.texShape,i=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,u=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===u&&e.shapeInfo.flatOffset==null&&Nn(i,a))return`
      float ${s}() {
        return sampleTexture(${n}, resultUV);
      }
    `;const c=Vn(u),l=GH(e.shapeInfo.logicalShape,t.logicalShape),d=u-o;let h;const p=["x","y","z","w","u","v"];o===0?h="":u<2&&l.length>=1?h="coords = 0;":h=l.map(m=>`coords.${p[m+d]} = 0;`).join(`
`);let f="";return u<2&&o>0?f="coords":f=e.shapeInfo.logicalShape.map((m,g)=>`coords.${p[g+d]}`).join(", "),`
    float ${s}() {
      ${c} coords = getOutputCoords();
      ${h}
      return get${r}(${f});
    }
  `}function Vn(e){if(e<=1)return"int";if(e===2)return"ivec2";if(e===3)return"ivec3";if(e===4)return"ivec4";if(e===5)return"ivec5";if(e===6)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function I$(e,t,n){const{newShape:r,keptDims:s}=Fu(t),a=t.length,i=e&&a===3&&t[0]===1,o=i?t.slice(1):r,u=!e&&a>1&&!Nn(t,n)&&r.length<a||i;return{useSqueezeShape:u,uniformShape:u?o:t,keptDims:s}}function ub(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function cb(e,t){return t.map(n=>e[n]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cqe(e,t,n,r){const s=n.map((l,d)=>{const h={logicalShape:l.shape,texShape:l.isUniform?null:l.texData.texShape,isUniform:l.isUniform,isPacked:l.isUniform?!1:l.texData.isPacked,flatOffset:null};return l.texData!=null&&l.texData.slice!=null&&l.texData.slice.flatOffset>0&&(h.flatOffset=l.texData.slice.flatOffset),{name:t.variableNames[d],shapeInfo:h}}),a=s.map(l=>l.shapeInfo),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},o=Eje(s,i,t),u=rje(e.gl,o),c=e.createProgram(u);return ke().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:u,source:o,webGLProgram:c,inShapeInfos:a,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(c),Object.assign({program:t,fragmentShader:u,source:o,webGLProgram:c,inShapeInfos:a,outShapeInfo:i},qH(e,t,c)))}function qH(e,t,n){const r=[],s=[];let a,i,o,u=null,c=null;c=e.getUniformLocation(n,"NAN",!1),ke().getNumber("WEBGL_VERSION")===1&&(u=e.getUniformLocation(n,"INFINITY",!1));const l=!1;for(const d of t.variableNames){const h={name:d,uniform:e.getUniformLocation(n,d,l),offset:e.getUniformLocation(n,`offset${d}`,l)};t.enableShapeUniforms&&(h.shape=e.getUniformLocation(n,`${d}Shape`,l),h.texShape=e.getUniformLocation(n,`${d}TexShape`,l)),r.push(h)}if(t.enableShapeUniforms&&(a=e.getUniformLocation(n,"outShape",l),o=e.getUniformLocation(n,"outShapeStrides",l),i=e.getUniformLocation(n,"outTexShape",l)),t.customUniforms)for(const d of t.customUniforms)s.push(e.getUniformLocation(n,d.name,l));return{variablesLocations:r,customUniformLocations:s,infLoc:u,nanLoc:c,outShapeLocation:a,outShapeStridesLocation:o,outTexShapeLocation:i}}function ZD(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach((n,r)=>{const s=n.logicalShape,a=t[r],i=a.shape;if(!Nn(s,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${i} must match`);if(n.isUniform&&a.isUniform)return;const o=n.texShape,u=a.isUniform?null:a.texData.texShape;if(!Nn(o,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${u} must match`)})}function dqe(e,t,n,r,s){t.program.enableShapeUniforms||(ZD(t.inShapeInfos,n),ZD([t.outShapeInfo],[r]));const a=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(a.texture,i[0],i[1]):e.setOutputMatrixTexture(a.texture,i[0],i[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),ke().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&e.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&e.gl.uniform1f(t.nanLoc,NaN);for(let u=0;u<n.length;++u){const c=n[u],{uniform:l,offset:d,shape:h,texShape:p}=t.variablesLocations[u];if(h){const{uniformShape:f}=I$(t.program.packedInputs,c.shape,c.texData.texShape);switch(f.length){case 1:e.gl.uniform1iv(h,new Int32Array(f));break;case 2:e.gl.uniform2iv(h,new Int32Array(f));break;case 3:e.gl.uniform3iv(h,new Int32Array(f));break;case 4:e.gl.uniform4iv(h,new Int32Array(f));break}}if(p&&e.gl.uniform2i(p,c.texData.texShape[0],c.texData.texShape[1]),l!=null){if(c.isUniform){if(fe(c.shape)<2)e.gl.uniform1f(l,c.uniformValues[0]);else{let f=c.uniformValues;f instanceof Float32Array||(f=new Float32Array(f)),e.gl.uniform1fv(l,f)}continue}c.texData.slice!=null&&d!=null&&e.gl.uniform1i(d,c.texData.slice.flatOffset),e.setInputMatrixTexture(c.texData.texture.texture,l,u)}}const o=t.outShapeLocation;if(o)switch(r.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(r.shape));break}if(t.outShapeStridesLocation){const u=ot(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(u));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(u));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(u));break}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&s)for(let u=0;u<t.program.customUniforms.length;++u){const c=t.program.customUniforms[u],l=t.customUniformLocations[u],d=s[u];if(c.type==="float")e.gl.uniform1fv(l,d);else if(c.type==="vec2")e.gl.uniform2fv(l,d);else if(c.type==="vec3")e.gl.uniform3fv(l,d);else if(c.type==="vec4")e.gl.uniform4fv(l,d);else if(c.type==="int")e.gl.uniform1iv(l,d);else if(c.type==="ivec2")e.gl.uniform2iv(l,d);else if(c.type==="ivec3")e.gl.uniform3iv(l,d);else if(c.type==="ivec4")e.gl.uniform4iv(l,d);else throw Error(`uniform type ${c.type} is not supported yet.`)}e.executeProgram()}function hqe(e,t,n){let r="";t.concat(n).forEach(i=>{const o=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!i.isUniform){const u=i.texData.texShape,{useSqueezeShape:c,uniformShape:l,keptDims:d}=I$(e.packedInputs,i.shape,u);let h="",p="",f="";if(l.length===1&&e.packedInputs){const v=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)];h=`${v[0]>1}_${v[1]>1}`}else if(l.length===2&&!e.packedInputs)p=`${l[0]>1}_${l[1]>1}`;else if(l.length>2&&!e.packedInputs){const v=ot(l);f=`${v[0]===u[1]}_${v[v.length-1]===u[1]}`}const m=i.shape.length,g=l.length===2&&Nn(i.shape,u),b=fe(i.shape)===1,y=rf(i.shape,n.shape),x=!e.packedInputs&&m===n.shape.length&&Nn(u,n.texData.texShape),w=e.packedInputs||l.length>2?"":`${u[0]>1}_${u[1]>1}`;r+=`${m}_${x}_${c?d:""}_${l.length}_${b}_${y}_${g}_${h}_${p}_${f}_${w}_${o}`}else{const u=i.isUniform?"uniform":i.texData.texShape;r+=`${i.shape}_${u}_${o}`}});const s=e.userCode;let a=e.constructor.name;return a+="_"+r+"_"+s+`${ke().getNumber("WEBGL_VERSION")}`,a}function $s(e){return ke().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pqe{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Ly.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=Ys();this.outputShape=t,this.enableShapeUniforms=$s(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?VI(["r","c","d"],t):op(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fqe{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Ly.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=Ys();this.outputShape=t,this.enableShapeUniforms=$s(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?VI(["r","c","d"],t):op(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mqe{constructor(t){this.variableNames=["A"],this.outTexUsage=Wa.DOWNLOAD;const n=Ys();this.outputShape=t,this.userCode=`
      ${UH}

      void main() {
        float x = getAAtOutCoords();
        ${n.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gqe{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Wa.DOWNLOAD;const n=Ys();this.outputShape=t,this.userCode=`
      ${UH}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${n.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bqe={R:0,G:1,B:2,A:3};class eF{constructor(t,n=!1,r="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=Ys();this.outputShape=t,this.enableShapeUniforms=$s(this.outputShape.length);let a="result";n&&(a="floor(result * 255. + 0.5)");let i="";for(let o=0;o<r.length;o++){const u=r[o];i+=`
          if(offset == ${o}) {
            result = values[${bqe[u]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?v$():w$(t)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${r.length});

        flatIndex = idiv(flatIndex, ${r.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${s.texture2D}(A, uv);
          ${i}
        }
        ${s.output} = vec4(${a}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yqe{constructor(t,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=Ys();this.outputShape=t,this.enableShapeUniforms=$s(this.outputShape.length);let s="",a="result";n&&(a="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let o=0;o<=1;o++){const u=i*2+o;s+=`
          localCoords = coords;
          if(localCoords[2] + ${o} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {
          localCoords[2] += ${o};
          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {
            localCoords[1] += ${i};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${r.texture2D}(A, uv);

            if (offset == 0) {
              result[${u}] = values[0];
            } else if (offset == 1) {
              result[${u}] = values[1];
            } else if (offset == 2) {
              result[${u}] = values[2];
            } else {
              result[${u}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?v$():w$(t)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${s}

          ${r.output} = ${a};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xqe(e){const t=Ys(),n=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return nje(e,n)}function wqe(e){const t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return oje(e,t)}function vqe(e){const t=new Uint16Array([0,1,2,2,1,3]);return lje(e,t)}function a2(e,t,n,r,s,a){cje(t,n);const i=uje(e),o=e.TEXTURE_2D;return st(e,()=>e.bindTexture(o,i)),st(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),st(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),st(e,()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST)),st(e,()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST)),ke().getNumber("WEBGL_VERSION")===1?st(e,()=>e.texImage2D(o,0,r,t,n,0,s,a,null)):st(e,()=>e.texStorage2D(o,1,r,t,n)),st(e,()=>e.bindTexture(e.TEXTURE_2D,null)),{texture:i,texShape:[n,t]}}function KH(e){return e.internalFormatFloat}function Iqe(e,t,n,r){const[s,a]=r2(t,n);return a2(e,s,a,KH(r),r.textureFormatFloat,e.FLOAT)}function XH(e){return e.internalFormatHalfFloat}function kqe(e,t,n,r){const[s,a]=r2(t,n);return a2(e,s,a,XH(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function QH(e){return e.downloadTextureFormat}function Cqe(e,t,n,r){const[s,a]=r2(t,n);return a2(e,s,a,QH(r),e.RGBA,e.UNSIGNED_BYTE)}function YH(e){return e.internalFormatPackedFloat}function Sqe(e,t,n,r){const[s,a]=ib(t,n);return a2(e,s,a,YH(r),e.RGBA,e.FLOAT)}function JH(e){return e.internalFormatPackedHalfFloat}function Nqe(e,t,n,r){const[s,a]=ib(t,n);return a2(e,s,a,JH(r),e.RGBA,r.textureTypeHalfFloat)}function Tqe(e,t,n){return st(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),QD(e,t,"clipSpacePos",n,3,20,0)&&QD(e,t,"uv",n,2,20,12)}function Eqe(e,t,n,r,s,a){st(e,()=>e.bindTexture(e.TEXTURE_2D,t));let i,o,u;s instanceof Uint8Array?(i=new Uint8Array(n*r*4),o=e.UNSIGNED_BYTE,u=e.RGBA):(i=new Float32Array(n*r*4),o=e.FLOAT,u=a.internalFormatPackedFloat),i.set(s),ke().getNumber("WEBGL_VERSION")===2?st(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,o,i)):st(e,()=>e.texImage2D(e.TEXTURE_2D,0,u,n,r,0,e.RGBA,o,i)),st(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function Aqe(e,t,n){st(e,()=>e.bindTexture(e.TEXTURE_2D,t)),n.data instanceof Uint8Array?ke().getNumber("WEBGL_VERSION")===2?st(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data)):st(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data)):ke().getNumber("WEBGL_VERSION")===2?st(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n)):st(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)),st(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function $qe(e,t,n,r){const s=e.createBuffer();st(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,s));const o=4*4*t*n;return st(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,o,e.STREAM_READ)),st(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)),st(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),s}function Rqe(e,t,n){const r=e,s=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}function _qe(e,t,n,r){const[s,a]=r2(t,n),i=4,o=new Uint8Array(XHe(t*n,i));return st(e,()=>e.readPixels(0,0,s,a,r.downloadTextureFormat,e.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}function Dqe(e,t,n,r,s,a,i,o){const u=e,c=new Float32Array(QHe(a,i));return u.bindBuffer(u.PIXEL_PACK_BUFFER,t),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,c),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),c}function Fqe(e,t,n){const r=new Float32Array(t*n*4);return st(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r)),r}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Mk{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const n=ke().getNumber("WEBGL_VERSION");if(t!=null?(this.gl=t,jHe(n,t)):this.gl=Yi(n),t=this.gl,ke().getNumber("WEBGL_VERSION")===2){const a=t;this.createVertexArray=()=>st(a,()=>a.createVertexArray()),this.bindVertexArray=i=>st(a,()=>a.bindVertexArray(i)),this.deleteVertexArray=i=>st(a,()=>a.deleteVertexArray(i)),this.getVertexArray=()=>st(a,()=>a.getParameter(a.VERTEX_ARRAY_BINDING))}else if(t!=null){const a=t.getExtension("OES_vertex_array_object");if(a==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>st(t,()=>a.createVertexArrayOES()),this.bindVertexArray=i=>st(t,()=>a.bindVertexArrayOES(i)),this.deleteVertexArray=i=>st(t,()=>a.deleteVertexArrayOES(i)),this.getVertexArray=()=>st(t,()=>t.getParameter(a.VERTEX_ARRAY_BINDING_OES))}let r="WEBGL_color_buffer_float";const s="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),ke().getNumber("WEBGL_VERSION")===1){const a="OES_texture_float",i="OES_texture_half_float";if(this.textureFloatExtension=F2(this.gl,a),ui(this.gl,i))this.textureHalfFloatExtension=F2(this.gl,i);else if(ke().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),ui(this.gl,s))this.colorBufferHalfFloatExtension=F2(this.gl,s);else if(ke().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",ui(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else if(ui(this.gl,s))this.colorBufferHalfFloatExtension=this.gl.getExtension(s);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=wqe(this.gl),this.indexBuffer=vqe(this.gl),this.framebuffer=dje(this.gl),this.textureConfig=x$(this.gl,this.textureHalfFloatExtension)}get debug(){return ke().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;st(t,()=>t.finish()),st(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),st(t,()=>t.deleteFramebuffer(this.framebuffer)),st(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),st(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),st(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,n){return this.throwIfDisposed(),Iqe(this.gl,t,n,this.textureConfig)}createFloat16MatrixTexture(t,n){return this.throwIfDisposed(),kqe(this.gl,t,n,this.textureConfig)}createUnsignedBytesMatrixTexture(t,n){return this.throwIfDisposed(),Cqe(this.gl,t,n,this.textureConfig)}uploadPixelDataToTexture(t,n){this.throwIfDisposed(),Aqe(this.gl,t,n)}uploadDenseMatrixToTexture(t,n,r,s){this.throwIfDisposed(),Eqe(this.gl,t,n,r,s,this.textureConfig)}createFloat16PackedMatrixTexture(t,n){return this.throwIfDisposed(),Nqe(this.gl,t,n,this.textureConfig)}createPackedMatrixTexture(t,n){return this.throwIfDisposed(),Sqe(this.gl,t,n,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(YD(this.gl,this.framebuffer),this.outputTexture=null),st(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,n,r){return this.downloadMatrixDriver(t,()=>_qe(this.gl,n,r,this.textureConfig))}downloadPackedMatrixFromBuffer(t,n,r,s,a,i){return Dqe(this.gl,t,n,r,s,a,i,this.textureConfig)}downloadFloat32MatrixFromBuffer(t,n){return Rqe(this.gl,t,n)}createBufferFromTexture(t,n,r){this.bindTextureToFrameBuffer(t);const s=$qe(this.gl,n,r,this.textureConfig);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let n,r;if(ke().getBool("WEBGL_FENCE_API_ENABLED")){const s=t,a=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),r=()=>{const i=s.clientWaitSync(a,0,0);return i===s.ALREADY_SIGNALED||i===s.CONDITION_SATISFIED},n=a}else ke().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(n=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(n,ke().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:n,isFencePassed:r}}downloadMatrixFromPackedTexture(t,n,r){return this.downloadMatrixDriver(t,()=>Fqe(this.gl,n,r))}createProgram(t){this.throwIfDisposed();const n=this.gl;this.vertexShader==null&&(this.vertexShader=xqe(n));const r=aje(n);st(n,()=>n.attachShader(r,this.vertexShader)),st(n,()=>n.attachShader(r,t)),ije(n,r);const s=Object.assign(r,{vao:this.createVertexArray()});return this.debug&&Rk(n,s),s}buildVao(t){this.setProgram(t),this.bindVertexArray(t.vao);const n=this.gl;st(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),Tqe(n,t,this.vertexBuffer)}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),t!=null&&(st(this.gl,()=>this.gl.deleteProgram(t)),this.deleteVertexArray(t.vao))}setProgram(t){this.throwIfDisposed(),this.program=t,this.program!=null&&this.debug&&Rk(this.gl,this.program),st(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,n,r=!0){return this.throwIfDisposed(),r?pje(this.gl,t,n):fje(this.gl,t,n)}getAttributeLocation(t,n){return this.throwIfDisposed(),st(this.gl,()=>this.gl.getAttribLocation(t,n))}getUniformLocationNoThrow(t,n){return this.throwIfDisposed(),this.gl.getUniformLocation(t,n)}setInputMatrixTexture(t,n,r){this.throwIfDisposed(),this.throwIfNoProgram(),mje(this.gl,t,n,r)}setOutputMatrixTexture(t,n,r){this.setOutputMatrixTextureDriver(t,r,n)}setOutputPackedMatrixTexture(t,n,r){this.throwIfDisposed();const[s,a]=ib(n,r);this.setOutputMatrixTextureDriver(t,s,a)}setOutputMatrixWriteRegion(t,n,r,s){this.setOutputMatrixWriteRegionDriver(r,t,s,n)}setOutputPackedMatrixWriteRegion(t,n,r,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&Rk(this.gl,this.program),M2(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;if(this.debug){const n=this.getVertexArray();console.assert(n===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}st(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),st(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=F2(this.gl,ke().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(ke().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),a=r.createQuery();return r.beginQuery(s.TIME_ELAPSED_EXT,a),a}const t=this.getQueryTimerExtensionWebGL1(),n=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,n),n}endQuery(){if(ke().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const n=this.gl,r=this.getQueryTimerExtensionWebGL2();n.endQuery(r.TIME_ELAPSED_EXT);return}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await F_(()=>this.disposed||this.isQueryAvailable(t,ke().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(t,ke().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,n){if(n===0)return null;if(n===2){const r=this.gl;return r.getQueryParameter(t,r.QUERY_RESULT)/1e6}else{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(t,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,n){if(n===0)return!0;if(n===2){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),a=r.getQueryParameter(t,r.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),a&&!this.disjoint}else{const r=this.getQueryTimerExtensionWebGL1(),s=r.getQueryObjectEXT(t,r.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}}pollFence(t){return new Promise(n=>{this.addItemToPoll(()=>t.isFencePassed(),()=>n())})}pollItems(){const t=Mqe(this.itemsToPoll.map(n=>n.isDoneFn));for(let n=0;n<=t;++n){const{resolveFn:r}=this.itemsToPoll[n];r()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,n){if(this.itemsToPoll.push({isDoneFn:t,resolveFn:n}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in ke().platform&&(r=ke().platform.setTimeoutCustom.bind(ke().platform)),F_(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,r)}bindTextureToFrameBuffer(t){this.throwIfDisposed(),_k(this.gl,t,this.framebuffer),this.debug&&M2(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(_k(this.gl,this.outputTexture,this.framebuffer),this.debug&&M2(this.gl)):YD(this.gl,this.framebuffer)}downloadMatrixDriver(t,n){this.bindTextureToFrameBuffer(t);const r=n();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(t,n,r){this.throwIfDisposed();const s=this.gl;_k(s,t,this.framebuffer),this.debug&&M2(s),this.outputTexture=t,st(s,()=>s.viewport(0,0,n,r)),st(s,()=>s.scissor(0,0,n,r))}setOutputMatrixWriteRegionDriver(t,n,r,s){this.throwIfDisposed(),st(this.gl,()=>this.gl.scissor(t,n,r,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function Mqe(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:Oqe,bincountImpl:ZH,bincountReduceImpl:Lqe,bitwiseAndImpl:Pqe,castImpl:Bqe,ceilImpl:zqe,concatImpl:Wqe,equalImpl:Vqe,expImpl:Uqe,expm1Impl:Gqe,floorImpl:Hqe,gatherNdImpl:jqe,gatherV2Impl:qqe,greaterImpl:Kqe,greaterEqualImpl:Xqe,lessImpl:Qqe,lessEqualImpl:Yqe,linSpaceImpl:Jqe,logImpl:Zqe,maxImpl:eKe,maximumImpl:tKe,minimumImpl:nKe,multiplyImpl:rKe,negImpl:sKe,notEqualImpl:aKe,prodImpl:iKe,raggedGatherImpl:oKe,raggedRangeImpl:lKe,raggedTensorToTensorImpl:uKe,rangeImpl:cKe,rsqrtImpl:dKe,scatterImpl:hKe,sigmoidImpl:pKe,simpleAbsImpl:ej,sliceImpl:fKe,sparseFillEmptyRowsImpl:mKe,sparseReshapeImpl:gKe,sparseSegmentReductionImpl:tj,sqrtImpl:bKe,staticRegexReplaceImpl:yKe,stridedSliceImpl:xKe,stringNGramsImpl:wKe,stringSplitImpl:vKe,stringToHashBucketFastImpl:IKe,subImpl:kKe,tileImpl:CKe,topKImpl:SKe,transposeImpl:k$,uniqueImpl:NKe}=Aze;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nj(e,t){return["x","y","z","w","u","v"].slice(0,t).map(n=>`${e}.${n}`)}function Bs(e,t){return t===1?[e]:nj(e,t)}function TKe(e,t){if(e===1)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class EKe{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=$s(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const n=Bs("rc",this.rank),r=Vn(this.rank),s=this.getOutOfBoundsCondition(n),a=this.getSetup(n),i=this.getOutput(n);this.userCode=`
        void main() {
          ${r} rc = getOutputCoords();

          if(${s}) {
            setOutput(vec4(0));
          } else {
            ${a}

            setOutput(vec4(${i}));
          }
        }
      `}}getSourceCoordsArr(t){const n=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let a=`${r===0?"r":"rp1"}, ${s===0?"c":"cp1"}`;for(let i=2;i<this.rank;i++)a=`${t[t.length-1-i]},`+a;n.push(a)}return n}getOutOfBoundsCondition(t){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let n="";for(let r=this.rank-2;r<this.rank;r++)n+=`${t[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(n+="||");return n}getSetup(t){if(this.rank===1)return"";const n=t.slice(-2),r=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],s=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${n[0]};
      int c = ${n[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${r};
      bool rEdge = rp1 >= ${s};
    `}getOutput(t){const n=this.getSourceCoordsArr(t);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${n[0]}),
            cEdge ? 0. : getA(${n[1]}),
            rEdge ? 0. : getA(${n[2]}),
            rEdge || cEdge ? 0. : getA(${n[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rj{constructor(t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=$s(this.outputShape.length);let r="";for(let s=0;s<4;s++){let a="thisRC = rc;";s%2===1&&(a+="thisRC.z += 1;"),s>1&&(a+="thisRC.y += 1;"),r+=`
        ${a}
        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${s}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${s>0?"}":""}
      `}this.userCode=`
      ${AKe(n,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?v$():w$(t)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};

        ${r}

        setOutput(result);
      }
    `}}function AKe(e,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?Tje(["r","c","d"],"inputShape"):op(["r","c","d"],e)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $Ke{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(t,n,r){const s=nF(n,r),a=rF(t,s,r);a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]);const i=tF(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();const u=this.freeTextures[a].pop();return this.usedTextures[a].push(u),u}let o;return s===ps.PACKED_2X2_FLOAT32?o=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):s===ps.PACKED_2X2_FLOAT16?o=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):s===ps.UNPACKED_FLOAT32?o=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):s===ps.UNPACKED_FLOAT16?o=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):s===ps.PACKED_4X1_UNSIGNED_BYTE&&(o=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[a].push(o),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),o}releaseTexture(t,n,r,s){if(this.freeTextures==null)return;const a=nF(r,s),i=rF(n,a,s);i in this.freeTextures||(this.freeTextures[i]=[]);const o=tF(n,a,this.gpgpu.gl,this.gpgpu.textureConfig,s),u=ke().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");u!==-1&&this._numBytesAllocated>u?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=o):(this.freeTextures[i].push(t),this.numFreeTextures++,this._numBytesFree+=o),this.numUsedTextures--;const c=this.usedTextures[i],l=c&&c.indexOf(t);if(l==null||l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c[l]=c[c.length-1],c.pop(),this.log()}log(){if(!this.logEnabled)return;const t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${t})`);const n=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*n)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const t in this.freeTextures)this.freeTextures[t].forEach(n=>{this.gpgpu.deleteMatrixTexture(n.texture)});for(const t in this.usedTextures)this.usedTextures[t].forEach(n=>{this.gpgpu.deleteMatrixTexture(n.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function RKe(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function tF(e,t,n,r,s){const a=_Ke(t,r);let i;if(s){const[u,c]=ib(e[0],e[1]);i=u*c}else{const[u,c]=r2(e[0],e[1]);i=u*c}const o=RKe(n,a);return i*o}function _Ke(e,t){switch(e){case ps.PACKED_2X2_FLOAT32:return YH(t);case ps.PACKED_2X2_FLOAT16:return JH(t);case ps.UNPACKED_FLOAT32:return KH(t);case ps.UNPACKED_FLOAT16:return XH(t);case ps.PACKED_4X1_UNSIGNED_BYTE:return QH(t);default:throw new Error(`Unknown physical texture type ${e}`)}}function DKe(e){return ke().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?ps.PACKED_2X2_FLOAT32:ps.UNPACKED_FLOAT32:e?ps.PACKED_2X2_FLOAT16:ps.UNPACKED_FLOAT16}function nF(e,t){if(e===Wa.UPLOAD)return ps.PACKED_2X2_FLOAT32;if(e===Wa.RENDER||e==null)return DKe(t);if(e===Wa.DOWNLOAD||e===Wa.PIXELS)return ps.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function rF(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yo{constructor(t,n){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=$s(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${n}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const xi="if (isnan(x)) return x;",FKe="return x;",sF="return abs(x);",MKe="return (x >= 0.0) ? x : (exp(x) - 1.0);",OKe=xi+`
  return (x < 0.0) ? 0.0 : x;
`,LKe=xi+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Rl="return x;",PKe="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BKe="return x;",zKe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,WKe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,VKe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,UKe="return 1.0 / (1.0 + exp(-1.0 * x));";class zl{constructor(t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=$s(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${n}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GKe{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=$s(this.outputShape.length);const n=t.length,r=Bs("rc",n),s=Vn(n),a=TKe(n,r),i=r.slice(-2),o=n<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`
      void main() {
        ${s} rc = getOutputCoords();
        vec4 packedInput = getA(${a});

        setOutput(getChannel(packedInput, ${o}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HKe=jW,jKe=1e-7,qKe=1e-4,P2={};function KKe(e){return e in P2||(P2[e]={}),P2[e]}const XKe=ke().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),QKe=600;function YKe(){return ke().global.screen==null?1024:ke().global.screen.height*ke().global.screen.width*window.devicePixelRatio*QKe/1024/1024}class UI extends Pv{nextDataId(){return UI.nextDataId++}constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!ke().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let n;if(t!=null){if(t instanceof Mk)n=t;else{const r=Yi(ke().getNumber("WEBGL_VERSION"),t);n=new Mk(r)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const r=Yi(ke().getNumber("WEBGL_VERSION"));n=new Mk(r),this.binaryCache=KKe(ke().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=n,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new $Ke(this.gpgpu),this.numMBBeforeWarning=YKe(),this.texData=new sE(this,Fi())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(t,n,r,s,a,i){const o=this.makeTensorInfo(n,r),u=this.texData.get(o.dataId);u.isPacked=!1,u.texture={texture:t,texShape:[s,a]},u.texShape=[s,a];const c=O2(n),l=new eF(c,!1,i),d=this.runWebGLProgram(l,[o],r,[[s,a]]);return d.shape=n,u.texture=null,this.disposeIntermediateTensorInfo(o),d.dataId}write(t,n,r){if((ke().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||ke().getBool("DEBUG"))&&this.checkNumericalProblems(t),r==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const s={id:this.nextDataId()};return this.texData.set(s,{shape:n,dtype:r,values:t,usage:Wa.UPLOAD,refCount:1}),s}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){const n=this.texData.get(t);n.refCount++}decRef(t){if(this.texData.has(t)){const n=this.texData.get(t);n.refCount--}}move(t,n,r,s,a){if(ke().getBool("DEBUG")&&this.checkNumericalProblems(n),s==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:r,dtype:s,values:n,usage:Wa.UPLOAD,refCount:a})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){const n=this.texData.get(t),{values:r,dtype:s,complexTensorInfos:a,slice:i,shape:o,isPacked:u}=n;if(i!=null){let h;u?h=new zl(o,Rl):h=new yo(o,Rl);const p=this.runWebGLProgram(h,[{dataId:t,shape:o,dtype:s}],s),f=this.readSync(p.dataId);return this.disposeIntermediateTensorInfo(p),f}if(r!=null)return this.convertAndCacheOnCPU(t);if(s==="string")return r;const c=this.activeTimers!=null;let l;c&&(l=ws());let d;if(s==="complex64"){const h=this.readSync(a.real.dataId),p=this.readSync(a.imag.dataId);d=cl(h,p)}else d=this.getValuesFromTexture(t);return c&&(this.downloadWaitMs+=ws()-l),this.convertAndCacheOnCPU(t,d)}async read(t){if(this.pendingRead.has(t)){const f=this.pendingRead.get(t);return new Promise(m=>f.push(m))}const n=this.texData.get(t),{values:r,shape:s,slice:a,dtype:i,complexTensorInfos:o,isPacked:u}=n;if(a!=null){let f;u?f=new zl(s,Rl):f=new yo(s,Rl);const m=this.runWebGLProgram(f,[{dataId:t,shape:s,dtype:i}],i),g=this.read(m.dataId);return this.disposeIntermediateTensorInfo(m),g}if(r!=null)return this.convertAndCacheOnCPU(t);if(ke().getBool("DEBUG")&&!ke().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&ke().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c=null,l;if(i!=="complex64"&&ke().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(t);const f=this.texData.get(l.dataId);c=this.gpgpu.createBufferFromTexture(f.texture.texture,...D2(s))}this.pendingRead.set(t,[]),i!=="complex64"&&await this.gpgpu.createAndWaitForFence();let d;if(i==="complex64"){const f=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),m=f[0],g=f[1];d=cl(m,g)}else if(c==null)d=this.getValuesFromTexture(t);else{const f=fe(s);d=this.gpgpu.downloadFloat32MatrixFromBuffer(c,f)}if(l!=null&&this.disposeIntermediateTensorInfo(l),c!=null){const f=this.gpgpu.gl;st(f,()=>f.deleteBuffer(c))}const h=this.convertAndCacheOnCPU(t,d),p=this.pendingRead.get(t);return this.pendingRead.delete(t),p.forEach(f=>f(h)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&Fi().removeDataId(t,this),this.pendingDeletes--),h}readToGPU(t,n={}){const r=this.texData.get(t),{values:s,shape:a,slice:i,dtype:o,isPacked:u,texture:c}=r;if(o==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(i!=null){let p;u?p=new zl(a,Rl):p=new yo(a,Rl);const f=this.runWebGLProgram(p,[{dataId:t,shape:a,dtype:o}],o),m=this.readToGPU(f,n);return this.disposeIntermediateTensorInfo(f),m}if(c==null)throw s!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const l=this.decode(t,n.customTexShape),d=Fi().makeTensorFromTensorInfo(l),h=this.texData.get(l.dataId);return Object.assign({tensorRef:d},h.texture)}bufferSync(t){const n=this.readSync(t.dataId);if(t.dtype==="string")try{const r=n.map(s=>cu(s));return Yt(t.shape,t.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Yt(t.shape,t.dtype,n)}checkNumericalProblems(t){if(t!=null)for(let n=0;n<t.length;n++){const r=t[n];if(!eje(r))throw ke().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${r} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${r} cannot be represented on this device.`)}}getValuesFromTexture(t){const{shape:n,dtype:r,isPacked:s}=this.texData.get(t),a=fe(n);if(ke().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const h=this.decode(t),p=this.texData.get(h.dataId),f=this.gpgpu.downloadMatrixFromPackedTexture(p.texture.texture,...D2(n)).subarray(0,a);return this.disposeIntermediateTensorInfo(h),f}const i=ke().getBool("WEBGL_PACK")&&s===!0,o=i?O2(n):n,u=i?new gqe(o):new mqe(o),c=this.runWebGLProgram(u,[{shape:o,dtype:r,dataId:t}],"float32"),l=this.texData.get(c.dataId),d=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(l.texture.texture,l.texShape[0],l.texShape[1]).subarray(0,a);return this.disposeIntermediateTensorInfo(c),d}timerAvailable(){return ke().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){const n=this.activeTimers,r=[];let s=!1;this.programTimersStack==null?(this.programTimersStack=r,s=!0):this.activeTimers.push(r),this.activeTimers=r,t();const a=rd(this.activeTimers.map(u=>u.query)).filter(u=>u!=null),i=rd(this.activeTimers.map(u=>u.name)).filter(u=>u!=null);this.activeTimers=n,s&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(ke().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const u=await Promise.all(a);o.kernelMs=P_e(u),o.getExtraProfileInfo=()=>u.map((c,l)=>({name:i[l],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return ke().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:ws(),endMs:null}}endTimer(t){return ke().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=ws(),t)}async getQueryTime(t){if(ke().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);const n=t;return n.endMs-n.startMs}disposeData(t,n=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(n?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!n&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);const{complexTensorInfos:r}=this.texData.get(t);return r!=null&&(this.disposeData(r.real.dataId,n),this.disposeData(r.imag.dataId,n)),this.texData.delete(t),!0}releaseGPUData(t){const{texture:n,dtype:r,texShape:s,usage:a,isPacked:i,slice:o}=this.texData.get(t),u=o&&o.origDataId||t,c=this.dataRefCount.get(u);c>1?this.dataRefCount.set(u,c-1):(this.dataRefCount.delete(u),n!=null&&(this.numBytesInGPU-=this.computeBytes(s,r),this.textureManager.releaseTexture(n,s,a,i)));const l=this.texData.get(t);l.texture=null,l.texShape=null,l.isPacked=!1,l.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,n=XKe){return ke().getBool("WEBGL_CPU_FORWARD")&&t.every(r=>this.texData.get(r.dataId).texture==null&&fe(r.shape)<n)}getGPGPUContext(){return this.gpgpu}where(t){Oa("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const n=t.dataSync();return HKe(t.shape,n)}packedUnaryOp(t,n,r){const s=new zl(t.shape,n),a=this.compileAndRun(s,[t],r);return Fi().makeTensorFromTensorInfo(a)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){const s=ej(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,s)}if(ke().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,sF,t.dtype);const n=new yo(t.shape,sF),r=this.compileAndRun(n,[t]);return Fi().makeTensorFromTensorInfo(r)}makeTensorInfo(t,n,r){let s;if(n==="string"&&r!=null&&r.length>0&&K0(r[0])){const a=r.map(i=>jl(i));s=this.write(a,t,n)}else s=this.write(r,t,n);return this.texData.get(s).usage=null,{dataId:s,shape:t,dtype:n}}makeOutput(t,n,r){return Fi().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,r),this)}unpackTensor(t){const n=new GKe(t.shape);return this.runWebGLProgram(n,[t],t.dtype)}packTensor(t){const n=new EKe(t.shape);return this.runWebGLProgram(n,[t],t.dtype,null,!0)}packedReshape(t,n){const r=[cf(t.shape),...df(t.shape)],s={dtype:t.dtype,shape:r,dataId:t.dataId},a=[cf(n),...df(n)],i=new rj(a,r),o=!0,u=[r],c=this.runWebGLProgram(i,[s],t.dtype,u,o);return{dataId:c.dataId,shape:n,dtype:c.dtype}}decode(t,n){const r=this.texData.get(t),{isPacked:s,shape:a,dtype:i}=r;if(n!=null){const h=fe(a),p=n[0]*n[1]*4;U(h<=p,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const o=O2(a);let u;s?u=new fqe(o):u=new pqe(o);const c=!0,l=[n??D2(o)],d=this.runWebGLProgram(u,[{shape:o,dtype:i,dataId:t}],i,l,c,n);return{dtype:i,shape:a,dataId:d.dataId}}runWebGLProgram(t,n,r,s,a=!1,i){const o=this.makeTensorInfo(t.outputShape,r),u=this.texData.get(o.dataId);if(t.packedOutput&&(u.isPacked=!0),t.outPackingScheme===Ly.DENSE){const b=i??D2(t.outputShape);u.texShape=b.map(y=>y*2)}if(t.outTexUsage!=null&&(u.usage=t.outTexUsage),fe(o.shape)===0)return u.values=ks(o.dtype,0),o;const c=[],l=n.map(b=>{if(b.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let y=this.texData.get(b.dataId);if(y.texture==null){if(!t.packedInputs&&fe(b.shape)<=ke().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:b.shape,texData:null,isUniform:!0,uniformValues:y.values};t.packedInputs&&(y.isPacked=!0,y.shape=b.shape)}if(this.uploadToGPU(b.dataId),!!y.isPacked!=!!t.packedInputs)b=y.isPacked?this.unpackTensor(b):this.packTensor(b),c.push(b),y=this.texData.get(b.dataId);else if(y.isPacked&&!rw(y.shape,b.shape)){const x=b,w=b.shape;b.shape=y.shape,b=this.packedReshape(b,w),c.push(b),y=this.texData.get(b.dataId),x.shape=w}return{shape:b.shape,texData:y,isUniform:!1}});this.uploadToGPU(o.dataId);const d={shape:o.shape,texData:u,isUniform:!1},h=hqe(t,l,d),p=this.getAndSaveBinary(h,()=>cqe(this.gpgpu,t,l,d)),f=this.activeTimers!=null;let m;f&&(m=this.startTimer()),ke().get("ENGINE_COMPILE_ONLY")||dqe(this.gpgpu,p,l,d,s),c.forEach(b=>this.disposeIntermediateTensorInfo(b)),f&&(m=this.endTimer(m),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(m)}));const g=ke().getNumber("WEBGL_FLUSH_THRESHOLD");if(g>0){const b=ws();b-this.lastGlFlushTime>g&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=b)}if(!ke().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&a===!1){const b=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),b}return o}compileAndRun(t,n,r,s,a=!1){return r=r||n[0].dtype,this.runWebGLProgram(t,n,r,s,a)}getAndSaveBinary(t,n){return t in this.binaryCache||(this.binaryCache[t]=n()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(ke().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(n=>{this.gpgpu.deleteProgram(this.binaryCache[n].webGLProgram),delete this.binaryCache[n]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=we(()=>{if(!ke().get("WEBGL_RENDER_FLOAT32_ENABLED")){const t=ke().getBool("DEBUG");ke().set("DEBUG",!1);const n=this.abs(Sn(1e-8)).dataSync()[0];if(ke().set("DEBUG",t),n>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?jKe:qKe}uploadToGPU(t){const n=this.texData.get(t),{shape:r,dtype:s,values:a,texture:i,usage:o,isPacked:u}=n;if(i!=null)return;const c=this.activeTimers!=null;let l;c&&(l=ws());let d=n.texShape;if(d==null&&(d=yje(r,u),n.texShape=d),a!=null){const h=O2(r);let p,f=d[1],m=d[0];const g=a instanceof Uint8Array||a instanceof Uint8ClampedArray;(u||!g)&&([f,m]=ib(d[0],d[1])),u?p=new yqe(h,g):p=new eF(h,g);const b=g?[m,f]:d,y=this.makeTensorInfo(b,s),x=this.texData.get(y.dataId);g?x.usage=Wa.PIXELS:x.usage=Wa.UPLOAD,x.texShape=b,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(y.dataId),f,m,a);const w=[[m,f]],I=this.runWebGLProgram(p,[y],s,w,!0),N=this.texData.get(I.dataId);n.texShape=N.texShape,n.isPacked=N.isPacked,n.usage=N.usage,ke().get("ENGINE_COMPILE_ONLY")?this.disposeData(I.dataId):(n.texture=N.texture,n.values=null,this.texData.delete(I.dataId)),this.disposeIntermediateTensorInfo(y),c&&(this.uploadWaitMs+=ws()-l)}else{const h=this.acquireTexture(d,o,s,u);n.texture=h}}convertAndCacheOnCPU(t,n){const r=this.texData.get(t),{dtype:s}=r;return n!=null&&(r.values=JKe(n,s)),r.values}acquireTexture(t,n,r,s){if(this.numBytesInGPU+=this.computeBytes(t,r),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const a=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${a} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,n,s)}computeBytes(t,n){return t[0]*t[1]*Jp(n)}checkCompileCompletion(){for(const[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){const t=[];if(this.gpgpu.parallelCompilationExtension){for(const[,n]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(n));return Promise.all(t)}else{for(const[,n]of Object.entries(this.binaryCache)){const r=new Promise(s=>{try{this.checkCompletion_(n),s(!0)}catch(a){throw a}});t.push(r)}return Promise.all(t)}}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await uV(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(VH(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const t of Object.values(this.binaryCache)){this.gpgpu.buildVao(t.webGLProgram);const{variablesLocations:n,customUniformLocations:r,infLoc:s,nanLoc:a,outShapeLocation:i,outShapeStridesLocation:o,outTexShapeLocation:u}=qH(this.gpgpu,t.program,t.webGLProgram);t.variablesLocations=n,t.customUniformLocations=r,t.infLoc=s,t.nanLoc=a,t.outShapeLocation=i,t.outShapeStridesLocation=o,t.outTexShapeLocation=u}}createTensorFromGPUData(t,n,r){t.channels=t.channels||"RGBA";const{texture:s,height:a,width:i,channels:o}=t,u=Fi().backend;if(!u.gpgpu.gl.isTexture(s))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const c=u.writeTexture(s,n,r,a,i,o);return Fi().makeTensorFromDataId(c,n,r,u)}}UI.nextDataId=0;function JKe(e,t){if(t==="float32"||t==="complex64")return e;if(t==="int32"||t==="bool"){const n=t==="int32"?new Int32Array(e.length):new Uint8Array(e.length);for(let r=0;r<n.length;++r)n[r]=Math.round(e[r]);return n}else throw new Error(`Unknown dtype ${t}`)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */oW()&&_E("webgl",()=>new UI,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const C$=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class md{constructor(t,n,r){this.variableNames=["A","B"],this.outputShape=Ot(n,r),this.enableShapeUniforms=$s(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${t}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const up=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class db{constructor(t,n,r,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Ot(n,r);const a=this.outputShape.length;this.enableShapeUniforms=$s(a);let i="";if(s)if(a===0||fe(this.outputShape)===1)i=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(i=`
          ${Vn(a)} coords = getOutputCoords();
        `,a===1)this.enableShapeUniforms?i+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:i+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const u=Bs("coords",a);this.enableShapeUniforms?i+=`
            bool nextRowOutOfBounds =
              (${u[a-2]} + 1) >= outShape[${a} - 2];
            bool nextColOutOfBounds =
              (${u[a-1]} + 1) >= outShape[${a} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:i+=`
            bool nextRowOutOfBounds =
              (${u[a-2]} + 1) >= ${this.outputShape[a-2]};
            bool nextColOutOfBounds =
              (${u[a-1]} + 1) >= ${this.outputShape[a-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${t}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${i}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _a(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const ZKe={kernelName:dg,backendName:"webgl",kernelFunc:_a};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vu(e){const{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.makeTensorInfo(r.shape,"complex64"),i=n.texData.get(a.dataId),o=_a({inputs:{x:r},backend:n}),u=_a({inputs:{x:s},backend:n});return i.complexTensorInfos={real:o,imag:u},a}const eXe={kernelName:dE,backendName:"webgl",kernelFunc:Vu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sj="return (a < 0.) ? b * a : a;",aj=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function tXe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:a}=r,i=n.makeTensorInfo([],"float32",Mu(a,"float32")),o=ke().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new db(aj,s.shape,i.shape):new md(sj,s.shape,i.shape),u=n.runWebGLProgram(o,[s,i],"float32");return n.disposeIntermediateTensorInfo(i),u}const nXe={kernelName:mg,backendName:"webgl",kernelFunc:tXe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ij="return (a < 0.) ? b * a : a;",oj=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function rXe(e){const{inputs:t,backend:n}=e,{x:r,alpha:s}=t,a=ke().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new db(oj,r.shape,s.shape):new md(ij,r.shape,s.shape);return n.runWebGLProgram(a,[r,s],"float32")}const sXe={kernelName:Rg,backendName:"webgl",kernelFunc:rXe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hb="if (isnan(x)) return x;";function hn({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return({inputs:s,backend:a})=>{const{x:i}=s,o=a,u=r||i.dtype;if(o.shouldExecuteOnCPU([i])&&n!=null){const d=o.texData.get(i.dataId),h=n(d.values,u);return o.makeTensorInfo(i.shape,u,h)}const c=ke().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null;let l;return c?l=new zl(i.shape,t):l=new yo(i.shape,e),o.runWebGLProgram(l,[i],u)}}function ys({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:a}){return({inputs:i,backend:o})=>{const{a:u,b:c}=i,l=o;if(r&&u.dtype==="complex64"){const f=l.texData.get(u.dataId),m=l.texData.get(c.dataId),[g,b]=[[f.complexTensorInfos.real,m.complexTensorInfos.real],[f.complexTensorInfos.imag,m.complexTensorInfos.imag]].map(x=>{const[w,v]=x,I={dataId:w.dataId,dtype:w.dtype,shape:u.shape},N={dataId:v.dataId,dtype:v.dtype,shape:c.shape},T=new md(e,u.shape,c.shape);return l.runWebGLProgram(T,[I,N],$a(w.dtype,v.dtype))}),y=Vu({inputs:{real:g,imag:b},backend:l});return l.disposeIntermediateTensorInfo(g),l.disposeIntermediateTensorInfo(b),y}const d=a||$a(u.dtype,c.dtype);if((u.dtype==="string"||c.dtype==="string"||l.shouldExecuteOnCPU([u,c]))&&s!=null){const f=l.texData.get(u.dataId).values,m=l.texData.get(c.dataId).values,g=u.dtype==="string"?dl(f):f,b=u.dtype==="string"?dl(m):m,[y,x]=s(u.shape,c.shape,g,b,d),w=l.makeTensorInfo(x,d),v=l.texData.get(w.dataId);return v.values=y,w}const h=ke().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null;let p;return h?p=new db(t,u.shape,c.shape,n):p=new md(e,u.shape,c.shape),l.runWebGLProgram(p,[u,c],d)}}function Py(e,t=!1){if(e==="linear")return t?BKe:FKe;if(e==="relu")return t?WKe:OKe;if(e==="elu")return t?zKe:MKe;if(e==="relu6")return t?VKe:LKe;if(e==="prelu")return t?oj:ij;if(e==="leakyrelu")return t?aj:sj;if(e==="sigmoid")return t?UKe:PKe;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lj{constructor(t,n,r,s=!1,a=!1,i=!1,o=null,u=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=$s(this.outputShape.length);const l=s?t[1]:t[2],d=Math.ceil(l/2),h=s?"i * 2, rc.y":"rc.y, i * 2",p=a?"rc.z, i * 2":"i * 2, rc.z",f=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],m=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let g="",b="";o&&(u?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${o}
        }`:c?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${o}
        }`:g=`vec4 activation(vec4 x) {
          ${o}
        }`,b="result = activation(result);");const y=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let x="rc.x",w="rc.x";t[0]<n[0]?x=`imod(rc.x, ${t[0]})`:n[0]<t[0]&&(w=`imod(rc.x, ${n[0]})`),this.userCode=`
      ${g}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${d}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${x};
        int batchB = ${w};
        for (int i = 0; i < ${d}; i++) {
          vec4 a = getMatrixA(batchA, ${h});
          vec4 b = getMatrixB(batchB, ${p});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${f[0]} * ${m[0]});
          result += (${f[1]} * ${m[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${y}

        ${b}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aF={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class iF{constructor(t,n,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Ot(n,r),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${t}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oF="return a * b;";function S$(e){const{inputs:t,backend:n}=e,{a:r,b:s}=t,a=$a(r.dtype,s.dtype);if(r.dtype==="complex64"){const o=n.texData.get(r.dataId),u=n.texData.get(s.dataId),c=new iF(aF.REAL,r.shape,s.shape),l=new iF(aF.IMAG,r.shape,s.shape),d=[{dataId:o.complexTensorInfos.real.dataId,dtype:o.complexTensorInfos.real.dtype,shape:r.shape},{dataId:o.complexTensorInfos.imag.dataId,dtype:o.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:s.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:s.shape}],h=n.runWebGLProgram(c,d,"float32"),p=n.runWebGLProgram(l,d,"float32"),f=Vu({inputs:{real:h,imag:p},backend:n});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),f}if(n.shouldExecuteOnCPU([r,s])){const o=n.texData.get(r.dataId),u=n.texData.get(s.dataId),[c,l]=rKe(r.shape,s.shape,o.values,u.values,a),d=n.makeTensorInfo(l,a),h=n.texData.get(d.dataId);return h.values=c,d}let i;return ke().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new db(oF,r.shape,s.shape):i=new md(oF,r.shape,s.shape),n.runWebGLProgram(i,[r,s],a)}const aXe={kernelName:Tg,backendName:"webgl",kernelFunc:S$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iXe(e,t,n){const r=[cf(e.shape),...df(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},a=[cf(t),...df(t)],i=new rj(a,r),o=!0,u=[r],c=n.runWebGLProgram(i,[s],e.dtype,u,o);return{dataId:c.dataId,shape:t,dtype:c.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Je(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:a}=r,i=n,o=fe(s.shape),u=iE(a,o),c=fe(u);U(o===c,()=>`The new shape (${u}) has ${c} elements and the old shape (${s.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);const l=i.texData.get(s.dataId);return l.isPacked&&!rw(s.shape,u)&&!(l.texture!==null&&rw(l.shape,u))?iXe(s,u,i):(i.incRef(s.dataId),{dataId:s.dataId,shape:u,dtype:s.dtype})}const oXe={kernelName:$1,backendName:"webgl",kernelFunc:Je};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lF{constructor(t,n){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:a,outSize:i}=t;this.outputShape=[s,i];const o=Math.floor(r/4)*4,u=r%4;let c="sumValue += dot(values, ones);";if(n!=null){const d=1/n;c=`sumValue += dot(values * ${Yp(d)?d.toPrecision(2):d}, ones);`}let l="";a%r>0&&(l=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${l}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        float sumValue = 0.0;

        for (int i = 0; i < ${o}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${c}
        }

        int inIdx = inOffset + ${o};
        if (${u===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${c}
        } else if (${u===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${c}
        } else if (${u===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${c}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lXe{constructor(t,n){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:a,outSize:i}=t;this.outputShape=[s,i];let o="0.0",u="";n==="prod"?o="1.0":n==="min"?(o="1.0 / 1e-20",u="min"):n==="max"&&(o="-1.0 / 1e-20",u="max");let c=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="sum"?c="sumValue":n==="prod"?c="prodValue":n==="all"?c="allValue":n==="any"&&(c="anyValue");const l=Math.floor(r/4)*4,d=r%4;let h=`
      if (${n==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${n==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${u}(values, minMaxValue);
        if (${n==="min"} || ${n==="max"}) {
          minMaxValue = ${u}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,p="vec4";n==="all"?(o="1.0",h=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,p="bvec4"):n==="any"&&(o="0.0",h=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,p="bvec4");let f="";a%r>0&&(f=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${o};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        vec4 minMaxValue = vec4(${o});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${l}; i += 4) {
          int inIdx = inOffset + i;
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${h}
        }

        int inIdx = inOffset + ${l};
        if (${d===1}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${h}
        } else if (${d===2}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${h}
        } else if (${d===3}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${h}
        }
        setOutput(${c});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uXe(e){const t=[];for(;t.length===0||t[t.length-1].outSize!==1;){const n=t.length?t[t.length-1].outSize:e[1],r=II(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}function cp(e,t,n,r){const s=uXe(e.shape);let a=e;for(let i=0;i<s.length;i++){const{inSize:o,windowSize:u,outSize:c}=s[i];let l,d;n==="mean"?l=i===0?new lF({windowSize:u,inSize:o,batchSize:e.shape[0],outSize:c},o):new lF({windowSize:u,inSize:o,batchSize:e.shape[0],outSize:c}):l=new lXe({windowSize:u,inSize:o,batchSize:e.shape[0],outSize:c},n),d=a,a=r.runWebGLProgram(l,[a],t),d.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(d)}return a}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cXe{constructor(t,n){this.variableNames=["A"];const r=new Array(t.length);for(let i=0;i<r.length;i++)r[i]=t[n[i]];this.outputShape=r,this.rank=r.length;const s=Vn(this.rank),a=dXe(n);this.userCode=`
    void main() {
      ${s} resRC = getOutputCoords();
      setOutput(getA(${a}));
    }
    `}}function dXe(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let s=0;s<e.length;s++)r[e[s]]=n[s];return r.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hXe{constructor(t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=new Array(t.length);for(let l=0;l<r.length;l++)r[l]=t[n[l]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const s=Vn(this.rank),a=nj("rc",this.rank),i=new Array(this.rank);for(let l=0;l<n.length;l++)i[n[l]]=a[l];const o=`vec2(${i.slice(-2).join()})`,u=`++${a[this.rank-1]} < ${r[this.rank-1]}`,c=`getChannel(getA(${i.join()}), ${o})`;this.userCode=`
    void main() {
      ${s} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${c};
      if(${u}) {
        result[1] = ${c};
      }
      --${a[this.rank-1]};
      if(++${a[this.rank-2]} < ${r[this.rank-2]}) {
        result[2] = ${c};
        if(${u}) {
          result[3] = ${c};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GI(e,t,n){const r=ke().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new hXe(e.shape,t):new cXe(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pXe(e,t,n,r){const s=t,a=e.shape.length,i=zt(s,e.shape);let o=i;const u=nr(o,a),c=u!=null;let l=e;c&&(l=GI(e,u,r),o=qn(o.length,a)),tr("sum",o,a);const[d,h]=sr(l.shape,o);let p=d;n&&(p=jn(d,i));const f=fe(h),g=fe(e.shape)/f,b=Je({inputs:{x:l},attrs:{shape:[g,f]},backend:r}),y=$E(e.dtype),x=cp(b,y,"sum",r),w=Je({inputs:{x},attrs:{shape:p},backend:r});return r.disposeIntermediateTensorInfo(b),r.disposeIntermediateTensorInfo(x),c&&r.disposeIntermediateTensorInfo(l),w}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HI(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;return pXe(s,a,i,n)}const fXe={kernelName:Kg,backendName:"webgl",kernelFunc:HI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function js(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{perm:a}=r,i=n,o=s.shape.length,u=new Array(o);for(let l=0;l<u.length;l++)u[l]=s.shape[a[l]];let c;if(i.shouldExecuteOnCPU([s])){const d=i.texData.get(s.dataId).values,h=k$(d,s.shape,s.dtype,a,u);c=i.makeTensorInfo(u,s.dtype);const p=i.texData.get(c.dataId);p.values=h}else c=GI(s,a,i);return c}const mXe={kernelName:Gl,backendName:"webgl",kernelFunc:js};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uj=1e3;function sw({a:e,b:t,transposeA:n,transposeB:r,backend:s,bias:a=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:u=null}){const c=e.shape.length,l=t.shape.length,d=n?e.shape[c-2]:e.shape[c-1],h=r?t.shape[l-1]:t.shape[l-2],p=n?e.shape[c-1]:e.shape[c-2],f=r?t.shape[l-2]:t.shape[l-1],m=e.shape.slice(0,-2),g=t.shape.slice(0,-2),b=fe(m),y=fe(g),w=Ot(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([p,f]);U(d===h,()=>`Error in matMul: inner shapes (${d}) and (${h}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`);const v=n?[b,d,p]:[b,p,d],I=r?[y,f,h]:[y,h,f],N=Je({inputs:{x:e},backend:s,attrs:{shape:v}}),T=Je({inputs:{x:t},backend:s,attrs:{shape:I}}),E=[N,T],A=Math.max(b,y),k=n?N.shape[1]:N.shape[2],C=a!=null,M=i!=null,L=u==="leakyrelu",O=u!=null?Py(u,!0):null,B=C||M||L||O!=null;let G;if((p===1||f===1)&&k>uj&&B===!1){let q=N,Q=T;n&&(q=js({inputs:{x:N},backend:s,attrs:{perm:[0,2,1]}}),E.push(q)),r&&(Q=js({inputs:{x:T},backend:s,attrs:{perm:[0,2,1]}}),E.push(Q));const K=f!==1,ee=f===1;let Y=q;K&&(Y=Je({inputs:{x:q},backend:s,attrs:{shape:[A,k,1]}}),E.push(Y));const de=f===1?2:1;let ue=Q;ee&&(ue=Je({inputs:{x:Q},backend:s,attrs:{shape:[A,1,k]}}),E.push(ue));const Ie=S$({inputs:{a:Y,b:ue},backend:s});G=HI({inputs:{x:Ie},backend:s,attrs:{axis:de,keepDims:!0}}),E.push(Ie)}else{const q=$a(e.dtype,t.dtype),Q=new lj(v,I,[A,p,f],n,r,C,O,M,L),K=[N,T];if(a!=null&&K.push(a),M&&K.push(i),L){const ee=s.makeTensorInfo([],"float32",Mu(o,"float32"));K.push(ee),E.push(ee)}G=s.runWebGLProgram(Q,K,q)}const z=Je({inputs:{x:G},backend:s,attrs:{shape:w}});E.push(G);for(const q of E)s.disposeIntermediateTensorInfo(q);return z}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gXe(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:o}=t,{transposeA:u,transposeB:c,activation:l,leakyreluAlpha:d}=r;return sw({a:s,b:a,transposeA:u,transposeB:c,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:d,activation:l})}const bXe={kernelName:Zp,backendName:"webgl",kernelFunc:gXe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uF="return abs(x);";function yXe(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){const a=n.texData.get(r.dataId),i=ej(a.values);return n.makeTensorInfo(r.shape,r.dtype,i)}let s;return ke().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new zl(r.shape,uF):s=new yo(r.shape,uF),n.runWebGLProgram(s,[r],r.dtype)}const xXe={kernelName:X0,backendName:"webgl",kernelFunc:yXe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wXe=xi+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,vXe=hn({opSnippet:wXe}),IXe={kernelName:Lm,backendName:"webgl",kernelFunc:vXe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kXe=xi+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,CXe=hn({opSnippet:kXe}),SXe={kernelName:Pm,backendName:"webgl",kernelFunc:CXe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cF="return a + b;",NXe=ys({opSnippet:cF,packedOpSnippet:cF,supportsComplex:!0,cpuKernelImpl:Oqe}),TXe={kernelName:Xh,backendName:"webgl",kernelFunc:NXe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class EXe{constructor(t,n){this.outputShape=[],this.outputShape=t,this.variableNames=n.map((a,i)=>`T${i}`);const r=[];this.variableNames.forEach(a=>{r.push(`float v${a} = get${a}AtOutCoords();`)});const s=this.variableNames.map(a=>`v${a}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        float result = ${s};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AXe{constructor(t,n){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=n.map((a,i)=>`T${i}`);const r=[];this.variableNames.forEach(a=>{r.push(`vec4 v${a} = get${a}AtOutCoords();`)});const s=this.variableNames.map(a=>`v${a}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        vec4 result = ${s};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rx(e){const{inputs:t,backend:n}=e,r=t;if(r.length===1)return _a({inputs:{x:r[0]},backend:n});if(r.length>ke().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const u=Math.floor(r.length/2),c=rx({inputs:r.slice(0,u),backend:n}),l=rx({inputs:r.slice(u),backend:n});return rx({inputs:[c,l],backend:n})}const s=r.map(u=>u.dtype).reduce((u,c)=>$a(u,c)),a=r.map(u=>u.shape),o=ke().getBool("WEBGL_PACK")?new AXe(r[0].shape,a):new EXe(r[0].shape,a);return n.runWebGLProgram(o,r,s)}const $Xe={kernelName:Q0,backendName:"webgl",kernelFunc:rx};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RXe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,u=zt(a,s.shape);let c=u;const l=nr(c,o);let d=s;l!=null&&(d=js({inputs:{x:s},backend:n,attrs:{perm:l}}),c=qn(c.length,o)),tr("all",c,o);const[h,p]=sr(d.shape,c),f=fe(p),m=Je({inputs:{x:d},backend:n,attrs:{shape:[-1,f]}}),g=cp(m,m.dtype,"all",n);let b;if(i){const y=jn(h,u);b=Je({inputs:{x:g},backend:n,attrs:{shape:y}})}else b=Je({inputs:{x:g},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),l!=null&&n.disposeIntermediateTensorInfo(d),b}const _Xe={kernelName:Y0,backendName:"webgl",kernelFunc:RXe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DXe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,u=zt(a,s.shape);let c=u;const l=nr(c,o);let d=s;l!=null&&(d=js({inputs:{x:s},backend:n,attrs:{perm:l}}),c=qn(c.length,o)),tr("any",c,o);const[h,p]=sr(d.shape,c),f=fe(p),m=Je({inputs:{x:d},backend:n,attrs:{shape:[-1,f]}}),g=cp(m,m.dtype,"any",n);let b;if(i){const y=jn(h,u);b=Je({inputs:{x:g},backend:n,attrs:{shape:y}})}else b=Je({inputs:{x:g},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),l!=null&&n.disposeIntermediateTensorInfo(d),b}const FXe={kernelName:J0,backendName:"webgl",kernelFunc:DXe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MXe{constructor(t,n,r){this.variableNames=["A"];const{windowSize:s,batchSize:a,outSize:i}=t;r||this.variableNames.push("bestIndicesA"),this.outputShape=[a,i];const o=n==="max"?">":"<",u=r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${s}; i++) {
          int inIdx = ${u};
          float candidate = getA(batch, inIdx);
          if (candidate ${o} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class OXe{constructor(t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,U(t.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const a=t[t.length-1],i=Math.ceil(a/n);this.outputShape=t.slice(0,-1),i>1&&this.outputShape.push(i),s||this.variableNames.push("bestIndicesA");const o=this.outputShape,u=o.length,c=Vn(u),l=Bs("coords",u);let d,h;if(i===1){h=u+1;const T=Vn(h);d=`
        ${T} sourceLocR = ${T}(${l.join()}, 0);
        ++${l[u-1]};
        ${T} sourceLocG = ${T}(${l.join()}, 0);
        ++${l[u-2]};
        ${T} sourceLocA = ${T}(${l.join()}, 0);
        --${l[u-1]};
        ${T} sourceLocB = ${T}(${l.join()}, 0);
        --${l[u-2]};`}else h=u,d=`
        ${c} sourceLocR = coords;
        ++${l[u-1]};
        ${c} sourceLocG = coords;
        ++${l[u-2]};
        ${c} sourceLocA = coords;
        --${l[u-1]};
        ${c} sourceLocB = coords;
        --${l[u-2]};`;const p=["x","y","z","w","u","v"].slice(0,h),f="."+p[h-1],m=p.map(T=>"int "+T),g=Bs("sourceLocR",h-1).concat("inIdx.r"),b=Bs("sourceLocG",h-1).concat("inIdx.g"),y=Bs("sourceLocB",h-1).concat("inIdx.b"),x=Bs("sourceLocA",h-1).concat("inIdx.a"),w=r==="max"?"greaterThan":"lessThan",v=s?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${x.join()})));`,I=`vec4(
            getAChannel(${g.join()}),
            hasNextCol ? getAChannel(${b.join()}) : 0.,
            hasNextRow ? getAChannel(${y.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${x.join()}) : 0.)`,N=s?"":`
      float getBestIndicesAChannel(${m.join()}) {
        return getChannel(getBestIndicesA(${p.join()}),
                                          vec2(${p.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${m.join()}) {
        return getChannel(getA(${p.join()}),
                               vec2(${p.slice(-2).join()}));
      }
      ${N}
      void main() {
        ${c} coords = getOutputCoords();
        bool hasNextCol = ${l[u-1]} < ${o[u-1]-1};
        bool hasNextRow = ${l[u-2]} < ${o[u-2]-1};
        ${d}
        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},
          sourceLocB${f}, sourceLocA${f}) * ${n};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${I};

        for (int i = 0; i < ${n}; i++) {
          inIdx = srcIdx;
          ${v}
          vec4 candidate = ${I};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${w}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cj(e,t,n,r=null){let s=t.shape[0],a=t.shape[1];r!=null&&(s=r.shape[0],a=r.shape[1]);const i=II(a),o={windowSize:i,inSize:a,batchSize:s,outSize:Math.ceil(a/i)},u=new MXe(o,n,r==null),c=[t];r!=null&&c.push(r);const l=e.runWebGLProgram(u,c,"int32");if(l.shape[1]===1)return l;const d=cj(e,t,n,l);return e.disposeIntermediateTensorInfo(l),d}function dj(e,t,n,r=null){const s=r!=null?r.shape:t.shape,a=s[s.length-1],i=II(a),o=new OXe(s,i,n,r==null),u=r==null?[t]:[t,r],c=e.runWebGLProgram(o,u,"int32");if(c.shape.length===t.shape.length){const l=dj(e,t,n,c);return e.disposeIntermediateTensorInfo(c),l}return c}function hj(e,t,n,r){const s=[n];if(tr("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,t.shape.length),!ke().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const a=[],i=e.texData.get(t.dataId),o=i!==null&&i.isPacked;let u=t;o&&(u=e.unpackTensor(t),a.push(u));const[c,l]=sr(u.shape,s),d=fe(l),h=Je({inputs:{x:u},backend:e,attrs:{shape:[-1,d]}});a.push(h);const p=cj(e,h,r);a.push(p);const f=Je({inputs:{x:p},backend:e,attrs:{shape:c}});return a.forEach(m=>e.disposeIntermediateTensorInfo(m)),f}return dj(e,t,r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LXe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;let i=zt(a,s.shape);const o=nr(i,s.shape.length);let u=s;const c=[];o!=null&&(u=js({inputs:{x:s},backend:n,attrs:{perm:o}}),c.push(u),i=qn(i.length,u.shape.length)),tr("argMax",[i[0]],u.shape.length);const l=hj(n,u,i[0],"max");return c.forEach(d=>n.disposeIntermediateTensorInfo(d)),l}const PXe={kernelName:Z0,backendName:"webgl",kernelFunc:LXe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BXe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;let i=zt(a,s.shape);const o=nr(i,s.shape.length);let u=s;const c=[];o!=null&&(u=js({inputs:{x:s},backend:n,attrs:{perm:o}}),c.push(u),i=qn(i.length,u.shape.length)),tr("argMin",[i[0]],u.shape.length);const l=hj(n,u,i[0],"min");return c.forEach(d=>n.disposeIntermediateTensorInfo(d)),l}const zXe={kernelName:e1,backendName:"webgl",kernelFunc:BXe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WXe=xi+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,VXe=hn({opSnippet:WXe}),UXe={kernelName:Bm,backendName:"webgl",kernelFunc:VXe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GXe=xi+"return log(x + sqrt(x * x + 1.0));",HXe=hn({opSnippet:GXe}),jXe={kernelName:zm,backendName:"webgl",kernelFunc:HXe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qXe=xi+`
  return atan(x);
`,KXe=hn({opSnippet:qXe}),XXe={kernelName:Wm,backendName:"webgl",kernelFunc:KXe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QXe=C$+`
  return atan(a, b);
`,YXe=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+up+`
  return result;
`,JXe=ys({opSnippet:QXe,packedOpSnippet:YXe}),ZXe={kernelName:Um,backendName:"webgl",kernelFunc:JXe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eQe=xi+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,tQe=hn({opSnippet:eQe}),nQe={kernelName:Vm,backendName:"webgl",kernelFunc:tQe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class By{constructor(t,n,r,s=!1,a=!1){if(this.variableNames=["x"],n==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const i=t.filterWidth,o=t.strideHeight,u=t.strideWidth,c=t.dilationHeight,l=t.dilationWidth,d=t.effectiveFilterHeight,h=t.effectiveFilterWidth,p=t.padInfo.top,f=t.padInfo.left;this.outputShape=t.outShape;const m=n==="avg",g=`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`,b=`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`;let y="0.0";if(m||(y="-1.0 / 1e-20"),r){this.userCode=`
        const ivec2 strides = ivec2(${o}, ${u});
        const ivec2 pads = ivec2(${p}, ${f});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${d};
              wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${h};
                wC += ${l}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value >= currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${s?a?g:b:`wR * ${h} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const x="max";let w=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="avg"&&(w="avgValue / max(count, 1.0)");const v=Math.floor(i/4)*4,I=i%4,N=`
      if (${m}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${x}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${o}, ${u});
      const ivec2 pads = ivec2(${p}, ${f});
      const float initializationValue = ${y};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${y});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${d};
            wR += ${c}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${v}; wC += 4) {
            int xC = xCCorner + wC * ${l};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${l}, d),
              getValue(batch, xR, xC + 2 * ${l}, d),
              getValue(batch, xR, xC + 3 * ${l}, d)
            );

            ${N}
          }

          int xC = xCCorner + ${v};
          if (${I===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${N}
          } else if (${I===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${l}, d),
              initializationValue,
              initializationValue
            );

            ${N}
          } else if (${I===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${l}, d),
              getValue(batch, xR, xC + 2 * ${l}, d),
              initializationValue
            );

            ${N}
          }
        }
        setOutput(${w});
      }
    `}}class N${constructor(t,n,r,s=!1,a=!1){if(this.variableNames=["x"],n==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const i=t.filterWidth,o=t.strideDepth,u=t.strideHeight,c=t.strideWidth,l=t.dilationDepth,d=t.dilationHeight,h=t.dilationWidth,p=t.effectiveFilterDepth,f=t.effectiveFilterHeight,m=t.effectiveFilterWidth,g=t.padInfo.front,b=t.padInfo.top,y=t.padInfo.left;this.outputShape=t.outShape;const x=n==="avg";let w="0.0";if(x||(w="-1.0 / 1e-20"),r){this.userCode=`
        const ivec3 strides =
            ivec3(${o}, ${u}, ${c});
        const ivec3 pads = ivec3(${g}, ${b}, ${y});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${p};
              wD += ${l}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${t.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${f};
                wR += ${d}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${m};
                  wC += ${h}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value >= currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${s?a?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${f} * ${m} +
                      wR * ${m} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const v="max";let I=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="avg"&&(I="avgValue / max(count, 1.0)");const N=Math.floor(i/4)*4,T=i%4,E=`
      if (${x}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${v}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${o}, ${u}, ${c});
      const ivec3 pads = ivec3(${g}, ${b}, ${y});
      const float initializationValue = ${w};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${w});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${l}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f};
            wR += ${d}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${N}; wC += 4) {
              int xC = xCCorner + wC * ${h};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h}, ch),
                getValue(batch, xD, xR, xC + 2 * ${h}, ch),
                getValue(batch, xD, xR, xC + 3 * ${h}, ch)
              );

              ${E}
            }

            int xC = xCCorner + ${N};
            if (${T===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${E}
            } else if (${T===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h}, ch),
                initializationValue,
                initializationValue
              );

              ${E}
            } else if (${T===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h}, ch),
                getValue(batch, xD, xR, xC + 2 * ${h}, ch),
                initializationValue
              );

              ${E}
            }
          }
        }
        setOutput(${I});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rQe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;s2(s,"avgPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:u}=r,c=1;U(bs(i,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const l=Es(s.shape,a,i,c,o,u);if(l.filterWidth===1&&l.filterHeight===1&&Nn(l.inShape,l.outShape))return _a({inputs:{x:s},backend:n});const d=new By(l,"avg",!1);return n.runWebGLProgram(d,[s],"float32")}const sQe={kernelName:Gm,backendName:"webgl",kernelFunc:rQe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aQe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:u,dataFormat:c}=r,l=[1,1,1],d=Qa(s.shape,a,i,l,o,u,c),h=new N$(d,"avg",!1);return n.runWebGLProgram(h,[s],"float32")}const iQe={kernelName:t1,backendName:"webgl",kernelFunc:aQe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oQe{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const n=t.filterHeight,r=t.filterWidth,s=t.strideHeight,a=t.strideWidth,i=t.dilationHeight,o=t.dilationWidth,u=t.effectiveFilterHeight,c=t.effectiveFilterWidth,l=u-1-t.padInfo.top,d=c-1-t.padInfo.left,h=1/(n*r);this.userCode=`
      const ivec2 pads = ivec2(${l}, ${d});
      const float avgMultiplier = float(${h});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${u};
            wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${c};
            wC+= ${o}) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class lQe{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const n=t.filterDepth,r=t.filterHeight,s=t.filterWidth,a=t.strideDepth,i=t.strideHeight,o=t.strideWidth,u=t.dilationDepth,c=t.dilationHeight,l=t.dilationWidth,d=t.effectiveFilterDepth,h=t.effectiveFilterHeight,p=t.effectiveFilterWidth,f=d-1-t.padInfo.front,m=h-1-t.padInfo.top,g=p-1-t.padInfo.left,b=1/(n*r*s);this.userCode=`
      const ivec3 pads = ivec3(${f}, ${m}, ${g});
      const float avgMultiplier = float(${b});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${u}) {
          float dyD = float(dyDCorner + wD) / ${a}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${h};
              wR += ${c}) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${p};
                wC += ${l}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uQe(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a,{filterSize:o,strides:u,pad:c,dimRoundingMode:l}=r,d=[1,1,1],h=Qa(i.shape,o,u,d,c,l),p=new lQe(h);return n.runWebGLProgram(p,[s],i.dtype)}const cQe={kernelName:Wv,backendName:"webgl",kernelFunc:uQe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dQe(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a;s2([s,a],"avgPoolGrad");const{filterSize:o,strides:u,pad:c}=r,l=Es(i.shape,o,u,1,c),d=new oQe(l);return n.runWebGLProgram(d,[s],i.dtype)}const hQe={kernelName:zv,backendName:"webgl",kernelFunc:dQe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pQe(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:o}=r;return sw({a:s,b:a,transposeA:i,transposeB:o,backend:n})}const fQe={kernelName:Hm,backendName:"webgl",kernelFunc:pQe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mQe{constructor(t,n,r,s,a,i){this.outputShape=[],this.variableNames=["x","mean","variance"],Ot(t,n),Ot(t,r);let o="0.0";s!=null&&(Ot(t,s),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let u="1.0";a!=null&&(Ot(t,a),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${o};
        float scale = ${u};
        float inv = scale * inversesqrt(variance + float(${i}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gQe{constructor(t,n,r,s,a,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Ot(t,n),Ot(t,r);let o="vec4(0.0)";s!=null&&(Ot(t,s),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let u="vec4(1.0)";a!=null&&(Ot(t,a),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        vec4 offset = ${o};
        vec4 scale = ${u};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${i}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bQe=({inputs:e,backend:t,attrs:n})=>{const{x:r,mean:s,variance:a,offset:i,scale:o}=e;U(s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),U(i==null||s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),U(o==null||s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=n;u==null&&(u=.001);const c=[r,s,a];let l=null;i!=null&&(l=i.shape,c.push(i));let d=null;o!=null&&(d=o.shape,c.push(o));const h=ke().getBool("WEBGL_PACK_NORMALIZATION")?new gQe(r.shape,s.shape,a.shape,l,d,u):new mQe(r.shape,s.shape,a.shape,l,d,u);return t.runWebGLProgram(h,c,c[0].dtype)},yQe={kernelName:ug,backendName:"webgl",kernelFunc:bQe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xQe{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const n=Vn(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const r=wQe(this.rank);let s;const a=t.map((i,o)=>`sourceLoc.${AS[o]} = start[${o}] + coords.${AS[o]};`);s=`
        ${n} sourceLoc;
        ${n} coords = getOutputCoords();
        ${a.join(`
`)}
      `,this.userCode=`
      void main() {
        ${s}
        setOutput(getSource(${r}));
      }
    `}}const AS=["x","y","z","w","u","v"];function wQe(e){if(e===1)return"sourceLoc";if(e<=6)return AS.slice(0,e).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vQe{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=Vn(this.rank),r=Bs("coords",this.rank),s=Bs("sourceLoc",this.rank),a=this.rank===1?"sourceLoc":`vec2(${s.slice(-2).join()})`,i=`getChannel(getSource(${s.join()}), ${a})`,o=`
      result.x = ${i};
      if (++${r[this.rank-1]} < ${t[this.rank-1]}) {
        ++${s[this.rank-1]};
        result.y = ${i};
        --${s[this.rank-1]};
      }
    `,u=this.rank===1?"":`
      --${r[this.rank-1]};
      if (++${r[this.rank-2]} < ${t[this.rank-2]}) {
        ++${s[this.rank-2]};
        result.z = ${i};
        if (++${r[this.rank-1]} < ${t[this.rank-1]}) {
          ++${s[this.rank-1]};
          result.w = ${i};
        }
      }
    `,c=this.rank<=4?`sourceLoc = coords +
            ${n}(${t.map((l,d)=>`start[${d}]`).join()});`:t.map((l,d)=>`${s[d]} = ${r[d]} + start[${d}];`).join(`
`);this.userCode=`
      void main() {
        ${n} coords = getOutputCoords();
        ${n} sourceLoc;
        ${c}
        vec4 result = vec4(0.);
        ${o}
        ${u}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IQe(e,t,n,r){const s=r.texData.get(e.dataId),a=r.makeTensorInfo(n,e.dtype),i=r.texData.get(a.dataId);Object.assign(i,s),i.refCount=1,i.shape=n,i.dtype=e.dtype;let o=xI(t,ot(e.shape));s.slice&&(o+=s.slice.flatOffset),i.slice={flatOffset:o,origDataId:s.slice&&s.slice.origDataId||e.dataId};const u=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,u+1),a}function pb(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,size:i}=r,[o,u]=q1(s,a,i);if(cA(s,o,u),fe(u)===0)return n.makeTensorInfo(u,s.dtype,[]);if(n.shouldExecuteOnCPU([s])||s.dtype==="string"){const d=n.texData.get(s.dataId),h=fKe(d.values,o,u,s.shape,s.dtype);return n.makeTensorInfo(u,s.dtype,h)}const{isPacked:c}=n.texData.get(s.dataId),l=yI(s.shape,o,u);if(c||!l){const d=ke().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new vQe(u):new xQe(u),h=[o];return n.runWebGLProgram(d,[s],s.dtype,h)}return n.uploadToGPU(s.dataId),IQe(s,o,u,n)}const kQe={kernelName:F1,backendName:"webgl",kernelFunc:pb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CQe=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:i}=r;U(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const o=a.reduce((y,x)=>y*x),u=np(s.shape,a,o),c=rp(u.length,a.length),l=sp(s.shape,a,o),d=CI(i,a.length),h=SI(l,i,a.length),p=[],f=Je({inputs:{x:s},backend:n,attrs:{shape:u}}),m=js({inputs:{x:f},backend:n,attrs:{perm:c}}),g=Je({inputs:{x:m},backend:n,attrs:{shape:l}}),b=pb({inputs:{x:g},backend:n,attrs:{begin:d,size:h}});return p.push(f),p.push(m),p.push(g),p.forEach(y=>n.disposeIntermediateTensorInfo(y)),b},SQe={kernelName:n1,backendName:"webgl",kernelFunc:CQe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NQe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i}=r,o=n.readSync(s.dataId),u=n.readSync(a.dataId),c=ZH(o,u,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,c)}const TQe={kernelName:r1,backendName:"webgl",kernelFunc:NQe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EQe=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,AQe=`
  return float(int(a.r) & int(b.r));
`;function $Qe(e){const{inputs:t,backend:n}=e,{a:r,b:s}=t,a=ke().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=ke().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([r,s])||i===1){const u=n.texData.get(r.dataId).values,c=n.texData.get(s.dataId).values,[l,d]=Pqe(r.shape,s.shape,u,c,r.dtype),h=n.makeTensorInfo(d,r.dtype),p=n.texData.get(h.dataId);return p.values=l,h}let o;return a?o=new db(EQe,r.shape,s.shape,!1):o=new md(AQe,r.shape,s.shape),n.runWebGLProgram(o,[r,s],r.dtype)}const RQe={kernelName:Vv,backendName:"webgl",kernelFunc:$Qe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Qe(e){const{inputs:t,backend:n}=e,{s0:r,s1:s}=t,a=n.readSync(r.dataId),i=n.readSync(s.dataId),o=Ot(Array.from(a),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}const DQe={kernelName:cE,backendName:"webgl",kernelFunc:_Qe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FQe="return float(a != b);",pj=ys({opSnippet:FQe,cpuKernelImpl:aKe,dtype:"bool"}),MQe={kernelName:C1,backendName:"webgl",kernelFunc:pj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i2(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.texData.get(r.dataId);return _a({inputs:{x:s.complexTensorInfos.real},backend:n})}const OQe={kernelName:vE,backendName:"webgl",kernelFunc:i2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LQe="return float(int(x));";function PQe(e,t){const n=new yo(e.shape,LQe),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $S(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dtype:a}=r;if(a==="complex64"){if(s.dtype==="complex64")return _a({inputs:{x:s},backend:n});const i=ss(s.shape),o=$S({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),u=Vu({inputs:{real:o,imag:i},backend:n});return i.dispose(),n.disposeIntermediateTensorInfo(o),u}if(s.dtype==="complex64"){const i=i2({inputs:{input:s},backend:n}),o=$S({inputs:{x:i},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(i),o}if(!zz(s.dtype,a)){const i=_a({inputs:{x:s},backend:n});return{dataId:i.dataId,shape:i.shape,dtype:a}}if(n.shouldExecuteOnCPU([s])){const i=n.texData.get(s.dataId).values,[o,u,c]=Bqe(i,s.shape,s.dtype,a);return n.makeTensorInfo(o,u,c)}if(a==="int32")return PQe(s,n);if(a==="bool"){const i=n.makeTensorInfo([],"bool",ks("bool",1)),u=pj({inputs:{a:s,b:i},backend:n});return n.disposeIntermediateTensorInfo(i),u}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${a}`)}const BQe={kernelName:jm,backendName:"webgl",kernelFunc:$S};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dF="return ceil(x);",zQe=hn({opSnippet:dF,packedOpSnippet:dF,cpuKernelImpl:zqe}),WQe={kernelName:qm,backendName:"webgl",kernelFunc:zQe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VQe{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UQe{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GQe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{clipValueMin:a,clipValueMax:i}=r;let o;ke().getBool("WEBGL_PACK_CLIP")?o=new UQe(s.shape):o=new VQe(s.shape);const u=[[a],[i]];return n.runWebGLProgram(o,[s],s.dtype,u)}const HQe={kernelName:Qh,backendName:"webgl",kernelFunc:GQe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jQe{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hF(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}function qQe(e){const{inputs:t,backend:n}=e,{x:r}=t,s=n.texData.get(r.dataId),a=new jQe(r.shape),i=[hF(r,s.complexTensorInfos.real),hF(r,s.complexTensorInfos.imag)];return n.runWebGLProgram(a,i,i[0].dtype)}const KQe={kernelName:Uv,backendName:"webgl",kernelFunc:qQe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XQe{constructor(t){this.outputShape=[],this.outputShape=Ga(t,1),this.variableNames=t.map((i,o)=>`T${o}`);const n=new Array(t.length-1);n[0]=t[0][1];for(let i=1;i<n.length;i++)n[i]=n[i-1]+t[i][1];const r=[`if (yC < ${n[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<n.length;i++){const o=n[i-1];r.push(`else if (yC < ${n[i]}) setOutput(getT${i}(yR, yC-${o}));`)}const s=n.length,a=n[n.length-1];r.push(`else setOutput(getT${s}(yR, yC-${a}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${r.join(`
        `)}
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QQe{constructor(t,n){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Ga(t,n);const r=this.outputShape,s=r.length,a=Vn(s),i=Bs("coords",s),o=["x","y","z","w","u","v"].slice(0,s);this.variableNames=t.map((m,g)=>`T${g}`);const u=new Array(t.length-1);u[0]=t[0][n];for(let m=1;m<u.length;m++)u[m]=u[m-1]+t[m][n];const c=o[n],l=o.slice(-2),d=o.join();let h=`if (${c} < ${u[0]}) {
        return getChannel(
            getT0(${d}), vec2(${l.join()}));
        }`;for(let m=1;m<u.length;m++){const g=u[m-1];h+=`
        if (${c} < ${u[m]}  && ${c} >= ${u[m-1]}) {
          return getChannel(
            getT${m}(${B2(o,c,g)}),
            vec2(${B2(l,c,g)}));
        }`}const p=u.length,f=u[u.length-1];h+=`
        return getChannel(
          getT${p}(${B2(o,c,f)}),
          vec2(${B2(l,c,f)}));`,this.userCode=`
      float getValue(${o.map(m=>"int "+m)}) {
        ${h}
      }

      void main() {
        ${a} coords = getOutputCoords();
        vec4 result = vec4(getValue(${i}), 0., 0., 0.);

        ${i[s-1]} = ${i[s-1]} + 1;
        if (${i[s-1]} < ${r[s-1]}) {
          result.g = getValue(${i});
        }

        ${i[s-2]} = ${i[s-2]} + 1;
        if (${i[s-2]} < ${r[s-2]}) {
          result.a = getValue(${i});
        }

        ${i[s-1]} = ${i[s-1]} - 1;
        if (${i[s-2]} < ${r[s-2]} &&
            ${i[s-1]} < ${r[s-1]}) {
          result.b = getValue(${i});
        }
        setOutput(result);
      }
    `}}function B2(e,t,n){const r=e.indexOf(t);return e.map((a,i)=>i===r?`${a} - ${n}`:a).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jI(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.texData.get(r.dataId);return _a({inputs:{x:s.complexTensorInfos.imag},backend:n})}const YQe={kernelName:xE,backendName:"webgl",kernelFunc:jI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yb(e,t,n){const r=e[0].dtype;if(r==="complex64"){const p=e.map(y=>i2({inputs:{input:y},backend:n})),f=e.map(y=>jI({inputs:{input:y},backend:n})),m=Yb(p,t,n),g=Yb(f,t,n),b=Vu({inputs:{real:m,imag:g},backend:n});return p.forEach(y=>n.disposeIntermediateTensorInfo(y)),f.forEach(y=>n.disposeIntermediateTensorInfo(y)),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),b}let s=n.shouldExecuteOnCPU(e);if(r==="string"&&(s=!0),s){const p=e.map(w=>{const I=[-1,fe(w.shape.slice(t))];return Je({inputs:{x:w},backend:n,attrs:{shape:I}})}),f=p.map(w=>({vals:n.readSync(w.dataId),shape:w.shape})),m=Ga(p.map(w=>w.shape),1),g=p[0].shape[0]===1,b=Wqe(f,m,r,g),y=Ga(e.map(w=>w.shape),t),x=n.makeTensorInfo(y,r,b);return p.forEach(w=>n.disposeIntermediateTensorInfo(w)),x}const a=e.filter(p=>fe(p.shape)>0),i=ke().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&a[0].shape.length>1;if(a.length===1){const p=i?new yo(e[0].shape,Rl):new zl(e[0].shape,Rl);return n.runWebGLProgram(p,e,r)}const o=ke().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(a.length>o){const p=[];for(let m=0;m<a.length;m+=o){const g=a.slice(m,m+o);p.push(Yb(g,t,n))}const f=Yb(p,t,n);for(const m of p)n.disposeIntermediateTensorInfo(m);return f}if(i){const p=new QQe(a.map(f=>f.shape),t);return n.runWebGLProgram(p,a,r)}const{tensors2D:u,outShape:c}=JQe(a,t,n),l=new XQe(u.map(p=>p.shape)),d=n.runWebGLProgram(l,u,r);u.forEach(p=>n.disposeIntermediateTensorInfo(p));const h=Je({inputs:{x:d},attrs:{shape:c},backend:n});return n.disposeIntermediateTensorInfo(d),h}function JQe(e,t,n){const r=Ga(e.map(a=>a.shape),t);return{tensors2D:e.map(a=>Je({inputs:{x:a},attrs:{shape:[-1,fe(a.shape.slice(t))]},backend:n})),outShape:r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fj(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,a=zt(s,t[0].shape)[0],i=t.map(c=>c.shape);vI(i,a);const o=Ga(t.map(c=>c.shape),a);if(fe(o)===0)return n.makeTensorInfo(o,t[0].dtype,[]);const u=t.filter(c=>fe(c.shape)>0);return u.length===1?_a({inputs:{x:u[0]},backend:n}):Yb(u,a,n)}const ZQe={kernelName:s1,backendName:"webgl",kernelFunc:fj};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mj{constructor(t,n=!1,r=null,s=!1,a=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const i=t.padInfo.top,o=t.padInfo.left,u=t.strideHeight,c=t.strideWidth,l=t.dilationHeight,d=t.dilationWidth,h=t.filterHeight,p=t.filterWidth,f=Math.floor(t.inChannels/4)*4,m=t.inChannels%4,g=t.dataFormat==="channelsLast",b=g?1:2,y=g?2:3,x=g?3:1;let w="",v="";r&&(s?w=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:a?w=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:w=`
          float activation(float x) {
            ${r}
          }
        `,v="result = activation(result);");const I=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${w}

      const ivec2 strides = ivec2(${u}, ${c});
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${x}];

        ivec2 xRCCorner =
            ivec2(coords[${b}], coords[${y}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${h}; wR++) {
          int xR = xRCorner + wR * ${l};

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${p}; wC++) {
            int xC = xCCorner + wC * ${d};

            if (xC < 0 || xC >= ${t.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${f}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${g}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${m===1}) {

              if (${g}) {
                dotProd +=
                    getX(batch, xR, xC, ${f}) *
                    getW(wR, wC, ${f}, d2);
              } else {
                dotProd +=
                    getX(batch, ${f}, xR, xC) *
                    getW(wR, wC, ${f}, d2);
              }

            } else if (${m===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2)
              );

              if (${g}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${m===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2),
                getW(wR, wC, ${f} + 2, d2)
              );

              if (${g}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1),
                  getX(batch, xR, xC, ${f} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC),
                  getX(batch, ${f} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${I}
        ${v}
        setOutput(result);
      }
    `}}class eYe{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const n=t.padInfo.front,r=t.padInfo.top,s=t.padInfo.left,a=t.strideDepth,i=t.strideHeight,o=t.strideWidth,u=t.dilationDepth,c=t.dilationHeight,l=t.dilationWidth,d=t.filterDepth,h=t.filterHeight,p=t.filterWidth,f=Math.floor(t.inChannels/4)*4,m=t.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${a}, ${i}, ${o});
      const ivec3 pads = ivec3(${n}, ${r}, ${s});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${d}; wF++) {
          int xF = xFCorner + wF * ${u};

          if (xF < 0 || xF >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${h}; wR++) {
            int xR = xRCorner + wR * ${c};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p}; wC++) {
              int xC = xCCorner + wC * ${l};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${f}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${m===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${f}) *
                  getW(wF, wR, wC, ${f}, d2);
              } else if (${m===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${m===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1),
                  getX(batch, xF, xR, xC, ${f} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2),
                  getW(wF, wR, wC, ${f} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gj{constructor(t,n=!1,r=null,s=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=$s(this.outputShape.length);const i=t.padInfo.left,o=t.strideWidth,u=t.dilationWidth,c=t.filterHeight,l=t.filterWidth,d=l;let h=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<l;g++)h+=`
           vec4 xTexelC${g*2};
           int xTexelC${g*2}Ready;
           vec4 xTexelC${g*2+1};
           int xTexelC${g*2+1}Ready;
           vec4 xC${g};`;h+=`
     for (int r = 0; r < ${c}; r++) {
      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {
       `;for(let g=0;g<l;g++)h+=`
           xTexelC${g*2} = vec4(0.0);
           xTexelC${g*2}Ready = 0;
           xTexelC${g*2+1} = vec4(0.0);
           xTexelC${g*2+1}Ready = 0;
           xC${g} = vec4(0.0);`;h+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let g=0;g<(d+1)/2;g++){const b=g*2;if(h+=`
           xC = xCCorner + ${b*u};
           `,o===1){if(b<l&&(i%2===1?(h+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }
               `,u===1&&b>0?h+=`
                 xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);
                 `:h+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${b} = vec4(previous.zw, xTexelC${b}.xy);
                   } else {
                     xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);
                   }
                   `):h+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }

                 xC${b} = xTexelC${b};
                 `,b+1<l)){const y=i%2===0?aE(u):u;u%2===0&&i%2===1||u%2!==0&&i%2!==1?(h+=`
                   xCOffset = xC + imod(pads[1], 2) + ${y};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                     xTexelC${b+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${b+1}.zw = vec2(0.0);
                     }
                     xTexelC${b+1}Ready = 1;
                   }
                   `,u>1?h+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);
                     } else {
                      xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);
                     }
                     `:h+=`
                     xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);
                     `):y===1?h+=`
                     xC${b+1} = xTexelC${b};
                     `:h+=`
                     xCOffset = xC + ${y};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                       xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${b+1}.zw = vec2(0.0);
                       }
                       xTexelC${b+1}Ready = 1;
                     }

                     xC${b+1} = xTexelC${b+1};
                     `}}else b<l&&(i%2===1?(h+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {
                   xTexelC${b+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${b+1}.zw = vec2(0.0);
                   }
                   xTexelC${b+1}Ready = 1;
                 }

                 xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
               `,b+1<l&&(h+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);
                 `)):(h+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                   xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${b+1}.zw = vec2(0.);
                   }
                   xTexelC${b+1}Ready = 1;
                 }

                 xC${b} = vec4(
                   xTexelC${b}.xy, xTexelC${b+1}.xy);
               `,b+1<l&&(h+=`
                   xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
                 `)));b<l&&(h+=`
             wTexel = getW(r, ${b}, d1, d2);
             dotProd += xC${b}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${t.inChannels}) {
               dotProd += xC${b}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,b+1<l&&(h+=`
               wTexel = getW(r, ${b+1}, d1, d2);
               dotProd += xC${b+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${t.inChannels}) {
                 dotProd += xC${b+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}h+=`
     }
   `,h+=`
     }
   `,h+=`
     }
   `;let p="",f="";r&&(s?p=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${r}
         }`:a?p=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${r}
         }`:p=`vec4 activation(vec4 x) {
           ${r}
         }`,f="result = activation(result);");const m=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${p}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${h}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${m}
         ${f}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tYe{constructor(t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=$s(this.outputShape.length);const{dataFormat:r}=n,s=Ys(),a=r==="channelsLast",i=a?1:2,o=a?2:3,u=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${t[2]} && pos < ${t[1]}) {`;let c="";for(let l=0;l<=1;l++)for(let d=0;d<=1;d++)c+=`
          blockIndex = rc.z + ${d};
          pos = rc.y + ${l};

          ${u}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${i}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${o}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${a}) {
                  innerDims = vec2(d1, ch);
                  result[${l*2+d}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${l*2+d}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${c}

        ${s.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aw(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&n===1&&e[0]>1?[e[0],1]:null}function bj({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){const u=e.shape,c=r.texData.get(e.dataId),l=n.inChannels,d=u[0]*u[1]*u[2],h=n.outChannels,p=n.dataFormat==="channelsLast",f=!1,m=!1;let g;const b=[];if(a!=null){const w=aw(a.shape,p);w!=null&&(a=Je({inputs:{x:a},backend:r,attrs:{shape:w}}),b.push(a))}if(s!=null){const w=aw(s.shape,p);w!=null&&(s=Je({inputs:{x:s},backend:r,attrs:{shape:w}}),b.push(s))}if(!((d===1||h===1)&&l>uj)&&c.isPacked&&p&&c.texture!=null&&u[2]%2!==0&&Nn(c.shape.slice(-3),u.slice(-3))){const w=u[0]*u[1]*(u[2]+1),v={dataId:e.dataId,shape:[1,w,n.inChannels],dtype:e.dtype},I=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,U(rw(c.shape,v.shape),()=>`packed reshape ${c.shape} to ${v.shape} isn't free`);const N=Je({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});b.push(N);const T=sw({a:v,b:N,backend:r,transposeA:f,transposeB:m,bias:s,activation:o,preluActivationWeights:a,leakyreluAlpha:i}),E=r.texData.get(T.dataId);U(E.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=I,E.shape=n.outShape,g=_a({inputs:{x:T},backend:r}),g.shape=n.outShape,b.push(T)}else{const w=n.outHeight*n.outWidth,v=Je({inputs:{x:e},backend:r,attrs:{shape:p?[n.batchSize,w,n.inChannels]:[n.batchSize,n.inChannels,w]}}),I=Je({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),N=sw({a:p?v:I,b:p?I:v,transposeA:!p,transposeB:m,backend:r,bias:s,activation:o,preluActivationWeights:a,leakyreluAlpha:i});g=Je({inputs:{x:N},backend:r,attrs:{shape:n.outShape}}),b.push(v),b.push(I),b.push(N)}for(const w of b)r.disposeIntermediateTensorInfo(w);return g}function yj({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){const{filterWidth:u,filterHeight:c,inChannels:l,outWidth:d,outHeight:h,dataFormat:p}=n,f=p==="channelsLast",m=u*c*l,g=h*d,b=[n.batchSize,m,g],y=!0,x=!1,w=[];if(a!=null){const z=aw(a.shape,f);z!=null&&(a=Je({inputs:{x:a},backend:r,attrs:{shape:z}}),w.push(a))}if(s!=null){const z=aw(s.shape,f);z!=null&&(s=Je({inputs:{x:s},backend:r,attrs:{shape:z}}),w.push(s))}const v=Je({inputs:{x:t},backend:r,attrs:{shape:[1,m,fe(t.shape)/m]}});w.push(v);const I=new tYe(b,n),N=[e.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],T=r.runWebGLProgram(I,[e],"float32",N),E=Je({inputs:{x:T},backend:r,attrs:{shape:b}});w.push(T),w.push(E);const A=s!=null,k=a!=null,C=o==="leakyrelu",M=o?Py(o,!0):null,L=new lj(f?E.shape:v.shape,f?v.shape:E.shape,f?[n.batchSize,g,n.outChannels]:[n.batchSize,n.outChannels,g],y,x,A,M,k,C),O=f?[E,v]:[v,E];if(s&&O.push(s),k&&O.push(a),C){const z=r.makeTensorInfo([],"float32",Mu(i,"float32"));O.push(z),w.push(z)}const B=r.runWebGLProgram(L,O,"float32"),G=Je({inputs:{x:B},backend:r,attrs:{shape:n.outShape}});w.push(B);for(const z of w)r.disposeIntermediateTensorInfo(z);return G}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nYe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dataFormat:u,dilations:c,dimRoundingMode:l}=r,d=to(u),h=yr(s.shape,a.shape,i,c,o,l,!1,d);let p;if(h.filterHeight===1&&h.filterWidth===1&&h.dilationHeight===1&&h.dilationWidth===1&&h.strideHeight===1&&h.strideWidth===1&&(h.padInfo.type==="SAME"||h.padInfo.type==="VALID"))p=bj({x:s,filter:a,convInfo:h,backend:n});else if(h.strideWidth<=2&&d==="channelsLast"&&ke().getBool("WEBGL_EXP_CONV")){const m=new gj(h),g=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];p=n.runWebGLProgram(m,[s,a],"float32",g)}else if(ke().getBool("WEBGL_CONV_IM2COL"))p=yj({x:s,filter:a,convInfo:h,backend:n});else{const m=new mj(h);p=n.runWebGLProgram(m,[s,a],"float32")}const f=Je({inputs:{x:p},backend:n,attrs:{shape:h.outShape}});return n.disposeIntermediateTensorInfo(p),f}const rYe={kernelName:Km,backendName:"webgl",kernelFunc:nYe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sYe{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const n=t.strideHeight,r=t.strideWidth,s=t.padInfo.top,a=t.padInfo.left,i=t.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${s};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${a};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              ${i?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class aYe{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const n=t.filterHeight,r=t.filterWidth,s=t.strideHeight,a=t.strideWidth,i=t.dataFormat==="channelsLast",o=n-1-t.padInfo.top,u=r-1-t.padInfo.left,c=i?1:2,l=i?2:3,d=i?3:1;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${d}];

        ivec2 dyCorner = ivec2(coords[${c}], coords[${l}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {

              if (${i}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class iYe{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const n=t.strideDepth,r=t.strideHeight,s=t.strideWidth,a=t.padInfo.front,i=t.padInfo.top,o=t.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yF = 0; yF < ${t.outDepth}; yF++) {
            int xF = wF + yF * ${n} - ${a};

            if (xF < 0 || xF >= ${t.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${t.outHeight}; yR++) {
              int xR = wR + yR * ${r} - ${i};

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${t.outWidth}; yC++) {
                int xC = wC + yC * ${s} - ${o};

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class oYe{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const n=t.filterDepth,r=t.filterHeight,s=t.filterWidth,a=t.strideDepth,i=t.strideHeight,o=t.strideWidth,u=n-1-t.padInfo.front,c=r-1-t.padInfo.top,l=s-1-t.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${u}, ${c}, ${l});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${n}; wF++) {
          float dyF = float(dyFCorner + wF) / ${a}.0;

          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${n} - 1 - wF;

          for (int wR = 0; wR < ${r}; wR++) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${r} - 1 - wR;

            for (int wC = 0; wC < ${s}; wC++) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${s} - 1 - wC;

              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lYe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,dataFormat:u,dimRoundingMode:c,filterShape:l}=r,d=to(u),h=yr(s.shape,l,i,1,o,c,!1,d),p=new sYe(h);return n.runWebGLProgram(p,[s,a],"float32")}const uYe={kernelName:hE,backendName:"webgl",kernelFunc:lYe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cYe{constructor(t){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=t.inShape,this.enableShapeUniforms=$s(this.outputShape.length);const n=t.filterHeight,r=t.filterWidth,s=n-1-t.padInfo.top,a=r-1-t.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${s}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            int wCPerm = ${r} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${t.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${t.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dYe(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{inputShape:i,strides:o,pad:u,dataFormat:c,dimRoundingMode:l}=r,d=to(c),h=yr(i,a.shape,o,1,u,l,!1,d);if(ke().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&d==="channelsLast"){const p=[[h.strideHeight,h.strideWidth]],f=new cYe(h);return n.runWebGLProgram(f,[s,a],"float32",p)}else{const p=new aYe(h);return n.runWebGLProgram(p,[s,a],"float32")}}const hYe={kernelName:Xm,backendName:"webgl",kernelFunc:dYe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pYe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:u}=r,c=eo(s.shape,a.shape,i,u,o),l=new eYe(c);return n.runWebGLProgram(l,[s,a],"float32")}const fYe={kernelName:Qm,backendName:"webgl",kernelFunc:pYe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mYe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,filterShape:u}=r,c=eo(s.shape,u,i,1,o),l=new iYe(c);return n.runWebGLProgram(l,[s,a],"float32")}const gYe={kernelName:a1,backendName:"webgl",kernelFunc:mYe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bYe(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:i,strides:o,inputShape:u}=r,c=eo(u,a.shape,o,1,i),l=new oYe(c);return n.runWebGLProgram(l,[s,a],"float32")}const yYe={kernelName:i1,backendName:"webgl",kernelFunc:bYe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xYe=hb+`
  return cos(x);
`,wYe=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${up}
  return result;
`,vYe=hn({opSnippet:xYe,packedOpSnippet:wYe}),IYe={kernelName:Ym,backendName:"webgl",kernelFunc:vYe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kYe=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,CYe=hn({opSnippet:kYe}),SYe={kernelName:Jm,backendName:"webgl",kernelFunc:CYe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class NYe{constructor(t,n,r,s,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[i,o,u,c]=t,[l]=n,[d,h]=r;this.outputShape=[l,d,h,c];const p=s==="bilinear"?1:0,[f,m]=[`${o-1}.0`,`${u-1}.0`],[g,b,y]=d>1?[`${(o-1)/(d-1)}`,"(y2-y1) * height_ratio",`y1*${f} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${f}`],[x,w,v]=h>1?[`${(u-1)/(h-1)}`,"(x2-x1) * width_ratio",`x1*${m} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${m}`];this.userCode=`
      const float height_ratio = float(${g});
      const float width_ratio = float(${x});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${i}) {
          return;
        }

        float height_scale = ${b};
        float width_scale = ${w};

        float in_y = ${y};
        if( in_y < 0.0 || in_y > ${f} ) {
          setOutput(float(${a}));
          return;
        }
        float in_x = ${v};
        if( in_x < 0.0 || in_x > ${m} ) {
          setOutput(float(${a}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${p} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TYe=e=>{const{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:i}=t,{cropSize:o,method:u,extrapolationValue:c}=r,l=new NYe(s.shape,a.shape,o,u,c);return n.runWebGLProgram(l,[s,a,i],"float32")},EYe={kernelName:l1,backendName:"webgl",kernelFunc:TYe};var zy;(function(e){e.Prod="*",e.Sum="+"})(zy||(zy={}));class pF{constructor(t,n,r,s){this.op=t,this.outputShape=n,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const a=this.outputShape.length,i=this.op===zy.Prod?"1.0":"0.0",o=r?i:`getX(${fF(a,"coords",this.op)})`,u=this.outputShape[this.outputShape.length-1];let c="",l="";r?(c=s?`end != ${u-1}`:"end != 0",l=s?"end + 1":"end - 1"):(c=s?`end + pow2 < ${u}`:"end >= pow2",l=s?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Vn(a)} coords = getOutputCoords();
        int end = ${mF(a,"coords",this.op)};
        float val = ${o};
        int pow2 = int(pow(2.0, index));
        if (${c}) {
          int idx = ${l};
          ${mF(a,"coords",this.op)} = idx;
          val ${this.op}= getX(${fF(a,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function fF(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.x, ${t}.y`;if(e===3)return`${t}.x, ${t}.y, ${t}.z`;if(e===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function mF(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.y`;if(e===3)return`${t}.z`;if(e===4)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xj(e,t,n,r,s,a){const i=t.shape.length,o=nr([r],i);let u=t;o!=null&&(u=js({inputs:{x:t},backend:n,attrs:{perm:o}}));const c=qn(1,i)[0];if(c!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);const l=u.shape[c];let d=_a({inputs:{x:u},backend:n});for(let h=0;h<=Math.ceil(Math.log2(l))-1;h++){const p=new pF(e,u.shape,!1,a),f=[[h]],m=d;d=n.runWebGLProgram(p,[d],d.dtype,f),n.disposeIntermediateTensorInfo(m)}if(s){const h=new pF(e,u.shape,s,a),p=d;d=n.runWebGLProgram(h,[d],d.dtype),n.disposeIntermediateTensorInfo(p)}if(o!=null){const h=Bo(o),p=js({inputs:{x:d},backend:n,attrs:{perm:h}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(u),p}return d}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AYe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;return xj(zy.Prod,s,n,a,i,o)}const $Ye={kernelName:o1,backendName:"webgl",kernelFunc:AYe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RYe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;return xj(zy.Sum,s,n,a,i,o)}const _Ye={kernelName:Zm,backendName:"webgl",kernelFunc:RYe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DYe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i,binaryOutput:o}=r;if(s.shape.length===1){const u=n.readSync(s.dataId),c=n.readSync(a.dataId),l=ZH(u,c,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,l)}else if(s.shape.length===2){const u=n.bufferSync(s),c=n.bufferSync(a),l=Lqe(u,c,i,o);return n.makeTensorInfo(l.shape,a.dtype,l.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}const FYe={kernelName:Gv,backendName:"webgl",kernelFunc:DYe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MYe{constructor(t,n,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=n,this.dataFormat=r,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${n};
      int offset_h = imod(h, ${n});
      int in_w = w / ${n};
      int offset_w = imod(w, ${n});
      int offset_d = (offset_h * ${n} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OYe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:i}=r,o=s.shape[0],u=i==="NHWC"?s.shape[1]:s.shape[2],c=i==="NHWC"?s.shape[2]:s.shape[3],l=i==="NHWC"?s.shape[3]:s.shape[1],d=u*a,h=c*a,p=l/(a*a),f=i==="NHWC"?[o,d,h,p]:[o,p,d,h],m=new MYe(f,a,i);return n.runWebGLProgram(m,[s],s.dtype)}const LYe={kernelName:u1,backendName:"webgl",kernelFunc:OYe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wj{constructor(t,n=!1,r=null,s=!1,a=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=$s(this.outputShape.length);const i=t.filterHeight,o=t.filterWidth,u=t.outChannels/t.inChannels;let c="",l="";r&&(s?c=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:a?c=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:c=`
          float activation(float x) {
            ${r}
          }
        `,l="result = activation(result);");const d=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${c}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${u};
        int q = d2 - d1 * ${u};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${i}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${o}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${d}
        ${l}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vj{constructor(t,n=!1,r=null,s=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=$s(this.outputShape.length);const i=t.outChannels/t.inChannels,o=t.padInfo.left,u=t.strideWidth,c=t.dilationWidth,l=t.filterHeight,d=t.filterWidth,h=d;let p=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let b=0;b<d;b++)p+=`
          vec4 xTexelC${b*2};
          int xTexelC${b*2}Ready;
          vec4 xTexelC${b*2+1};
          int xTexelC${b*2+1}Ready;
          vec4 xC${b};`;p+=`
    for (int r = 0; r < ${l}; r++) {
      `;for(let b=0;b<d;b++)p+=`
          xTexelC${b*2} = vec4(0.0);
          xTexelC${b*2}Ready = 0;
          xTexelC${b*2+1} = vec4(0.0);
          xTexelC${b*2+1}Ready = 0;
          xC${b} = vec4(0.0);`;p+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let b=0;b<(h+1)/2;b++){const y=b*2;if(p+=`
          xC = xCCorner + ${y*c};
          `,u===1){if(y<d&&(o%2===1?(p+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }
              `,c===1&&y>0?p+=`
                xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);
                `:p+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${y} = vec4(previous.zw, xTexelC${y}.xy);
                  } else {
                    xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);
                  }
                  `):p+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                xC${y} = xTexelC${y};
                `,y+1<d)){const x=o%2===0?aE(c):c;c%2===0&&o%2===1||c%2!==0&&o%2!==1?(p+=`
                  xCOffset = xC + imod(pads[1], 2) + ${x};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                    xTexelC${y+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${y+1}.zw = vec2(0.0);
                    }
                    xTexelC${y+1}Ready = 1;
                  }
                  `,c>1?p+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);
                    } else {
                     xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);
                    }
                    `:p+=`
                    xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);
                    `):x===1?p+=`
                    xC${y+1} = xTexelC${y};
                    `:p+=`
                    xCOffset = xC + ${x};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                      xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${y+1}.zw = vec2(0.0);
                      }
                      xTexelC${y+1}Ready = 1;
                    }

                    xC${y+1} = xTexelC${y+1};
                    `}}else y<d&&(o%2===1?(p+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {
                  xTexelC${y+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${y+1}.zw = vec2(0.0);
                  }
                  xTexelC${y+1}Ready = 1;
                }

                xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
              `,y+1<d&&(p+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);
                `)):(p+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                  xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y+1}.zw = vec2(0.);
                  }
                  xTexelC${y+1}Ready = 1;
                }

                xC${y} = vec4(
                  xTexelC${y}.xy, xTexelC${y+1}.xy);
              `,y+1<d&&(p+=`
                  xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
                `)));y<d&&(p+=`
            wTexel = getW(r, ${y}, d1, q);
            dotProd += xC${y} * vec4(wTexel.xz, wTexel.xz);
          `,y+1<d&&(p+=`
              wTexel = getW(r, ${y+1}, d1, q);
              dotProd += xC${y+1} * vec4(wTexel.xz, wTexel.xz);
            `))}p+=`
    }
  `,p+=`
      }
    `;let f="",m="";r&&(s?f=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:a?f=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:f=`vec4 activation(vec4 x) {
          ${r}
        }`,m="result = activation(result);");const g=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${f}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${i};
        int q = d2 - d1 * ${i};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${p}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${g}
        ${m}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PYe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:u,dimRoundingMode:c}=r;let l=u;l==null&&(l=[1,1]),U(bs(i,l),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);const d=yr(s.shape,a.shape,i,l,o,c,!0);let h;ke().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels===1?h=new vj(d):h=new wj(d);const p=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return n.runWebGLProgram(h,[s,a],"float32",p)}const BYe={kernelName:eg,backendName:"webgl",kernelFunc:PYe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zYe{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const n=t.strideHeight,r=t.strideWidth,s=t.padInfo.top,a=t.padInfo.left,i=t.outChannels/t.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${i} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${s};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${a};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class WYe{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const n=t.filterHeight,r=t.filterWidth,s=t.strideHeight,a=t.strideWidth,i=n-1-t.padInfo.top,o=r-1-t.padInfo.left,u=t.outChannels/t.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${u}; dm++) {
              int d2 = d1 * ${u} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VYe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,dilations:o,pad:u,dimRoundingMode:c,filterShape:l}=r,d=yr(s.shape,l,i,o,u,c,!0),h=new zYe(d);return n.runWebGLProgram(h,[s,a],"float32")}const UYe={kernelName:pE,backendName:"webgl",kernelFunc:VYe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GYe(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{strides:i,dilations:o,pad:u,dimRoundingMode:c,inputShape:l}=r,d=yr(l,a.shape,i,o,u,c,!0),h=new WYe(d);return n.runWebGLProgram(h,[s,a],"float32")}const HYe={kernelName:fE,backendName:"webgl",kernelFunc:GYe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jYe{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qYe(e){const{inputs:t,backend:n}=e,{x:r}=t,s=[...r.shape,...r.shape],a=fe(r.shape),i=Je({inputs:{x:r},backend:n,attrs:{shape:[a]}}),o=new jYe(a),u=n.runWebGLProgram(o,[i],i.dtype),c=Je({inputs:{x:u},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(u),c}const KYe={kernelName:mE,backendName:"webgl",kernelFunc:qYe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XYe{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:n,inWidth:r,padInfo:s,strideHeight:a,strideWidth:i,filterHeight:o,filterWidth:u,dilationHeight:c,dilationWidth:l}=t,{top:d,left:h}=s;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${i});
      const ivec2 pads = ivec2(${d}, ${h});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${o}; h++) {
          int hIn = hBeg + h * ${c};

          if (hIn >= 0 && hIn < ${n}) {
            for (int w = 0; w < ${u}; w++) {
              int wIn = wBeg + w * ${l};

              if (wIn >= 0 && wIn < ${r}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QYe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:u}=r,c=Ou(s.shape,a.shape,i,o,"NHWC",u);let l;const d=new XYe(c);l=n.runWebGLProgram(d,[s,a],"float32");const h=Je({inputs:{x:l},backend:n,attrs:{shape:c.outShape}});return n.disposeIntermediateTensorInfo(l),h}const YYe={kernelName:tg,backendName:"webgl",kernelFunc:QYe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JYe(e){const{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,a=t,{allDims:i,summedDims:o,idDims:u}=xA(s,a.length);vA(i.length,u,a);const{path:c,steps:l}=IA(o,u),d=l.length;let h=null,p=i.length;const f=[];for(let m=0;m<d;++m){for(const g of l[m]){const{permutationIndices:b,expandDims:y}=wA(p,u[g]);let x;kA(b)?x=a[g]:(x=js({inputs:{x:a[g]},backend:n,attrs:{perm:b}}),f.push(x));const w=x.shape.slice();for(let v=0;v<y.length;++v)w.splice(y[v],0,1);Nn(x.shape,w)||(x=Je({inputs:{x},backend:n,attrs:{shape:w}}),f.push(x)),h===null?h=x:(h=S$({inputs:{a:x,b:h},backend:n}),f.push(h))}m<d-1&&(c[m]>=0&&(h=HI({inputs:{x:h},backend:n,attrs:{axis:c[m]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(const m of f)m!==h&&n.disposeIntermediateTensorInfo(m);return h}const ZYe={kernelName:gE,backendName:"webgl",kernelFunc:JYe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eJe="return (x >= 0.0) ? x : (exp(x) - 1.0);",tJe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,nJe=hn({opSnippet:eJe,packedOpSnippet:tJe}),rJe={kernelName:rg,backendName:"webgl",kernelFunc:nJe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sJe="return (b >= 0.0) ? a : a * (b + 1.0);",aJe=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,iJe=e=>{const{inputs:t,backend:n}=e,{dy:r,y:s}=t,a=ke().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new db(aJe,r.shape,s.shape):new md(sJe,r.shape,s.shape);return n.runWebGLProgram(a,[r,s],r.dtype)},oJe={kernelName:c1,backendName:"webgl",kernelFunc:iJe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lJe=`
  return vec4(equal(a, b));
`,uJe="return float(a == b);",cJe=ys({opSnippet:uJe,packedOpSnippet:lJe,dtype:"bool",cpuKernelImpl:Vqe}),dJe={kernelName:d1,backendName:"webgl",kernelFunc:cJe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hJe=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${hA};
  float a1 = ${pA};
  float a2 = ${fA};
  float a3 = ${mA};
  float a4 = ${gA};
  float a5 = ${bA};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,pJe=hn({opSnippet:hJe}),fJe={kernelName:sg,backendName:"webgl",kernelFunc:pJe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mJe=hb+`
  return exp(x);
`,gJe=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Ij=hn({opSnippet:mJe,packedOpSnippet:gJe,cpuKernelImpl:Uqe,dtype:"float32"}),bJe={kernelName:ag,backendName:"webgl",kernelFunc:Ij};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RS(e){const{inputs:t,attrs:n,backend:r}=e,{dim:s}=n,{input:a}=t,i=a.shape.length,o=a.shape.slice();let u=s;return s<0&&(U(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+s+1),o.splice(u,0,1),Je({inputs:{x:a},backend:r,attrs:{shape:o}})}const yJe={kernelName:h1,backendName:"webgl",kernelFunc:RS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gF="return exp(x) - 1.0;",xJe=hn({opSnippet:gF,packedOpSnippet:gF,cpuKernelImpl:Gqe}),wJe={kernelName:ig,backendName:"webgl",kernelFunc:xJe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bF{constructor(t,n,r){this.variableNames=["real","imag"];const s=n[1];this.outputShape=n;const a=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=r?`${s}.0`:"1.0";let o;if(t==="real")o="return real * expR - imag * expI;";else if(t==="imag")o="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);this.userCode=`
      const float exponentMultiplier = ${a};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${o}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${s});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${s}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${i};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kj(e,t,n){const r=n.texData.get(e.dataId),s=fe(e.shape),a=e.shape[e.shape.length-1],i=s/a,o=Je({inputs:{x:e},backend:n,attrs:{shape:[i,a]}}),u=o.shape,c=new bF("real",u,t),l=new bF("imag",u,t),d=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:u},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:u}],h=n.runWebGLProgram(c,d,"float32"),p=n.runWebGLProgram(l,d,"float32"),f=Vu({inputs:{real:h,imag:p},backend:n});n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p);const m=Je({inputs:{x:f},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(f),m}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vJe(e){const{inputs:t,backend:n}=e,{input:r}=t;return kj(r,!1,n)}const IJe={kernelName:bE,backendName:"webgl",kernelFunc:vJe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kJe{constructor(t,n){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o2(e){const{backend:t,attrs:n}=e,{shape:r,value:s}=n;let{dtype:a}=n;if(a=a||Kh(s),a==="string"){const i=wr(a,fe(r));return i.fill(s),t.makeTensorInfo(r,a,i)}else{const i=new kJe(r,s),o=[[s]];return t.runWebGLProgram(i,[],a,o)}}const CJe={kernelName:Hv,backendName:"webgl",kernelFunc:o2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SJe{constructor(t){this.variableNames=["Image"],this.outputShape=[];const n=t[2];this.outputShape=t,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${n} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${n}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NJe={kernelName:p1,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,r=t,s=new SJe(n.shape);return r.runWebGLProgram(s,[n],n.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yF="return floor(x);",TJe=hn({opSnippet:yF,packedOpSnippet:yF,cpuKernelImpl:Hqe}),EJe={kernelName:og,backendName:"webgl",kernelFunc:TJe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AJe=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,$Je=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,RJe=ys({opSnippet:AJe,packedOpSnippet:$Je,dtype:"int32"}),_Je={kernelName:lg,backendName:"webgl",kernelFunc:RJe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DJe{constructor(t){this.variableNames=["A"];const n=Ys(),[r,s]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${r}.0);

        vec4 values = ${n.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FJe{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const n=Ys(),[r,s]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${s}.0, ${r}.0);
            vec4 values = ${n.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MJe={kernelName:eDe,backendName:"webgl",kernelFunc:OJe};let bp,Ok=ke().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function OJe(e){const{inputs:t,backend:n,attrs:r}=e;let{pixels:s}=t;const{numChannels:a}=r,i=typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement,o=typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement,[u,c]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],l=[c,u],d=[c,u,a];if(o||i){const m=ke().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(bp==null||m!==Ok)&&(Ok=m,bp=document.createElement("canvas").getContext("2d",{willReadFrequently:Ok})),bp.canvas.width=u,bp.canvas.height=c,bp.drawImage(s,0,0,u,c),s=bp.canvas}const h=n.makeTensorInfo(l,"int32");n.texData.get(h.dataId).usage=Wa.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(h.dataId),s);const p=ke().getBool("WEBGL_PACK")?new FJe(d):new DJe(d),f=n.runWebGLProgram(p,[h],"int32");return n.disposeData(h.dataId),f}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LJe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:u,pad:c,dataFormat:l,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r,m=to(l),g=yr(s.shape,a.shape,u,d,c,h,!1,m);let b;const y=[],x=i!=null,w=o!=null,v=p==="leakyrelu",I=()=>{const T=[s,a],E=(A,k)=>{if(k==="NCHW"&&A.shape.length===1&&A.shape[0]!==1){const C=Je({inputs:{x:A},backend:n,attrs:{shape:[A.shape[0],1,1]}});return y.push(C),C}return A};if(x&&T.push(E(i,l)),w&&T.push(E(o,l)),v){const A=n.makeTensorInfo([],"float32",Mu(f,"float32"));T.push(A),y.push(A)}return T};if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))b=bj({x:s,filter:a,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else if(g.strideWidth<=2&&m==="channelsLast"&&ke().getBool("WEBGL_EXP_CONV")){const T=p?Py(p,!0):null,E=new gj(g,x,T,w,v),A=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],k=I();b=n.runWebGLProgram(E,k,"float32",A)}else if(ke().getBool("WEBGL_CONV_IM2COL"))b=yj({x:s,filter:a,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else{const T=p?Py(p,!1):null,E=new mj(g,x,T,w,v),A=I();b=n.runWebGLProgram(E,A,"float32")}const N=Je({inputs:{x:b},backend:n,attrs:{shape:g.outShape}});return y.push(b),y.forEach(T=>n.disposeIntermediateTensorInfo(T)),N}const PJe={kernelName:ef,backendName:"webgl",kernelFunc:LJe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BJe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:u,pad:c,dilations:l,dimRoundingMode:d,activation:h,leakyreluAlpha:p}=r,f=[];let m=l;m==null&&(m=[1,1]),U(bs(u,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${m}'`);const g=yr(s.shape,a.shape,u,m,c,d,!0),b=ke().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,y=h?Py(h,b):null,x=[s,a],w=i!=null,v=o!=null,I=h==="leakyrelu";if(w&&x.push(i),v&&x.push(o),I){const A=n.makeTensorInfo([],"float32",Mu(p,"float32"));x.push(A),f.push(A)}let N;b?N=new vj(g,w,y,v,I):N=new wj(g,w,y,v,I);const T=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],E=n.runWebGLProgram(N,x,"float32",T);return f.forEach(A=>n.disposeIntermediateTensorInfo(A)),E}const zJe={kernelName:iI,backendName:"webgl",kernelFunc:BJe};class WJe{constructor(t,n,r,s){this.sliceDim=t,this.strides=n,this.paramsShape=s,this.variableNames=["x","indices"],this.outputShape=r;const a=Vn(r.length);let i=`
    int index;`;for(let o=0;o<this.sliceDim;o++)i+=`
          index = round(getIndices(coords[0], ${o}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[o]};
          flattenIndex += index * ${this.strides[o]};`;this.userCode=`
         void main() {
          ${a} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${i}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VJe(e){const{inputs:t,backend:n}=e,{params:r,indices:s}=t,a=s.shape,i=a[a.length-1],o=fe(r.shape),[u,c,l,d]=gI(r,s),h=Je({inputs:{x:s},backend:n,attrs:{shape:[c,i]}}),p=Je({inputs:{x:r},backend:n,attrs:{shape:[fe(r.shape)/l,l]}});if(n.shouldExecuteOnCPU([r,s])||r.dtype==="string"){const b=n.readSync(s.dataId),y=n.bufferSync(r),x=jqe(b,y,r.dtype,c,i,l,d,r.shape,o);return n.makeTensorInfo(u,r.dtype,x.values)}const f=new WJe(i,d,[c,l],r.shape),m=n.runWebGLProgram(f,[p,h],p.dtype),g=Je({inputs:{x:m},backend:n,attrs:{shape:u}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}const UJe={kernelName:jv,backendName:"webgl",kernelFunc:VJe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GJe{constructor(t,n){this.variableNames=["A","indices"],this.outputShape=n,this.rank=n.length;const r=Vn(this.rank),s=HJe(t);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${s}));
      }
    `}}function HJe(e,t){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<e.length;s++)s===2?r.push("index"):r.push(`${n[s]}`);return r.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cj(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,indices:a}=t,{axis:i,batchDims:o}=r,u=zt(i,s.shape)[0];if(ke().get("DEBUG")){const y=n.readSync(a.dataId),x=s.shape[u];for(let w=0;w<y.length;++w){const v=y[w];U(v<=x-1&&v>=0,()=>`GatherV2: the index value ${v} is not in [0, ${x-1}]`)}}const c=AI(s,a,u,o),l=fe(a.shape),d=[],h=Je({inputs:{x:s},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),p=Je({inputs:{x:a},backend:n,attrs:{shape:[c.batchSize,l/c.batchSize]}});d.push(h),d.push(p);const f=[c.batchSize,c.outerSize,l/c.batchSize,c.sliceSize];if(n.shouldExecuteOnCPU([s,a])||s.dtype==="string"){const y=n.bufferSync(p),x=n.bufferSync(h),w=qqe(x,y,f);return d.forEach(v=>n.disposeIntermediateTensorInfo(v)),n.makeTensorInfo(c.outputShape,w.dtype,w.values)}const m=new GJe(h.shape,f),g=n.runWebGLProgram(m,[h,p],h.dtype);d.push(g);const b=Je({inputs:{x:g},backend:n,attrs:{shape:c.outputShape}});return d.forEach(y=>n.disposeIntermediateTensorInfo(y)),b}const jJe={kernelName:f1,backendName:"webgl",kernelFunc:Cj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qJe="return float(a > b);",KJe=`
  return vec4(greaterThan(a, b));
`,XJe=ys({opSnippet:qJe,packedOpSnippet:KJe,cpuKernelImpl:Kqe,dtype:"bool"}),QJe={kernelName:m1,backendName:"webgl",kernelFunc:XJe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YJe="return float(a >= b);",JJe=`
  return vec4(greaterThanEqual(a, b));
`,ZJe=ys({opSnippet:YJe,packedOpSnippet:JJe,dtype:"bool",cpuKernelImpl:Xqe}),eZe={kernelName:cg,backendName:"webgl",kernelFunc:ZJe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tZe(e){const{inputs:t,backend:n}=e,{input:r}=t;return kj(r,!0,n)}const nZe={kernelName:yE,backendName:"webgl",kernelFunc:tZe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rZe="return float(!isnan(x) && !isinf(x));",sZe=hn({opSnippet:rZe,dtype:"bool"}),aZe={kernelName:hg,backendName:"webgl",kernelFunc:sZe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iZe="return float(isinf(x));",oZe=hn({opSnippet:iZe,dtype:"bool"}),lZe={kernelName:pg,backendName:"webgl",kernelFunc:oZe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uZe="return float(isnan(x));",cZe=hn({opSnippet:uZe,dtype:"bool"}),dZe={kernelName:fg,backendName:"webgl",kernelFunc:cZe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hZe="return float(a < b);",pZe=`
  return vec4(lessThan(a, b));
`,fZe=ys({opSnippet:hZe,packedOpSnippet:pZe,cpuKernelImpl:Qqe,dtype:"bool"}),mZe={kernelName:g1,backendName:"webgl",kernelFunc:fZe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gZe="return float(a <= b);",bZe=`
  return vec4(lessThanEqual(a, b));
`,yZe=ys({opSnippet:gZe,packedOpSnippet:bZe,cpuKernelImpl:Yqe,dtype:"bool"}),xZe={kernelName:b1,backendName:"webgl",kernelFunc:yZe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wZe(e){const{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,i=Jqe(r,s,a);return t.makeTensorInfo([i.length],"float32",i)}const vZe={kernelName:qv,backendName:"webgl",kernelFunc:wZe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IZe=hb+`
  return x < 0.0 ? 0./0. : log(x);
`,kZe=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,CZe=hn({opSnippet:IZe,packedOpSnippet:kZe,cpuKernelImpl:Zqe}),SZe={kernelName:gg,backendName:"webgl",kernelFunc:CZe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NZe=hb+`
  return log(1.0 + x);
`,TZe=hn({opSnippet:NZe}),EZe={kernelName:bg,backendName:"webgl",kernelFunc:TZe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AZe="return float(a >= 1.0 && b >= 1.0);",$Ze=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,RZe=ys({opSnippet:AZe,packedOpSnippet:$Ze,dtype:"bool"}),_Ze={kernelName:y1,backendName:"webgl",kernelFunc:RZe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DZe="return float(!(x >= 1.0));",FZe=hn({opSnippet:DZe}),MZe={kernelName:x1,backendName:"webgl",kernelFunc:FZe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OZe="return float(a >= 1.0 || b >= 1.0);",LZe=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,PZe=ys({opSnippet:OZe,packedOpSnippet:LZe,dtype:"bool"}),BZe={kernelName:w1,backendName:"webgl",kernelFunc:PZe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zZe{constructor(t,n,r,s,a){this.variableNames=["x"],this.outputShape=[];const i=n,o=t[3]-1;this.outputShape=t;let u;const c=`float(${r}) + float(${s}) * sum`;a===.5?u=`inversesqrt(${c})`:a===1?u=`1.0/(${c})`:u=`exp(log(${c}) * float(-${a}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${i}; j <= ${i}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${o}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${u};
        setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WZe{constructor(t,n,r,s,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const i=n,o=t[3]-1;this.outputShape=t;let u;const c=`float(${r}) + float(${s}) * sum`;a===.5?u=`inversesqrt(${c})`:a===1?u=`1.0/(${c})`:u=`exp(log(${c}) * float(-${a}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${i};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${i}; j <= ${i}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${o}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${u};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VZe=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:i,alpha:o,beta:u}=r,c=ke().getBool("WEBGL_PACK_NORMALIZATION")?new WZe(s.shape,a,i,o,u):new zZe(s.shape,a,i,o,u);return n.runWebGLProgram(c,[s],s.dtype)},UZe={kernelName:yg,backendName:"webgl",kernelFunc:VZe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GZe{constructor(t,n,r,s,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=n,this.bias=r,this.alpha=s,this.beta=a,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${n})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${n} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${s}) * norm + float(${r});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${s})
                * float(${a})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${a});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HZe=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:i}=t,{depthRadius:o,bias:u,alpha:c,beta:l}=r,d=new GZe(s.shape,o,u,c,l);return n.runWebGLProgram(d,[s,a,i],s.dtype)},jZe={kernelName:v1,backendName:"webgl",kernelFunc:HZe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qZe(e,t,n,r){const s=fe(t),i=fe(e.shape)/s,o=Je({inputs:{x:e},attrs:{shape:[i,s]},backend:r}),u=cp(o,e.dtype,"max",r),c=Je({inputs:{x:u},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(u),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sj(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:a,keepDims:i}=r,o=s.shape.length,u=zt(a,s.shape);let c=u;const l=nr(c,o),d=l!=null,h=n.shouldExecuteOnCPU([s]);let p=s;if(d){if(h){const x=n.texData.get(p.dataId).values,w=new Array(o);for(let N=0;N<w.length;N++)w[N]=s.shape[l[N]];const v=k$(x,s.shape,s.dtype,l,w);p=n.makeTensorInfo(w,s.dtype);const I=n.texData.get(p.dataId);I.values=v}else p=GI(s,l,n);c=qn(c.length,o)}tr("max",c,o);const[f,m]=sr(p.shape,c);let g=f;i&&(g=jn(f,u));let b;if(h){const x=n.texData.get(p.dataId).values,w=eKe(x,fe(m),g,s.dtype);b=n.makeTensorInfo(g,s.dtype);const v=n.texData.get(b.dataId);v.values=w}else b=qZe(p,m,g,n);return d&&n.disposeIntermediateTensorInfo(p),b}const KZe={kernelName:xg,backendName:"webgl",kernelFunc:Sj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XZe=C$+`
  return max(a, b);
`,QZe=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+up+`
  return result;
`,YZe=ys({opSnippet:XZe,packedOpSnippet:QZe,cpuKernelImpl:tKe}),JZe={kernelName:wg,backendName:"webgl",kernelFunc:YZe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZZe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;s2(s,"maxPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:u}=r,c=1;U(bs(i,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const l=Es(s.shape,a,i,c,o,u);if(l.filterWidth===1&&l.filterHeight===1&&Nn(l.inShape,l.outShape))return _a({inputs:{x:s},backend:n});const d=new By(l,"max",!1);return n.runWebGLProgram(d,[s],s.dtype)}const e7e={kernelName:vg,backendName:"webgl",kernelFunc:ZZe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t7e(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dataFormat:u,dimRoundingMode:c}=r,l=[1,1,1],d=Qa(s.shape,a,i,l,o,c,u),h=new N$(d,"max",!1);return n.runWebGLProgram(h,[s],s.dtype)}const n7e={kernelName:I1,backendName:"webgl",kernelFunc:t7e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class r7e{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const n=t.strideHeight,r=t.strideWidth,s=t.dilationHeight,a=t.effectiveFilterHeight,i=t.effectiveFilterWidth,o=a-1-t.padInfo.top,u=i-1-t.padInfo.left,c=a*i-1;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${a};
          wR += ${s}) {
          float dyR = float(dyRCorner + wR) / ${n}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${i}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${c} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${i} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class s7e{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const n=t.strideDepth,r=t.strideHeight,s=t.strideWidth,a=t.dilationDepth,i=t.dilationHeight,o=t.dilationWidth,u=t.effectiveFilterDepth,c=t.effectiveFilterHeight,l=t.effectiveFilterWidth,d=u-1-t.padInfo.front,h=c-1-t.padInfo.top,p=l-1-t.padInfo.left,f=u*c*l-1;this.userCode=`
      const ivec3 pads = ivec3(${d}, ${h}, ${p});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${u};
           wD += ${a}) {
          float dyD = float(dyDCorner + wD) / ${n}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${c};
              wR += ${i}) {
            float dyR = float(dyRCorner + wR) / ${r}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${l};
                wC += ${o}) {
              float dyC = float(dyCCorner + wC) / ${s}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${f} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${c} * ${l} +
                  wR * ${l} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a7e(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a,{filterSize:o,strides:u,pad:c,dimRoundingMode:l}=r,d=[1,1,1],h=Qa(i.shape,o,u,d,c,l),p=new N$(h,"max",!0),f=n.runWebGLProgram(p,[i],i.dtype),m=new s7e(h),g=n.runWebGLProgram(m,[s,f],i.dtype);return n.disposeIntermediateTensorInfo(f),g}const i7e={kernelName:Xv,backendName:"webgl",kernelFunc:a7e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o7e(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a,output:i}=t,o=a;s2([a,i],"maxPoolGrad");const{filterSize:u,strides:c,pad:l,dimRoundingMode:d}=r,h=Es(o.shape,u,c,1,l,d),p=!0,f=new By(h,"max",p),m=n.runWebGLProgram(f,[o],o.dtype),g=new r7e(h),b=n.runWebGLProgram(g,[s,m],o.dtype);return n.disposeIntermediateTensorInfo(m),b}const l7e={kernelName:Kv,backendName:"webgl",kernelFunc:o7e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u7e(e,t,n,r){let s=new By(n,"max",!1);const a=r.runWebGLProgram(s,[e],"float32");s=new By(n,"max",!0,!0,t);const i=r.runWebGLProgram(s,[e],"float32");return[a,i]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c7e={kernelName:wE,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{filterSize:s,strides:a,pad:i,includeBatchInIndex:o}=t,u=n;U(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const c=[1,1];U(bs(a,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);const l=Es(r.shape,s,a,c,i),[d,h]=u7e(r,o,l,u);return[d,h]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d7e(e,t,n,r){const s=fe(t),i=fe(e.shape)/s,o=Je({inputs:{x:e},attrs:{shape:[i,s]},backend:r}),u=cp(o,"float32","mean",r),c=Je({inputs:{x:u},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(u),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h7e={kernelName:Ig,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{keepDims:s,axis:a}=t,i=n,o=r.shape.length,u=zt(a,r.shape);let c=u;const l=nr(c,o),d=l!=null,h=i.shouldExecuteOnCPU([r]),p=[];let f=r;if(d){if(h){const w=i.texData.get(f.dataId).values,v=new Array(o);for(let T=0;T<v.length;T++)v[T]=r.shape[l[T]];const I=k$(w,r.shape,r.dtype,l,v);f=i.makeTensorInfo(v,r.dtype);const N=i.texData.get(f.dataId);N.values=I}else f=GI(r,l,i);p.push(f),c=qn(c.length,o)}tr("sum",c,o);const[m,g]=sr(f.shape,c);let b=m;s&&(b=jn(m,u));const y=d7e(f,g,b,i);for(const x of p)i.disposeIntermediateTensorInfo(x);return y}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p7e(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,u=zt(a,s.shape);let c=u;const l=nr(c,o);let d=s;l!=null&&(d=js({inputs:{x:s},backend:n,attrs:{perm:l}}),c=qn(c.length,s.shape.length)),tr("min",c,o);const[h,p]=sr(d.shape,c),f=fe(p),m=Je({inputs:{x:d},backend:n,attrs:{shape:[-1,f]}}),g=cp(m,m.dtype,"min",n);let b;if(i){const y=jn(h,u);b=Je({inputs:{x:g},backend:n,attrs:{shape:y}})}else b=Je({inputs:{x:g},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),l!=null&&n.disposeIntermediateTensorInfo(d),b}const f7e={kernelName:kg,backendName:"webgl",kernelFunc:p7e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m7e=C$+`
  return min(a, b);
`,g7e=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+up+`
  return result;
`,b7e=ys({opSnippet:m7e,packedOpSnippet:g7e,cpuKernelImpl:nKe}),y7e={kernelName:Cg,backendName:"webgl",kernelFunc:b7e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class x7e{constructor(t,n,r){this.variableNames=["x"],this.outputShape=n.map((l,d)=>l[0]+t[d]+l[1]);const s=t.length,a=Vn(s),i=n.map(l=>l[0]).join(","),o=n.map((l,d)=>l[0]+t[d]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s),c=r==="reflect"?0:1;if(s===1){this.userCode=`
        int start = ${i};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${c};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${c};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${a} start = ${a}(${i});
      ${a} end = ${a}(${o});

      void main() {
        ${a} outC = getOutputCoords();
        for (int i = 0; i < ${s}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${c};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};
          }
        }
        ${a} coords = outC - start;
        setOutput(getX(${u}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class w7e{constructor(t,n,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n.map((f,m)=>f[0]+t[m]+f[1]);const s=t.length,a=Vn(s),i=n.map(f=>f[0]).join(","),o=n.map((f,m)=>f[0]+t[m]).join(","),u=Bs("rc",s),c=Bs("source",s),l=`${u[s-1]} < ${this.outputShape[s-1]}`,d=s===1?"source":`vec2(${c.slice(-2).join()})`,h=r==="reflect"?0:1;let p="";if(s===1){const f=`
        ${a} source = rc;
        if (source < start) {
          source = start * 2 - source - ${h};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${h};
        }
        source -= start;
      `;p=`
        ${a} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${c.join()}), ${d});
        ${u[s-1]} += 1;
        if(${l}) {
          ${f}
          result[1] = getChannel(getX(${c.join()}), ${d});
        }
      `}else{const f=`
        ${a} source = rc;
        ${a} lt = ${a}(lessThan(source, start));
        ${a} gte = ${a}(greaterThanEqual(source, end));
        ${a} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${h}) +
                gte * ((end - 1) * 2 - source + ${h});
        source -= start;
      `;p=`
        ${a} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${c.join()}), ${d});
        ${u[s-1]} += 1;
        if(${l}) {
          ${f}
          result[1] = getChannel(getX(${c.join()}), ${d});
        }
        rc = outputLoc;
        ${u[s-2]} += 1;
        if(${u[s-2]} < ${this.outputShape[s-2]}) {
          ${f}
          result[2] = getChannel(getX(${c.join()}), ${d});
          ${u[s-1]} += 1;
          if(${l}) {
            ${f}
            result[3] = getChannel(getX(${c.join()}), ${d});
          }
        }
      `}this.userCode=`
      const ${a} start = ${a}(${i});
      const ${a} end = ${a}(${o});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v7e=({inputs:e,backend:t,attrs:n})=>{const{x:r}=e,{paddings:s,mode:a}=n,i=ke().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new w7e(r.shape,s,a):new x7e(r.shape,s,a);return t.runWebGLProgram(i,[r],r.dtype)},I7e={kernelName:Sg,backendName:"webgl",kernelFunc:v7e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k7e=`if (b == 0.0) return NAN;
  return mod(a, b);`,C7e=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+up+`
  return result;
`,S7e=ys({opSnippet:k7e,packedOpSnippet:C7e}),N7e={kernelName:Ng,backendName:"webgl",kernelFunc:S7e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class T7e{constructor(t,n,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,r],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${n-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${n-1}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const E7e=`
if (a == b) {
  return 1.0;
};
return a / b;`,A7e=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,Nj=ys({opSnippet:E7e,packedOpSnippet:A7e,checkOutOfBounds:!0}),$7e={kernelName:ng,backendName:"webgl",kernelFunc:Nj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xF="return a - b;",Tj=ys({opSnippet:xF,packedOpSnippet:xF,supportsComplex:!0,cpuKernelImpl:kKe}),R7e={kernelName:Yg,backendName:"webgl",kernelFunc:Tj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ej(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:a}=r,i=zt([a],s.shape),o=Sj({inputs:{x:s},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),u=jn(o.shape,i),c=Je({inputs:{x:o},backend:n,attrs:{shape:u}}),l=Tj({inputs:{a:s,b:c},backend:n}),d=Ij({inputs:{x:l},backend:n}),h=HI({inputs:{x:d},backend:n,attrs:{axis:i,keepDims:!1}}),p=Je({inputs:{x:h},backend:n,attrs:{shape:u}}),f=Nj({inputs:{a:d,b:p},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),f}const _7e={kernelName:Xg,backendName:"webgl",kernelFunc:Ej};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D7e(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:i,normalized:o}=r,u=o?s:Ej({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),c=u.shape[0],l=u.shape[1],d=new T7e(c,l,a),h=[[i]],p=n.runWebGLProgram(d,[u],"int32",h);return o||n.disposeIntermediateTensorInfo(u),p}const F7e={kernelName:Qv,backendName:"webgl",kernelFunc:D7e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M7e=xi+`
  return -x;
`,O7e=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function L7e(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){const a=n.texData.get(r.dataId),[i,o]=sKe(a.values,r.shape,r.dtype);return n.makeTensorInfo(o,r.dtype,i)}let s;return ke().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new zl(r.shape,O7e):s=new yo(r.shape,M7e),n.runWebGLProgram(s,[r],r.dtype)}const P7e={kernelName:k1,backendName:"webgl",kernelFunc:L7e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B7e=aA;function z7e(e){Oa("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u}=r,c=n.readSync(s.dataId),l=n.readSync(a.dataId),{selectedIndices:d}=B7e(c,l,i,o,u);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}const W7e={kernelName:S1,backendName:"webgl",kernelFunc:z7e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V7e=iA;function U7e(e){Oa("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u,padToMaxOutputSize:c}=r,l=n.readSync(s.dataId),d=n.readSync(a.dataId),{selectedIndices:h,validOutputs:p}=V7e(l,d,i,o,u,c);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}const G7e={kernelName:N1,backendName:"webgl",kernelFunc:U7e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H7e=oA;function j7e(e){Oa("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u,softNmsSigma:c}=r,l=n.readSync(s.dataId),d=n.readSync(a.dataId),h=i,p=o,f=u,m=c,{selectedIndices:g,selectedScores:b}=H7e(l,d,h,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}const q7e={kernelName:T1,backendName:"webgl",kernelFunc:j7e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class K7e{constructor(t,n,r,s){this.variableNames=["indices"],this.outputShape=[t,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${s}), float(${r}),
                      float(index == coords.y)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X7e=e=>{const{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{dtype:a,depth:i,onValue:o,offValue:u}=r,c=fe(s.shape),l=new K7e(c,i,o,u),d=Je({inputs:{x:s},backend:n,attrs:{shape:[c]}}),h=n.runWebGLProgram(l,[d],a);n.disposeIntermediateTensorInfo(d);const p=[...s.shape,i],f=Je({inputs:{x:h},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(h),f},Q7e={kernelName:Eg,backendName:"webgl",kernelFunc:X7e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iw(e){const{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="complex64"){const s=i2({inputs:{input:r},backend:n}),a=iw({inputs:{x:s},backend:n}),i=jI({inputs:{input:r},backend:n}),o=iw({inputs:{x:i},backend:n}),u=Vu({inputs:{real:a,imag:o},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),u}else return o2({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:n})}const Y7e={kernelName:W1,backendName:"webgl",kernelFunc:iw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aj(e){const{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){const s=i2({inputs:{input:r},backend:n}),a=Aj({inputs:{x:s},backend:n}),i=jI({inputs:{input:r},backend:n}),o=iw({inputs:{x:i},backend:n}),u=Vu({inputs:{real:a,imag:o},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),u}else return o2({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:n})}const J7e={kernelName:E1,backendName:"webgl",kernelFunc:Aj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z7e(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(t.length===1)return RS({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const a=t[0].shape,i=t[0].dtype;t.forEach(l=>{Bv(a,l.shape,"All tensors passed to stack must have matching shapes"),U(i===l.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],u=t.map(l=>{const d=RS({inputs:{input:l},backend:n,attrs:{dim:s}});return o.push(d),d}),c=fj({inputs:u,backend:n,attrs:{axis:s}});return o.forEach(l=>n.disposeIntermediateTensorInfo(l)),c}const eet={kernelName:A1,backendName:"webgl",kernelFunc:Z7e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tet{constructor(t,n,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((c,l)=>c[0]+t[l]+c[1]);const s=t.length,a=Vn(s),i=n.map(c=>c[0]).join(","),o=n.map((c,l)=>c[0]+t[l]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);if(s===1){this.userCode=`
        int start = ${i};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${a} start = ${a}(${i});
      ${a} end = ${a}(${o});

      void main() {
        ${a} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${a} coords = outC - start;
          setOutput(getX(${u}));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class net{constructor(t,n,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((m,g)=>m[0]+t[g]+m[1]);const s=t.length,a=Vn(s),i=n.map(m=>m[0]).join(","),o=n.map((m,g)=>m[0]+t[g]).join(","),u=Bs("rc",s),c=Bs("source",s),l=`${u[s-1]} < ${this.outputShape[s-1]}`,d=s===1?"source":`vec2(${c.slice(-2).join()})`,h=[`${a} rc = outputLoc;`,`${u[s-1]} += 1;
       if(${l}) {
      `,s===1?"":`}
       rc = outputLoc;
       ${u[s-2]} += 1;
       if(${u[s-2]} < ${this.outputShape[s-2]}) {`,s===1?"":`  ${u[s-1]} += 1;
         if(${l}) {`],p=s===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let f="";for(let m=0,g=s===1?2:4;m<g;m++)f+=`
        ${h[m]}
        if (${p}) {
          result[${m}] = float(value);
        } else {
          ${a} source = rc - start;
          result[${m}] = getChannel(getX(${c.join()}), ${d});
        }
      `;f+=s===1?"} ":"}}",this.userCode=`
      const ${a} start = ${a}(${i});
      const ${a} end = ${a}(${o});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $j=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,constantValue:i}=r;if(fe(s.shape)===0){const c=a.map((l,d)=>l[0]+s.shape[d]+l[1]);return o2({backend:n,attrs:{shape:c,value:i,dtype:s.dtype}})}const o=ke().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new net(s.shape,a,i):new tet(s.shape,a,i),u=[[i]];return n.runWebGLProgram(o,[s],s.dtype,u)},ret={kernelName:Ag,backendName:"webgl",kernelFunc:$j};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const set=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,aet=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+up+`
  return result;
`,iet=ys({opSnippet:set,packedOpSnippet:aet}),oet={kernelName:$g,backendName:"webgl",kernelFunc:iet};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uet(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,u=[],c=zt(a,s.shape);let l=c;const d=nr(l,o);let h=s;d!=null&&(h=js({inputs:{x:s},backend:n,attrs:{perm:d}}),l=qn(l.length,o),u.push(h)),tr("prod",l,o);let p;if(n.shouldExecuteOnCPU([h])){const f=n.texData.get(h.dataId).values,{outVals:m,outShape:g,outDtype:b}=iKe(h.shape,h.dtype,f,l);p=n.makeTensorInfo(g,b,m)}else{const[f,m]=sr(h.shape,l),g=fe(m),b=Je({inputs:{x:h},backend:n,attrs:{shape:[-1,g]}}),y=$E(s.dtype),x=cp(b,y,"prod",n);p=Je({inputs:{x},backend:n,attrs:{shape:f}}),u.push(b),u.push(x)}if(i){u.push(p);const f=jn(p.shape,c);p=Je({inputs:{x:p},backend:n,attrs:{shape:f}})}return u.forEach(f=>n.disposeIntermediateTensorInfo(f)),p}const cet={kernelName:_g,backendName:"webgl",kernelFunc:uet};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function det(e){const{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:s,paramsDenseValues:a,indices:i}=t,{outputRaggedRank:o}=r,u=s.map(b=>n.readSync(b.dataId)),c=s.map(b=>b.shape),l=n.readSync(a.dataId),d=n.readSync(i.dataId),[h,p,f]=oKe(u,c,l,a.shape,a.dtype,d,i.shape,o),m=h.map(b=>n.makeTensorInfo([b.length],"int32",b)),g=n.makeTensorInfo(f,a.dtype,p);return m.concat([g])}const het={kernelName:Hz,backendName:"webgl",kernelFunc:det};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pet(e){const{inputs:t,backend:n}=e,{starts:r,limits:s,deltas:a}=t,i=n.readSync(r.dataId),o=n.readSync(s.dataId),u=n.readSync(a.dataId),[c,l]=lKe(i,r.shape,r.dtype,o,s.shape,u,a.shape),d=n.makeTensorInfo([c.length],"int32",c),h=n.makeTensorInfo([l.length],r.dtype,l);return[d,h]}const fet={kernelName:jz,backendName:"webgl",kernelFunc:pet};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function met(e){const{inputs:t,backend:n,attrs:r}=e,{shape:s,values:a,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:u}=r,c=n.readSync(s.dataId),l=n.readSync(a.dataId),d=n.readSync(i.dataId),h=o.map(g=>n.readSync(g.dataId)),p=o.map(g=>g.shape),[f,m]=uKe(c,s.shape,l,a.shape,a.dtype,d,i.shape,h,p,u);return n.makeTensorInfo(f,a.dtype,m)}const get={kernelName:qz,backendName:"webgl",kernelFunc:met};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rj=e=>{const{backend:t,attrs:n}=e,{start:r,stop:s,step:a,dtype:i}=n,o=cKe(r,s,a,i);return t.makeTensorInfo([o.length],i,o)},bet={kernelName:Yv,backendName:"webgl",kernelFunc:Rj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yet="return 1.0 / x;",xet=hn({opSnippet:yet}),wet={kernelName:Dg,backendName:"webgl",kernelFunc:xet};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vet=xi+`
  return (x < 0.0) ? 0.0 : x;
`,Iet=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,ket=hn({opSnippet:vet,packedOpSnippet:Iet}),Cet={kernelName:Fg,backendName:"webgl",kernelFunc:ket};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Net=xi+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Tet=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Eet=hn({opSnippet:Net,packedOpSnippet:Tet}),Aet={kernelName:Lg,backendName:"webgl",kernelFunc:Eet};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $et{constructor(t,n,r,s,a){this.variableNames=["A"],this.outputShape=[];const[i,o,u,c]=t;this.outputShape=[i,n,r,c];const l=[s&&n>1?o-1:o,s&&r>1?u-1:u],d=[s&&n>1?n-1:n,s&&r>1?r-1:r];let h;a?h="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":h="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${l[0]/d[0]},
          ${l[1]/d[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${h};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ret{constructor(t,n,r,s,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,o,u,c]=t;this.outputShape=[i,n,r,c];const l=[s&&n>1?o-1:o,s&&r>1?u-1:u],d=[s&&n>1?n-1:n,s&&r>1?r-1:r];let h;a?h="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":h="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${l[0]/d[0]},
          ${l[1]/d[1]},
          ${l[1]/d[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${h};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${r-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _et(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r,[u,c]=o,l=ke().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Ret(s.shape,u,c,a,i):new $et(s.shape,u,c,a,i);return n.runWebGLProgram(l,[s],"float32")}const Det={kernelName:Og,backendName:"webgl",kernelFunc:_et};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fet{constructor(t,n,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,s,a]=n,[,i,o]=t,u=[r&&i>1?s-1:s,r&&o>1?a-1:a],c=[r&&i>1?i-1:i,r&&o>1?o-1:o],l=u[0]/c[0],d=u[1]/c[1],h=1/l,p=1/d,f=Math.ceil(h)*2+2,m=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${l});
        const float widthScale = float(${d});

        const float invHeightScale = float(${h});
        const float invWidthScale = float(${p});

        const int winHeight = int(${f});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${a-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Met(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=new Fet(a.shape,s.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}const Oet={kernelName:_1,backendName:"webgl",kernelFunc:Met};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Let{constructor(t,n,r,s,a){this.variableNames=["A"],this.outputShape=[];const[i,o,u,c]=t;this.outputShape=[i,n,r,c];const l=[s&&n>1?o-1:o,s&&r>1?u-1:u],d=[s&&n>1?n-1:n,s&&r>1?r-1:r],h=s?"0.5":"0.0";let p;a?p="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${l[0]/d[0]},
          ${l[1]/d[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Pet{constructor(t,n,r,s,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,o,u,c]=t;this.outputShape=[i,n,r,c];const l=[s&&n>1?o-1:o,s&&r>1?u-1:u],d=[s&&n>1?n-1:n,s&&r>1?r-1:r],h=s?"0.5":"0.0";let p;a?p="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${l[0]/d[0]},
          ${l[1]/d[1]},
          ${l[1]/d[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${r-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bet(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r,[u,c]=o,l=ke().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Pet(s.shape,u,c,a,i):new Let(s.shape,u,c,a,i);return n.runWebGLProgram(l,[s],s.dtype)}const zet={kernelName:Mg,backendName:"webgl",kernelFunc:Bet};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wet{constructor(t,n,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,s,a]=n,[,i,o]=t,u=[r&&i>1?s-1:s,r&&o>1?a-1:a],c=[r&&i>1?i-1:i,r&&o>1?o-1:o],l=u[0]/c[0],d=u[1]/c[1],h=1/l,p=1/d,f=Math.ceil(h)*2+2,m=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${l});
        const float widthScale = float(${d});

        const float invHeightScale = float(${h});
        const float invWidthScale = float(${p});

        const int winHeight = int(${f});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float sourceFracRow =
              float(${u[0]}) *
                (float(dyR) / float(${c[0]}));

            float sourceFracCol =
                float(${u[1]}) *
                  (float(dyC) / float(${c[1]}));

            int sourceNearestRow = int(min(
                float(int(${s}) - 1),
                ${r} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${a}) - 1),
                ${r} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vet(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=new Wet(a.shape,s.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}const Uet={kernelName:R1,backendName:"webgl",kernelFunc:Vet};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Get{constructor(t,n){this.variableNames=["x"];const r=t.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=t,r===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${t[0]} - coord - 1));
        }
      `;return}const s=o=>n.indexOf(o)!==-1&&t[o]!==1?`${t[o]} - coords[${o}] - 1`:`coords[${o}]`,a=t.map((o,u)=>s(u)).join(","),i=Vn(r);this.userCode=`
      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Het{constructor(t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=t.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=t;const s=Bs("rc",r),a=`${s[r-1]} + 1 < ${this.outputShape[r-1]}`,i=`${s[r-2]} + 1 < ${this.outputShape[r-2]}`,o=Vn(r);r===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${t[0]} - rc - 1),
            ${t[0]} - rc - 1);
          if(${a}){
              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),
                ${t[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${o} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${u(s.slice())};
          if(${a}){
            result.g = ${c(s.slice())};
          }
          if(${i}) {
            result.b = ${l(s.slice())};
            if(${a}) {
              result.a = ${d(s.slice())};
            }
          }
          setOutput(result);
        }
    `;function u(f){return h(f)}function c(f){return f[r-1]="("+f[r-1]+" + 1)",h(f)}function l(f){return f[r-2]="("+f[r-2]+" + 1)",h(f)}function d(f){return f[r-1]="("+f[r-1]+" + 1)",f[r-2]="("+f[r-2]+" + 1)",h(f)}function h(f){const m=t.map((y,x)=>p(x,f)),g=m.join(","),b=m.slice(-2).join(",");return`getChannel(getX(${g}), vec2(${b}))`}function p(f,m){return n.indexOf(f)!==-1&&t[f]!==1?`${t[f]} - ${m[f]} - 1`:`${m[f]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jet(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r,i=s.shape.length,o=zt(a,s.shape);if(i===0)return _a({inputs:{x:s},backend:n});const u=ke().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Het(s.shape,o):new Get(s.shape,o);return n.runWebGLProgram(u,[s],s.dtype)}const qet={kernelName:Pg,backendName:"webgl",kernelFunc:jet};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ket{constructor(t,n){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const r=t[1],s=t[2];this.outputShape=t;let a="";typeof n=="number"?a=`float outputValue = ${n.toFixed(2)};`:a=`
        vec3 fill = vec3(${n.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${a}
          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${r}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xet={kernelName:V1,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,{radians:s,fillValue:a,center:i}=t,o=n,u=new Ket(r.shape,a),[c,l]=kI(i,r.shape[1],r.shape[2]),d=[[c,l,Math.sin(s),Math.cos(s)]];return o.runWebGLProgram(u,[r],r.dtype,d)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qet=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,Yet=hn({opSnippet:Qet}),Jet={kernelName:Bg,backendName:"webgl",kernelFunc:Yet};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zet="return inversesqrt(x);",ett=hn({opSnippet:Zet,cpuKernelImpl:dKe}),ttt={kernelName:zg,backendName:"webgl",kernelFunc:ett};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class T${constructor(t,n,r,s,a,i,o=!0,u=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;const c=Vn(a.length),l=Vn(i.length);let d="";r===1?d="i":r===2&&(d="i, j");const h=`getIndices(${d})`;let p="";s===1?p="i":s===2&&(p="i, coords[1]");const f=`getUpdates(${p})`;let m="";u&&(m="coords[0], coords[1]");const g=`getDefaultValue(${m})`,b=n>1?"strides[j]":"strides";this.userCode=`
        ${c} strides = ${c}(${a});

        void main() {
          ${l} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${t}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${n}; j++) {
              int index = round(${h});
              flattenedIndex += index * ${b};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${f};
              found = true;
            }
          }
          setOutput(mix(${g}, sum, float(found)));
        }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ntt{constructor(t,n,r,s,a,i,o=!0,u=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i;const c=Vn(a.length),l=Vn(i.length);let d="";r===1?d="i":r===2&&(d="i, j");const h=`getIndices(${d})`;let p="";s===1?p="i":s===2&&(p="i, coords[1]");const f=`getUpdates(${p})`;let m="";u&&(m="coords[0], coords[1]");const g=`getDefaultValue(${m})`,b=n>1?"strides[j]":"strides",y=n>1?"strides[j + 1]":"strides";this.userCode=`
        ${c} strides = ${c}(${a});

        void main() {
          ${l} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${t}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${n}; j+=2) {
              ivec4 index = round(${h});
              flattenedIndex += index.xz * ${b};
              if (j + 1 < ${n}) {
                flattenedIndex += index.yw * ${y};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${f};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${g}, sum, found));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rtt(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:a}=t,{shape:i}=r,{sliceRank:o,numUpdates:u,sliceSize:c,strides:l,outputSize:d}=zo(a,s,i),h=[d/c,c];if(d===0)return n.makeTensorInfo(i,s.dtype);const p=Je({inputs:{x:s},backend:n,attrs:{shape:[u,o]}}),f=Je({inputs:{x:a},backend:n,attrs:{shape:[u,c]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0]));let g;ke().getBool("WEBGL_PACK")?g=new ntt(u,o,p.shape.length,f.shape.length,l,h):g=new T$(u,o,p.shape.length,f.shape.length,l,h);const b=n.runWebGLProgram(g,[f,p,m],f.dtype),y=Je({inputs:{x:b},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(m),y}const stt={kernelName:Jv,backendName:"webgl",kernelFunc:rtt};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class att{constructor(t,n,r,s){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,r];const a="while (left < right) {",i=`for (int i = 0; i < ${Math.ceil(Math.log2(n+1))}; ++i) { if (left >= right) break;`,o=ke().getNumber("WEBGL_VERSION")===2?a:i,u=s==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${o}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${u} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function itt(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:s,values:a}=t,{side:i}=r,o=new att(s.shape[0],s.shape[1],a.shape[1],i),u=[[s.shape[1]]];return n.runWebGLProgram(o,[s,a],"int32",u)}const ott={kernelName:eI,backendName:"webgl",kernelFunc:itt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ltt{constructor(t,n,r){this.variableNames=["c","a","b"],this.outputShape=n;let s,a;if(r>4)throw Error(`Where for rank ${r} is not yet supported`);if(r===1)a="resRC",s="resRC";else{const o=["resRC.x","resRC.y","resRC.z","resRC.w"],u=[],c=[];for(let l=0;l<n.length;l++)c.push(`${o[l]}`),l<t&&u.push(`${o[l]}`);s=u.join(),a=c.join()}const i=Vn(r);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        float cVal = getC(${s});
        if (cVal >= 1.0) {
          setOutput(getA(${a}));
        } else {
          setOutput(getB(${a}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function utt(e){const{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t,i=new ltt(r.shape.length,s.shape,s.shape.length);return n.runWebGLProgram(i,[r,s,a],$a(s.dtype,a.dtype))}const ctt={kernelName:D1,backendName:"webgl",kernelFunc:utt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dtt=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${NI};
  float scale = ${TI};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,htt=hn({opSnippet:dtt}),ptt={kernelName:Wg,backendName:"webgl",kernelFunc:htt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ftt=hb+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,mtt=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,gtt=hn({opSnippet:ftt,packedOpSnippet:mtt,cpuKernelImpl:pKe}),btt={kernelName:Hg,backendName:"webgl",kernelFunc:gtt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ytt=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,xtt=hn({opSnippet:ytt}),wtt={kernelName:Gg,backendName:"webgl",kernelFunc:xtt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vtt=hb+`
  return sin(x);
`,Itt=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${up}
  return result;
`,ktt=hn({opSnippet:vtt,packedOpSnippet:Itt}),Ctt={kernelName:Vg,backendName:"webgl",kernelFunc:ktt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Stt=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,Ntt=hn({opSnippet:Stt}),Ttt={kernelName:Ug,backendName:"webgl",kernelFunc:Ntt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ett=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,Att=hn({opSnippet:Ett}),$tt={kernelName:jg,backendName:"webgl",kernelFunc:Att};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rtt=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:i}=r;U(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const o=a.reduce((b,y)=>b*y),u=[[0,0]];u.push(...i);for(let b=1+a.length;b<s.shape.length;++b)u.push([0,0]);const c=[],l=$j({inputs:{x:s},backend:n,attrs:{paddings:u,constantValue:0}}),d=np(l.shape,a,o,!1),h=rp(d.length,a.length,!1),p=sp(l.shape,a,o,!1),f=Je({inputs:{x:l},backend:n,attrs:{shape:d}}),m=js({inputs:{x:f},backend:n,attrs:{perm:h}}),g=Je({inputs:{x:m},backend:n,attrs:{shape:p}});return c.push(l),c.push(f),c.push(m),c.forEach(b=>n.disposeIntermediateTensorInfo(b)),g},_tt={kernelName:M1,backendName:"webgl",kernelFunc:Rtt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dtt(e){const{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:a,defaultValue:i}=t;if(a.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${a.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${s.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);const o=n.readSync(r.dataId),u=n.readSync(s.dataId),c=n.readSync(a.dataId),l=n.readSync(i.dataId)[0],[d,h,p,f,m]=mKe(o,r.shape,r.dtype,u,s.dtype,c,l);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([h[0]],s.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}const Ftt={kernelName:IE,backendName:"webgl",kernelFunc:Dtt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mtt(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:a}=t;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const i=Array.from(n.readSync(s.dataId)),o=n.readSync(r.dataId),u=Array.from(n.readSync(a.dataId)),[c,l,d]=gKe(o,r.shape,r.dtype,i,u);return[n.makeTensorInfo(l,r.dtype,c),n.makeTensorInfo([d.length],a.dtype,new Int32Array(d))]}const Ott={kernelName:tI,backendName:"webgl",kernelFunc:Mtt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ltt(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${a.shape}`);const i=n.readSync(r.dataId),o=n.readSync(s.dataId),u=n.readSync(a.dataId),[c,l]=tj(i,r.shape,r.dtype,o,u,!0);return n.makeTensorInfo(l,r.dtype,c)}const Ptt={kernelName:kE,backendName:"webgl",kernelFunc:Ltt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Btt(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${a.shape}`);const i=n.readSync(r.dataId),o=n.readSync(s.dataId),u=n.readSync(a.dataId),[c,l]=tj(i,r.shape,r.dtype,o,u);return n.makeTensorInfo(l,r.dtype,c)}const ztt={kernelName:CE,backendName:"webgl",kernelFunc:Btt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wtt(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:u,numUpdates:c,sliceSize:l,strides:d,outputSize:h}=zo(a,s,o),p=!1;if(a.dtype==="string"){const b=n.bufferSync(s),y=n.bufferSync(a),x=cu(n.readSync(i.dataId)[0]),w=hKe(b,y,o,h,l,c,u,d,x,p);return n.makeTensorInfo(o,w.dtype,w.values)}const f=new T$(c,u,s.shape.length,a.shape.length,d,[h,1],p),m=n.runWebGLProgram(f,[a,s,i],a.dtype),g=Je({inputs:{x:m},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(m),g}const Vtt={kernelName:nI,backendName:"webgl",kernelFunc:Wtt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Utt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:i}=r,o=zt(i,s.shape)[0],u=EI(s,a,o),c=s.shape.length,l=new Array(c).fill(0),d=s.shape.slice();return u.map(h=>{const p=[...d];p[o]=h;const f=pb({inputs:{x:s},backend:n,attrs:{begin:l,size:p}});return l[o]+=h,f})}const Gtt={kernelName:O1,backendName:"webgl",kernelFunc:Utt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wF="return sqrt(x);",Htt=hn({opSnippet:wF,packedOpSnippet:wF,cpuKernelImpl:bKe}),jtt={kernelName:qg,backendName:"webgl",kernelFunc:Htt};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qtt="return x * x;",Ktt=hn({opSnippet:qtt}),Xtt={kernelName:rI,backendName:"webgl",kernelFunc:Ktt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vF="return (a - b) * (a - b);",Qtt=ys({opSnippet:vF,packedOpSnippet:vF}),Ytt={kernelName:Qg,backendName:"webgl",kernelFunc:Qtt};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jtt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");const a=n.readSync(s.dataId),i=dl(a),o=yKe(i,"string",r);return n.makeTensorInfo(s.shape,"string",o)}const Ztt={kernelName:SE,backendName:"webgl",kernelFunc:Jtt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ent({inputs:e,attrs:t,backend:n}){const{x:r}=e,s=xi+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,a=new yo(r.shape,s);return n.runWebGLProgram(a,[r],r.dtype)}const tnt={kernelName:Jh,backendName:"webgl",kernelFunc:ent};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nnt{constructor(t,n,r){this.variableNames=["x"],this.outputShape=r;const s=r.length,a=Vn(r.length),i=Vn(r.length);let o="";if(s===1)o="coords * strides + begin";else{let u=0;o=r.map((c,l)=>(u++,r.length===1?`coords * strides[${l}] + begin[${l}]`:`coords[${u-1}] * strides[${l}] + begin[${l}]`)).join(",")}this.userCode=`
      ${a} begin = ${a}(${t});
      ${a} strides = ${a}(${n});

      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${o}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rnt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,end:i,strides:o,beginMask:u,endMask:c,ellipsisMask:l,newAxisMask:d,shrinkAxisMask:h}=r,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:b,begin:y,end:x,strides:w}=wI(s.shape,a,i,o,u,c,l,d,h);let v;if(m)v=Je({inputs:{x:s},backend:n,attrs:{shape:f}});else if(g||b){U(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const N=bI(y,x,w),T=pb({inputs:{x:s},backend:n,attrs:{begin:y,size:N}});v=Je({inputs:{x:T},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(T)}else if(n.shouldExecuteOnCPU([s])){const T=n.readSync(s.dataId),E=Yt(s.shape,s.dtype,T),A=xKe(p,E,w,y);v=n.makeTensorInfo(f,s.dtype,A.values)}else{const T=new nnt(y,w,p);v=n.runWebGLProgram(T,[s],s.dtype)}const I=Je({inputs:{x:v},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(v),I}const snt={kernelName:L1,backendName:"webgl",kernelFunc:rnt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ant(e){const{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:a,leftPad:i,rightPad:o,padWidth:u,preserveShortSequences:c}=r,{data:l,dataSplits:d}=t,h=n.readSync(l.dataId),p=n.readSync(d.dataId),[f,m]=wKe(h,p,s,a,i,o,u,c);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}const int={kernelName:NE,backendName:"webgl",kernelFunc:ant};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ont(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:a,delimiter:i}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(a.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=n.readSync(a.dataId),u=n.readSync(i.dataId)[0],[c,l,d]=vKe(o,u,s),h=l.length;return[n.makeTensorInfo([h,2],"int32",c),n.makeTensorInfo([h],"string",l),n.makeTensorInfo([2],"int32",new Int32Array(d))]}const lnt={kernelName:TE,backendName:"webgl",kernelFunc:ont};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function unt(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:a}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=n.readSync(a.dataId),o=IKe(i,s);return n.makeTensorInfo(a.shape,"int32",o)}const cnt={kernelName:EE,backendName:"webgl",kernelFunc:unt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dnt="return tan(x);",hnt=hn({opSnippet:dnt}),pnt={kernelName:Jg,backendName:"webgl",kernelFunc:hnt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fnt=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,mnt=hn({opSnippet:fnt}),gnt={kernelName:Zg,backendName:"webgl",kernelFunc:mnt};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bnt(e){const{inputs:t,backend:n,attrs:r}=e,{tensor:s,indices:a,updates:i}=t,{sliceRank:o,numUpdates:u,sliceSize:c,strides:l,outputSize:d}=zo(i,a,s.shape),h=[d/c,c];if(d===0)return n.makeTensorInfo(s.shape,a.dtype);const p=Je({inputs:{x:a},backend:n,attrs:{shape:[u,o]}}),f=Je({inputs:{x:i},backend:n,attrs:{shape:[u,c]}}),m=Je({inputs:{x:s},backend:n,attrs:{shape:h}}),g=new T$(u,o,p.shape.length,f.shape.length,l,h,!1,!0),b=n.runWebGLProgram(g,[f,p,m],m.dtype),y=Je({inputs:{x:b},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(b),y}const ynt={kernelName:Zv,backendName:"webgl",kernelFunc:bnt};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xnt{constructor(t,n){this.variableNames=["A"];const r=new Array(t.length);for(let i=0;i<r.length;i++)r[i]=t[i]*n[i];this.outputShape=r,this.rank=r.length;const s=Vn(this.rank),a=wnt(t);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        setOutput(getA(${a}));
      }
    `}}function wnt(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<e.length;s++)r.push(`imod(${n[s]}, ${e[s]})`);return r.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _j(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:a}=r;if(s.dtype==="string"||s.shape.length>5){const u=n.readSync(s.dataId),c=s.dtype==="string"?u.map(h=>cu(h)):u,l=Yt(s.shape,s.dtype,c),d=CKe(l,a);return n.makeTensorInfo(d.shape,d.dtype,d.values)}const i=new xnt(s.shape,a);return n.runWebGLProgram(i,[s],s.dtype)}const vnt={kernelName:Yh,backendName:"webgl",kernelFunc:_j};class Int{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class knt{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dc(e,t){t!==null&&e.disposeIntermediateTensorInfo(t)}function IF(e){let t=1;for(;t<e;)t*=2;return t}function Cnt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:a,sorted:i}=r,o=ke().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),u=ke().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=s.shape,l=c[c.length-1];if(n.shouldExecuteOnCPU([s])||l<o||a>u){const A=n.readSync(s.dataId),[k,C]=SKe(A,c,s.dtype,a,i);return[n.makeTensorInfo(k.shape,k.dtype,k.values),n.makeTensorInfo(C.shape,C.dtype,C.values)]}if(a===0)return c[c.length-1]=0,[n.makeTensorInfo(c,s.dtype,[]),n.makeTensorInfo(c,"int32",[])];if(l===1)return[s,o2({attrs:{shape:c,dtype:"int32",value:0},backend:n})];const d=n.texData.get(s.dataId),h=d!==null&&d.isPacked,p=h?n.unpackTensor(s):s,m=fe(c)/l,g=Je({inputs:{x:p},attrs:{shape:[m,l]},backend:n});h&&dc(n,p);const b=IF(a),y=IF(l);let x=null;const w=()=>x===null?[g,g]:[g,x],v=(A,k,C)=>{const M=w(),L=new Int(C),B=[[l],[x===null?1:0],[Number.NEGATIVE_INFINITY],[A],[k]],G=x;x=n.runWebGLProgram(L,M,"int32",B),dc(n,G)};for(let A=1;A<b;A*=2){const k=A*2;for(let C=A;C>=1;C/=2)v(k,C,[m,y])}for(let A=y;A>b;A/=2){const k=w(),C=new knt([m,A/2]),L=[[l],[x===null?1:0],[b]],O=x;x=n.runWebGLProgram(C,k,"int32",L),dc(n,O);const B=b/2,G=B*2;for(let z=B;z>=1;z/=2)v(G,z,x.shape)}let I=x;x=pb({inputs:{x},backend:n,attrs:{begin:0,size:[m,a]}}),dc(n,I);let N=Cj({inputs:{x:g,indices:x},backend:n,attrs:{axis:1,batchDims:1}});dc(n,g);const T=c.slice(0,-1);T.push(a),I=x,x=Je({inputs:{x},attrs:{shape:T},backend:n}),dc(n,I);const E=N;return N=Je({inputs:{x:N},attrs:{shape:T},backend:n}),dc(n,E),[N,x]}const Snt={kernelName:P1,backendName:"webgl",kernelFunc:Cnt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Nnt{constructor(t,n,r,s,a,i){this.variableNames=["Image","Transforms"],this.outputShape=i;const o=r==="nearest"?1:2;let u;switch(s){case"constant":u=1;break;case"reflect":u=2;break;case"wrap":u=3;break;case"nearest":u=4;break;default:u=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${u} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${n}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${a});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${a});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${n}));
                float mapY = mapCoord(inY, float(${t}));

                if (${o} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tnt(e){const{inputs:t,backend:n,attrs:r}=e,{image:s,transforms:a}=t,{interpolation:i,fillMode:o,fillValue:u,outputShape:c}=r,[l,d,h,p]=s.shape,[f,m]=c??[d,h],g=[l,f,m,p],b=new Nnt(d,h,i,o,u,g);return n.runWebGLProgram(b,[s,a],"float32")}const Ent={kernelName:B1,backendName:"webgl",kernelFunc:Tnt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ant(e){const{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t;s2(a,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=r.readSync(a.dataId),{outputValues:o,outputShape:u,indices:c}=NKe(i,s,a.shape,a.dtype);return[r.makeTensorInfo(u,a.dtype,o),r.makeTensorInfo([c.length],"int32",c)]}const $nt={kernelName:sI,backendName:"webgl",kernelFunc:Ant};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rnt(e){const{inputs:t,backend:n,attrs:r}=e,{value:s}=t;let{axis:a}=r;a<0&&(a+=s.shape.length);const i=s,o=i.shape.length,u=s.shape[a],c=new Array(o-1);let l=0;for(let m=0;m<o;m++)m!==a&&(c[l++]=i.shape[m]);const d=[],h=new Array(o).fill(0),p=i.shape.slice();p[a]=1;const f=new Array(u);for(let m=0;m<f.length;m++){h[a]=m;const g=pb({inputs:{x:i},backend:n,attrs:{begin:h,size:p}}),b=Je({inputs:{x:g},backend:n,attrs:{shape:c}});f[m]=b,d.push(g)}return d.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}const _nt={kernelName:z1,backendName:"webgl",kernelFunc:Rnt};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Dnt{constructor(t,n){this.variableNames=["x","segmentIds"];const r=t.windowSize,s=t.batchSize,a=t.inSize,i=t.numSegments,o=i*Math.ceil(a/r);this.outputShape=[s,o];const u="0.0",c="sumValue",l=Math.floor(r/4)*4,d=r%4,h=`
        sumValue += dot(values, segFilter);
    `;let p="";a%r>0&&(p=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return initializationValue;
        }
      `);let f="";a%r>0&&(f=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${u};

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${f}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${i})) * float(${r}));
        int currentSeg = int(mod(float(outIdx), float(${i})));

        float sumValue = 0.0;

        for (int i = 0; i < ${l}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${h}
        }

        int inIdx = inOffset + ${l};
        if (${d===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${h}
        } else if (${d===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${h}
        } else if (${d===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${h}
        }
        setOutput(${c});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fnt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:a}=t,{numSegments:i}=r,o=s.shape.length,u=[];let c=0;const l=nr([c],o);let d=s;l!=null&&(d=js({inputs:{x:s},backend:n,attrs:{perm:l}}),u.push(d),c=qn(1,o)[0]);const h=vV(d.shape,c,i),p=fe([d.shape[c]]),f=Je({inputs:{x:d},backend:n,attrs:{shape:[-1,p]}});u.push(f);const m=$E(s.dtype),g=(w,v,I,N,T)=>{const E=w.shape[0],A=w.shape[1],k=wV(A,T),C={windowSize:k,inSize:A,batchSize:E,numSegments:T},M=new Dnt(C,v),L=n.compileAndRun(M,[w,I],N);if(u.push(L),L.shape[1]===T)return L;const O=Rj({backend:n,attrs:{start:0,stop:T,step:1,dtype:"float32"}}),B=_j({inputs:{x:O},backend:n,attrs:{reps:[A/k]}});return u.push(O),u.push(B),g(L,v,B,N,T)},b=g(f,"unsortedSegmentSum",a,m,i),y=Je({inputs:{x:b},backend:n,attrs:{shape:h}});let x=y;if(l!=null){u.push(y);const w=Bo(l);x=js({inputs:{x},backend:n,attrs:{perm:w}})}return u.forEach(w=>n.disposeIntermediateTensorInfo(w)),x}const Mnt={kernelName:aI,backendName:"webgl",kernelFunc:Fnt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ont=[bXe,xXe,IXe,SXe,TXe,$Xe,_Xe,FXe,PXe,zXe,UXe,jXe,XXe,ZXe,nQe,sQe,iQe,cQe,hQe,fQe,yQe,SQe,TQe,RQe,DQe,BQe,WQe,HQe,eXe,KQe,ZQe,rYe,uYe,hYe,fYe,gYe,yYe,IYe,SYe,EYe,$Ye,_Ye,FYe,LYe,BYe,UYe,HYe,KYe,YYe,ZYe,rJe,oJe,dJe,fJe,bJe,yJe,wJe,IJe,CJe,NJe,EJe,_Je,MJe,PJe,zJe,UJe,jJe,QJe,eZe,ZKe,nZe,YQe,aZe,lZe,dZe,nXe,mZe,xZe,vZe,SZe,EZe,_Ze,MZe,BZe,UZe,jZe,KZe,JZe,e7e,n7e,i7e,l7e,c7e,h7e,f7e,y7e,I7e,N7e,F7e,aXe,P7e,W7e,G7e,q7e,MQe,Q7e,J7e,eet,ret,oet,sXe,cet,het,fet,get,bet,OQe,$7e,wet,Cet,Aet,oXe,Det,Oet,zet,Uet,qet,Xet,Jet,ttt,stt,ott,ctt,ptt,btt,wtt,Ctt,Ttt,kQe,_7e,$tt,_tt,Ftt,Ott,Ptt,ztt,Vtt,Gtt,jtt,Xtt,Ytt,Ztt,tnt,snt,int,lnt,cnt,R7e,fXe,pnt,gnt,ynt,vnt,Snt,Ent,mXe,$nt,_nt,Mnt,Y7e];for(const e of Ont)AE(e);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var bn;(function(e){e[e.float32=0]="float32",e[e.int32=1]="int32",e[e.bool=2]="bool",e[e.string=3]="string",e[e.complex64=4]="complex64"})(bn||(bn={}));var Wy;(function(e){e[e.linear=0]="linear",e[e.relu=1]="relu",e[e.relu6=2]="relu6",e[e.prelu=3]="prelu",e[e.leakyrelu=4]="leakyrelu",e[e.sigmoid=5]="sigmoid",e[e.elu=6]="elu"})(Wy||(Wy={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Dj;function Lnt(e){Dj=e.wasm.cwrap(Zp,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])}function Pnt(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:o}=t;if(s.dtype!=="float32"||a.dtype!=="float32")throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");const{transposeA:u,transposeB:c,activation:l,leakyreluAlpha:d}=r,h=n.dataIdMap.get(s.dataId).id,p=n.dataIdMap.get(a.dataId).id;let f=0;if(i!=null){const T=n.dataIdMap.get(i.dataId);if(T.shape.length!==1)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${T.shape.length}.`);f=T.id}const m=o==null?0:n.dataIdMap.get(o.dataId).id,g=Wy[l];if(g==null)throw new Error(`${l} activation not yet supported for FusedConv2D in the wasm backend.`);const b=u?s.shape[2]:s.shape[1],y=c?a.shape[1]:a.shape[2],x=Ot(s.shape.slice(0,-2),a.shape.slice(0,-2)),w=n.makeOutput([...x,b,y],s.dtype),v=n.dataIdMap.get(w.dataId).id,I=new Uint8Array(new Int32Array(s.shape).buffer),N=new Uint8Array(new Int32Array(a.shape).buffer);return Dj(h,I,s.shape.length,p,N,a.shape.length,u,c,g,f,m,d||0,v),w}const Bnt={kernelName:Zp,backendName:"wasm",setupFunc:Lnt,kernelFunc:Pnt};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ln(e,t){let n;function r(a){n=a.wasm.cwrap(e,null,["number","number","number"])}function s(a){const{backend:i,inputs:{x:o}}=a,u=i.dataIdMap.get(o.dataId).id,c=i.makeOutput(o.shape,t||o.dtype),l=i.dataIdMap.get(c.dataId).id;return fe(c.shape)===0||n(u,bn[o.dtype],l),c}return{kernelName:e,backendName:"wasm",setupFunc:r,kernelFunc:s}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const znt=ln(X0);/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wnt=ln(Lm);/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vnt=ln(Pm);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lr(e,t,n){let r;function s(i){r=i.wasm.cwrap(e,null,["number","array","number","number","array","number","number","number"])}function a(i){const{backend:o,inputs:u}=i,{a:c,b:l}=u,d=o.dataIdMap.get(c.dataId).id,h=o.dataIdMap.get(l.dataId).id,p=n??c.dtype,f=Ot(c.shape,l.shape),m=o.makeOutput(f,p);if(fe(f)===0)return m;const g=new Uint8Array(new Int32Array(c.shape).buffer),b=new Uint8Array(new Int32Array(l.shape).buffer),y=o.dataIdMap.get(m.dataId).id;return r(d,g,c.shape.length,h,b,l.shape.length,bn[c.dtype],y),m}return{kernelName:e,backendName:"wasm",setupFunc:s,kernelFunc:a}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Unt=Lr(Xh);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Fj;function Gnt(e){Fj=e.wasm.cwrap(Q0,null,["array","number","number","number"])}function Hnt(e){const{inputs:t,backend:n}=e,r=n.makeOutput(t[0].shape,t[0].dtype);if(fe(r.shape)===0)return r;const s=t.map(o=>n.dataIdMap.get(o.dataId).id),a=new Uint8Array(new Int32Array(s).buffer),i=n.dataIdMap.get(r.dataId).id;return Fj(a,s.length,bn[r.dtype],i),r}const jnt={kernelName:Q0,backendName:"wasm",setupFunc:Gnt,kernelFunc:Hnt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qI(e){const{inputs:{x:t},backend:n}=e;if(t.dtype==="string")return RE(n.readSync(t.dataId),t.shape,t.dtype);const r=n.makeOutput(t.shape,t.dtype),s=n.typedArrayFromHeap(t);return n.typedArrayFromHeap(r).set(s),r}const qnt={kernelName:dg,backendName:"wasm",kernelFunc:qI};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Mj;function Knt(e){Mj=e.wasm.cwrap(Gl,null,["number","array","number","number","number","array","number"])}function gu(e){const{inputs:t,backend:n,attrs:r}=e,[s,a]=Qnt(t.x.shape,r.perm);let i=!0;for(let f=0;f<a.length;f++)a[f]!==f&&(i=!1);const o=Xnt(t.x.shape,r.perm),u={dataId:t.x.dataId,shape:s,dtype:t.x.dtype};if(i){const f=qI({inputs:t,backend:n});return f.shape=o,f}const c=n.makeOutput(o,u.dtype),l=n.dataIdMap.get(u.dataId).id,d=n.dataIdMap.get(c.dataId).id,h=new Uint8Array(new Int32Array(a).buffer),p=new Uint8Array(new Int32Array(u.shape).buffer);return Mj(l,p,u.shape.length,bn[u.dtype],d,h,a.length),c}function Xnt(e,t){const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];return n}function Qnt(e,t){const n=[],r=[];for(let s=0;s<e.length;++s)e[s]!==1&&n.push(e[s]),e[t[s]]!==1&&r.push(t[s]);for(let s=0;s<r.length;++s){let a=-1;for(let i=0;i<r.length;++i)r[i]>=s&&(a===-1||r[a]>r[i])&&(a=i);r[a]=s}return[n,r]}const Ynt={kernelName:Gl,backendName:"wasm",kernelFunc:gu,setupFunc:Knt};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uu(e,t,n){const r=e.shape,s=e.shape.length,a=zt(t,r);let i=a;const o=nr(i,s);let u=null,c=!1;if(o!=null){const l=new Array(s);for(let p=0;p<l.length;p++)l[p]=r[o[p]];i=qn(i.length,s),u=gu({inputs:{x:e},attrs:{perm:o},backend:n});const d=n.dataIdMap.get(e.dataId).id;n.dataIdMap.get(u.dataId).id!==d&&(c=!0)}return{transposed:u,originalAxes:a,axes:i,inputWasTransposed:c}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Oj;function Jnt(e){Oj=e.wasm.cwrap(Y0,null,["number, number, number"])}function Znt(e){const{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:a}=r,{x:i}=n;let u=t.dataIdMap.get(i.dataId).id,c=i;const{transposed:l,axes:d,originalAxes:h,inputWasTransposed:p}=Uu(i,s,t);if(p){const x=t.dataIdMap.get(l.dataId).id;c=l,u=x}const f=c.shape.length;tr("all",d,f);const[m,g]=sr(c.shape,d),b=fe(g),y=t.makeOutput(m,i.dtype);if(fe(c.shape)!==0){const x=t.dataIdMap.get(y.dataId).id;Oj(u,b,x)}if(p&&t.disposeData(l.dataId),a){const x=jn(y.shape,h);y.shape=x}return y}const ert={kernelName:Y0,backendName:"wasm",setupFunc:Jnt,kernelFunc:Znt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Lj;function trt(e){Lj=e.wasm.cwrap(J0,null,["number, number, number"])}function nrt(e){const{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:a}=r,{x:i}=n;let u=t.dataIdMap.get(i.dataId).id,c=i;const{transposed:l,axes:d,originalAxes:h,inputWasTransposed:p}=Uu(i,s,t);if(p){const x=t.dataIdMap.get(l.dataId).id;c=l,u=x}const f=c.shape.length;tr("any",d,f);const[m,g]=sr(c.shape,d),b=fe(g),y=t.makeOutput(m,i.dtype);if(fe(c.shape)!==0){const x=t.dataIdMap.get(y.dataId).id;Lj(u,b,x)}if(p&&t.disposeData(l.dataId),a){const x=jn(y.shape,h);y.shape=x}return y}const rrt={kernelName:J0,backendName:"wasm",setupFunc:trt,kernelFunc:nrt};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pj(e){let t;function n(s){t=s.wasm.cwrap(e,null,["number","number","number","number","number"])}function r(s){const{backend:a,inputs:i,attrs:o}=s,{axis:u}=o,{x:c}=i,l=a.dataIdMap.get(c.dataId).id;let d=l,h=c;const{transposed:p,axes:f,inputWasTransposed:m}=Uu(c,u,a);if(m){const v=a.dataIdMap.get(p.dataId).id;v!==l&&(h=p,d=v)}const g=h.shape.slice(0,-1),b=a.makeOutput(g,"int32"),y=a.dataIdMap.get(b.dataId).id,x=fe(b.shape),w=h.shape[f[0]];return t(d,bn[h.dtype],x,w,y),m&&a.disposeData(p.dataId),b}return{kernelName:e,backendName:"wasm",setupFunc:n,kernelFunc:r}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const srt=Pj(Z0);/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const art=Pj(e1);/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const irt=ln(Bm);/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ort=ln(zm);/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lrt=ln(Wm);/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const urt=Lr(Um);/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const crt=ln(Vm);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Bj;function drt(e){Bj=e.wasm.cwrap(Gm,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function hrt(e){const{inputs:t,attrs:n,backend:r}=e,s=t.x,a=r.dataIdMap.get(s.dataId).id,{filterSize:i,strides:o,pad:u,dimRoundingMode:c}=n,l=Es(s.shape,i,o,1,u,c),d=l.filterHeight,h=l.filterWidth,p=l.padInfo.top,f=l.padInfo.right,m=l.padInfo.bottom,g=l.padInfo.left,b=l.strideHeight,y=l.strideWidth,x=l.inChannels;if(l.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${l.dataFormat}'. Please use 'channelsLast'.`);if(l.dilationWidth!==1||l.dilationHeight!==1)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${l.dilationHeight}, ${l.dilationWidth}].`);const w=r.makeOutput(l.outShape,"float32"),v=r.dataIdMap.get(w.dataId).id;return Bj(a,s.shape[0],s.shape[1],s.shape[2],d,h,p,f,m,g,b,y,x,v),w}const prt={kernelName:Gm,backendName:"wasm",setupFunc:drt,kernelFunc:hrt};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let zj;function frt(e){zj=e.wasm.cwrap("AvgPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function mrt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:u,dataFormat:c}=r,l=Qa(s.shape,a,i,1,o,u,c),d=n.makeOutput(l.outShape,s.dtype);return zj(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(d.dataId).id,l.batchSize,l.inChannels,l.inDepth,l.inHeight,l.inWidth,l.outDepth,l.outHeight,l.outWidth,l.strideDepth,l.strideHeight,l.strideWidth,l.dilationDepth,l.dilationHeight,l.dilationWidth,l.effectiveFilterDepth,l.effectiveFilterHeight,l.effectiveFilterWidth,l.padInfo.front,l.padInfo.top,l.padInfo.left),d}const grt={kernelName:t1,backendName:"wasm",setupFunc:frt,kernelFunc:mrt};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Wj;function brt(e){Wj=e.wasm.cwrap("AvgPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function yrt(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:u,dimRoundingMode:c}=r,l=Qa(a.shape,i,o,1,u,c),d=n.makeOutput(a.shape,a.dtype);return Wj(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(d.dataId).id,l.batchSize,l.inChannels,l.inDepth,l.inHeight,l.inWidth,l.outDepth,l.outHeight,l.outWidth,l.strideDepth,l.strideHeight,l.strideWidth,l.dilationDepth,l.dilationHeight,l.dilationWidth,l.effectiveFilterDepth,l.effectiveFilterHeight,l.effectiveFilterWidth,l.padInfo.front,l.padInfo.top,l.padInfo.left,l.filterDepth,l.filterHeight,l.filterWidth),d}const xrt={kernelName:Wv,backendName:"wasm",setupFunc:brt,kernelFunc:yrt};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Vj;function wrt(e){Vj=e.wasm.cwrap("AvgPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function vrt(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:u}=r,c=Es(a.shape,i,o,1,u),l=n.makeOutput(a.shape,a.dtype);return Vj(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(l.dataId).id,c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.top,c.padInfo.left,c.filterHeight,c.filterWidth),l}const Irt={kernelName:zv,backendName:"wasm",setupFunc:wrt,kernelFunc:vrt};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oa(e){const{inputs:t,attrs:n}=e,{x:r}=t,{shape:s}=n,a=fe(r.shape),i=iE(s,a);return U(a===fe(i),()=>`new shape: ${i}, old shape: ${r.shape}. New shape and old shape must have the same number of elements.`),e.backend.incRef(r.dataId),{dataId:r.dataId,shape:i,dtype:r.dtype}}const krt={kernelName:$1,backendName:"wasm",kernelFunc:oa};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Uj;function Crt(e){Uj=e.wasm.cwrap(Hm,null,["number","array","number","number","array","number","number","number","number"])}function Srt(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:o}=r;if(s.dtype!=="float32"||a.dtype!=="float32")throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");const u=s.shape.length,c=a.shape.length,l=i?s.shape[u-2]:s.shape[u-1],d=o?a.shape[c-1]:a.shape[c-2],h=i?s.shape[u-1]:s.shape[u-2],p=o?a.shape[c-2]:a.shape[c-1],f=s.shape.slice(0,-2),m=a.shape.slice(0,-2),g=fe(f),b=fe(m),x=Ot(s.shape.slice(0,-2),a.shape.slice(0,-2)).concat([h,p]);U(l===d,()=>`Error in matMul: inner shapes (${l}) and (${d}) of Tensors with shapes ${s.shape} and ${a.shape} and transposeA=${i} and transposeB=${o} must match.`);const w=i?[g,l,h]:[g,h,l],v=o?[b,p,d]:[b,d,p],I=oa({inputs:{x:s},backend:n,attrs:{shape:w}}),N=oa({inputs:{x:a},backend:n,attrs:{shape:v}}),T=n.dataIdMap.get(I.dataId).id,E=n.dataIdMap.get(N.dataId).id,A=i?I.shape[2]:I.shape[1],k=o?N.shape[1]:N.shape[2],C=Math.max(g,b),M=n.makeOutput([C,A,k],I.dtype),L=n.dataIdMap.get(M.dataId).id,O=new Uint8Array(new Int32Array(I.shape).buffer),B=new Uint8Array(new Int32Array(N.shape).buffer);return Uj(T,O,I.shape.length,E,B,N.shape.length,i,o,L),n.disposeData(I.dataId),n.disposeData(N.dataId),M.shape=x,M}const Nrt={kernelName:Hm,backendName:"wasm",setupFunc:Crt,kernelFunc:Srt};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gd(e){const{inputs:{x:t},attrs:{begin:n,size:r},backend:s}=e,[a,i]=q1(t,n,r),o=yI(t.shape,a,i),u=s.readSync(t.dataId),c=s.makeOutput(i,t.dtype),l=ot(t.shape),d=s.dataIdMap.get(c.dataId);if(o){const f=xI(a,l);return t.dtype==="string"?d.stringBytes=u.slice(f,f+fe(i)):s.typedArrayFromHeap(c).set(u.subarray(f,f+fe(i))),c}if(t.dtype==="string"){const f=Zx(u,a,i,t.shape,t.dtype);return d.stringBytes=f,c}const h=s.typedArrayFromHeap(c),p=t.shape.length;if(p===2)Trt(u,l[0],h,a,i);else if(p===3)Ert(u,l[0],l[1],h,a,i);else if(p===4)Art(u,l[0],l[1],l[2],h,a,i);else{const f=Zx(u,a,i,t.shape,t.dtype);h.set(f)}return c}function Trt(e,t,n,r,s){let a=0;const i=r[0],o=r[1],u=i+s[0];for(let c=i;c<u;c++){const l=c*t+o;n.set(e.subarray(l,l+s[1]),a),a+=s[1]}}function Ert(e,t,n,r,s,a){let i=0;const o=s[0],u=s[1],c=s[2],l=o+a[0],d=u+a[1];for(let h=o;h<l;h++)for(let p=u;p<d;p++){const f=h*t+p*n+c;r.set(e.subarray(f,f+a[2]),i),i+=a[2]}}function Art(e,t,n,r,s,a,i){let o=0;const u=a[0],c=a[1],l=a[2],d=u+i[0],h=c+i[1],p=l+i[2],f=a[3];for(let m=u;m<d;m++)for(let g=c;g<h;g++)for(let b=l;b<p;b++){const y=m*t+g*n+b*r+f;s.set(e.subarray(y,y+i[3]),o),o+=i[3]}}const $rt={kernelName:F1,backendName:"wasm",kernelFunc:gd};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rrt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:i}=r,o=a.reduce((b,y)=>b*y),u=np(s.shape,a,o),c=rp(u.length,a.length),l=sp(s.shape,a,o),d=CI(i,a.length),h=SI(l,i,a.length),p=oa({inputs:{x:s},backend:n,attrs:{shape:u}}),f=gu({inputs:{x:p},backend:n,attrs:{perm:c}}),m=oa({inputs:{x:f},backend:n,attrs:{shape:l}}),g=gd({inputs:{x:m},backend:n,attrs:{begin:d,size:h}});return n.disposeData(p.dataId),n.disposeData(f.dataId),n.disposeData(m.dataId),g}const _rt={kernelName:n1,backendName:"wasm",kernelFunc:Rrt};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Gj;function Drt(e){Gj=e.wasm.cwrap(r1,null,["number","number","boolean","number","number","number"])}function Frt(e){const{backend:t,inputs:n,attrs:r}=e,{x:s,weights:a}=n,{size:i}=r,o=a.shape.reduce((d,h)=>d*h,1)!==0,u=s.shape.length===1?[i]:[s.shape[0],i],c=t.makeOutput(u,a.dtype);function l(d){return t.dataIdMap.get(d.dataId).id}return Gj(l(s),i,o,l(a),bn[a.dtype],l(c)),c}const Mrt={kernelName:r1,backendName:"wasm",setupFunc:Drt,kernelFunc:Frt};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ort=Lr(Vv);/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lrt(e){const{inputs:t,backend:n}=e,{s0:r,s1:s}=t,a=n.typedArrayFromHeap(r),i=n.typedArrayFromHeap(s),o=Ot(Array.from(a),Array.from(i));return n.makeOutput([o.length],"int32",void 0,new Int32Array(o))}const Prt={kernelName:cE,backendName:"wasm",kernelFunc:Lrt};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gu(e){const{inputs:{x:t},attrs:{dtype:n},backend:r}=e,s=r.makeOutput(t.shape,n),a=r.typedArrayFromHeap(t);return r.typedArrayFromHeap(s).set(a),s}const Brt={kernelName:jm,backendName:"wasm",kernelFunc:Gu};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zrt=ln(qm);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Hj;function Wrt(e){Hj=e.wasm.cwrap(Qh,null,["number","number","number","number"])}function Vrt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{clipValueMin:a,clipValueMax:i}=r,o=n.dataIdMap.get(s.dataId).id,u=n.makeOutput(s.shape,s.dtype),c=n.dataIdMap.get(u.dataId).id;return Hj(o,a,i,c),u}const Urt={kernelName:Qh,backendName:"wasm",setupFunc:Wrt,kernelFunc:Vrt};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jj(e){const{inputs:t,backend:n}=e,r=zt(e.attrs.axis,t[0].shape)[0],s=t.map(p=>p.shape);vI(s,r);let a=Ga(t.map(p=>p.shape),r);const i=t.filter(p=>fe(p.shape)>0);if(i.length===1)return qI({inputs:{x:i[0]},backend:n});const o=n.makeOutput(a,t[0].dtype);if(fe(a)===0)return o;if(i[0].dtype==="string"){const p=i.map(x=>{const v=[-1,fe(x.shape.slice(r))];return oa({inputs:{x},backend:n,attrs:{shape:v}})}),f=p.map(x=>({vals:n.readSync(x.dataId),shape:x.shape}));a=Ga(p.map(x=>x.shape),1);const m=p[0].shape[0]===1,g=i$(f,a,t[0].dtype,m),b=Ga(i.map(x=>x.shape),r);o.shape=b;const y=n.dataIdMap.get(o.dataId);return y.stringBytes=MA(g),p.forEach(x=>n.disposeData(x.dataId)),o}const u=fe(i[0].shape.slice(0,r));let c=0;const l=i.map(p=>{const f=fe(p.shape.slice(r));return c+=f,f}),d=i.map(p=>n.typedArrayFromHeap(p)),h=n.typedArrayFromHeap(o);for(let p=0;p<u;p++){let f=p*c;for(let m=0;m<d.length;m++){const g=l[m],b=p*g,y=d[m].subarray(b,b+g);h.set(y,f),f+=g}}return o}const Grt={kernelName:s1,backendName:"wasm",kernelFunc:jj};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let qj;function Hrt(e){qj=e.wasm.cwrap(Km,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function jrt(e){const{inputs:t,attrs:n,backend:r}=e,{x:s,filter:a}=t,i=r.dataIdMap.get(s.dataId).id,o=r.dataIdMap.get(a.dataId).id,{strides:u,dilations:c,pad:l,dimRoundingMode:d,dataFormat:h}=n,p=to(h),f=yr(s.shape,a.shape,u,c,l,d,!1,p),m=f.filterHeight,g=f.filterWidth,b=f.padInfo.top,y=f.padInfo.right,x=f.padInfo.bottom,w=f.padInfo.left,v=f.dilationHeight,I=f.dilationWidth,N=f.strideHeight,T=f.strideWidth,E=f.inChannels,A=f.outChannels,k=f.padInfo.type==="SAME"?1:0;if(f.dataFormat!=="channelsLast")throw new Error(`wasm backend Conv2D does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);const C=r.makeOutput(f.outShape,"float32"),M=r.dataIdMap.get(C.dataId).id;return qj(i,s.shape[0],s.shape[1],s.shape[2],o,m,g,b,y,x,w,k,v,I,N,T,E,A,M),C}const qrt={kernelName:Km,backendName:"wasm",setupFunc:Hrt,kernelFunc:jrt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Kj;function Krt(e){Kj=e.wasm.cwrap(Xm,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Xrt(e){const{backend:t,inputs:n,attrs:r}=e,{dy:s,filter:a}=n,{strides:i,pad:o,dataFormat:u,dimRoundingMode:c,inputShape:l}=r,d=1,h=to(u),p=yr(l,a.shape,i,d,o,c,!1,h),{batchSize:f,filterHeight:m,filterWidth:g,inChannels:b,inHeight:y,inWidth:x,outChannels:w,outHeight:v,outWidth:I,strideHeight:N,strideWidth:T}=p,E=m-1-p.padInfo.top,A=g-1-p.padInfo.left,k=p.dataFormat==="channelsLast",C=ot(p.inShape),M=ot(s.shape),[L,O,B]=ot(a.shape),G=C[0],z=k?C[1]:C[2],q=k?C[2]:1,Q=k?1:C[1],K=M[0],ee=k?M[1]:M[2],Y=k?M[2]:1,de=k?1:M[1],ue=t.makeOutput(p.inShape,"float32"),Ie=t.dataIdMap.get(ue.dataId).id,Ee=t.dataIdMap.get(s.dataId).id,ve=t.dataIdMap.get(a.dataId).id;return Kj(Ee,ve,f,m,g,y,x,b,v,I,w,N,T,E,A,L,O,B,G,z,q,Q,K,ee,Y,de,Ie),ue}const Qrt={kernelName:Xm,backendName:"wasm",setupFunc:Krt,kernelFunc:Xrt};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Xj;function Yrt(e){Xj=e.wasm.cwrap(Qm,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Jrt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:u}=r;if(s.dtype!=="float32")throw new Error(`Tensor x must have dtype float32, got ${s.dtype}`);if(a.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${a.dtype}`);const c=eo(s.shape,a.shape,i,u,o),l=n.makeOutput(c.outShape,s.dtype);return Xj(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(l.dataId).id,c.batchSize,c.inDepth,c.inHeight,c.inWidth,c.inChannels,c.outDepth,c.outHeight,c.outWidth,c.outChannels,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.filterDepth,c.filterHeight,c.filterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),l}const Zrt={kernelName:Qm,backendName:"wasm",setupFunc:Yrt,kernelFunc:Jrt};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Qj;function est(e){Qj=e.wasm.cwrap(a1,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function tst(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,filterShape:u}=r;if(s.dtype!=="float32")throw new Error(`Tensor dy must have dtype float32, got ${s.dtype}`);if(a.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${a.dtype}`);const c=eo(s.shape,u,i,1,o),l=n.makeOutput(c.filterShape,a.dtype);return Qj(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(l.dataId).id,c.batchSize,c.inDepth,c.inHeight,c.inWidth,c.inChannels,c.outDepth,c.outHeight,c.outWidth,c.outChannels,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.filterDepth,c.filterHeight,c.filterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),l}const nst={kernelName:a1,backendName:"wasm",setupFunc:est,kernelFunc:tst};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Yj;function rst(e){Yj=e.wasm.cwrap(i1,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function sst(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:i,strides:o,inputShape:u}=r;if(s.dtype!=="float32")throw new Error(`Tensor dy must have dtype float32, got ${s.dtype}`);if(a.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${a.dtype}`);const c=eo(u,a.shape,o,1,i),l=n.makeOutput(c.inShape,s.dtype);return Yj(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(l.dataId).id,c.batchSize,c.inDepth,c.inHeight,c.inWidth,c.inChannels,c.outDepth,c.outHeight,c.outWidth,c.outChannels,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.filterDepth,c.filterHeight,c.filterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),l}const ast={kernelName:i1,backendName:"wasm",setupFunc:rst,kernelFunc:sst};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ist=ln(Ym);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ost=ln(Jm);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var _S;(function(e){e[e.bilinear=0]="bilinear",e[e.nearest=1]="nearest"})(_S||(_S={}));let Jj;function lst(e){Jj=e.wasm.cwrap(l1,null,["number","number","number","number","array","number","number","number","number","number"])}function ust(e){const{backend:t,inputs:n,attrs:r}=e,{method:s,extrapolationValue:a,cropSize:i}=r,{image:o,boxes:u,boxInd:c}=n,l=u.shape[0],[d,h]=i,p=[l,d,h,o.shape[3]];let f=t.dataIdMap.get(o.dataId),m;o.dtype!=="float32"&&(m=Gu({backend:t,inputs:{x:o},attrs:{dtype:"float32"}}),f=t.dataIdMap.get(m.dataId));const g=f.id,b=t.dataIdMap.get(u.dataId).id,y=t.dataIdMap.get(c.dataId).id,x=t.makeOutput(p,"float32"),w=t.dataIdMap.get(x.dataId).id,v=new Uint8Array(new Int32Array(o.shape).buffer);return Jj(g,b,y,l,v,d,h,_S[s],a,w),m!=null&&t.disposeData(m.dataId),x}const cst={kernelName:l1,backendName:"wasm",setupFunc:lst,kernelFunc:ust};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Zj;function dst(e){Zj=e.wasm.cwrap(o1,null,["number","number","number","number","number","number"])}function hst(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r,u=s.shape.length;U(s.dtype==="float32"||s.dtype==="int32",()=>`cumprod does not support ${s.dtype} tensors in the WASM backend`);const c=nr([a],u);let l=s;c!==null&&(l=gu({inputs:{x:s},attrs:{perm:c},backend:n}));const d=qn(1,u)[0];tr("cumprod",[d],u);const h=n.makeOutput(l.shape,l.dtype),p=l.shape[d],f=n.dataIdMap.get(l.dataId).id,m=n.dataIdMap.get(h.dataId).id;Zj(f,i?1:0,o?1:0,p,m,bn[s.dtype]);let g=h;if(c!==null){const b=Bo(c);g=gu({inputs:{x:h},attrs:{perm:b},backend:n}),n.disposeData(l.dataId),n.disposeData(h.dataId)}return g}const pst={kernelName:o1,backendName:"wasm",setupFunc:dst,kernelFunc:hst};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let eq;function fst(e){eq=e.wasm.cwrap(Zm,null,["number","number","number","number","number","number"])}function mst(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r,u=s.shape.length;U(s.dtype==="float32"||s.dtype==="int32",()=>`cumsum does not support ${s.dtype} tensors in the WASM backend`);const c=nr([a],u);let l=s;c!==null&&(l=gu({inputs:{x:s},attrs:{perm:c},backend:n}));const d=qn(1,u)[0];tr("cumsum",[d],u);const h=n.makeOutput(l.shape,l.dtype),p=l.shape[d],f=n.dataIdMap.get(l.dataId).id,m=n.dataIdMap.get(h.dataId).id;eq(f,i?1:0,o?1:0,p,m,bn[s.dtype]);let g=h;if(c!==null){const b=Bo(c);g=gu({inputs:{x:h},attrs:{perm:b},backend:n}),n.disposeData(l.dataId),n.disposeData(h.dataId)}return g}const gst={kernelName:Zm,backendName:"wasm",setupFunc:fst,kernelFunc:mst};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let tq;function bst(e){tq=e.wasm.cwrap("DenseBincount",null,["number","array","number","number","boolean","number","number","boolean","number"])}function yst(e){const{backend:t,inputs:n,attrs:r}=e,{x:s,weights:a}=n,{size:i,binaryOutput:o}=r,u=a.shape.reduce((h,p)=>h*p,1)!==0,c=s.shape.length===1?[i]:[s.shape[0],i],l=t.makeOutput(c,a.dtype);function d(h){return t.dataIdMap.get(h.dataId).id}return tq(d(s),new Uint8Array(new Int32Array(s.shape).buffer),s.shape.length,i,u,d(a),bn[a.dtype],o,d(l)),l}const xst={kernelName:Gv,backendName:"wasm",setupFunc:bst,kernelFunc:yst};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let nq;function wst(e){nq=e.wasm.cwrap(u1,null,["number","number","number","array","number","array","array","number","number"])}function vst(e){const{backend:t,inputs:n,attrs:r}=e,{x:s}=n,{blockSize:a,dataFormat:i}=r,o=s.shape[0],u=i==="NHWC"?s.shape[1]:s.shape[2],c=i==="NHWC"?s.shape[2]:s.shape[3],l=i==="NHWC"?s.shape[3]:s.shape[1],d=u*a,h=c*a,p=l/(a*a),f=i==="NHWC"?[o,d,h,p]:[o,p,d,h],m=t.makeOutput(f,"float32"),b=t.dataIdMap.get(s.dataId).id,y=new Uint8Array(new Int32Array(ot(s.shape)).buffer),x=new Uint8Array(new Int32Array(f).buffer),w=new Uint8Array(new Int32Array(ot(f)).buffer),v=t.dataIdMap.get(m.dataId).id;return nq(b,a,i==="NHWC"?1:0,y,s.shape.length-1,x,w,f.length,v),m}const Ist={kernelName:u1,backendName:"wasm",setupFunc:wst,kernelFunc:vst};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let rq;function kst(e){rq=e.wasm.cwrap(eg,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Cst(e){const{inputs:t,attrs:n,backend:r}=e,{x:s,filter:a}=t,i=r.dataIdMap.get(s.dataId).id,o=r.dataIdMap.get(a.dataId).id,{strides:u,dilations:c,pad:l,dimRoundingMode:d}=n,h=c??[1,1],p=yr(s.shape,a.shape,u,h,l,d,!0),f=p.filterHeight,m=p.filterWidth,g=p.padInfo.top,b=p.padInfo.right,y=p.padInfo.bottom,x=p.padInfo.left,w=p.dilationHeight,v=p.dilationWidth,I=p.strideHeight,N=p.strideWidth,T=p.inChannels,E=p.outChannels,A=p.padInfo.type==="SAME"?1:0;if(p.dataFormat!=="channelsLast")throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${p.dataFormat}'. Please use 'channelsLast'.`);const k=r.makeOutput(p.outShape,"float32"),C=r.dataIdMap.get(k.dataId).id;return rq(i,s.shape[0],s.shape[1],s.shape[2],o,f,m,g,b,y,x,A,w,v,I,N,T,E,C),k}const Sst={kernelName:eg,backendName:"wasm",setupFunc:kst,kernelFunc:Cst};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let sq;function Nst(e){sq=e.wasm.cwrap("Diag",null,["number","number","number","number"])}function Tst(e){const{inputs:t,backend:n}=e,{x:r}=t,s=fe(r.shape),a=n.makeOutput([...r.shape,...r.shape],r.dtype);return sq(n.dataIdMap.get(r.dataId).id,bn[r.dtype],s,n.dataIdMap.get(a.dataId).id),a}const Est={kernelName:mE,backendName:"wasm",setupFunc:Nst,kernelFunc:Tst};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let aq;function Ast(e){aq=e.wasm.cwrap(tg,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function $st(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:u}=r;if(s.dtype!==a.dtype)throw new Error(`Dilation2D error: x must have the same dtype as filter. Got ${s.dtype} and ${a.dtype}`);const c=Ou(s.shape,a.shape,i,o,"NHWC",u),l=n.makeOutput(c.outShape,s.dtype);return aq(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(l.dataId).id,bn[s.dtype],c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.filterHeight,c.filterWidth,c.padInfo.top,c.padInfo.left),l}const Rst={kernelName:tg,backendName:"wasm",setupFunc:Ast,kernelFunc:$st};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let iq;function _st(e){iq=e.wasm.cwrap(Ny,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Dst(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,dy:i}=t,{strides:o,pad:u,dilations:c}=r;if(s.dtype!==a.dtype||s.dtype!==i.dtype)throw new Error(`Dilation2DBackpropFilter error: x must have the same dtype as filter and dy. Got ${s.dtype}, ${a.dtype}, and ${i.dtype}`);const l=Ou(s.shape,a.shape,o,u,"NHWC",c),d=n.makeOutput(a.shape,a.dtype);return iq(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,bn[s.dtype],l.batchSize,l.inChannels,l.inHeight,l.inWidth,l.outHeight,l.outWidth,l.strideHeight,l.strideWidth,l.dilationHeight,l.dilationWidth,l.filterHeight,l.filterWidth,l.padInfo.top,l.padInfo.left),d}const Fst={kernelName:Ny,backendName:"wasm",setupFunc:_st,kernelFunc:Dst};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let oq;function Mst(e){oq=e.wasm.cwrap(Sy,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Ost(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,dy:i}=t,{strides:o,pad:u,dilations:c}=r;if(s.dtype!==a.dtype||s.dtype!==i.dtype)throw new Error(`Dilation2DBackpropInput error: x must have the same dtype as filter and dy. Got ${s.dtype}, ${a.dtype}, and ${i.dtype}`);const l=Ou(s.shape,a.shape,o,u,"NHWC",c),d=n.makeOutput(s.shape,s.dtype);return oq(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,bn[s.dtype],l.batchSize,l.inChannels,l.inHeight,l.inWidth,l.outHeight,l.outWidth,l.strideHeight,l.strideWidth,l.dilationHeight,l.dilationWidth,l.filterHeight,l.filterWidth,l.padInfo.top,l.padInfo.left),d}const Lst={kernelName:Sy,backendName:"wasm",setupFunc:Mst,kernelFunc:Ost};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pst=ln(rg);/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let lq;function Bst(e){lq=e.wasm.cwrap(c1,null,["number","number","number"])}function zst(e){const{inputs:t,backend:n}=e,{dy:r,y:s}=t,a=n.makeOutput(s.shape,"float32"),i=o=>n.dataIdMap.get(o.dataId).id;return lq(i(s),i(r),i(a)),a}const Wst={kernelName:c1,backendName:"wasm",setupFunc:Bst,kernelFunc:zst};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vst=!1,Ust=Lr(d1,Vst,"bool");/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gst=ln(sg);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hst=ln(ag,"float32");/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DS(e){const{inputs:t,attrs:n,backend:r}=e,{input:s}=t,{dim:a}=n,i=s.shape.length,o=s.shape.slice();let u=a;return a<0&&(U(-(i+1)<=a,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+a+1),o.splice(u,0,1),oa({inputs:{x:s},backend:r,attrs:{shape:o}})}const jst={kernelName:h1,backendName:"wasm",kernelFunc:DS};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qst=ln(ig,"float32");/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uq(e){const{attrs:{shape:t,value:n},backend:r}=e;let{attrs:{dtype:s}}=e;s=s||Kh(n);const a=r.makeOutput(t,s);return r.typedArrayFromHeap(a).fill(n),a}const Kst={kernelName:Hv,backendName:"wasm",kernelFunc:uq};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let cq;function Xst(e){cq=e.wasm.cwrap(p1,null,["number","number","number","number","number","number"])}function Qst(e){const{inputs:t,backend:n}=e,{image:r}=t,s=n.makeOutput(r.shape,r.dtype),a=n.dataIdMap.get(r.dataId).id,i=n.dataIdMap.get(s.dataId).id,[o,u,c,l]=r.shape;return cq(a,o,u,c,l,i),s}const Yst={kernelName:p1,backendName:"wasm",kernelFunc:Qst,setupFunc:Xst};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jst=ln(og);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zst=Lr(lg);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let dq;function eat(e){dq=e.wasm.cwrap(ug,null,["number","number","number","number","number","number","number"])}function tat(e){const{backend:t,inputs:n,attrs:r}=e,{varianceEpsilon:s}=r,{x:a,mean:i,variance:o,offset:u,scale:c}=n,l=t.dataIdMap.get(a.dataId).id,d=t.dataIdMap.get(i.dataId).id,h=t.dataIdMap.get(o.dataId).id,p=u!=null?t.dataIdMap.get(u.dataId).id:0,f=c!=null?t.dataIdMap.get(c.dataId).id:0,m=t.makeOutput(a.shape,a.dtype);if(fe(a.shape)===0)return m;const g=t.dataIdMap.get(m.dataId).id;return dq(l,d,h,p,f,s,g),m}const nat={kernelName:ug,backendName:"wasm",setupFunc:eat,kernelFunc:tat};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let hq;function rat(e){hq=e.wasm.cwrap(ef,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function sat(e){const{inputs:t,attrs:n,backend:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:u,pad:c,dilations:l,dataFormat:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=n,m=yr(s.shape,a.shape,u,l,c,h),g=Wy[p];if(g==null)throw new Error(`${p} activation not yet supported for FusedConv2D in the wasm backend.`);const b=r.dataIdMap.get(s.dataId).id,y=r.dataIdMap.get(a.dataId).id,x=m.outChannels;let w=0;if(i!=null){const Y=r.dataIdMap.get(i.dataId);if(Y.shape.length!==1)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${Y.shape.length}.`);if(Y.shape[0]!==x)throw new Error(`FusedConv2D bias shape (${Y.shape}) does not match the number of output channels (${x})`);w=Y.id}const v=m.filterHeight,I=m.filterWidth,N=m.padInfo.top,T=m.padInfo.right,E=m.padInfo.bottom,A=m.padInfo.left,k=m.dilationHeight,C=m.dilationWidth,M=m.strideHeight,L=m.strideWidth,O=m.inChannels,B=m.padInfo.type==="SAME"?1:0,G=m.batchSize,z=m.inHeight,q=m.inWidth;if(d!=="NHWC")throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${d}'. Please use 'NHWC'.`);const Q=r.makeOutput(m.outShape,"float32"),K=r.dataIdMap.get(Q.dataId).id,ee=o==null?0:r.dataIdMap.get(o.dataId).id;return hq(b,G,z,q,y,v,I,w,N,T,E,A,B,k,C,M,L,O,x,g,ee,f||0,K),Q}const aat={kernelName:ef,backendName:"wasm",setupFunc:rat,kernelFunc:sat};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let pq;function iat(e){pq=e.wasm.cwrap(iI,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function oat(e){const{inputs:t,attrs:n,backend:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:u,pad:c,dilations:l,dataFormat:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=n,m=yr(s.shape,a.shape,u,l,c,h,!0),g=Wy[p];if(g==null)throw new Error(`${p} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);const b=r.dataIdMap.get(s.dataId).id,y=r.dataIdMap.get(a.dataId).id,x=m.outChannels;let w=0;if(i!=null){const Y=r.dataIdMap.get(i.dataId);if(Y.shape.length!==1)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${Y.shape.length}.`);if(Y.shape[0]!==x)throw new Error(`FusedDepthwiseConv2D bias shape (${Y.shape}) does not match the number of output channels (${x})`);w=Y.id}const v=m.filterHeight,I=m.filterWidth,N=m.padInfo.top,T=m.padInfo.right,E=m.padInfo.bottom,A=m.padInfo.left,k=m.dilationHeight,C=m.dilationWidth,M=m.strideHeight,L=m.strideWidth,O=m.inChannels,B=m.padInfo.type==="SAME"?1:0,G=m.batchSize,z=m.inHeight,q=m.inWidth;if(d!=="NHWC")throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${d}'. Please use 'NHWC'.`);const Q=r.makeOutput(m.outShape,"float32"),K=r.dataIdMap.get(Q.dataId).id,ee=o==null?0:r.dataIdMap.get(o.dataId).id;return pq(b,G,z,q,y,v,I,w,N,T,E,A,B,k,C,M,L,O,x,g,ee,f||0,K),Q}const lat={kernelName:iI,backendName:"wasm",setupFunc:iat,kernelFunc:oat};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let fq;function uat(e){fq=e.wasm.cwrap(jv,null,["number","number","number","number","number","number","array","number"])}function cat(e){const{backend:t,inputs:n}=e,{params:r,indices:s}=n,[a,i,o,u]=gI(r,s),c=t.makeOutput(a,r.dtype);if(i===0)return c;const l=s.shape,d=l[l.length-1],p=t.dataIdMap.get(r.dataId).id,m=t.dataIdMap.get(s.dataId).id,g=new Uint8Array(new Int32Array(u).buffer),b=t.dataIdMap.get(c.dataId).id;return fq(p,bn[r.dtype],m,i,d,o,g,b),c}const dat={kernelName:jv,backendName:"wasm",setupFunc:uat,kernelFunc:cat};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let mq;function hat(e){mq=e.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])}function pat(e){const{backend:t,inputs:n,attrs:r}=e,{x:s,indices:a}=n,{axis:i,batchDims:o}=r,u=zt(i,s.shape)[0],c=t.readSync(a.dataId),l=s.shape[u];for(let E=0;E<c.length;++E){const A=c[E];U(A<=l-1&&A>=0,()=>`GatherV2: the index value ${A} is not in [0, ${l-1}]`)}const d=AI(s,a,u,o),h=oa({inputs:{x:s},attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]},backend:t}),p=fe(a.shape),f=oa({inputs:{x:a},attrs:{shape:[d.batchSize,p/d.batchSize]},backend:t}),m=[d.batchSize,d.outerSize,p/d.batchSize,d.sliceSize],g=t.makeOutput(m,s.dtype);if(fe(s.shape)===0)return g;const b=h.shape.length-1,x=t.dataIdMap.get(h.dataId).id,v=t.dataIdMap.get(f.dataId).id,I=t.dataIdMap.get(g.dataId).id,N=new Uint8Array(new Int32Array(ot(h.shape)).buffer),T=new Uint8Array(new Int32Array(ot(m)).buffer);return mq(x,bn[s.dtype],N,b,v,d.batchSize,T,I),t.disposeData(h.dataId),t.disposeData(f.dataId),g.shape=d.outputShape,g}const fat={kernelName:f1,backendName:"wasm",setupFunc:hat,kernelFunc:pat};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mat=!1,gat=Lr(m1,mat,"bool");/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bat=!1,yat=Lr(cg,bat,"bool");/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xat=ln(hg,"bool");/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wat=ln(pg,"bool");/**
 * @license
 * Copyright 2022 The TensorFlow Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vat=ln(fg,"bool");/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let gq;function Iat(e){gq=e.wasm.cwrap(mg,null,["number","number","number","number"])}function kat(e){const{inputs:{x:t},attrs:{alpha:n},backend:r}=e,s=r.dataIdMap.get(t.dataId).id,a=r.makeOutput(t.shape,"float32");if(fe(t.shape)!==0){const i=r.dataIdMap.get(a.dataId).id;gq(s,bn[t.dtype],n,i)}return a}const Cat={kernelName:mg,backendName:"wasm",setupFunc:Iat,kernelFunc:kat};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sat=!1,Nat=Lr(g1,Sat,"bool");/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tat=!1,Eat=Lr(b1,Tat,"bool");/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let bq;function Aat(e){bq=e.wasm.cwrap(qv,null,["number","number","number","number"])}function $at(e){const{attrs:t,backend:n}=e,{start:r,stop:s,num:a}=t,i=Math.floor(a),o=n.makeOutput([i],"float32");return bq(n.dataIdMap.get(o.dataId).id,r,s,i),o}const Rat={kernelName:qv,backendName:"wasm",setupFunc:Aat,kernelFunc:$at};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _at=ln(gg);/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dat=ln(bg);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fat=!1,Mat=Lr(y1,Fat,"bool");/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oat=ln(x1);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lat=!1,Pat=Lr(w1,Lat,"bool");/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bat=!1,zat=Lr(J_e,Bat,"bool");/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let yq;function Wat(e){yq=e.wasm.cwrap(yg,null,["number","number","number","number","number","number","number"])}function Vat(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:i,alpha:o,beta:u}=r;if(s.dtype!=="float32")throw new Error("LRN error: x must have dtype float32");const c=n.makeOutput(s.shape,s.dtype);return yq(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(c.dataId).id,s.shape[3],a,i,o,u),c}const Uat={kernelName:yg,backendName:"wasm",setupFunc:Wat,kernelFunc:Vat};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let xq;function Gat(e){xq=e.wasm.cwrap(v1,null,["number","number","number","number","number","number","number","number","number"])}function Hat(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:i}=t,{depthRadius:o,bias:u,alpha:c,beta:l}=r;if(s.dtype!=="float32"||a.dtype!=="float32"||i.dtype!=="float32")throw new Error("LRNGrad error: x, y, and dy must have dtype float32");const d=n.makeOutput(s.shape,s.dtype);return xq(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,i.shape[3],o,u,c,l),d}const jat={kernelName:v1,backendName:"wasm",setupFunc:Gat,kernelFunc:Hat};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let wq;function qat(e){wq=e.wasm.cwrap(xg,null,["number","number","number","number"])}function Kat(e){const{backend:t,inputs:n,attrs:r}=e,{reductionIndices:s,keepDims:a}=r,{x:i}=n;let u=t.dataIdMap.get(i.dataId).id,c=i;const{transposed:l,axes:d,originalAxes:h,inputWasTransposed:p}=Uu(i,s,t);if(p){const x=t.dataIdMap.get(l.dataId).id;c=l,u=x}const f=c.shape.length;tr("max",d,f);const[m,g]=sr(c.shape,d),b=fe(g),y=t.makeOutput(m,i.dtype);if(fe(c.shape)!==0){const x=t.dataIdMap.get(y.dataId).id;wq(u,bn[i.dtype],b,x)}if(p&&t.disposeData(l.dataId),a){const x=jn(y.shape,h);y.shape=x}return y}const Xat={kernelName:xg,backendName:"wasm",setupFunc:qat,kernelFunc:Kat};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qat=Lr(wg);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let vq;function Yat(e){vq=e.wasm.cwrap(vg,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Jat(e){const{inputs:t,attrs:n,backend:r}=e,s=t.x,a=r.dataIdMap.get(s.dataId).id;U(s.dtype==="float32",()=>`Error in MaxPool: only float32 input is supported. Got ${s.dtype}.`);const{filterSize:i,strides:o,pad:u,dimRoundingMode:c}=n,l=Es(s.shape,i,o,1,u,c),d=l.filterHeight,h=l.filterWidth,p=l.padInfo.top,f=l.padInfo.right,m=l.padInfo.bottom,g=l.padInfo.left,b=l.dilationHeight,y=l.dilationWidth,x=l.strideHeight,w=l.strideWidth,v=l.inChannels,I=l.outChannels;if(l.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${l.dataFormat}'. Please use 'channelsLast'.`);const N=r.makeOutput(l.outShape,"float32"),T=r.dataIdMap.get(N.dataId).id;return vq(a,s.shape[0],s.shape[1],s.shape[2],d,h,p,f,m,g,b,y,x,w,v,I,T),N}const Zat={kernelName:vg,backendName:"wasm",setupFunc:Yat,kernelFunc:Jat};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Iq;function eit(e){Iq=e.wasm.cwrap("MaxPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function tit(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:u,dataFormat:c}=r,l=Qa(s.shape,a,i,1,o,u,c),d=n.makeOutput(l.outShape,s.dtype);return Iq(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(d.dataId).id,l.batchSize,l.inChannels,l.inDepth,l.inHeight,l.inWidth,l.outDepth,l.outHeight,l.outWidth,l.strideDepth,l.strideHeight,l.strideWidth,l.dilationDepth,l.dilationHeight,l.dilationWidth,l.effectiveFilterDepth,l.effectiveFilterHeight,l.effectiveFilterWidth,l.padInfo.front,l.padInfo.top,l.padInfo.left),d}const nit={kernelName:I1,backendName:"wasm",setupFunc:eit,kernelFunc:tit};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let kq;function rit(e){kq=e.wasm.cwrap("MaxPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function sit(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:u,dimRoundingMode:c}=r,l=Qa(a.shape,i,o,1,u,c),d=n.makeOutput(a.shape,a.dtype);return kq(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(d.dataId).id,l.batchSize,l.inChannels,l.inDepth,l.inHeight,l.inWidth,l.outDepth,l.outHeight,l.outWidth,l.strideDepth,l.strideHeight,l.strideWidth,l.dilationDepth,l.dilationHeight,l.dilationWidth,l.effectiveFilterDepth,l.effectiveFilterHeight,l.effectiveFilterWidth,l.padInfo.front,l.padInfo.top,l.padInfo.left),d}const ait={kernelName:Xv,backendName:"wasm",setupFunc:rit,kernelFunc:sit};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Cq;function iit(e){Cq=e.wasm.cwrap("MaxPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function oit(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:u,dimRoundingMode:c}=r,l=Es(a.shape,i,o,1,u,c),d=n.makeOutput(a.shape,a.dtype);return Cq(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(d.dataId).id,l.batchSize,l.inChannels,l.inHeight,l.inWidth,l.outHeight,l.outWidth,l.strideHeight,l.strideWidth,l.dilationHeight,l.dilationWidth,l.effectiveFilterHeight,l.effectiveFilterWidth,l.padInfo.top,l.padInfo.left),d}const lit={kernelName:Kv,backendName:"wasm",setupFunc:iit,kernelFunc:oit};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Sq;function uit(e){Sq=e.wasm.cwrap("MaxPoolWithArgmax",null,["number","number","number","number","boolean","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function cit(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,includeBatchInIndex:u}=r;U(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const c=[1,1];U(bs(i,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const l=Es(s.shape,a,i,[1,1],o),d=n.makeOutput(l.outShape,s.dtype),h=n.makeOutput(l.outShape,"int32");return Sq(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(d.dataId).id,n.dataIdMap.get(h.dataId).id,bn[s.dtype],u,l.batchSize,l.inChannels,l.inHeight,l.inWidth,l.outHeight,l.outWidth,l.strideHeight,l.strideWidth,l.dilationHeight,l.dilationWidth,l.effectiveFilterHeight,l.effectiveFilterWidth,l.padInfo.top,l.padInfo.left),[d,h]}const dit={kernelName:wE,backendName:"wasm",setupFunc:uit,kernelFunc:cit};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Nq;function hit(e){Nq=e.wasm.cwrap(Ig,null,["number, number, number"])}function pit(e){const{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:a}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id;let u=o,c=i;const{transposed:l,axes:d,originalAxes:h,inputWasTransposed:p}=Uu(i,s,t);let f=d;if(p){const w=t.dataIdMap.get(l.dataId).id;w!==o&&(c=l,u=w,f=qn(f.length,c.shape.length))}tr("mean",f,c.shape.length);const[m,g]=sr(c.shape,f),b=fe(g);let y=c;c.dtype!=="float32"&&(y=Gu({backend:t,inputs:{x:c},attrs:{dtype:"float32"}}),u=t.dataIdMap.get(y.dataId).id);const x=t.makeOutput(m,"float32");if(fe(c.shape)!==0){const w=t.dataIdMap.get(x.dataId).id;Nq(u,b,w)}if(p&&t.disposeData(l.dataId),a){const w=jn(x.shape,h);x.shape=w}return c.dtype!=="float32"&&t.disposeData(y.dataId),x}const fit={kernelName:Ig,backendName:"wasm",setupFunc:hit,kernelFunc:pit};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Tq;function mit(e){Tq=e.wasm.cwrap(kg,null,["number","number","number","number"])}function git(e){const{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:a}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id;let u=o,c=i;const{transposed:l,axes:d,originalAxes:h,inputWasTransposed:p}=Uu(i,s,t);if(p){const x=t.dataIdMap.get(l.dataId).id;x!==o&&(c=l,u=x)}const f=c.shape.length;tr("min",d,f);const[m,g]=sr(c.shape,d),b=fe(g),y=t.makeOutput(m,c.dtype);if(fe(c.shape)!==0){const x=t.dataIdMap.get(y.dataId).id;Tq(u,bn[i.dtype],b,x)}if(p&&t.disposeData(l.dataId),a){const x=jn(y.shape,h);y.shape=x}return y}const bit={kernelName:kg,backendName:"wasm",setupFunc:mit,kernelFunc:git};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yit=Lr(Cg);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var FS;(function(e){e[e.reflect=0]="reflect",e[e.symmetric=1]="symmetric"})(FS||(FS={}));let Eq;function xit(e){Eq=e.wasm.cwrap(Sg,null,["number","array","number","number","array","array","number","number"])}function wit(e){const{inputs:{x:t},backend:n,attrs:{paddings:r,mode:s}}=e,a=r.map((f,m)=>f[0]+t.shape[m]+f[1]),i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(a,t.dtype),u=n.dataIdMap.get(o.dataId).id,c=new Uint8Array(new Int32Array(t.shape).buffer),l=r.map(f=>f[0]),d=r.map(f=>f[1]),h=new Uint8Array(new Int32Array(l).buffer),p=new Uint8Array(new Int32Array(d).buffer);return Eq(i,c,t.shape.length,bn[t.dtype],h,p,FS[s],u),o}const vit={kernelName:Sg,backendName:"wasm",kernelFunc:wit,setupFunc:xit};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Aq;function Iit(e){Aq=e.wasm.cwrap(Xg,null,["number","number","number","number"])}function $q(e){const{backend:t,inputs:{logits:n},attrs:{dim:r}}=e,s=t.dataIdMap.get(n.dataId).id,a=t.makeOutput(n.shape,n.dtype),i=t.dataIdMap.get(a.dataId).id,o=n.shape[r],u=fe(n.shape)/o;return fe(a.shape)===0||Aq(s,i,o,u),a}const kit={kernelName:Xg,backendName:"wasm",setupFunc:Iit,kernelFunc:$q};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Rq;function Cit(e){Rq=e.wasm.cwrap(Qv,null,["number","number","number","number","number","number"])}function Sit(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:i,normalized:o}=r;if(s.dtype!=="float32")throw new Error(`Tensor logits must have dtype float32, got ${s.dtype}`);const u=o?s:$q({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),[c,l]=u.shape,d=n.makeOutput([c,a],"int32");return Rq(n.dataIdMap.get(u.dataId).id,c,l,a,i,n.dataIdMap.get(d.dataId).id),o||n.disposeData(u.dataId),d}const Nit={kernelName:Qv,backendName:"wasm",setupFunc:Cit,kernelFunc:Sit};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tit=Lr(Ng);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eit=Lr(Tg);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ait=ln(k1);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E$(e,t){const n=new Int32Array(e.wasm.HEAPU8.buffer,t,4),r=n[0],s=n[1],a=n[2],i=n[3];return e.wasm._free(t),{pSelectedIndices:r,selectedSize:s,pSelectedScores:a,pValidOutputs:i}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let _q;function $it(e){_q=e.wasm.cwrap(S1,"number",["number","number","number","number","number"])}function Rit(e){const{backend:t,inputs:n,attrs:r}=e,{iouThreshold:s,maxOutputSize:a,scoreThreshold:i}=r,{boxes:o,scores:u}=n,c=t.dataIdMap.get(o.dataId).id,l=t.dataIdMap.get(u.dataId).id,d=_q(c,l,a,s,i),{pSelectedIndices:h,selectedSize:p,pSelectedScores:f,pValidOutputs:m}=E$(t,d);return t.wasm._free(f),t.wasm._free(m),t.makeOutput([p],"int32",h)}const _it={kernelName:S1,backendName:"wasm",setupFunc:$it,kernelFunc:Rit};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Dq;function Dit(e){Dq=e.wasm.cwrap(N1,"number",["number","number","number","number","number","bool"])}function Fit(e){const{backend:t,inputs:n,attrs:r}=e,{iouThreshold:s,maxOutputSize:a,scoreThreshold:i,padToMaxOutputSize:o}=r,{boxes:u,scores:c}=n,l=t.dataIdMap.get(u.dataId).id,d=t.dataIdMap.get(c.dataId).id,h=Dq(l,d,a,s,i,o),{pSelectedIndices:p,selectedSize:f,pSelectedScores:m,pValidOutputs:g}=E$(t,h);t.wasm._free(m);const b=t.makeOutput([f],"int32",p),y=t.makeOutput([],"int32",g);return[b,y]}const Mit={kernelName:N1,backendName:"wasm",setupFunc:Dit,kernelFunc:Fit};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Fq;function Oit(e){Fq=e.wasm.cwrap(T1,"number",["number","number","number","number","number","number"])}function Lit(e){const{backend:t,inputs:n,attrs:r}=e,{iouThreshold:s,maxOutputSize:a,scoreThreshold:i,softNmsSigma:o}=r,{boxes:u,scores:c}=n,l=t.dataIdMap.get(u.dataId).id,d=t.dataIdMap.get(c.dataId).id,h=Fq(l,d,a,s,i,o),{pSelectedIndices:p,selectedSize:f,pSelectedScores:m,pValidOutputs:g}=E$(t,h);t.wasm._free(g);const b=t.makeOutput([f],"int32",p),y=t.makeOutput([f],"float32",m);return[b,y]}const Pit={kernelName:T1,backendName:"wasm",setupFunc:Oit,kernelFunc:Lit};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bit=!1,zit=Lr(C1,Bit,"bool");/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Mq;function Wit(e){Mq=e.wasm.cwrap(Eg,null,["number","number","number","number","number"])}function Vit(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{dtype:a,depth:i,onValue:o,offValue:u}=r,c=n.makeOutput([...s.shape,i],a),l=n.dataIdMap.get(c.dataId).id,h=n.dataIdMap.get(s.dataId).id;return Mq(h,i,o,u,l),c}const Uit={kernelName:Eg,backendName:"wasm",setupFunc:Wit,kernelFunc:Vit};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Git(e){const{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(1),r}const Hit={kernelName:E1,backendName:"wasm",kernelFunc:Git};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jit(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(t.length===1)return DS({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const a=t[0].shape,i=t[0].dtype;t.forEach(l=>{Bv(a,l.shape,"All tensors passed to stack must have matching shapes"),U(i===l.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],u=t.map(l=>{const d=DS({inputs:{input:l},backend:n,attrs:{dim:s}});return o.push(d),d}),c=jj({inputs:u,backend:n,attrs:{axis:s}});return o.forEach(l=>n.disposeData(l.dataId)),c}const qit={kernelName:A1,backendName:"wasm",kernelFunc:jit};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Oq;function Kit(e){Oq=e.wasm.cwrap(Ag,null,["number","array","number","number","array","array","number","number"])}function Xit(e){const{inputs:{x:t},backend:n,attrs:{paddings:r,constantValue:s}}=e,a=r.map((m,g)=>m[0]+t.shape[g]+m[1]);if(fe(t.shape)===0)return uq({backend:n,attrs:{shape:a,value:s,dtype:t.dtype}});const i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(a,t.dtype),c=n.dataIdMap.get(o.dataId).id,l=new Uint8Array(new Int32Array(t.shape).buffer),d=r.map(m=>m[0]),h=r.map(m=>m[1]),p=new Uint8Array(new Int32Array(d).buffer),f=new Uint8Array(new Int32Array(h).buffer);return Oq(i,l,t.shape.length,bn[t.dtype],p,f,s,c),o}const Lq={kernelName:Ag,backendName:"wasm",kernelFunc:Xit,setupFunc:Kit};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qit=Lr($g);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Pq;function Yit(e){Pq=e.wasm.cwrap(Rg,null,["number","number","number"])}function Jit(e){const{inputs:t,backend:n}=e,{x:r,alpha:s}=t,a=n.dataIdMap.get(r.dataId).id,i=n.dataIdMap.get(s.dataId).id;let o=a;const u=r;let c=u;u.dtype!=="float32"&&(c=Gu({backend:n,inputs:{x:r},attrs:{dtype:"float32"}}),o=n.dataIdMap.get(c.dataId).id);const l=n.makeOutput(r.shape,"float32"),d=n.dataIdMap.get(l.dataId).id;return Pq(o,i,d),u.dtype!=="float32"&&n.disposeData(c.dataId),l}const Zit={kernelName:Rg,backendName:"wasm",setupFunc:Yit,kernelFunc:Jit};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Bq;function eot(e){Bq=e.wasm.cwrap(_g,null,["number","number","number","number"])}function tot(e){const{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:a}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id;let u=o,c=i;const{transposed:l,axes:d,originalAxes:h,inputWasTransposed:p}=Uu(i,s,t);let f=d;if(p){const x=t.dataIdMap.get(l.dataId).id;x!==o&&(c=l,u=x,f=qn(f.length,c.shape.length))}tr("prod",f,c.shape.length);const[m,g]=sr(c.shape,f),b=fe(g),y=t.makeOutput(m,c.dtype);if(fe(c.shape)!==0){const x=t.dataIdMap.get(y.dataId).id;Bq(u,b,bn[y.dtype],x)}if(p&&t.disposeData(l.dataId),a){const x=jn(y.shape,h);y.shape=x}return y}const not={kernelName:_g,backendName:"wasm",setupFunc:eot,kernelFunc:tot};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rot=e=>{const{backend:t,attrs:n}=e,{start:r,stop:s,step:a,dtype:i}=n,o=u$(r,s,a,i),u=t.makeOutput([o.length],i);return t.typedArrayFromHeap(u).set(o),u},sot={kernelName:Yv,backendName:"wasm",kernelFunc:rot};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aot=Lr(ng);/**
 * @license
 * Copyright 2022 The TensorFlow Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iot=ln(Dg);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oot=ln(Fg);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lot=ln(Lg);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let zq;function uot(e){zq=e.wasm.cwrap(Og,null,["number","number","number","number","number","number","number","number","number","number"])}function cot(e){const{backend:t,inputs:n,attrs:r}=e,{images:s}=n,{alignCorners:a,halfPixelCenters:i,size:o}=r,[u,c]=o,[l,d,h,p]=s.shape,f=[l,u,c,p];let m=t.dataIdMap.get(s.dataId),g;m.dtype!=="float32"&&(g=Gu({backend:t,inputs:{x:s},attrs:{dtype:"float32"}}),m=t.dataIdMap.get(g.dataId));const b=m.id,y=t.makeOutput(f,"float32");if(fe(s.shape)===0)return y;const x=t.dataIdMap.get(y.dataId).id;return zq(b,l,d,h,p,u,c,a?1:0,i?1:0,x),g!=null&&t.disposeData(g.dataId),y}const dot={kernelName:Og,backendName:"wasm",setupFunc:uot,kernelFunc:cot};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Wq;function hot(e){Wq=e.wasm.cwrap(_1,null,["number","number","number","array","array","boolean"])}function pot(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=n.makeOutput(s.shape,"float32");let u=n.dataIdMap.get(s.dataId),c;return u.dtype!=="float32"&&(c=Gu({backend:n,inputs:{x:s},attrs:{dtype:"float32"}}),u=n.dataIdMap.get(c.dataId)),Wq(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(o.dataId).id,new Uint8Array(new Int32Array(s.shape).buffer),new Uint8Array(new Int32Array(a.shape).buffer),i),c!=null&&n.disposeData(c.dataId),o}const fot={kernelName:_1,backendName:"wasm",setupFunc:hot,kernelFunc:pot};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Vq;function mot(e){Vq=e.wasm.cwrap(Mg,null,["number","number","number","number","number","number","number","number","number","number"])}function got(e){const{backend:t,inputs:n,attrs:r}=e,{images:s}=n,{alignCorners:a,halfPixelCenters:i,size:o}=r,[u,c]=o,[l,d,h,p]=s.shape,f=[l,u,c,p],m=t.makeOutput(f,"float32");if(fe(s.shape)===0)return m;let g=t.dataIdMap.get(s.dataId),b;g.dtype!=="float32"&&(b=Gu({backend:t,inputs:{x:s},attrs:{dtype:"float32"}}),g=t.dataIdMap.get(b.dataId));const y=g.id,x=t.dataIdMap.get(m.dataId).id;return Vq(y,l,d,h,p,u,c,a?1:0,i?1:0,x),b!=null&&t.disposeData(b.dataId),m}const bot={kernelName:Mg,backendName:"wasm",setupFunc:mot,kernelFunc:got};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Uq;function yot(e){Uq=e.wasm.cwrap(R1,null,["number","number","number","array","array","boolean"])}function xot(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=n.makeOutput(s.shape,"float32");let u=n.dataIdMap.get(s.dataId),c;return u.dtype!=="float32"&&(c=Gu({backend:n,inputs:{x:s},attrs:{dtype:"float32"}}),u=n.dataIdMap.get(c.dataId)),Uq(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(o.dataId).id,new Uint8Array(new Int32Array(s.shape).buffer),new Uint8Array(new Int32Array(a.shape).buffer),i),c!=null&&n.disposeData(c.dataId),o}const wot={kernelName:R1,backendName:"wasm",setupFunc:yot,kernelFunc:xot};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Gq;function vot(e){Gq=e.wasm.cwrap(Pg,null,["number","array","number","array","number","number"])}function Iot(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r,i=zt(a,s.shape);if(s.shape.length===0)return qI({inputs:{x:s},backend:n});const o=n.makeOutput(s.shape,s.dtype),u=n.dataIdMap.get(s.dataId).id,c=n.dataIdMap.get(o.dataId).id,l=new Uint8Array(new Int32Array(i).buffer),d=new Uint8Array(new Int32Array(s.shape).buffer);Gq(u,l,i.length,d,s.shape.length,c);const h=oa({inputs:{x:o},attrs:{shape:s.shape},backend:n});return n.disposeData(o.dataId),h}const kot={kernelName:Pg,backendName:"wasm",kernelFunc:Iot,setupFunc:vot};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Hq;function Cot(e){Hq=e.wasm.cwrap(V1,null,["number","number","number","number","number","number","number","number","array","number","number"])}function Sot(e){const{inputs:t,backend:n,attrs:r}=e,{image:s}=t,{radians:a,fillValue:i,center:o}=r,u=n.makeOutput(s.shape,s.dtype),c=n.dataIdMap.get(s.dataId).id,l=n.dataIdMap.get(u.dataId).id,[d,h,p,f]=s.shape,[m,g]=kI(o,h,p),b=i===0,y=255,x=typeof i=="number"?[i,i,i,b?0:y]:[...i,y],w=new Uint8Array(new Int32Array(x).buffer);return Hq(c,d,h,p,f,a,m,g,w,x.length,l),u}const Not={kernelName:V1,backendName:"wasm",kernelFunc:Sot,setupFunc:Cot};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tot=ln(Bg);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eot=ln(zg);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let jq;function Aot(e){jq=e.wasm.cwrap(Jv,null,["number","number","number","number","number","number","array","number","number"])}function $ot(e){const{backend:t,inputs:n,attrs:r}=e,{indices:s,updates:a}=n,{shape:i}=r,o=t.makeOutput(i,a.dtype);if(fe(i)===0)return o;const{sliceRank:u,numUpdates:c,sliceSize:l,strides:d,outputSize:h}=zo(a,s,i),f=t.dataIdMap.get(s.dataId).id,g=t.dataIdMap.get(a.dataId).id,b=new Uint8Array(new Int32Array(d).buffer),y=t.dataIdMap.get(o.dataId).id;return jq(f,g,bn[a.dtype],u,c,l,b,h,y),o}const Rot={kernelName:Jv,backendName:"wasm",setupFunc:Aot,kernelFunc:$ot};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let qq;function _ot(e){qq=e.wasm.cwrap(eI,null,["number","number","number","number","number","number","bool","number"])}function Dot(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:s,values:a}=t,{side:i}=r;if(s.dtype!==a.dtype)throw new Error(`SearchSorted error: sorted_sequence must have the same dtype as values. Got ${s.dtype} and ${a.dtype}`);const o=n.makeOutput(a.shape,"int32");function u(c){return n.dataIdMap.get(c.dataId).id}return qq(u(s),u(a),s.shape[0],s.shape[1],a.shape[1],bn[s.dtype],i==="left",u(o)),o}const Fot={kernelName:eI,backendName:"wasm",setupFunc:_ot,kernelFunc:Dot};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Kq;function Mot(e){Kq=e.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}function Oot(e){const{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t,i=n.dataIdMap.get(r.dataId).id,o=n.dataIdMap.get(s.dataId).id,u=n.dataIdMap.get(a.dataId).id,c=n.makeOutput(s.shape,s.dtype),l=n.dataIdMap.get(c.dataId).id,d=r.shape.length,h=s.shape.length,p=d===0||d>1||h===1?1:fe(s.shape.slice(1));return Kq(i,o,u,p,l),c}const Lot={kernelName:D1,backendName:"wasm",kernelFunc:Oot,setupFunc:Mot};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pot=ln(Wg);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Xq;function Bot(e){Xq=e.wasm.cwrap(Hg,null,["number","number"])}function zot(e){const{backend:t,inputs:{x:n}}=e,r=t.dataIdMap.get(n.dataId).id,s=t.makeOutput(n.shape,n.dtype),a=t.dataIdMap.get(s.dataId).id;return fe(s.shape)===0||Xq(r,a),s}const Wot={kernelName:"Sigmoid",backendName:"wasm",setupFunc:Bot,kernelFunc:zot};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vot=ln(Gg);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uot=ln(Vg);/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Got=ln(Ug);/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hot=ln(jg);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jot(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:i}=r,o=fe(a),u=[[0,0]];u.push(...i);for(let I=1+a.length;I<s.shape.length;++I)u.push([0,0]);const c=Lq.kernelFunc({inputs:{x:s},backend:n,attrs:{paddings:u,constantValue:0}}),l=np(c.shape,a,o,!1),d=rp(l.length,a.length,!1),h=sp(c.shape,a,o,!1),m=oa({inputs:{x:c},backend:n,attrs:{shape:l}}),y=gu({inputs:{x:m},backend:n,attrs:{perm:d}}),v=oa({inputs:{x:y},backend:n,attrs:{shape:h}});return n.disposeData(c.dataId),n.disposeData(m.dataId),n.disposeData(y.dataId),v}const qot={kernelName:M1,backendName:"wasm",kernelFunc:jot};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Qq;function Kot(e){Qq=e.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])}function Xot(e){const{backend:t,inputs:n}=e,{indices:r,values:s,denseShape:a,defaultValue:i}=n,o=r.shape[0],u=r.shape[1],c=t.readSync(a.dataId)[0],l=[o+c,u],d=t.dataIdMap.get(r.dataId).id,h=t.dataIdMap.get(s.dataId).id,p=t.dataIdMap.get(i.dataId).id,f=t.makeOutput(l,r.dtype),m=t.dataIdMap.get(f.dataId).id,g=t.makeOutput(l.slice(0,1),s.dtype),b=t.dataIdMap.get(g.dataId).id,y=t.makeOutput([c],"bool"),x=t.dataIdMap.get(y.dataId).id,w=t.makeOutput([o],r.dtype),v=t.dataIdMap.get(w.dataId).id,I=t.makeOutput([4],"int32"),N=t.dataIdMap.get(I.dataId).id,T=Qq(d,h,bn[s.dtype],o,c,u,p,m,b,x,v,N),E=t.readSync(I.dataId);let A;switch(E[0]){case 1:{A=CA(E[1]);break}case 2:{A=SA(E[1],E[2]);break}case 3:A=NA(E[1],E[2],E[3]);break;default:A=""}if(t.disposeData(I.dataId),A)throw t.disposeData(f.dataId),t.disposeData(g.dataId),t.disposeData(y.dataId),t.disposeData(w.dataId),new Error(A);let k=f,C=g;return T!==l[0]&&(k=gd({inputs:{x:f},attrs:{begin:0,size:[T,u]},backend:t}),C=gd({inputs:{x:g},attrs:{begin:0,size:T},backend:t}),t.disposeData(f.dataId),t.disposeData(g.dataId)),[k,C,y,w]}const Qot={kernelName:IE,backendName:"wasm",setupFunc:Kot,kernelFunc:Xot};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Yq;function Yot(e){Yq=e.wasm.cwrap(tI,null,["number","number","number","number","number","number","number"])}function Jot(e){const{backend:t,inputs:n}=e,{inputIndices:r,inputShape:s,newShape:a}=n;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${s.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const i=t.dataIdMap.get(r.dataId).id,o=t.dataIdMap.get(s.dataId).id,u=t.dataIdMap.get(a.dataId).id,c=r.shape[0],l=fe(a.shape),d=t.makeOutput([c,l],r.dtype),h=t.dataIdMap.get(d.dataId).id,p=t.makeOutput([l],a.dtype),f=t.dataIdMap.get(p.dataId).id,m=t.makeOutput([3],"int32"),g=t.dataIdMap.get(m.dataId).id;Yq(i,o,u,c,h,f,g);const b=t.readSync(m.dataId);let y;switch(b[0]){case 0:{y=TA(b[1],b[2]);break}case 1:{y=EA(b[1],b[2]);break}case 2:y=AA();break;case 3:{const x=Array.from(t.readSync(s.dataId)),w=Array.from(t.readSync(p.dataId));y=$A(x,w);break}case 4:{const x=Array.from(t.readSync(s.dataId)),w=Array.from(t.readSync(p.dataId));y=RA(x,w);break}default:y=""}if(t.disposeData(m.dataId),y)throw t.disposeData(d.dataId),t.disposeData(p.dataId),new Error(y);return[d,p]}const Zot={kernelName:tI,backendName:"wasm",setupFunc:Yot,kernelFunc:Jot};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Jq;function Zq(e){Jq=e.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function eK(e,t){const{backend:n,inputs:r}=e,{data:s,indices:a,segmentIds:i}=r,o=a.shape[0],u=n.readSync(i.dataId,o-1,o)[0],l=o>0?u+1:0;if(l<0)throw new Error(_y());const d=s.shape.slice();d[0]=l;const h=n.dataIdMap.get(s.dataId).id,p=n.dataIdMap.get(a.dataId).id,f=n.dataIdMap.get(i.dataId).id,m=n.makeOutput(d,s.dtype),g=n.dataIdMap.get(m.dataId).id,b=n.makeOutput([4],"int32"),y=n.dataIdMap.get(b.dataId).id;Jq(h,bn[s.dtype],s.shape[0],p,f,g,y,t,0);const x=n.readSync(b.dataId);let w;switch(x[0]){case 0:{w=_y();break}case 1:{w=_A();break}case 2:w=DA(x[1],x[2]);break;case 3:w=FA(x[1],x[2],x[3]);break;default:w=""}if(n.disposeData(b.dataId),w)throw n.disposeData(m.dataId),new Error(w);return m}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function elt(e){return eK(e,!0)}const tlt={kernelName:kE,backendName:"wasm",setupFunc:Zq,kernelFunc:elt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nlt(e){return eK(e,!1)}const rlt={kernelName:CE,backendName:"wasm",setupFunc:Zq,kernelFunc:nlt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let tK;function slt(e){tK=e.wasm.cwrap(nI,null,["number","number","number","number","number","number","number","number","array","number","number"])}function alt(e){const{backend:t,inputs:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:i}=n,{outputShape:o}=r,u=t.makeOutput(o,i.dtype);if(fe(o)===0)return u;const{sliceRank:c,numUpdates:l,sliceSize:d,strides:h,outputSize:p}=zo(a,s,o),f=t.dataIdMap.get(s.dataId).id,m=t.dataIdMap.get(a.dataId).id,g=t.dataIdMap.get(i.dataId).id,b=new Uint8Array(new Int32Array(h).buffer),y=t.dataIdMap.get(u.dataId).id;return tK(f,m,a.shape.length,g,bn[i.dtype],c,l,d,b,p,y),u}const ilt={kernelName:nI,backendName:"wasm",setupFunc:slt,kernelFunc:alt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function olt(e){const{inputs:t,attrs:n,backend:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:i}=n,o=zt(i,s.shape)[0],u=EI(s,a,o),c=new Array(s.shape.length).fill(0),l=s.shape.slice();return u.map(d=>{const h=[...l];h[o]=d;const p=gd({inputs:{x:s},attrs:{begin:c,size:h},backend:r});return c[o]+=d,p})}const llt={kernelName:O1,backendName:"wasm",kernelFunc:olt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ult=ln(qg);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const clt=ln(rI);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dlt=Lr(Qg);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let nK;function hlt(e){nK=e.wasm.cwrap(Jh,null,["number","number","number","number"])}function plt(e){const{backend:t,inputs:n,attrs:r}=e,{alpha:s}=r,{x:a}=n,i=t.dataIdMap.get(a.dataId).id,o=t.makeOutput(a.shape,a.dtype),u=t.dataIdMap.get(o.dataId).id;return nK(i,s,bn[a.dtype],u),o}const flt={kernelName:Jh,backendName:"wasm",setupFunc:hlt,kernelFunc:plt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let rK;function mlt(e){rK=e.wasm.cwrap(L1,null,["number","array","number","array","array","array","array","array","number","number"])}function glt(e){const{backend:t,inputs:n,attrs:r}=e,{x:s}=n,{begin:a,end:i,strides:o,beginMask:u,endMask:c,ellipsisMask:l,newAxisMask:d,shrinkAxisMask:h}=r,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:b,begin:y,end:x,strides:w}=wI(s.shape,a,i,o,u,c,l,d,h);let v;if(m)v=oa({inputs:{x:s},backend:t,attrs:{shape:f}});else if(g||b){U(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const I=bI(y,x,w),N=gd({inputs:{x:s},backend:t,attrs:{begin:y,size:I}});v=oa({inputs:{x:N},backend:t,attrs:{shape:f}}),t.disposeData(N.dataId)}else{const I=t.makeOutput(p,"float32"),N=t.dataIdMap.get(s.dataId).id,T=new Uint8Array(new Int32Array(ot(s.shape)).buffer),E=new Uint8Array(new Int32Array(y).buffer),A=new Uint8Array(new Int32Array(x).buffer),k=new Uint8Array(new Int32Array(w).buffer),C=new Uint8Array(new Int32Array(p).buffer),M=new Uint8Array(new Int32Array(ot(p)).buffer),L=t.dataIdMap.get(I.dataId).id;rK(N,T,s.shape.length,E,A,k,C,M,p.length,L),v=oa({inputs:{x:I},backend:t,attrs:{shape:f}}),t.disposeData(I.dataId)}return v}const blt={kernelName:L1,backendName:"wasm",setupFunc:mlt,kernelFunc:glt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ylt(e){const{backend:t,inputs:n,attrs:r}=e,{data:s,dataSplits:a}=n,{separator:i,nGramWidths:o,leftPad:u,rightPad:c,padWidth:l,preserveShortSequences:d}=r,h=t.readSync(s.dataId),p=t.readSync(a.dataId),[f,m]=d$(h,p,i,o,u,c,l,d),g=t.makeOutput([f.length],"string"),b=t.dataIdMap.get(g.dataId);b.stringBytes=f;const y=t.makeOutput(a.shape,"int32");return t.typedArrayFromHeap(y).set(m),[g,y]}const xlt={kernelName:NE,backendName:"wasm",kernelFunc:ylt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wlt(e){const{backend:t,inputs:n,attrs:r}=e,{input:s,delimiter:a}=n,{skipEmpty:i}=r,o=t.readSync(s.dataId),u=t.readSync(a.dataId),[c,l,d]=h$(o,u[0],i),h=l.length,p=t.makeOutput([h,2],"int32");t.typedArrayFromHeap(p).set(c);const m=t.makeOutput([h],"string"),g=t.dataIdMap.get(m.dataId);g.stringBytes=l;const b=t.makeOutput([2],"int32");return t.typedArrayFromHeap(b).set(d),[p,m,b]}const vlt={kernelName:TE,backendName:"wasm",kernelFunc:wlt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ilt(e){const{backend:t,inputs:n,attrs:r}=e,{input:s}=n,{numBuckets:a}=r,i=t.readSync(s.dataId),o=p$(i,a),u=t.makeOutput(s.shape,"int32");return t.typedArrayFromHeap(u).set(o),u}const klt={kernelName:EE,backendName:"wasm",kernelFunc:Ilt};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Clt=Lr(Yg);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let sK;function Slt(e){sK=e.wasm.cwrap(Kg,null,["number","number","number","number"])}function Nlt(e){const{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:a}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id;let u=o,c=i;const{transposed:l,axes:d,originalAxes:h,inputWasTransposed:p}=Uu(i,s,t);let f=d;if(p){const x=t.dataIdMap.get(l.dataId).id;x!==o&&(c=l,u=x,f=qn(f.length,c.shape.length))}tr("sum",f,c.shape.length);const[m,g]=sr(c.shape,f),b=fe(g),y=t.makeOutput(m,c.dtype);if(fe(c.shape)!==0){const x=t.dataIdMap.get(y.dataId).id;sK(u,b,bn[y.dtype],x)}if(p&&t.disposeData(l.dataId),a){const x=jn(y.shape,h);y.shape=x}return y}const Tlt={kernelName:Kg,backendName:"wasm",setupFunc:Slt,kernelFunc:Nlt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Elt=ln(Jg);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Alt=ln(Zg);/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let aK;function $lt(e){aK=e.wasm.cwrap(Zv,null,["number","number","number","number","number","number","array","number","number","number"])}function Rlt(e){const{backend:t,inputs:n,attrs:r}=e,{tensor:s,indices:a,updates:i}=n,o=t.makeOutput(s.shape,s.dtype);if(fe(s.shape)===0)return o;const{sliceRank:u,numUpdates:c,sliceSize:l,strides:d,outputSize:h}=zo(i,a,s.shape),f=t.dataIdMap.get(a.dataId).id,g=t.dataIdMap.get(i.dataId).id,y=t.dataIdMap.get(s.dataId).id,x=new Uint8Array(new Int32Array(d).buffer),w=t.dataIdMap.get(o.dataId).id;return aK(f,g,bn[i.dtype],u,c,l,x,h,w,y),o}const _lt={kernelName:Zv,backendName:"wasm",setupFunc:$lt,kernelFunc:Rlt};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let iK;function Dlt(e){iK=e.wasm.cwrap(Yh,null,["number","array","number","array","number","number"])}function Flt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,a=n.dataIdMap.get(s.dataId).id,{reps:i}=r,o=new Array(s.shape.length);for(let h=0;h<o.length;h++)o[h]=s.shape[h]*i[h];const u=new Uint8Array(new Int32Array(s.shape).buffer),c=new Uint8Array(new Int32Array(o).buffer),l=n.makeOutput(o,s.dtype),d=n.dataIdMap.get(l.dataId).id;return iK(a,u,s.shape.length,c,o.length,bn[l.dtype],d),l}const Mlt={kernelName:Yh,backendName:"wasm",setupFunc:Dlt,kernelFunc:Flt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let oK;function Olt(e){oK=e.wasm.cwrap(P1,null,["number","array","number","number","number","bool","number","number"])}const Llt=({inputs:e,backend:t,attrs:n})=>{const{x:r}=e,{k:s,sorted:a}=n,i=t.dataIdMap.get(r.dataId).id,o=new Uint8Array(new Int32Array(r.shape).buffer),u=r.shape.slice();u[u.length-1]=s;const c=t.makeOutput(u,r.dtype),l=t.dataIdMap.get(c.dataId).id,d=t.makeOutput(u,"int32"),h=t.dataIdMap.get(d.dataId).id;return oK(i,o,r.shape.length,bn[r.dtype],s,a,l,h),[c,d]},Plt={kernelName:P1,backendName:"wasm",setupFunc:Olt,kernelFunc:Llt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let lK;function Blt(e){lK=e.wasm.cwrap(B1,null,["number","number","bool","number","number","number","number","number","number","array","number","array","number","number","number","number","number"])}function zlt(e){const{backend:t,inputs:n,attrs:r}=e,{image:s,transforms:a}=n,{interpolation:i,fillMode:o,fillValue:u,outputShape:c}=r,[l,d,h,p]=s.shape,[f,m]=c??[d,h],g=[l,f,m,p],b=new Uint8Array(new Int32Array(ot(s.shape)).buffer),y=new Uint8Array(new Int32Array(ot(g)).buffer),x=t.makeOutput(g,s.dtype),w=t.dataIdMap.get(x.dataId).id,I=t.dataIdMap.get(s.dataId).id,T=t.dataIdMap.get(a.dataId).id,E=i==="nearest"?1:2;let A;switch(o){case"constant":A=1;break;case"reflect":A=2;break;case"wrap":A=3;break;case"nearest":A=4;break;default:A=1;break}return lK(I,T,a.shape[0]>1,l,f,m,p,h,d,b,s.shape.length-1,y,g.length-1,E,A,u,w),x}const Wlt={kernelName:B1,backendName:"wasm",setupFunc:Blt,kernelFunc:zlt};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vlt(e){const{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t,{outputValues:i,outputShape:o,indices:u}=m$(r.readSync(a.dataId),s,a.shape,a.dtype);return[r.makeOutput(o,a.dtype,void 0,i),r.makeOutput([u.length],"int32",void 0,u)]}const Ult={kernelName:sI,backendName:"wasm",kernelFunc:Vlt};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Glt(e){const{inputs:t,backend:n,attrs:r}=e,{value:s}=t;let{axis:a}=r;a<0&&(a+=s.shape.length);const i=s.shape[a],o=s.shape.length,u=new Array(o-1);let c=0;for(let p=0;p<o;p++)p!==a&&(u[c++]=s.shape[p]);const l=new Array(i),d=new Array(o).fill(0),h=s.shape.slice();h[a]=1;for(let p=0;p<l.length;p++)d[a]=p,l[p]=gd({inputs:{x:s},attrs:{begin:d,size:h},backend:n});return l.map(({dataId:p,dtype:f})=>({dataId:p,dtype:f,shape:u}))}const Hlt={kernelName:z1,backendName:"wasm",kernelFunc:Glt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jlt(e){const{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(0),r}const qlt={kernelName:W1,backendName:"wasm",kernelFunc:jlt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Klt=[Bnt,znt,Wnt,Vnt,Unt,jnt,ert,rrt,srt,art,irt,ort,lrt,urt,crt,prt,Irt,grt,xrt,Nrt,_rt,Mrt,Ort,Prt,Brt,zrt,Urt,Grt,qrt,Qrt,Zrt,nst,ast,ist,ost,cst,pst,gst,xst,Ist,Sst,Est,Rst,Fst,Lst,Pst,Wst,Ust,Gst,Hst,jst,qst,Kst,Yst,Jst,Zst,nat,aat,lat,dat,fat,gat,yat,qnt,xat,wat,vat,Cat,Nat,Eat,Rat,Dat,_at,Mat,Oat,Pat,zat,Uat,jat,Xat,Qat,Zat,nit,ait,lit,dit,fit,bit,yit,vit,Nit,Tit,Eit,Ait,_it,Mit,Pit,zit,Uit,Hit,qit,Lq,Qit,Zit,not,sot,aot,iot,oot,lot,krt,dot,fot,bot,wot,kot,Not,Tot,Eot,Rot,Fot,Lot,Pot,Wot,Vot,Uot,Got,$rt,kit,Hot,qot,Qot,Zot,tlt,rlt,ilt,llt,ult,clt,dlt,flt,blt,xlt,vlt,klt,Clt,Tlt,Elt,Alt,_lt,Mlt,Plt,Wlt,Ynt,Ult,Hlt,qlt];for(const e of Klt)AE(e);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MS=ke();MS.registerFlag("WASM_HAS_SIMD_SUPPORT",async()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))}catch{return!1}});MS.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",async()=>{if(MS.get("IS_NODE"))return!1;try{return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}});var Lk={exports:{}},kF;function Xlt(){return kF||(kF=1,(function(e,t){var n=(()=>{var r=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(r=r||__filename),(function(s){s=s||{};function a(){return z.buffer!=ve&&nt(z.buffer),Ae}function i(){return z.buffer!=ve&&nt(z.buffer),Be}function o(){return z.buffer!=ve&&nt(z.buffer),Ue}function u(){return z.buffer!=ve&&nt(z.buffer),qe}function c(){return z.buffer!=ve&&nt(z.buffer),ut}var l=typeof s<"u"?s:{},d,h;l.ready=new Promise(function(_,V){d=_,h=V});var p;typeof process<"u"&&process.listeners&&(p={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var f=Object.assign({},l),m=(_,V)=>{throw V},g=typeof window=="object",b=typeof importScripts=="function",y=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",x=l.ENVIRONMENT_IS_PTHREAD||!1,w="";function v(_){return l.locateFile?l.locateFile(_,w):w+_}var I,N,T;function E(_){if(_ instanceof kt)return;O("exiting due to exception: "+_)}if(y){var A=_l,k=_l;b?w=k.dirname(w)+"/":w=__dirname+"/",I=(V,me)=>(V=tt(V)?new URL(V):k.normalize(V),A.readFileSync(V,me?void 0:"utf8")),T=V=>{var me=I(V,!0);return me.buffer||(me=new Uint8Array(me)),me},N=(V,me,Pe)=>{V=tt(V)?new URL(V):k.normalize(V),A.readFile(V,function(He,je){He?Pe(He):me(je.buffer)})},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",function(V){if(!(V instanceof kt))throw V}),process.on("unhandledRejection",function(V){throw V}),m=(V,me)=>{if(St())throw process.exitCode=V,me;E(me),process.exit(V)},l.inspect=function(){return"[Emscripten Module object]"};let _;try{_=_l}catch(V){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),V}globalThis.Worker=_.Worker}else(g||b)&&(b?w=self.location.href:typeof document<"u"&&document.currentScript&&(w=document.currentScript.src),typeof r<"u"&&r&&(w=r),w.indexOf("blob:")!==0?w=w.substr(0,w.replace(/[?#].*/,"").lastIndexOf("/")+1):w="",y||(I=_=>{var V=new XMLHttpRequest;return V.open("GET",_,!1),V.send(null),V.responseText},b&&(T=_=>{var V=new XMLHttpRequest;return V.open("GET",_,!1),V.responseType="arraybuffer",V.send(null),new Uint8Array(V.response)}),N=(_,V,me)=>{var Pe=new XMLHttpRequest;Pe.open("GET",_,!0),Pe.responseType="arraybuffer",Pe.onload=()=>{if(Pe.status==200||Pe.status==0&&Pe.response){V(Pe.response);return}me()},Pe.onerror=me,Pe.send(null)}));y&&typeof performance>"u"&&(globalThis.performance=_l.performance);var C=console.log.bind(console),M=console.warn.bind(console);y&&(C=_=>A.writeSync(1,_+`
`),M=_=>A.writeSync(2,_+`
`));var L=l.print||C,O=l.printErr||M;Object.assign(l,f),f=null,l.arguments&&l.arguments,l.thisProgram&&l.thisProgram,l.quit&&(m=l.quit);var B;l.wasmBinary&&(B=l.wasmBinary);var G=l.noExitRuntime||!0;typeof WebAssembly!="object"&&re("no native wasm support detected");var z,q,Q=!1,K;function ee(_,V){_||re(V)}var Y=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function de(_,V,me){V>>>=0;for(var Pe=V+me,He=V;_[He]&&!(He>=Pe);)++He;if(He-V>16&&_.buffer&&Y)return Y.decode(_.buffer instanceof SharedArrayBuffer?_.slice(V,He):_.subarray(V,He));for(var je="";V<He;){var Ce=_[V++];if(!(Ce&128)){je+=String.fromCharCode(Ce);continue}var Fe=_[V++]&63;if((Ce&224)==192){je+=String.fromCharCode((Ce&31)<<6|Fe);continue}var Rt=_[V++]&63;if((Ce&240)==224?Ce=(Ce&15)<<12|Fe<<6|Rt:Ce=(Ce&7)<<18|Fe<<12|Rt<<6|_[V++]&63,Ce<65536)je+=String.fromCharCode(Ce);else{var En=Ce-65536;je+=String.fromCharCode(55296|En>>10,56320|En&1023)}}return je}function ue(_,V){return _>>>=0,_?de(i(),_,V):""}function Ie(_,V,me,Pe){if(me>>>=0,!(Pe>0))return 0;for(var He=me,je=me+Pe-1,Ce=0;Ce<_.length;++Ce){var Fe=_.charCodeAt(Ce);if(Fe>=55296&&Fe<=57343){var Rt=_.charCodeAt(++Ce);Fe=65536+((Fe&1023)<<10)|Rt&1023}if(Fe<=127){if(me>=je)break;V[me++>>>0]=Fe}else if(Fe<=2047){if(me+1>=je)break;V[me++>>>0]=192|Fe>>6,V[me++>>>0]=128|Fe&63}else if(Fe<=65535){if(me+2>=je)break;V[me++>>>0]=224|Fe>>12,V[me++>>>0]=128|Fe>>6&63,V[me++>>>0]=128|Fe&63}else{if(me+3>=je)break;V[me++>>>0]=240|Fe>>18,V[me++>>>0]=128|Fe>>12&63,V[me++>>>0]=128|Fe>>6&63,V[me++>>>0]=128|Fe&63}}return V[me>>>0]=0,me-He}function Ee(_,V,me){return Ie(_,i(),V,me)}var ve,Ae,Be,Ue,qe,ut;x&&(ve=l.buffer);function nt(_){ve=_,l.HEAP8=Ae=new Int8Array(_),l.HEAP16=new Int16Array(_),l.HEAP32=Ue=new Int32Array(_),l.HEAPU8=Be=new Uint8Array(_),l.HEAPU16=new Uint16Array(_),l.HEAPU32=qe=new Uint32Array(_),l.HEAPF32=new Float32Array(_),l.HEAPF64=ut=new Float64Array(_)}var rt=l.INITIAL_MEMORY||16777216;if(x)z=l.wasmMemory,ve=l.buffer;else if(l.wasmMemory)z=l.wasmMemory;else if(z=new WebAssembly.Memory({initial:rt/65536,maximum:65536,shared:!0}),!(z.buffer instanceof SharedArrayBuffer))throw O("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),y&&O("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");z&&(ve=z.buffer),rt=ve.byteLength,nt(ve);var ze,ct=[],ht=[],yn=[];function St(){return G}function pn(){if(l.preRun)for(typeof l.preRun=="function"&&(l.preRun=[l.preRun]);l.preRun.length;)wn(l.preRun.shift());wt(ct)}function jt(){x||wt(ht)}function nn(){if(!x){if(l.postRun)for(typeof l.postRun=="function"&&(l.postRun=[l.postRun]);l.postRun.length;)vn(l.postRun.shift());wt(yn)}}function wn(_){ct.unshift(_)}function Tt(_){ht.unshift(_)}function vn(_){yn.unshift(_)}var Kt=0,an=null;function xr(_){Kt++,l.monitorRunDependencies&&l.monitorRunDependencies(Kt)}function Re(_){if(Kt--,l.monitorRunDependencies&&l.monitorRunDependencies(Kt),Kt==0&&an){var V=an;an=null,V()}}function re(_){l.onAbort&&l.onAbort(_),_="Aborted("+_+")",O(_),Q=!0,K=1,_+=". Build with -sASSERTIONS for more info.";var V=new WebAssembly.RuntimeError(_);throw h(V),V}var $e="data:application/octet-stream;base64,";function Oe(_){return _.startsWith($e)}function tt(_){return _.startsWith("file://")}var Ke;Ke="tfjs-backend-wasm-threaded-simd.wasm",Oe(Ke)||(Ke=v(Ke));function pt(_){try{if(_==Ke&&B)return new Uint8Array(B);if(T)return T(_);throw"both async and sync fetching of the wasm failed"}catch(V){re(V)}}function lt(){if(!B&&(g||b)){if(typeof fetch=="function"&&!tt(Ke))return fetch(Ke,{credentials:"same-origin"}).then(function(_){if(!_.ok)throw"failed to load wasm binary file at '"+Ke+"'";return _.arrayBuffer()}).catch(function(){return pt(Ke)});if(N)return new Promise(function(_,V){N(Ke,function(me){_(new Uint8Array(me))},V)})}return Promise.resolve().then(function(){return pt(Ke)})}function Et(){var _={env:Ju,wasi_snapshot_preview1:Ju};function V(Ce,Fe){var Rt=Ce.exports;if(l.asm=Rt,Tr(l.asm._emscripten_tls_init),ze=l.asm.__indirect_function_table,Tt(l.asm.__wasm_call_ctors),q=Fe,!x){var En=xe.unusedWorkers.length;xe.unusedWorkers.forEach(function(Er){xe.loadWasmModuleToWorker(Er,function(){--En||Re()})})}}x||xr();function me(Ce){V(Ce.instance,Ce.module)}function Pe(Ce){return lt().then(function(Fe){return WebAssembly.instantiate(Fe,_)}).then(function(Fe){return Fe}).then(Ce,function(Fe){O("failed to asynchronously prepare wasm: "+Fe),re(Fe)})}function He(){return!B&&typeof WebAssembly.instantiateStreaming=="function"&&!Oe(Ke)&&!tt(Ke)&&!y&&typeof fetch=="function"?fetch(Ke,{credentials:"same-origin"}).then(function(Ce){var Fe=WebAssembly.instantiateStreaming(Ce,_);return Fe.then(me,function(Rt){return O("wasm streaming compile failed: "+Rt),O("falling back to ArrayBuffer instantiation"),Pe(me)})}):Pe(me)}if(l.instantiateWasm)try{var je=l.instantiateWasm(_,V);return je}catch(Ce){O("Module.instantiateWasm callback failed with error: "+Ce),h(Ce)}return He().catch(h),{}}var Bt={};function kt(_){this.name="ExitStatus",this.message="Program terminated with exit("+_+")",this.status=_}function Zt(_){var V=xe.pthreads[_];delete xe.pthreads[_],V.terminate(),qo(_),xe.runningWorkers.splice(xe.runningWorkers.indexOf(V),1),V.pthread_ptr=0}function At(_){var V=xe.pthreads[_];V.postMessage({cmd:"cancel"})}function In(_){var V=xe.pthreads[_];ee(V),xe.returnWorkerToPool(V)}function Un(_){var V=xe.getNewWorker();if(!V)return 6;xe.runningWorkers.push(V),xe.pthreads[_.pthread_ptr]=V,V.pthread_ptr=_.pthread_ptr;var me={cmd:"run",start_routine:_.startRoutine,arg:_.arg,pthread_ptr:_.pthread_ptr};return V.runPthread=()=>{y&&V.ref(),V.postMessage(me,_.transferList),delete V.runPthread},V.loaded&&V.runPthread(),0}function Kn(_){if(x)return mr(1,1,_);K=_,St()||(xe.terminateAllThreads(),l.onExit&&l.onExit(_),Q=!0),m(_,new kt(_))}function X(_,V){if(K=_,!V&&x)throw Xe(_),"unwind";Kn(_)}var he=X;function _e(_){if(_ instanceof kt||_=="unwind")return K;m(1,_)}var xe={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],pthreads:{},init:function(){x?xe.initWorker():xe.initMainThread()},initMainThread:function(){for(var _=8;_--;)xe.allocateUnusedWorker()},initWorker:function(){G=!1},setExitStatus:function(_){K=_},terminateAllThreads:function(){for(var _ of Object.values(xe.pthreads))xe.returnWorkerToPool(_);for(var _ of xe.unusedWorkers)_.terminate();xe.unusedWorkers=[]},returnWorkerToPool:function(_){var V=_.pthread_ptr;delete xe.pthreads[V],xe.unusedWorkers.push(_),xe.runningWorkers.splice(xe.runningWorkers.indexOf(_),1),_.pthread_ptr=0,y&&_.unref(),qo(V)},receiveObjectTransfer:function(_){},threadInitTLS:function(){xe.tlsInitFunctions.forEach(_=>_())},loadWasmModuleToWorker:function(_,V){_.onmessage=je=>{var Ce=je.data,Fe=Ce.cmd;if(_.pthread_ptr&&(xe.currentProxiedOperationCallerThread=_.pthread_ptr),Ce.targetThread&&Ce.targetThread!=Ci()){var Rt=xe.pthreads[Ce.targetThread];Rt?Rt.postMessage(Ce,Ce.transferList):O('Internal error! Worker sent a message "'+Fe+'" to target pthread '+Ce.targetThread+", but that thread no longer exists!"),xe.currentProxiedOperationCallerThread=void 0;return}Fe==="processProxyingQueue"?Vo(Ce.queue):Fe==="spawnThread"?Un(Ce):Fe==="cleanupThread"?In(Ce.thread):Fe==="killThread"?Zt(Ce.thread):Fe==="cancelThread"?At(Ce.thread):Fe==="loaded"?(_.loaded=!0,y&&_.unref(),V&&V(_),_.runPthread&&_.runPthread()):Fe==="print"?L("Thread "+Ce.threadId+": "+Ce.text):Fe==="printErr"?O("Thread "+Ce.threadId+": "+Ce.text):Fe==="alert"?alert("Thread "+Ce.threadId+": "+Ce.text):Ce.target==="setimmediate"?_.postMessage(Ce):Fe==="callHandler"?l[Ce.handler](...Ce.args):Fe&&O("worker sent an unknown command "+Fe),xe.currentProxiedOperationCallerThread=void 0},_.onerror=je=>{var Ce="worker sent an error!";throw O(Ce+" "+je.filename+":"+je.lineno+": "+je.message),je},y&&(_.on("message",function(je){_.onmessage({data:je})}),_.on("error",function(je){_.onerror(je)}),_.on("detachedExit",function(){}));var me=[],Pe=["onExit","onAbort","print","printErr"];for(var He of Pe)l.hasOwnProperty(He)&&me.push(He);_.postMessage({cmd:"load",handlers:me,urlOrBlob:l.mainScriptUrlOrBlob||r,wasmMemory:z,wasmModule:q})},allocateUnusedWorker:function(){var _,V=v("tfjs-backend-wasm-threaded-simd.worker.js");_=new Worker(V),xe.unusedWorkers.push(_)},getNewWorker:function(){return xe.unusedWorkers.length==0&&(xe.allocateUnusedWorker(),xe.loadWasmModuleToWorker(xe.unusedWorkers[0])),xe.unusedWorkers.pop()}};l.PThread=xe;function wt(_){for(;_.length>0;)_.shift()(l)}function bt(){var _=Ci(),V=o()[_+52>>>2],me=o()[_+56>>>2],Pe=V-me;Ko(V,Pe),Si(V)}l.establishStackSpace=bt;function Xe(_){if(x)return mr(2,0,_);try{he(_)}catch(V){_e(V)}}var Ge=[];function $t(_){var V=Ge[_];return V||(_>=Ge.length&&(Ge.length=_+1),Ge[_]=V=ze.get(_)),V}function Mn(_,V){var me=$t(_)(V);St()?xe.setExitStatus(me):nc(me)}l.invokeEntryPoint=Mn;function Tr(_){xe.tlsInitFunctions.push(_)}function wi(_){Zu(_,!b,1,!g),xe.threadInitTLS()}function Fa(_){x?postMessage({cmd:"cleanupThread",thread:_}):In(_)}function vi(_,V,me,Pe){return x?mr(3,1,_,V,me,Pe):rn(_,V,me,Pe)}function rn(_,V,me,Pe){if(typeof SharedArrayBuffer>"u")return O("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var He=[],je=0;if(x&&(He.length===0||je))return vi(_,V,me,Pe);var Ce={startRoutine:me,pthread_ptr:_,arg:Pe,transferList:He};return x?(Ce.cmd="spawnThread",postMessage(Ce,He),0):Un(Ce)}function ar(){return 65536}var Ii=!0;function fb(){return Ii}function Vo(_){Atomics.store(o(),_>>2,1),Ci()&&tc(_),Atomics.compareExchange(o(),_>>2,1,0)}l.executeNotifiedProxyingQueue=Vo;function Hu(_,V,me,Pe){if(_==V)setTimeout(()=>Vo(Pe));else if(x)postMessage({targetThread:_,cmd:"processProxyingQueue",queue:Pe});else{var He=xe.pthreads[_];if(!He)return;He.postMessage({cmd:"processProxyingQueue",queue:Pe})}return 1}function ju(_,V,me){return-1}function mb(){re("")}function Ma(_){Ma.shown||(Ma.shown={}),Ma.shown[_]||(Ma.shown[_]=1,y&&(_="warning: "+_),O(_))}function gb(){y||b||Ma("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")}function bb(){return Date.now()}function Uo(){return 4294901760}function yb(){return Uo()}var Go;y?Go=()=>{var _=process.hrtime();return _[0]*1e3+_[1]/1e6}:Go=()=>performance.timeOrigin+performance.now();function xb(_,V,me){i().copyWithin(_>>>0,V>>>0,V+me>>>0)}function wb(){return y?_l.cpus().length:navigator.hardwareConcurrency}function vb(_){var V=Js(),me=_();return Si(V),me}function mr(_,V){var me=arguments.length-2,Pe=arguments;return vb(()=>{for(var He=me,je=Ni(He*8),Ce=je>>3,Fe=0;Fe<me;Fe++){var Rt=Pe[2+Fe];c()[Ce+Fe>>>0]=Rt}return ec(_,He,je,V)})}var ro=[];function ki(_,V,me){ro.length=V;for(var Pe=me>>3,He=0;He<V;He++)ro[He]=c()[Pe+He>>>0];var je=_<0,Ce=je?Bt[-_-1]:jo[_];return Ce.apply(null,ro)}function qu(_){try{return z.grow(_-ve.byteLength+65535>>>16),nt(z.buffer),1}catch{}}function Ib(_){var V=i().length;if(_=_>>>0,_<=V)return!1;var me=Uo();if(_>me)return!1;let Pe=(Rt,En)=>Rt+(En-Rt%En)%En;for(var He=1;He<=4;He*=2){var je=V*(1+.2/He);je=Math.min(je,_+100663296);var Ce=Math.min(me,Pe(Math.max(_,je),65536)),Fe=qu(Ce);if(Fe)return!0}return!1}function kb(){throw"unwind"}function Ku(_){return x?mr(4,1,_):52}function Xu(_,V,me,Pe,He){return x?mr(5,1,_,V,me,Pe,He):70}var Qu=[null,[],[]];function Cb(_,V){var me=Qu[_];V===0||V===10?((_===1?L:O)(de(me,0)),me.length=0):me.push(V)}function Yu(_,V,me,Pe){if(x)return mr(6,1,_,V,me,Pe);for(var He=0,je=0;je<me;je++){var Ce=u()[V>>>2],Fe=u()[V+4>>>2];V+=8;for(var Rt=0;Rt<Fe;Rt++)Cb(_,i()[Ce+Rt>>>0]);He+=Fe}return u()[Pe>>>2]=He,0}function Il(_){var V=l["_"+_];return V}function kl(_,V){a().set(_,V>>>0)}function Ho(_,V,me,Pe,He){var je={string:xn=>{var Zs=0;if(xn!=null&&xn!==0){var ic=(xn.length<<2)+1;Zs=Ni(ic),Ee(xn,Zs,ic)}return Zs},array:xn=>{var Zs=Ni(xn.length);return kl(xn,Zs),Zs}};function Ce(xn){return V==="string"?ue(xn):V==="boolean"?!!xn:xn}var Fe=Il(_),Rt=[],En=0;if(Pe)for(var Er=0;Er<Pe.length;Er++){var sc=je[me[Er]];sc?(En===0&&(En=Js()),Rt[Er]=sc(Pe[Er])):Rt[Er]=Pe[Er]}var Dt=Fe.apply(null,Rt);function ac(xn){return En!==0&&Si(En),Ce(xn)}return Dt=ac(Dt),Dt}function Sb(_,V,me,Pe){me=me||[];var He=me.every(Ce=>Ce==="number"||Ce==="boolean"),je=V!=="string";return je&&He&&!Pe?Il(_):function(){return Ho(_,V,me,arguments)}}xe.init();var jo=[null,Kn,Xe,vi,Ku,Xu,Yu],Ju={__emscripten_init_main_thread_js:wi,__emscripten_thread_cleanup:Fa,__pthread_create_js:rn,_emscripten_default_pthread_stack_size:ar,_emscripten_get_now_is_monotonic:fb,_emscripten_notify_task_queue:Hu,_emscripten_set_offscreencanvas_size:ju,abort:mb,emscripten_check_blocking_allowed:gb,emscripten_date_now:bb,emscripten_get_heap_max:yb,emscripten_get_now:Go,emscripten_memcpy_big:xb,emscripten_num_logical_cores:wb,emscripten_receive_on_main_thread_js:ki,emscripten_resize_heap:Ib,emscripten_unwind_to_js_event_loop:kb,exit:he,fd_close:Ku,fd_seek:Xu,fd_write:Yu,memory:z||l.wasmMemory};Et(),l.___wasm_call_ctors=function(){return(l.___wasm_call_ctors=l.asm.__wasm_call_ctors).apply(null,arguments)},l._init=function(){return(l._init=l.asm.init).apply(null,arguments)},l._init_with_threads_count=function(){return(l._init_with_threads_count=l.asm.init_with_threads_count).apply(null,arguments)},l._get_threads_count=function(){return(l._get_threads_count=l.asm.get_threads_count).apply(null,arguments)},l._register_tensor=function(){return(l._register_tensor=l.asm.register_tensor).apply(null,arguments)},l._dispose_data=function(){return(l._dispose_data=l.asm.dispose_data).apply(null,arguments)},l._dispose=function(){return(l._dispose=l.asm.dispose).apply(null,arguments)},l._Abs=function(){return(l._Abs=l.asm.Abs).apply(null,arguments)},l._Acos=function(){return(l._Acos=l.asm.Acos).apply(null,arguments)},l._Acosh=function(){return(l._Acosh=l.asm.Acosh).apply(null,arguments)},l._Add=function(){return(l._Add=l.asm.Add).apply(null,arguments)},l._AddN=function(){return(l._AddN=l.asm.AddN).apply(null,arguments)},l._All=function(){return(l._All=l.asm.All).apply(null,arguments)},l._Any=function(){return(l._Any=l.asm.Any).apply(null,arguments)},l._ArgMax=function(){return(l._ArgMax=l.asm.ArgMax).apply(null,arguments)},l._ArgMin=function(){return(l._ArgMin=l.asm.ArgMin).apply(null,arguments)},l._Asin=function(){return(l._Asin=l.asm.Asin).apply(null,arguments)},l._Asinh=function(){return(l._Asinh=l.asm.Asinh).apply(null,arguments)},l._Atan=function(){return(l._Atan=l.asm.Atan).apply(null,arguments)},l._Atan2=function(){return(l._Atan2=l.asm.Atan2).apply(null,arguments)},l._Atanh=function(){return(l._Atanh=l.asm.Atanh).apply(null,arguments)},l._AvgPool=function(){return(l._AvgPool=l.asm.AvgPool).apply(null,arguments)},l._AvgPool3D=function(){return(l._AvgPool3D=l.asm.AvgPool3D).apply(null,arguments)},l._AvgPool3DGrad=function(){return(l._AvgPool3DGrad=l.asm.AvgPool3DGrad).apply(null,arguments)},l._AvgPoolGrad=function(){return(l._AvgPoolGrad=l.asm.AvgPoolGrad).apply(null,arguments)},l._BatchMatMul=function(){return(l._BatchMatMul=l.asm.BatchMatMul).apply(null,arguments)},l._Bincount=function(){return(l._Bincount=l.asm.Bincount).apply(null,arguments)},l._BitwiseAnd=function(){return(l._BitwiseAnd=l.asm.BitwiseAnd).apply(null,arguments)},l._Ceil=function(){return(l._Ceil=l.asm.Ceil).apply(null,arguments)},l._ClipByValue=function(){return(l._ClipByValue=l.asm.ClipByValue).apply(null,arguments)},l._Conv2D=function(){return(l._Conv2D=l.asm.Conv2D).apply(null,arguments)},l._Conv2DBackpropInput=function(){return(l._Conv2DBackpropInput=l.asm.Conv2DBackpropInput).apply(null,arguments)},l._Conv3D=function(){return(l._Conv3D=l.asm.Conv3D).apply(null,arguments)},l._Conv3DBackpropFilterV2=function(){return(l._Conv3DBackpropFilterV2=l.asm.Conv3DBackpropFilterV2).apply(null,arguments)},l._Conv3DBackpropInputV2=function(){return(l._Conv3DBackpropInputV2=l.asm.Conv3DBackpropInputV2).apply(null,arguments)},l._Cos=function(){return(l._Cos=l.asm.Cos).apply(null,arguments)},l._Cosh=function(){return(l._Cosh=l.asm.Cosh).apply(null,arguments)},l._CropAndResize=function(){return(l._CropAndResize=l.asm.CropAndResize).apply(null,arguments)},l._Cumprod=function(){return(l._Cumprod=l.asm.Cumprod).apply(null,arguments)},l._Cumsum=function(){return(l._Cumsum=l.asm.Cumsum).apply(null,arguments)},l._DenseBincount=function(){return(l._DenseBincount=l.asm.DenseBincount).apply(null,arguments)},l._DepthToSpace=function(){return(l._DepthToSpace=l.asm.DepthToSpace).apply(null,arguments)},l._DepthwiseConv2dNative=function(){return(l._DepthwiseConv2dNative=l.asm.DepthwiseConv2dNative).apply(null,arguments)},l._Diag=function(){return(l._Diag=l.asm.Diag).apply(null,arguments)},l._Dilation2D=function(){return(l._Dilation2D=l.asm.Dilation2D).apply(null,arguments)},l._Dilation2DBackpropFilter=function(){return(l._Dilation2DBackpropFilter=l.asm.Dilation2DBackpropFilter).apply(null,arguments)},l._Dilation2DBackpropInput=function(){return(l._Dilation2DBackpropInput=l.asm.Dilation2DBackpropInput).apply(null,arguments)},l._Elu=function(){return(l._Elu=l.asm.Elu).apply(null,arguments)},l._EluGrad=function(){return(l._EluGrad=l.asm.EluGrad).apply(null,arguments)},l._Equal=function(){return(l._Equal=l.asm.Equal).apply(null,arguments)},l._Erf=function(){return(l._Erf=l.asm.Erf).apply(null,arguments)},l._Exp=function(){return(l._Exp=l.asm.Exp).apply(null,arguments)},l._Expm1=function(){return(l._Expm1=l.asm.Expm1).apply(null,arguments)},l._FlipLeftRight=function(){return(l._FlipLeftRight=l.asm.FlipLeftRight).apply(null,arguments)},l._Floor=function(){return(l._Floor=l.asm.Floor).apply(null,arguments)},l._FloorDiv=function(){return(l._FloorDiv=l.asm.FloorDiv).apply(null,arguments)},l._FusedBatchNorm=function(){return(l._FusedBatchNorm=l.asm.FusedBatchNorm).apply(null,arguments)},l._FusedConv2D=function(){return(l._FusedConv2D=l.asm.FusedConv2D).apply(null,arguments)},l._FusedDepthwiseConv2D=function(){return(l._FusedDepthwiseConv2D=l.asm.FusedDepthwiseConv2D).apply(null,arguments)},l._Gather=function(){return(l._Gather=l.asm.Gather).apply(null,arguments)},l._GatherNd=function(){return(l._GatherNd=l.asm.GatherNd).apply(null,arguments)},l._Greater=function(){return(l._Greater=l.asm.Greater).apply(null,arguments)},l._GreaterEqual=function(){return(l._GreaterEqual=l.asm.GreaterEqual).apply(null,arguments)},l._IsFinite=function(){return(l._IsFinite=l.asm.IsFinite).apply(null,arguments)},l._IsInf=function(){return(l._IsInf=l.asm.IsInf).apply(null,arguments)},l._IsNan=function(){return(l._IsNan=l.asm.IsNan).apply(null,arguments)},l._LRN=function(){return(l._LRN=l.asm.LRN).apply(null,arguments)},l._LRNGrad=function(){return(l._LRNGrad=l.asm.LRNGrad).apply(null,arguments)},l._LeakyRelu=function(){return(l._LeakyRelu=l.asm.LeakyRelu).apply(null,arguments)},l._Less=function(){return(l._Less=l.asm.Less).apply(null,arguments)},l._LessEqual=function(){return(l._LessEqual=l.asm.LessEqual).apply(null,arguments)},l._LinSpace=function(){return(l._LinSpace=l.asm.LinSpace).apply(null,arguments)},l._Log=function(){return(l._Log=l.asm.Log).apply(null,arguments)},l._Log1p=function(){return(l._Log1p=l.asm.Log1p).apply(null,arguments)},l._LogicalAnd=function(){return(l._LogicalAnd=l.asm.LogicalAnd).apply(null,arguments)},l._LogicalNot=function(){return(l._LogicalNot=l.asm.LogicalNot).apply(null,arguments)},l._LogicalOr=function(){return(l._LogicalOr=l.asm.LogicalOr).apply(null,arguments)},l._LogicalXor=function(){return(l._LogicalXor=l.asm.LogicalXor).apply(null,arguments)},l._Max=function(){return(l._Max=l.asm.Max).apply(null,arguments)},l._MaxPool=function(){return(l._MaxPool=l.asm.MaxPool).apply(null,arguments)},l._MaxPool3D=function(){return(l._MaxPool3D=l.asm.MaxPool3D).apply(null,arguments)},l._MaxPool3DGrad=function(){return(l._MaxPool3DGrad=l.asm.MaxPool3DGrad).apply(null,arguments)},l._MaxPoolGrad=function(){return(l._MaxPoolGrad=l.asm.MaxPoolGrad).apply(null,arguments)},l._MaxPoolWithArgmax=function(){return(l._MaxPoolWithArgmax=l.asm.MaxPoolWithArgmax).apply(null,arguments)},l._Maximum=function(){return(l._Maximum=l.asm.Maximum).apply(null,arguments)},l._Mean=function(){return(l._Mean=l.asm.Mean).apply(null,arguments)},l._Min=function(){return(l._Min=l.asm.Min).apply(null,arguments)},l._Minimum=function(){return(l._Minimum=l.asm.Minimum).apply(null,arguments)},l._MirrorPad=function(){return(l._MirrorPad=l.asm.MirrorPad).apply(null,arguments)},l._Mod=function(){return(l._Mod=l.asm.Mod).apply(null,arguments)},l._Multinomial=function(){return(l._Multinomial=l.asm.Multinomial).apply(null,arguments)},l._Multiply=function(){return(l._Multiply=l.asm.Multiply).apply(null,arguments)},l._Neg=function(){return(l._Neg=l.asm.Neg).apply(null,arguments)},l._NonMaxSuppressionV3=function(){return(l._NonMaxSuppressionV3=l.asm.NonMaxSuppressionV3).apply(null,arguments)},l._NonMaxSuppressionV4=function(){return(l._NonMaxSuppressionV4=l.asm.NonMaxSuppressionV4).apply(null,arguments)},l._NonMaxSuppressionV5=function(){return(l._NonMaxSuppressionV5=l.asm.NonMaxSuppressionV5).apply(null,arguments)},l._NotEqual=function(){return(l._NotEqual=l.asm.NotEqual).apply(null,arguments)},l._OneHot=function(){return(l._OneHot=l.asm.OneHot).apply(null,arguments)},l._PadV2=function(){return(l._PadV2=l.asm.PadV2).apply(null,arguments)},l._Pow=function(){return(l._Pow=l.asm.Pow).apply(null,arguments)},l._Prelu=function(){return(l._Prelu=l.asm.Prelu).apply(null,arguments)},l._Prod=function(){return(l._Prod=l.asm.Prod).apply(null,arguments)},l._RealDiv=function(){return(l._RealDiv=l.asm.RealDiv).apply(null,arguments)},l._Reciprocal=function(){return(l._Reciprocal=l.asm.Reciprocal).apply(null,arguments)},l._Relu=function(){return(l._Relu=l.asm.Relu).apply(null,arguments)},l._Relu6=function(){return(l._Relu6=l.asm.Relu6).apply(null,arguments)},l._ResizeBilinear=function(){return(l._ResizeBilinear=l.asm.ResizeBilinear).apply(null,arguments)},l._ResizeBilinearGrad=function(){return(l._ResizeBilinearGrad=l.asm.ResizeBilinearGrad).apply(null,arguments)},l._ResizeNearestNeighbor=function(){return(l._ResizeNearestNeighbor=l.asm.ResizeNearestNeighbor).apply(null,arguments)},l._ResizeNearestNeighborGrad=function(){return(l._ResizeNearestNeighborGrad=l.asm.ResizeNearestNeighborGrad).apply(null,arguments)},l._Reverse=function(){return(l._Reverse=l.asm.Reverse).apply(null,arguments)},l._RotateWithOffset=function(){return(l._RotateWithOffset=l.asm.RotateWithOffset).apply(null,arguments)},l._Round=function(){return(l._Round=l.asm.Round).apply(null,arguments)},l._Rsqrt=function(){return(l._Rsqrt=l.asm.Rsqrt).apply(null,arguments)},l._ScatterNd=function(){return(l._ScatterNd=l.asm.ScatterNd).apply(null,arguments)},l._SearchSorted=function(){return(l._SearchSorted=l.asm.SearchSorted).apply(null,arguments)},l._SelectV2=function(){return(l._SelectV2=l.asm.SelectV2).apply(null,arguments)},l._Selu=function(){return(l._Selu=l.asm.Selu).apply(null,arguments)},l._Sigmoid=function(){return(l._Sigmoid=l.asm.Sigmoid).apply(null,arguments)},l._Sign=function(){return(l._Sign=l.asm.Sign).apply(null,arguments)},l._Sin=function(){return(l._Sin=l.asm.Sin).apply(null,arguments)},l._Sinh=function(){return(l._Sinh=l.asm.Sinh).apply(null,arguments)},l._Softmax=function(){return(l._Softmax=l.asm.Softmax).apply(null,arguments)},l._Softplus=function(){return(l._Softplus=l.asm.Softplus).apply(null,arguments)},l._SparseFillEmptyRows=function(){return(l._SparseFillEmptyRows=l.asm.SparseFillEmptyRows).apply(null,arguments)},l._SparseReshape=function(){return(l._SparseReshape=l.asm.SparseReshape).apply(null,arguments)},l._SparseSegmentReduction=function(){return(l._SparseSegmentReduction=l.asm.SparseSegmentReduction).apply(null,arguments)},l._SparseToDense=function(){return(l._SparseToDense=l.asm.SparseToDense).apply(null,arguments)},l._Sqrt=function(){return(l._Sqrt=l.asm.Sqrt).apply(null,arguments)},l._Square=function(){return(l._Square=l.asm.Square).apply(null,arguments)},l._SquaredDifference=function(){return(l._SquaredDifference=l.asm.SquaredDifference).apply(null,arguments)},l._Step=function(){return(l._Step=l.asm.Step).apply(null,arguments)},l._StridedSlice=function(){return(l._StridedSlice=l.asm.StridedSlice).apply(null,arguments)},l._Sub=function(){return(l._Sub=l.asm.Sub).apply(null,arguments)},l._Sum=function(){return(l._Sum=l.asm.Sum).apply(null,arguments)},l._Tan=function(){return(l._Tan=l.asm.Tan).apply(null,arguments)},l._Tanh=function(){return(l._Tanh=l.asm.Tanh).apply(null,arguments)},l._TensorScatterUpdate=function(){return(l._TensorScatterUpdate=l.asm.TensorScatterUpdate).apply(null,arguments)},l._Tile=function(){return(l._Tile=l.asm.Tile).apply(null,arguments)},l._TopK=function(){return(l._TopK=l.asm.TopK).apply(null,arguments)},l._Transform=function(){return(l._Transform=l.asm.Transform).apply(null,arguments)},l._Transpose=function(){return(l._Transpose=l.asm.Transpose).apply(null,arguments)},l.__FusedMatMul=function(){return(l.__FusedMatMul=l.asm._FusedMatMul).apply(null,arguments)},l._malloc=function(){return(l._malloc=l.asm.malloc).apply(null,arguments)},l._free=function(){return(l._free=l.asm.free).apply(null,arguments)},l.__emscripten_tls_init=function(){return(l.__emscripten_tls_init=l.asm._emscripten_tls_init).apply(null,arguments)};var Ci=l._pthread_self=function(){return(Ci=l._pthread_self=l.asm.pthread_self).apply(null,arguments)};l.___errno_location=function(){return(l.___errno_location=l.asm.__errno_location).apply(null,arguments)};var Zu=l.__emscripten_thread_init=function(){return(Zu=l.__emscripten_thread_init=l.asm._emscripten_thread_init).apply(null,arguments)};l.__emscripten_thread_crashed=function(){return(l.__emscripten_thread_crashed=l.asm._emscripten_thread_crashed).apply(null,arguments)},l._emscripten_main_thread_process_queued_calls=function(){return(l._emscripten_main_thread_process_queued_calls=l.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},l._emscripten_main_browser_thread_id=function(){return(l._emscripten_main_browser_thread_id=l.asm.emscripten_main_browser_thread_id).apply(null,arguments)};var ec=l._emscripten_run_in_main_runtime_thread_js=function(){return(ec=l._emscripten_run_in_main_runtime_thread_js=l.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)};l._emscripten_dispatch_to_thread_=function(){return(l._emscripten_dispatch_to_thread_=l.asm.emscripten_dispatch_to_thread_).apply(null,arguments)};var tc=l.__emscripten_proxy_execute_task_queue=function(){return(tc=l.__emscripten_proxy_execute_task_queue=l.asm._emscripten_proxy_execute_task_queue).apply(null,arguments)},qo=l.__emscripten_thread_free_data=function(){return(qo=l.__emscripten_thread_free_data=l.asm._emscripten_thread_free_data).apply(null,arguments)},nc=l.__emscripten_thread_exit=function(){return(nc=l.__emscripten_thread_exit=l.asm._emscripten_thread_exit).apply(null,arguments)},Ko=l._emscripten_stack_set_limits=function(){return(Ko=l._emscripten_stack_set_limits=l.asm.emscripten_stack_set_limits).apply(null,arguments)},Js=l.stackSave=function(){return(Js=l.stackSave=l.asm.stackSave).apply(null,arguments)},Si=l.stackRestore=function(){return(Si=l.stackRestore=l.asm.stackRestore).apply(null,arguments)},Ni=l.stackAlloc=function(){return(Ni=l.stackAlloc=l.asm.stackAlloc).apply(null,arguments)};l.dynCall_iijjiiii=function(){return(l.dynCall_iijjiiii=l.asm.dynCall_iijjiiii).apply(null,arguments)},l.dynCall_jiji=function(){return(l.dynCall_jiji=l.asm.dynCall_jiji).apply(null,arguments)},l.keepRuntimeAlive=St,l.wasmMemory=z,l.cwrap=Sb,l.ExitStatus=kt,l.PThread=xe;var Ti;an=function _(){Ti||rc(),Ti||(an=_)};function rc(_){if(Kt>0)return;if(x){d(l),jt(),startWorker(l);return}if(pn(),Kt>0)return;function V(){Ti||(Ti=!0,l.calledRun=!0,!Q&&(jt(),d(l),l.onRuntimeInitialized&&l.onRuntimeInitialized(),nn()))}l.setStatus?(l.setStatus("Running..."),setTimeout(function(){setTimeout(function(){l.setStatus("")},1),V()},1)):V()}if(l.preInit)for(typeof l.preInit=="function"&&(l.preInit=[l.preInit]);l.preInit.length>0;)l.preInit.pop()();rc();var Za;p&&(Za={uncaughtException:process.listeners("uncaughtException").filter(function(_){return!p.uncaughtException.indexOf(_)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(_){return!p.unhandledRejection.indexOf(_)>-1})});var Ei;if(typeof WasmBackendModule<"u")Ei=WasmBackendModule;else if(typeof s<"u")Ei=s;else throw new Error("Could not find wasm module in post.js");if(Za){var dp=Ei._dispose;Ei._dispose=function(){dp(),Za.uncaughtException.forEach(function(_){process.removeListener("uncaughtException",_)}),Za.unhandledRejection.forEach(function(_){process.removeListener("unhandledRejection",_)})}}return s.ready})})();e.exports=n})(Lk)),Lk.exports}var uK=Xlt();const cK=ow(uK),Qlt=OS({__proto__:null,default:cK},[uK]);var Pk={},CF;function Ylt(){return CF||(CF=1,Pk.wasmWorkerContents=`"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",data=>onmessage({data:data}));var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8")+"//# sourceURL="+f)},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}var initializedJS=false;var pendingNotifiedProxyingQueues=[];function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"
");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=(info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports};self.onunhandledrejection=e=>{throw e.reason??e};self.startWorker=instance=>{Module=instance;postMessage({"cmd":"loaded"})};self.onmessage=e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=function(){postMessage({cmd:"callHandler",handler:handler,args:[...arguments]})}}Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob=="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module)}else if(e.data.cmd==="run"){Module["__emscripten_thread_init"](e.data.pthread_ptr,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInitTLS();if(!initializedJS){pendingNotifiedProxyingQueues.forEach(queue=>{Module["executeNotifiedProxyingQueue"](queue)});pendingNotifiedProxyingQueues=[];initializedJS=true}try{Module["invokeEntryPoint"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processProxyingQueue"){if(initializedJS){Module["executeNotifiedProxyingQueue"](e.data.queue)}else{pendingNotifiedProxyingQueues.push(e.data.queue)}}else if(e.data.cmd){err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}};`),Pk}var Jlt=Ylt(),Bk={exports:{}},SF;function Zlt(){return SF||(SF=1,(function(e,t){var n=(()=>{var r=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(r=r||__filename),(function(s){s=s||{};var a=typeof s<"u"?s:{},i,o;a.ready=new Promise(function(X,he){i=X,o=he});var u;typeof process<"u"&&process.listeners&&(u={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var c=Object.assign({},a),l=typeof window=="object",d=typeof importScripts=="function",h=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",p="";function f(X){return a.locateFile?a.locateFile(X,p):p+X}var m,g,b;if(h){var y=_l,x=_l;d?p=x.dirname(p)+"/":p=__dirname+"/",m=(X,he)=>(X=rt(X)?new URL(X):x.normalize(X),y.readFileSync(X,he?void 0:"utf8")),b=X=>{var he=m(X,!0);return he.buffer||(he=new Uint8Array(he)),he},g=(X,he,_e)=>{X=rt(X)?new URL(X):x.normalize(X),y.readFile(X,function(xe,wt){xe?_e(xe):he(wt.buffer)})},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",function(X){if(!(X instanceof St))throw X}),process.on("unhandledRejection",function(X){throw X}),a.inspect=function(){return"[Emscripten Module object]"}}else(l||d)&&(d?p=self.location.href:typeof document<"u"&&document.currentScript&&(p=document.currentScript.src),r&&(p=r),p.indexOf("blob:")!==0?p=p.substr(0,p.replace(/[?#].*/,"").lastIndexOf("/")+1):p="",m=X=>{var he=new XMLHttpRequest;return he.open("GET",X,!1),he.send(null),he.responseText},d&&(b=X=>{var he=new XMLHttpRequest;return he.open("GET",X,!1),he.responseType="arraybuffer",he.send(null),new Uint8Array(he.response)}),g=(X,he,_e)=>{var xe=new XMLHttpRequest;xe.open("GET",X,!0),xe.responseType="arraybuffer",xe.onload=()=>{if(xe.status==200||xe.status==0&&xe.response){he(xe.response);return}_e()},xe.onerror=_e,xe.send(null)});var w=a.print||console.log.bind(console),v=a.printErr||console.warn.bind(console);Object.assign(a,c),c=null,a.arguments&&a.arguments,a.thisProgram&&a.thisProgram,a.quit&&a.quit;var I;a.wasmBinary&&(I=a.wasmBinary),a.noExitRuntime,typeof WebAssembly!="object"&&qe("no native wasm support detected");var N,T=!1,E=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function A(X,he,_e){he>>>=0;for(var xe=he+_e,wt=he;X[wt]&&!(wt>=xe);)++wt;if(wt-he>16&&X.buffer&&E)return E.decode(X.subarray(he,wt));for(var bt="";he<wt;){var Xe=X[he++];if(!(Xe&128)){bt+=String.fromCharCode(Xe);continue}var Ge=X[he++]&63;if((Xe&224)==192){bt+=String.fromCharCode((Xe&31)<<6|Ge);continue}var $t=X[he++]&63;if((Xe&240)==224?Xe=(Xe&15)<<12|Ge<<6|$t:Xe=(Xe&7)<<18|Ge<<12|$t<<6|X[he++]&63,Xe<65536)bt+=String.fromCharCode(Xe);else{var Mn=Xe-65536;bt+=String.fromCharCode(55296|Mn>>10,56320|Mn&1023)}}return bt}function k(X,he){return X>>>=0,X?A(B,X,he):""}function C(X,he,_e,xe){if(_e>>>=0,!(xe>0))return 0;for(var wt=_e,bt=_e+xe-1,Xe=0;Xe<X.length;++Xe){var Ge=X.charCodeAt(Xe);if(Ge>=55296&&Ge<=57343){var $t=X.charCodeAt(++Xe);Ge=65536+((Ge&1023)<<10)|$t&1023}if(Ge<=127){if(_e>=bt)break;he[_e++>>>0]=Ge}else if(Ge<=2047){if(_e+1>=bt)break;he[_e++>>>0]=192|Ge>>6,he[_e++>>>0]=128|Ge&63}else if(Ge<=65535){if(_e+2>=bt)break;he[_e++>>>0]=224|Ge>>12,he[_e++>>>0]=128|Ge>>6&63,he[_e++>>>0]=128|Ge&63}else{if(_e+3>=bt)break;he[_e++>>>0]=240|Ge>>18,he[_e++>>>0]=128|Ge>>12&63,he[_e++>>>0]=128|Ge>>6&63,he[_e++>>>0]=128|Ge&63}}return he[_e>>>0]=0,_e-wt}function M(X,he,_e){return C(X,B,he,_e)}var L,O,B,G;function z(X){L=X,a.HEAP8=O=new Int8Array(X),a.HEAP16=new Int16Array(X),a.HEAP32=new Int32Array(X),a.HEAPU8=B=new Uint8Array(X),a.HEAPU16=new Uint16Array(X),a.HEAPU32=G=new Uint32Array(X),a.HEAPF32=new Float32Array(X),a.HEAPF64=new Float64Array(X)}a.INITIAL_MEMORY;var q=[],Q=[],K=[];function ee(){if(a.preRun)for(typeof a.preRun=="function"&&(a.preRun=[a.preRun]);a.preRun.length;)ue(a.preRun.shift());pn(q)}function Y(){pn(Q)}function de(){if(a.postRun)for(typeof a.postRun=="function"&&(a.postRun=[a.postRun]);a.postRun.length;)Ee(a.postRun.shift());pn(K)}function ue(X){q.unshift(X)}function Ie(X){Q.unshift(X)}function Ee(X){K.unshift(X)}var ve=0,Ae=null;function Be(X){ve++,a.monitorRunDependencies&&a.monitorRunDependencies(ve)}function Ue(X){if(ve--,a.monitorRunDependencies&&a.monitorRunDependencies(ve),ve==0&&Ae){var he=Ae;Ae=null,he()}}function qe(X){a.onAbort&&a.onAbort(X),X="Aborted("+X+")",v(X),T=!0,X+=". Build with -sASSERTIONS for more info.";var he=new WebAssembly.RuntimeError(X);throw o(he),he}var ut="data:application/octet-stream;base64,";function nt(X){return X.startsWith(ut)}function rt(X){return X.startsWith("file://")}var ze;ze="tfjs-backend-wasm.wasm",nt(ze)||(ze=f(ze));function ct(X){try{if(X==ze&&I)return new Uint8Array(I);if(b)return b(X);throw"both async and sync fetching of the wasm failed"}catch(he){qe(he)}}function ht(){if(!I&&(l||d)){if(typeof fetch=="function"&&!rt(ze))return fetch(ze,{credentials:"same-origin"}).then(function(X){if(!X.ok)throw"failed to load wasm binary file at '"+ze+"'";return X.arrayBuffer()}).catch(function(){return ct(ze)});if(g)return new Promise(function(X,he){g(ze,function(_e){X(new Uint8Array(_e))},he)})}return Promise.resolve().then(function(){return ct(ze)})}function yn(){var X={env:lt,wasi_snapshot_preview1:lt};function he(Xe,Ge){var $t=Xe.exports;a.asm=$t,N=a.asm.memory,z(N.buffer),a.asm.__indirect_function_table,Ie(a.asm.__wasm_call_ctors),Ue()}Be();function _e(Xe){he(Xe.instance)}function xe(Xe){return ht().then(function(Ge){return WebAssembly.instantiate(Ge,X)}).then(function(Ge){return Ge}).then(Xe,function(Ge){v("failed to asynchronously prepare wasm: "+Ge),qe(Ge)})}function wt(){return!I&&typeof WebAssembly.instantiateStreaming=="function"&&!nt(ze)&&!rt(ze)&&!h&&typeof fetch=="function"?fetch(ze,{credentials:"same-origin"}).then(function(Xe){var Ge=WebAssembly.instantiateStreaming(Xe,X);return Ge.then(_e,function($t){return v("wasm streaming compile failed: "+$t),v("falling back to ArrayBuffer instantiation"),xe(_e)})}):xe(_e)}if(a.instantiateWasm)try{var bt=a.instantiateWasm(X,he);return bt}catch(Xe){v("Module.instantiateWasm callback failed with error: "+Xe),o(Xe)}return wt().catch(o),{}}function St(X){this.name="ExitStatus",this.message="Program terminated with exit("+X+")",this.status=X}function pn(X){for(;X.length>0;)X.shift()(a)}function jt(){qe("")}function nn(){return 4294901760}function wn(){return nn()}function Tt(X,he,_e){B.copyWithin(X>>>0,he>>>0,he+_e>>>0)}function vn(X){try{return N.grow(X-L.byteLength+65535>>>16),z(N.buffer),1}catch{}}function Kt(X){var he=B.length;X=X>>>0;var _e=nn();if(X>_e)return!1;let xe=($t,Mn)=>$t+(Mn-$t%Mn)%Mn;for(var wt=1;wt<=4;wt*=2){var bt=he*(1+.2/wt);bt=Math.min(bt,X+100663296);var Xe=Math.min(_e,xe(Math.max(X,bt),65536)),Ge=vn(Xe);if(Ge)return!0}return!1}function an(X){return 52}function xr(X,he,_e,xe,wt){return 70}var Re=[null,[],[]];function re(X,he){var _e=Re[X];he===0||he===10?((X===1?w:v)(A(_e,0)),_e.length=0):_e.push(he)}function $e(X,he,_e,xe){for(var wt=0,bt=0;bt<_e;bt++){var Xe=G[he>>>2],Ge=G[he+4>>>2];he+=8;for(var $t=0;$t<Ge;$t++)re(X,B[Xe+$t>>>0]);wt+=Ge}return G[xe>>>2]=wt,0}function Oe(X){var he=a["_"+X];return he}function tt(X,he){O.set(X,he>>>0)}function Ke(X,he,_e,xe,wt){var bt={string:rn=>{var ar=0;if(rn!=null&&rn!==0){var Ii=(rn.length<<2)+1;ar=kt(Ii),M(rn,ar,Ii)}return ar},array:rn=>{var ar=kt(rn.length);return tt(rn,ar),ar}};function Xe(rn){return he==="string"?k(rn):he==="boolean"?!!rn:rn}var Ge=Oe(X),$t=[],Mn=0;if(xe)for(var Tr=0;Tr<xe.length;Tr++){var wi=bt[_e[Tr]];wi?(Mn===0&&(Mn=Et()),$t[Tr]=wi(xe[Tr])):$t[Tr]=xe[Tr]}var Fa=Ge.apply(null,$t);function vi(rn){return Mn!==0&&Bt(Mn),Xe(rn)}return Fa=vi(Fa),Fa}function pt(X,he,_e,xe){_e=_e||[];var wt=_e.every(Xe=>Xe==="number"||Xe==="boolean"),bt=he!=="string";return bt&&wt&&!xe?Oe(X):function(){return Ke(X,he,_e,arguments)}}var lt={abort:jt,emscripten_get_heap_max:wn,emscripten_memcpy_big:Tt,emscripten_resize_heap:Kt,fd_close:an,fd_seek:xr,fd_write:$e};yn(),a.___wasm_call_ctors=function(){return(a.___wasm_call_ctors=a.asm.__wasm_call_ctors).apply(null,arguments)},a._init=function(){return(a._init=a.asm.init).apply(null,arguments)},a._init_with_threads_count=function(){return(a._init_with_threads_count=a.asm.init_with_threads_count).apply(null,arguments)},a._get_threads_count=function(){return(a._get_threads_count=a.asm.get_threads_count).apply(null,arguments)},a._register_tensor=function(){return(a._register_tensor=a.asm.register_tensor).apply(null,arguments)},a._dispose_data=function(){return(a._dispose_data=a.asm.dispose_data).apply(null,arguments)},a._dispose=function(){return(a._dispose=a.asm.dispose).apply(null,arguments)},a._Abs=function(){return(a._Abs=a.asm.Abs).apply(null,arguments)},a._Acos=function(){return(a._Acos=a.asm.Acos).apply(null,arguments)},a._Acosh=function(){return(a._Acosh=a.asm.Acosh).apply(null,arguments)},a._Add=function(){return(a._Add=a.asm.Add).apply(null,arguments)},a._AddN=function(){return(a._AddN=a.asm.AddN).apply(null,arguments)},a._All=function(){return(a._All=a.asm.All).apply(null,arguments)},a._Any=function(){return(a._Any=a.asm.Any).apply(null,arguments)},a._ArgMax=function(){return(a._ArgMax=a.asm.ArgMax).apply(null,arguments)},a._ArgMin=function(){return(a._ArgMin=a.asm.ArgMin).apply(null,arguments)},a._Asin=function(){return(a._Asin=a.asm.Asin).apply(null,arguments)},a._Asinh=function(){return(a._Asinh=a.asm.Asinh).apply(null,arguments)},a._Atan=function(){return(a._Atan=a.asm.Atan).apply(null,arguments)},a._Atan2=function(){return(a._Atan2=a.asm.Atan2).apply(null,arguments)},a._Atanh=function(){return(a._Atanh=a.asm.Atanh).apply(null,arguments)},a._AvgPool=function(){return(a._AvgPool=a.asm.AvgPool).apply(null,arguments)},a._AvgPool3D=function(){return(a._AvgPool3D=a.asm.AvgPool3D).apply(null,arguments)},a._AvgPool3DGrad=function(){return(a._AvgPool3DGrad=a.asm.AvgPool3DGrad).apply(null,arguments)},a._AvgPoolGrad=function(){return(a._AvgPoolGrad=a.asm.AvgPoolGrad).apply(null,arguments)},a._BatchMatMul=function(){return(a._BatchMatMul=a.asm.BatchMatMul).apply(null,arguments)},a._Bincount=function(){return(a._Bincount=a.asm.Bincount).apply(null,arguments)},a._BitwiseAnd=function(){return(a._BitwiseAnd=a.asm.BitwiseAnd).apply(null,arguments)},a._Ceil=function(){return(a._Ceil=a.asm.Ceil).apply(null,arguments)},a._ClipByValue=function(){return(a._ClipByValue=a.asm.ClipByValue).apply(null,arguments)},a._Conv2D=function(){return(a._Conv2D=a.asm.Conv2D).apply(null,arguments)},a._Conv2DBackpropInput=function(){return(a._Conv2DBackpropInput=a.asm.Conv2DBackpropInput).apply(null,arguments)},a._Conv3D=function(){return(a._Conv3D=a.asm.Conv3D).apply(null,arguments)},a._Conv3DBackpropFilterV2=function(){return(a._Conv3DBackpropFilterV2=a.asm.Conv3DBackpropFilterV2).apply(null,arguments)},a._Conv3DBackpropInputV2=function(){return(a._Conv3DBackpropInputV2=a.asm.Conv3DBackpropInputV2).apply(null,arguments)},a._Cos=function(){return(a._Cos=a.asm.Cos).apply(null,arguments)},a._Cosh=function(){return(a._Cosh=a.asm.Cosh).apply(null,arguments)},a._CropAndResize=function(){return(a._CropAndResize=a.asm.CropAndResize).apply(null,arguments)},a._Cumprod=function(){return(a._Cumprod=a.asm.Cumprod).apply(null,arguments)},a._Cumsum=function(){return(a._Cumsum=a.asm.Cumsum).apply(null,arguments)},a._DenseBincount=function(){return(a._DenseBincount=a.asm.DenseBincount).apply(null,arguments)},a._DepthToSpace=function(){return(a._DepthToSpace=a.asm.DepthToSpace).apply(null,arguments)},a._DepthwiseConv2dNative=function(){return(a._DepthwiseConv2dNative=a.asm.DepthwiseConv2dNative).apply(null,arguments)},a._Diag=function(){return(a._Diag=a.asm.Diag).apply(null,arguments)},a._Dilation2D=function(){return(a._Dilation2D=a.asm.Dilation2D).apply(null,arguments)},a._Dilation2DBackpropFilter=function(){return(a._Dilation2DBackpropFilter=a.asm.Dilation2DBackpropFilter).apply(null,arguments)},a._Dilation2DBackpropInput=function(){return(a._Dilation2DBackpropInput=a.asm.Dilation2DBackpropInput).apply(null,arguments)},a._Elu=function(){return(a._Elu=a.asm.Elu).apply(null,arguments)},a._EluGrad=function(){return(a._EluGrad=a.asm.EluGrad).apply(null,arguments)},a._Equal=function(){return(a._Equal=a.asm.Equal).apply(null,arguments)},a._Erf=function(){return(a._Erf=a.asm.Erf).apply(null,arguments)},a._Exp=function(){return(a._Exp=a.asm.Exp).apply(null,arguments)},a._Expm1=function(){return(a._Expm1=a.asm.Expm1).apply(null,arguments)},a._FlipLeftRight=function(){return(a._FlipLeftRight=a.asm.FlipLeftRight).apply(null,arguments)},a._Floor=function(){return(a._Floor=a.asm.Floor).apply(null,arguments)},a._FloorDiv=function(){return(a._FloorDiv=a.asm.FloorDiv).apply(null,arguments)},a._FusedBatchNorm=function(){return(a._FusedBatchNorm=a.asm.FusedBatchNorm).apply(null,arguments)},a._FusedConv2D=function(){return(a._FusedConv2D=a.asm.FusedConv2D).apply(null,arguments)},a._FusedDepthwiseConv2D=function(){return(a._FusedDepthwiseConv2D=a.asm.FusedDepthwiseConv2D).apply(null,arguments)},a._Gather=function(){return(a._Gather=a.asm.Gather).apply(null,arguments)},a._GatherNd=function(){return(a._GatherNd=a.asm.GatherNd).apply(null,arguments)},a._Greater=function(){return(a._Greater=a.asm.Greater).apply(null,arguments)},a._GreaterEqual=function(){return(a._GreaterEqual=a.asm.GreaterEqual).apply(null,arguments)},a._IsFinite=function(){return(a._IsFinite=a.asm.IsFinite).apply(null,arguments)},a._IsInf=function(){return(a._IsInf=a.asm.IsInf).apply(null,arguments)},a._IsNan=function(){return(a._IsNan=a.asm.IsNan).apply(null,arguments)},a._LRN=function(){return(a._LRN=a.asm.LRN).apply(null,arguments)},a._LRNGrad=function(){return(a._LRNGrad=a.asm.LRNGrad).apply(null,arguments)},a._LeakyRelu=function(){return(a._LeakyRelu=a.asm.LeakyRelu).apply(null,arguments)},a._Less=function(){return(a._Less=a.asm.Less).apply(null,arguments)},a._LessEqual=function(){return(a._LessEqual=a.asm.LessEqual).apply(null,arguments)},a._LinSpace=function(){return(a._LinSpace=a.asm.LinSpace).apply(null,arguments)},a._Log=function(){return(a._Log=a.asm.Log).apply(null,arguments)},a._Log1p=function(){return(a._Log1p=a.asm.Log1p).apply(null,arguments)},a._LogicalAnd=function(){return(a._LogicalAnd=a.asm.LogicalAnd).apply(null,arguments)},a._LogicalNot=function(){return(a._LogicalNot=a.asm.LogicalNot).apply(null,arguments)},a._LogicalOr=function(){return(a._LogicalOr=a.asm.LogicalOr).apply(null,arguments)},a._LogicalXor=function(){return(a._LogicalXor=a.asm.LogicalXor).apply(null,arguments)},a._Max=function(){return(a._Max=a.asm.Max).apply(null,arguments)},a._MaxPool=function(){return(a._MaxPool=a.asm.MaxPool).apply(null,arguments)},a._MaxPool3D=function(){return(a._MaxPool3D=a.asm.MaxPool3D).apply(null,arguments)},a._MaxPool3DGrad=function(){return(a._MaxPool3DGrad=a.asm.MaxPool3DGrad).apply(null,arguments)},a._MaxPoolGrad=function(){return(a._MaxPoolGrad=a.asm.MaxPoolGrad).apply(null,arguments)},a._MaxPoolWithArgmax=function(){return(a._MaxPoolWithArgmax=a.asm.MaxPoolWithArgmax).apply(null,arguments)},a._Maximum=function(){return(a._Maximum=a.asm.Maximum).apply(null,arguments)},a._Mean=function(){return(a._Mean=a.asm.Mean).apply(null,arguments)},a._Min=function(){return(a._Min=a.asm.Min).apply(null,arguments)},a._Minimum=function(){return(a._Minimum=a.asm.Minimum).apply(null,arguments)},a._MirrorPad=function(){return(a._MirrorPad=a.asm.MirrorPad).apply(null,arguments)},a._Mod=function(){return(a._Mod=a.asm.Mod).apply(null,arguments)},a._Multinomial=function(){return(a._Multinomial=a.asm.Multinomial).apply(null,arguments)},a._Multiply=function(){return(a._Multiply=a.asm.Multiply).apply(null,arguments)},a._Neg=function(){return(a._Neg=a.asm.Neg).apply(null,arguments)},a._NonMaxSuppressionV3=function(){return(a._NonMaxSuppressionV3=a.asm.NonMaxSuppressionV3).apply(null,arguments)},a._NonMaxSuppressionV4=function(){return(a._NonMaxSuppressionV4=a.asm.NonMaxSuppressionV4).apply(null,arguments)},a._NonMaxSuppressionV5=function(){return(a._NonMaxSuppressionV5=a.asm.NonMaxSuppressionV5).apply(null,arguments)},a._NotEqual=function(){return(a._NotEqual=a.asm.NotEqual).apply(null,arguments)},a._OneHot=function(){return(a._OneHot=a.asm.OneHot).apply(null,arguments)},a._PadV2=function(){return(a._PadV2=a.asm.PadV2).apply(null,arguments)},a._Pow=function(){return(a._Pow=a.asm.Pow).apply(null,arguments)},a._Prelu=function(){return(a._Prelu=a.asm.Prelu).apply(null,arguments)},a._Prod=function(){return(a._Prod=a.asm.Prod).apply(null,arguments)},a._RealDiv=function(){return(a._RealDiv=a.asm.RealDiv).apply(null,arguments)},a._Reciprocal=function(){return(a._Reciprocal=a.asm.Reciprocal).apply(null,arguments)},a._Relu=function(){return(a._Relu=a.asm.Relu).apply(null,arguments)},a._Relu6=function(){return(a._Relu6=a.asm.Relu6).apply(null,arguments)},a._ResizeBilinear=function(){return(a._ResizeBilinear=a.asm.ResizeBilinear).apply(null,arguments)},a._ResizeBilinearGrad=function(){return(a._ResizeBilinearGrad=a.asm.ResizeBilinearGrad).apply(null,arguments)},a._ResizeNearestNeighbor=function(){return(a._ResizeNearestNeighbor=a.asm.ResizeNearestNeighbor).apply(null,arguments)},a._ResizeNearestNeighborGrad=function(){return(a._ResizeNearestNeighborGrad=a.asm.ResizeNearestNeighborGrad).apply(null,arguments)},a._Reverse=function(){return(a._Reverse=a.asm.Reverse).apply(null,arguments)},a._RotateWithOffset=function(){return(a._RotateWithOffset=a.asm.RotateWithOffset).apply(null,arguments)},a._Round=function(){return(a._Round=a.asm.Round).apply(null,arguments)},a._Rsqrt=function(){return(a._Rsqrt=a.asm.Rsqrt).apply(null,arguments)},a._ScatterNd=function(){return(a._ScatterNd=a.asm.ScatterNd).apply(null,arguments)},a._SearchSorted=function(){return(a._SearchSorted=a.asm.SearchSorted).apply(null,arguments)},a._SelectV2=function(){return(a._SelectV2=a.asm.SelectV2).apply(null,arguments)},a._Selu=function(){return(a._Selu=a.asm.Selu).apply(null,arguments)},a._Sigmoid=function(){return(a._Sigmoid=a.asm.Sigmoid).apply(null,arguments)},a._Sign=function(){return(a._Sign=a.asm.Sign).apply(null,arguments)},a._Sin=function(){return(a._Sin=a.asm.Sin).apply(null,arguments)},a._Sinh=function(){return(a._Sinh=a.asm.Sinh).apply(null,arguments)},a._Softmax=function(){return(a._Softmax=a.asm.Softmax).apply(null,arguments)},a._Softplus=function(){return(a._Softplus=a.asm.Softplus).apply(null,arguments)},a._SparseFillEmptyRows=function(){return(a._SparseFillEmptyRows=a.asm.SparseFillEmptyRows).apply(null,arguments)},a._SparseReshape=function(){return(a._SparseReshape=a.asm.SparseReshape).apply(null,arguments)},a._SparseSegmentReduction=function(){return(a._SparseSegmentReduction=a.asm.SparseSegmentReduction).apply(null,arguments)},a._SparseToDense=function(){return(a._SparseToDense=a.asm.SparseToDense).apply(null,arguments)},a._Sqrt=function(){return(a._Sqrt=a.asm.Sqrt).apply(null,arguments)},a._Square=function(){return(a._Square=a.asm.Square).apply(null,arguments)},a._SquaredDifference=function(){return(a._SquaredDifference=a.asm.SquaredDifference).apply(null,arguments)},a._Step=function(){return(a._Step=a.asm.Step).apply(null,arguments)},a._StridedSlice=function(){return(a._StridedSlice=a.asm.StridedSlice).apply(null,arguments)},a._Sub=function(){return(a._Sub=a.asm.Sub).apply(null,arguments)},a._Sum=function(){return(a._Sum=a.asm.Sum).apply(null,arguments)},a._Tan=function(){return(a._Tan=a.asm.Tan).apply(null,arguments)},a._Tanh=function(){return(a._Tanh=a.asm.Tanh).apply(null,arguments)},a._TensorScatterUpdate=function(){return(a._TensorScatterUpdate=a.asm.TensorScatterUpdate).apply(null,arguments)},a._Tile=function(){return(a._Tile=a.asm.Tile).apply(null,arguments)},a._TopK=function(){return(a._TopK=a.asm.TopK).apply(null,arguments)},a._Transform=function(){return(a._Transform=a.asm.Transform).apply(null,arguments)},a._Transpose=function(){return(a._Transpose=a.asm.Transpose).apply(null,arguments)},a.__FusedMatMul=function(){return(a.__FusedMatMul=a.asm._FusedMatMul).apply(null,arguments)},a._malloc=function(){return(a._malloc=a.asm.malloc).apply(null,arguments)},a._free=function(){return(a._free=a.asm.free).apply(null,arguments)},a.___errno_location=function(){return(a.___errno_location=a.asm.__errno_location).apply(null,arguments)};var Et=a.stackSave=function(){return(Et=a.stackSave=a.asm.stackSave).apply(null,arguments)},Bt=a.stackRestore=function(){return(Bt=a.stackRestore=a.asm.stackRestore).apply(null,arguments)},kt=a.stackAlloc=function(){return(kt=a.stackAlloc=a.asm.stackAlloc).apply(null,arguments)};a.dynCall_iijjiiii=function(){return(a.dynCall_iijjiiii=a.asm.dynCall_iijjiiii).apply(null,arguments)},a.dynCall_jiji=function(){return(a.dynCall_jiji=a.asm.dynCall_jiji).apply(null,arguments)},a.cwrap=pt;var Zt;Ae=function X(){Zt||At(),Zt||(Ae=X)};function At(X){if(ve>0||(ee(),ve>0))return;function he(){Zt||(Zt=!0,a.calledRun=!0,!T&&(Y(),i(a),a.onRuntimeInitialized&&a.onRuntimeInitialized(),de()))}a.setStatus?(a.setStatus("Running..."),setTimeout(function(){setTimeout(function(){a.setStatus("")},1),he()},1)):he()}if(a.preInit)for(typeof a.preInit=="function"&&(a.preInit=[a.preInit]);a.preInit.length>0;)a.preInit.pop()();At();var In;u&&(In={uncaughtException:process.listeners("uncaughtException").filter(function(X){return!u.uncaughtException.indexOf(X)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(X){return!u.unhandledRejection.indexOf(X)>-1})});var Un;if(typeof s<"u")Un=s;else if(typeof WasmBackendModuleThreadedSimd<"u")Un=WasmBackendModuleThreadedSimd;else throw new Error("Could not find wasm module in post.js");if(In){var Kn=Un._dispose;Un._dispose=function(){Kn(),In.uncaughtException.forEach(function(X){process.removeListener("uncaughtException",X)}),In.unhandledRejection.forEach(function(X){process.removeListener("unhandledRejection",X)})}}return s.ready})})();e.exports=n})(Bk)),Bk.exports}var dK=Zlt();const hK=ow(dK),eut=OS({__proto__:null,default:hK},[dK]);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NF=cK||Qlt,tut=hK||eut;class nut extends Pv{constructor(t){super(),this.wasm=t,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(out),this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new sE(this,Fi())}write(t,n,r){const s={id:this.dataIdNextNumber++};return this.move(s,t,n,r,1),s}numDataIds(){return this.dataIdMap.numDataIds()}async time(t){const n=ws();return t(),{kernelMs:ws()-n}}move(t,n,r,s,a){const i=this.dataIdNextNumber++;if(s==="string"){const l=n;this.dataIdMap.set(t,{id:i,stringBytes:l,shape:r,dtype:s,memoryOffset:null,refCount:a});return}const o=fe(r),u=o*Jp(s),c=this.wasm._malloc(u)>>>0;this.dataIdMap.set(t,{id:i,memoryOffset:c,shape:r,dtype:s,refCount:a}),this.wasm.tfjs.registerTensor(i,o,c),n!=null&&this.wasm.HEAPU8.set(new Uint8Array(n.buffer,n.byteOffset,u),c)}async read(t){return this.readSync(t)}readSync(t,n,r){const{memoryOffset:s,dtype:a,shape:i,stringBytes:o}=this.dataIdMap.get(t);if(a==="string")return(n==null||n===0)&&(r==null||r>=o.length)?o:o.slice(n,r);n=n||0,r=r||fe(i);const u=Jp(a),c=this.wasm.HEAPU8.slice(s+n*u,s+r*u);return aut(c.buffer,a)}disposeData(t,n=!1){if(this.dataIdMap.has(t)){const r=this.dataIdMap.get(t);if(r.refCount--,!n&&r.refCount>0)return!1;this.wasm._free(r.memoryOffset),this.wasm.tfjs.disposeData(r.id),this.dataIdMap.delete(t)}return!0}refCount(t){return this.dataIdMap.has(t)?this.dataIdMap.get(t).refCount:0}incRef(t){const n=this.dataIdMap.get(t);n!=null&&n.refCount++}floatPrecision(){return 32}getMemoryOffset(t){return this.dataIdMap.get(t).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(t,n,r,s){let a;if(r==null)a=this.write(s??null,t,n);else{const i=this.dataIdNextNumber++;a={id:i},this.dataIdMap.set(a,{id:i,memoryOffset:r,shape:t,dtype:n,refCount:1});const o=fe(t);this.wasm.tfjs.registerTensor(i,o,r)}return{dataId:a,shape:t,dtype:n}}typedArrayFromHeap({shape:t,dtype:n,dataId:r}){const s=this.wasm.HEAPU8.buffer,{memoryOffset:a}=this.dataIdMap.get(r),i=fe(t);switch(n){case"float32":return new Float32Array(s,a,i);case"int32":return new Int32Array(s,a,i);case"bool":return new Uint8Array(s,a,i);default:throw new Error(`Unknown dtype ${n}`)}}}function rut(e,t,n){let r="tfjs-backend-wasm.wasm";return e&&t?r="tfjs-backend-wasm-threaded-simd.wasm":e&&(r="tfjs-backend-wasm-simd.wasm"),zk!=null&&zk[r]!=null?zk[r]:n+r}async function sut(){const[e,t]=await Promise.all([ke().getAsync("WASM_HAS_SIMD_SUPPORT"),ke().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise((n,r)=>{const s={};s.locateFile=(o,u)=>{if(o.endsWith(".worker.js")){const c=Jlt.wasmWorkerContents.replace(/\n/g,"\\n"),l=new Blob([c],{type:"application/javascript"});return URL.createObjectURL(l)}return o.endsWith(".wasm")?rut(e,t,u):u+o};let a=!1;s.onAbort=()=>{if(a||Wk)return;Wk=!0,r({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"})};let i;t&&e&&iut==null?(s.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+NF.toString()],{type:"text/javascript"}),i=NF(s)):i=tut(s),i.then(o=>{a=!0,Wk=!1;const u=null;o.tfjs={init:o.cwrap("init",null,[]),initWithThreadsCount:o.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:o.cwrap("get_threads_count","number",[]),registerTensor:o.cwrap("register_tensor",null,["number","number","number"]),disposeData:o.cwrap("dispose_data",u,["number"]),dispose:o.cwrap("dispose",u,[])},n({wasm:o})}).catch(r)})}function aut(e,t){switch(t){case"float32":return new Float32Array(e);case"int32":return new Int32Array(e);case"bool":return new Uint8Array(e);default:throw new Error(`Unknown dtype ${t}`)}}let iut=null,zk={},Wk=!1,out=-1;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lut=2;_E("wasm",async()=>{const{wasm:e}=await sut();return new nut(e)},lut);var Vk={exports:{}};/*!
 * Pusher JavaScript Library v8.4.0
 * https://pusher.com/
 *
 * Copyright 2020, Pusher
 * Released under the MIT licence.
 */var TF;function uut(){return TF||(TF=1,(function(e,t){(function(r,s){e.exports=s()})(window,function(){return(function(n){var r={};function s(a){if(r[a])return r[a].exports;var i=r[a]={i:a,l:!1,exports:{}};return n[a].call(i.exports,i,i.exports,s),i.l=!0,i.exports}return s.m=n,s.c=r,s.d=function(a,i,o){s.o(a,i)||Object.defineProperty(a,i,{enumerable:!0,get:o})},s.r=function(a){typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(a,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(a,"__esModule",{value:!0})},s.t=function(a,i){if(i&1&&(a=s(a)),i&8||i&4&&typeof a=="object"&&a&&a.__esModule)return a;var o=Object.create(null);if(s.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:a}),i&2&&typeof a!="string")for(var u in a)s.d(o,u,(function(c){return a[c]}).bind(null,u));return o},s.n=function(a){var i=a&&a.__esModule?(function(){return a.default}):(function(){return a});return s.d(i,"a",i),i},s.o=function(a,i){return Object.prototype.hasOwnProperty.call(a,i)},s.p="",s(s.s=2)})([(function(n,r,s){var a=this&&this.__extends||(function(){var m=function(g,b){return m=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(y,x){y.__proto__=x}||function(y,x){for(var w in x)x.hasOwnProperty(w)&&(y[w]=x[w])},m(g,b)};return function(g,b){m(g,b);function y(){this.constructor=g}g.prototype=b===null?Object.create(b):(y.prototype=b.prototype,new y)}})();Object.defineProperty(r,"__esModule",{value:!0});var i=256,o=(function(){function m(g){g===void 0&&(g="="),this._paddingCharacter=g}return m.prototype.encodedLength=function(g){return this._paddingCharacter?(g+2)/3*4|0:(g*8+5)/6|0},m.prototype.encode=function(g){for(var b="",y=0;y<g.length-2;y+=3){var x=g[y]<<16|g[y+1]<<8|g[y+2];b+=this._encodeByte(x>>>18&63),b+=this._encodeByte(x>>>12&63),b+=this._encodeByte(x>>>6&63),b+=this._encodeByte(x>>>0&63)}var w=g.length-y;if(w>0){var x=g[y]<<16|(w===2?g[y+1]<<8:0);b+=this._encodeByte(x>>>18&63),b+=this._encodeByte(x>>>12&63),w===2?b+=this._encodeByte(x>>>6&63):b+=this._paddingCharacter||"",b+=this._paddingCharacter||""}return b},m.prototype.maxDecodedLength=function(g){return this._paddingCharacter?g/4*3|0:(g*6+7)/8|0},m.prototype.decodedLength=function(g){return this.maxDecodedLength(g.length-this._getPaddingLength(g))},m.prototype.decode=function(g){if(g.length===0)return new Uint8Array(0);for(var b=this._getPaddingLength(g),y=g.length-b,x=new Uint8Array(this.maxDecodedLength(y)),w=0,v=0,I=0,N=0,T=0,E=0,A=0;v<y-4;v+=4)N=this._decodeChar(g.charCodeAt(v+0)),T=this._decodeChar(g.charCodeAt(v+1)),E=this._decodeChar(g.charCodeAt(v+2)),A=this._decodeChar(g.charCodeAt(v+3)),x[w++]=N<<2|T>>>4,x[w++]=T<<4|E>>>2,x[w++]=E<<6|A,I|=N&i,I|=T&i,I|=E&i,I|=A&i;if(v<y-1&&(N=this._decodeChar(g.charCodeAt(v)),T=this._decodeChar(g.charCodeAt(v+1)),x[w++]=N<<2|T>>>4,I|=N&i,I|=T&i),v<y-2&&(E=this._decodeChar(g.charCodeAt(v+2)),x[w++]=T<<4|E>>>2,I|=E&i),v<y-3&&(A=this._decodeChar(g.charCodeAt(v+3)),x[w++]=E<<6|A,I|=A&i),I!==0)throw new Error("Base64Coder: incorrect characters for decoding");return x},m.prototype._encodeByte=function(g){var b=g;return b+=65,b+=25-g>>>8&6,b+=51-g>>>8&-75,b+=61-g>>>8&-15,b+=62-g>>>8&3,String.fromCharCode(b)},m.prototype._decodeChar=function(g){var b=i;return b+=(42-g&g-44)>>>8&-i+g-43+62,b+=(46-g&g-48)>>>8&-i+g-47+63,b+=(47-g&g-58)>>>8&-i+g-48+52,b+=(64-g&g-91)>>>8&-i+g-65+0,b+=(96-g&g-123)>>>8&-i+g-97+26,b},m.prototype._getPaddingLength=function(g){var b=0;if(this._paddingCharacter){for(var y=g.length-1;y>=0&&g[y]===this._paddingCharacter;y--)b++;if(g.length<4||b>2)throw new Error("Base64Coder: incorrect padding")}return b},m})();r.Coder=o;var u=new o;function c(m){return u.encode(m)}r.encode=c;function l(m){return u.decode(m)}r.decode=l;var d=(function(m){a(g,m);function g(){return m!==null&&m.apply(this,arguments)||this}return g.prototype._encodeByte=function(b){var y=b;return y+=65,y+=25-b>>>8&6,y+=51-b>>>8&-75,y+=61-b>>>8&-13,y+=62-b>>>8&49,String.fromCharCode(y)},g.prototype._decodeChar=function(b){var y=i;return y+=(44-b&b-46)>>>8&-i+b-45+62,y+=(94-b&b-96)>>>8&-i+b-95+63,y+=(47-b&b-58)>>>8&-i+b-48+52,y+=(64-b&b-91)>>>8&-i+b-65+0,y+=(96-b&b-123)>>>8&-i+b-97+26,y},g})(o);r.URLSafeCoder=d;var h=new d;function p(m){return h.encode(m)}r.encodeURLSafe=p;function f(m){return h.decode(m)}r.decodeURLSafe=f,r.encodedLength=function(m){return u.encodedLength(m)},r.maxDecodedLength=function(m){return u.maxDecodedLength(m)},r.decodedLength=function(m){return u.decodedLength(m)}}),(function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0});var a="utf8: invalid string",i="utf8: invalid source encoding";function o(l){for(var d=new Uint8Array(u(l)),h=0,p=0;p<l.length;p++){var f=l.charCodeAt(p);f<128?d[h++]=f:f<2048?(d[h++]=192|f>>6,d[h++]=128|f&63):f<55296?(d[h++]=224|f>>12,d[h++]=128|f>>6&63,d[h++]=128|f&63):(p++,f=(f&1023)<<10,f|=l.charCodeAt(p)&1023,f+=65536,d[h++]=240|f>>18,d[h++]=128|f>>12&63,d[h++]=128|f>>6&63,d[h++]=128|f&63)}return d}r.encode=o;function u(l){for(var d=0,h=0;h<l.length;h++){var p=l.charCodeAt(h);if(p<128)d+=1;else if(p<2048)d+=2;else if(p<55296)d+=3;else if(p<=57343){if(h>=l.length-1)throw new Error(a);h++,d+=4}else throw new Error(a)}return d}r.encodedLength=u;function c(l){for(var d=[],h=0;h<l.length;h++){var p=l[h];if(p&128){var f=void 0;if(p<224){if(h>=l.length)throw new Error(i);var m=l[++h];if((m&192)!==128)throw new Error(i);p=(p&31)<<6|m&63,f=128}else if(p<240){if(h>=l.length-1)throw new Error(i);var m=l[++h],g=l[++h];if((m&192)!==128||(g&192)!==128)throw new Error(i);p=(p&15)<<12|(m&63)<<6|g&63,f=2048}else if(p<248){if(h>=l.length-2)throw new Error(i);var m=l[++h],g=l[++h],b=l[++h];if((m&192)!==128||(g&192)!==128||(b&192)!==128)throw new Error(i);p=(p&15)<<18|(m&63)<<12|(g&63)<<6|b&63,f=65536}else throw new Error(i);if(p<f||p>=55296&&p<=57343)throw new Error(i);if(p>=65536){if(p>1114111)throw new Error(i);p-=65536,d.push(String.fromCharCode(55296|p>>10)),p=56320|p&1023}}d.push(String.fromCharCode(p))}return d.join("")}r.decode=c}),(function(n,r,s){n.exports=s(3).default}),(function(n,r,s){s.r(r);class a{constructor(S,D){this.lastId=0,this.prefix=S,this.name=D}create(S){this.lastId++;var D=this.lastId,j=this.prefix+D,te=this.name+"["+D+"]",De=!1,Qe=function(){De||(S.apply(null,arguments),De=!0)};return this[D]=Qe,{number:D,id:j,name:te,callback:Qe}}remove(S){delete this[S.number]}}var i=new a("_pusher_script_","Pusher.ScriptReceivers"),o={VERSION:"8.4.0",PROTOCOL:7,wsPort:80,wssPort:443,wsPath:"",httpHost:"sockjs.pusher.com",httpPort:80,httpsPort:443,httpPath:"/pusher",stats_host:"stats.pusher.com",authEndpoint:"/pusher/auth",authTransport:"ajax",activityTimeout:12e4,pongTimeout:3e4,unavailableTimeout:1e4,userAuthentication:{endpoint:"/pusher/user-auth",transport:"ajax"},channelAuthorization:{endpoint:"/pusher/auth",transport:"ajax"},cdn_http:"http://js.pusher.com",cdn_https:"https://js.pusher.com",dependency_suffix:""},u=o;class c{constructor(S){this.options=S,this.receivers=S.receivers||i,this.loading={}}load(S,D,j){var te=this;if(te.loading[S]&&te.loading[S].length>0)te.loading[S].push(j);else{te.loading[S]=[j];var De=Dt.createScriptRequest(te.getPath(S,D)),Qe=te.receivers.create(function(It){if(te.receivers.remove(Qe),te.loading[S]){var Vt=te.loading[S];delete te.loading[S];for(var kn=function(Pr){Pr||De.cleanup()},On=0;On<Vt.length;On++)Vt[On](It,kn)}});De.send(Qe)}}getRoot(S){var D,j=Dt.getDocument().location.protocol;return S&&S.useTLS||j==="https:"?D=this.options.cdn_https:D=this.options.cdn_http,D.replace(/\/*$/,"")+"/"+this.options.version}getPath(S,D){return this.getRoot(D)+"/"+S+this.options.suffix+".js"}}var l=new a("_pusher_dependencies","Pusher.DependenciesReceivers"),d=new c({cdn_http:u.cdn_http,cdn_https:u.cdn_https,version:u.VERSION,suffix:u.dependency_suffix,receivers:l});const h={baseUrl:"https://pusher.com",urls:{authenticationEndpoint:{path:"/docs/channels/server_api/authenticating_users"},authorizationEndpoint:{path:"/docs/channels/server_api/authorizing-users/"},javascriptQuickStart:{path:"/docs/javascript_quick_start"},triggeringClientEvents:{path:"/docs/client_api_guide/client_events#trigger-events"},encryptedChannelSupport:{fullUrl:"https://github.com/pusher/pusher-js/tree/cc491015371a4bde5743d1c87a0fbac0feb53195#encrypted-channel-support"}}};var f={buildLogSuffix:function(F){const S="See:",D=h.urls[F];if(!D)return"";let j;return D.fullUrl?j=D.fullUrl:D.path&&(j=h.baseUrl+D.path),j?`${S} ${j}`:""}},m;(function(F){F.UserAuthentication="user-authentication",F.ChannelAuthorization="channel-authorization"})(m||(m={}));class g extends Error{constructor(S){super(S),Object.setPrototypeOf(this,new.target.prototype)}}class b extends Error{constructor(S){super(S),Object.setPrototypeOf(this,new.target.prototype)}}class y extends Error{constructor(S){super(S),Object.setPrototypeOf(this,new.target.prototype)}}class x extends Error{constructor(S){super(S),Object.setPrototypeOf(this,new.target.prototype)}}class w extends Error{constructor(S){super(S),Object.setPrototypeOf(this,new.target.prototype)}}class v extends Error{constructor(S){super(S),Object.setPrototypeOf(this,new.target.prototype)}}class I extends Error{constructor(S){super(S),Object.setPrototypeOf(this,new.target.prototype)}}class N extends Error{constructor(S){super(S),Object.setPrototypeOf(this,new.target.prototype)}}class T extends Error{constructor(S,D){super(D),this.status=S,Object.setPrototypeOf(this,new.target.prototype)}}var A=function(F,S,D,j,te){const De=Dt.createXHR();De.open("POST",D.endpoint,!0),De.setRequestHeader("Content-Type","application/x-www-form-urlencoded");for(var Qe in D.headers)De.setRequestHeader(Qe,D.headers[Qe]);if(D.headersProvider!=null){let It=D.headersProvider();for(var Qe in It)De.setRequestHeader(Qe,It[Qe])}return De.onreadystatechange=function(){if(De.readyState===4)if(De.status===200){let It,Vt=!1;try{It=JSON.parse(De.responseText),Vt=!0}catch{te(new T(200,`JSON returned from ${j.toString()} endpoint was invalid, yet status code was 200. Data was: ${De.responseText}`),null)}Vt&&te(null,It)}else{let It="";switch(j){case m.UserAuthentication:It=f.buildLogSuffix("authenticationEndpoint");break;case m.ChannelAuthorization:It=`Clients must be authorized to join private or presence channels. ${f.buildLogSuffix("authorizationEndpoint")}`;break}te(new T(De.status,`Unable to retrieve auth string from ${j.toString()} endpoint - received status: ${De.status} from ${D.endpoint}. ${It}`),null)}},De.send(S),De};function k(F){return G(O(F))}var C=String.fromCharCode,M="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",L=function(F){var S=F.charCodeAt(0);return S<128?F:S<2048?C(192|S>>>6)+C(128|S&63):C(224|S>>>12&15)+C(128|S>>>6&63)+C(128|S&63)},O=function(F){return F.replace(/[^\x00-\x7F]/g,L)},B=function(F){var S=[0,2,1][F.length%3],D=F.charCodeAt(0)<<16|(F.length>1?F.charCodeAt(1):0)<<8|(F.length>2?F.charCodeAt(2):0),j=[M.charAt(D>>>18),M.charAt(D>>>12&63),S>=2?"=":M.charAt(D>>>6&63),S>=1?"=":M.charAt(D&63)];return j.join("")},G=window.btoa||function(F){return F.replace(/[\s\S]{1,3}/g,B)};class z{constructor(S,D,j,te){this.clear=D,this.timer=S(()=>{this.timer&&(this.timer=te(this.timer))},j)}isRunning(){return this.timer!==null}ensureAborted(){this.timer&&(this.clear(this.timer),this.timer=null)}}var q=z;function Q(F){window.clearTimeout(F)}function K(F){window.clearInterval(F)}class ee extends q{constructor(S,D){super(setTimeout,Q,S,function(j){return D(),null})}}class Y extends q{constructor(S,D){super(setInterval,K,S,function(j){return D(),j})}}var de={now(){return Date.now?Date.now():new Date().valueOf()},defer(F){return new ee(0,F)},method(F,...S){var D=Array.prototype.slice.call(arguments,1);return function(j){return j[F].apply(j,D.concat(arguments))}}},ue=de;function Ie(F,...S){for(var D=0;D<S.length;D++){var j=S[D];for(var te in j)j[te]&&j[te].constructor&&j[te].constructor===Object?F[te]=Ie(F[te]||{},j[te]):F[te]=j[te]}return F}function Ee(){for(var F=["Pusher"],S=0;S<arguments.length;S++)typeof arguments[S]=="string"?F.push(arguments[S]):F.push(nn(arguments[S]));return F.join(" : ")}function ve(F,S){var D=Array.prototype.indexOf;if(F===null)return-1;if(D&&F.indexOf===D)return F.indexOf(S);for(var j=0,te=F.length;j<te;j++)if(F[j]===S)return j;return-1}function Ae(F,S){for(var D in F)Object.prototype.hasOwnProperty.call(F,D)&&S(F[D],D,F)}function Be(F){var S=[];return Ae(F,function(D,j){S.push(j)}),S}function Ue(F){var S=[];return Ae(F,function(D){S.push(D)}),S}function qe(F,S,D){for(var j=0;j<F.length;j++)S.call(D||window,F[j],j,F)}function ut(F,S){for(var D=[],j=0;j<F.length;j++)D.push(S(F[j],j,F,D));return D}function nt(F,S){var D={};return Ae(F,function(j,te){D[te]=S(j)}),D}function rt(F,S){S=S||function(te){return!!te};for(var D=[],j=0;j<F.length;j++)S(F[j],j,F,D)&&D.push(F[j]);return D}function ze(F,S){var D={};return Ae(F,function(j,te){(S&&S(j,te,F,D)||j)&&(D[te]=j)}),D}function ct(F){var S=[];return Ae(F,function(D,j){S.push([j,D])}),S}function ht(F,S){for(var D=0;D<F.length;D++)if(S(F[D],D,F))return!0;return!1}function yn(F,S){for(var D=0;D<F.length;D++)if(!S(F[D],D,F))return!1;return!0}function St(F){return nt(F,function(S){return typeof S=="object"&&(S=nn(S)),encodeURIComponent(k(S.toString()))})}function pn(F){var S=ze(F,function(j){return j!==void 0}),D=ut(ct(St(S)),ue.method("join","=")).join("&");return D}function jt(F){var S=[],D=[];return(function j(te,De){var Qe,It,Vt;switch(typeof te){case"object":if(!te)return null;for(Qe=0;Qe<S.length;Qe+=1)if(S[Qe]===te)return{$ref:D[Qe]};if(S.push(te),D.push(De),Object.prototype.toString.apply(te)==="[object Array]")for(Vt=[],Qe=0;Qe<te.length;Qe+=1)Vt[Qe]=j(te[Qe],De+"["+Qe+"]");else{Vt={};for(It in te)Object.prototype.hasOwnProperty.call(te,It)&&(Vt[It]=j(te[It],De+"["+JSON.stringify(It)+"]"))}return Vt;case"number":case"string":case"boolean":return te}})(F,"$")}function nn(F){try{return JSON.stringify(F)}catch{return JSON.stringify(jt(F))}}class wn{constructor(){this.globalLog=S=>{window.console&&window.console.log&&window.console.log(S)}}debug(...S){this.log(this.globalLog,S)}warn(...S){this.log(this.globalLogWarn,S)}error(...S){this.log(this.globalLogError,S)}globalLogWarn(S){window.console&&window.console.warn?window.console.warn(S):this.globalLog(S)}globalLogError(S){window.console&&window.console.error?window.console.error(S):this.globalLogWarn(S)}log(S,...D){var j=Ee.apply(this,arguments);KI.log?KI.log(j):KI.logToConsole&&S.bind(this)(j)}}var Tt=new wn,vn=function(F,S,D,j,te){(D.headers!==void 0||D.headersProvider!=null)&&Tt.warn(`To send headers with the ${j.toString()} request, you must use AJAX, rather than JSONP.`);var De=F.nextAuthCallbackID.toString();F.nextAuthCallbackID++;var Qe=F.getDocument(),It=Qe.createElement("script");F.auth_callbacks[De]=function(On){te(null,On)};var Vt="Pusher.auth_callbacks['"+De+"']";It.src=D.endpoint+"?callback="+encodeURIComponent(Vt)+"&"+S;var kn=Qe.getElementsByTagName("head")[0]||Qe.documentElement;kn.insertBefore(It,kn.firstChild)},Kt=vn;class an{constructor(S){this.src=S}send(S){var D=this,j="Error loading "+D.src;D.script=document.createElement("script"),D.script.id=S.id,D.script.src=D.src,D.script.type="text/javascript",D.script.charset="UTF-8",D.script.addEventListener?(D.script.onerror=function(){S.callback(j)},D.script.onload=function(){S.callback(null)}):D.script.onreadystatechange=function(){(D.script.readyState==="loaded"||D.script.readyState==="complete")&&S.callback(null)},D.script.async===void 0&&document.attachEvent&&/opera/i.test(navigator.userAgent)?(D.errorScript=document.createElement("script"),D.errorScript.id=S.id+"_error",D.errorScript.text=S.name+"('"+j+"');",D.script.async=D.errorScript.async=!1):D.script.async=!0;var te=document.getElementsByTagName("head")[0];te.insertBefore(D.script,te.firstChild),D.errorScript&&te.insertBefore(D.errorScript,D.script.nextSibling)}cleanup(){this.script&&(this.script.onload=this.script.onerror=null,this.script.onreadystatechange=null),this.script&&this.script.parentNode&&this.script.parentNode.removeChild(this.script),this.errorScript&&this.errorScript.parentNode&&this.errorScript.parentNode.removeChild(this.errorScript),this.script=null,this.errorScript=null}}class xr{constructor(S,D){this.url=S,this.data=D}send(S){if(!this.request){var D=pn(this.data),j=this.url+"/"+S.number+"?"+D;this.request=Dt.createScriptRequest(j),this.request.send(S)}}cleanup(){this.request&&this.request.cleanup()}}var Re=function(F,S){return function(D,j){var te="http"+(S?"s":"")+"://",De=te+(F.host||F.options.host)+F.options.path,Qe=Dt.createJSONPRequest(De,D),It=Dt.ScriptReceivers.create(function(Vt,kn){i.remove(It),Qe.cleanup(),kn&&kn.host&&(F.host=kn.host),j&&j(Vt,kn)});Qe.send(It)}},re={name:"jsonp",getAgent:Re},$e=re;function Oe(F,S,D){var j=F+(S.useTLS?"s":""),te=S.useTLS?S.hostTLS:S.hostNonTLS;return j+"://"+te+D}function tt(F,S){var D="/app/"+F,j="?protocol="+u.PROTOCOL+"&client=js&version="+u.VERSION+(S?"&"+S:"");return D+j}var Ke={getInitial:function(F,S){var D=(S.httpPath||"")+tt(F,"flash=false");return Oe("ws",S,D)}},pt={getInitial:function(F,S){var D=(S.httpPath||"/pusher")+tt(F);return Oe("http",S,D)}},lt={getInitial:function(F,S){return Oe("http",S,S.httpPath||"/pusher")},getPath:function(F,S){return tt(F)}};class Et{constructor(){this._callbacks={}}get(S){return this._callbacks[Bt(S)]}add(S,D,j){var te=Bt(S);this._callbacks[te]=this._callbacks[te]||[],this._callbacks[te].push({fn:D,context:j})}remove(S,D,j){if(!S&&!D&&!j){this._callbacks={};return}var te=S?[Bt(S)]:Be(this._callbacks);D||j?this.removeCallback(te,D,j):this.removeAllCallbacks(te)}removeCallback(S,D,j){qe(S,function(te){this._callbacks[te]=rt(this._callbacks[te]||[],function(De){return D&&D!==De.fn||j&&j!==De.context}),this._callbacks[te].length===0&&delete this._callbacks[te]},this)}removeAllCallbacks(S){qe(S,function(D){delete this._callbacks[D]},this)}}function Bt(F){return"_"+F}class kt{constructor(S){this.callbacks=new Et,this.global_callbacks=[],this.failThrough=S}bind(S,D,j){return this.callbacks.add(S,D,j),this}bind_global(S){return this.global_callbacks.push(S),this}unbind(S,D,j){return this.callbacks.remove(S,D,j),this}unbind_global(S){return S?(this.global_callbacks=rt(this.global_callbacks||[],D=>D!==S),this):(this.global_callbacks=[],this)}unbind_all(){return this.unbind(),this.unbind_global(),this}emit(S,D,j){for(var te=0;te<this.global_callbacks.length;te++)this.global_callbacks[te](S,D);var De=this.callbacks.get(S),Qe=[];if(j?Qe.push(D,j):D&&Qe.push(D),De&&De.length>0)for(var te=0;te<De.length;te++)De[te].fn.apply(De[te].context||window,Qe);else this.failThrough&&this.failThrough(S,D);return this}}class Zt extends kt{constructor(S,D,j,te,De){super(),this.initialize=Dt.transportConnectionInitializer,this.hooks=S,this.name=D,this.priority=j,this.key=te,this.options=De,this.state="new",this.timeline=De.timeline,this.activityTimeout=De.activityTimeout,this.id=this.timeline.generateUniqueID()}handlesActivityChecks(){return!!this.hooks.handlesActivityChecks}supportsPing(){return!!this.hooks.supportsPing}connect(){if(this.socket||this.state!=="initialized")return!1;var S=this.hooks.urls.getInitial(this.key,this.options);try{this.socket=this.hooks.getSocket(S,this.options)}catch(D){return ue.defer(()=>{this.onError(D),this.changeState("closed")}),!1}return this.bindListeners(),Tt.debug("Connecting",{transport:this.name,url:S}),this.changeState("connecting"),!0}close(){return this.socket?(this.socket.close(),!0):!1}send(S){return this.state==="open"?(ue.defer(()=>{this.socket&&this.socket.send(S)}),!0):!1}ping(){this.state==="open"&&this.supportsPing()&&this.socket.ping()}onOpen(){this.hooks.beforeOpen&&this.hooks.beforeOpen(this.socket,this.hooks.urls.getPath(this.key,this.options)),this.changeState("open"),this.socket.onopen=void 0}onError(S){this.emit("error",{type:"WebSocketError",error:S}),this.timeline.error(this.buildTimelineMessage({error:S.toString()}))}onClose(S){S?this.changeState("closed",{code:S.code,reason:S.reason,wasClean:S.wasClean}):this.changeState("closed"),this.unbindListeners(),this.socket=void 0}onMessage(S){this.emit("message",S)}onActivity(){this.emit("activity")}bindListeners(){this.socket.onopen=()=>{this.onOpen()},this.socket.onerror=S=>{this.onError(S)},this.socket.onclose=S=>{this.onClose(S)},this.socket.onmessage=S=>{this.onMessage(S)},this.supportsPing()&&(this.socket.onactivity=()=>{this.onActivity()})}unbindListeners(){this.socket&&(this.socket.onopen=void 0,this.socket.onerror=void 0,this.socket.onclose=void 0,this.socket.onmessage=void 0,this.supportsPing()&&(this.socket.onactivity=void 0))}changeState(S,D){this.state=S,this.timeline.info(this.buildTimelineMessage({state:S,params:D})),this.emit(S,D)}buildTimelineMessage(S){return Ie({cid:this.id},S)}}class At{constructor(S){this.hooks=S}isSupported(S){return this.hooks.isSupported(S)}createConnection(S,D,j,te){return new Zt(this.hooks,S,D,j,te)}}var In=new At({urls:Ke,handlesActivityChecks:!1,supportsPing:!1,isInitialized:function(){return!!Dt.getWebSocketAPI()},isSupported:function(){return!!Dt.getWebSocketAPI()},getSocket:function(F){return Dt.createWebSocket(F)}}),Un={urls:pt,handlesActivityChecks:!1,supportsPing:!0,isInitialized:function(){return!0}},Kn=Ie({getSocket:function(F){return Dt.HTTPFactory.createStreamingSocket(F)}},Un),X=Ie({getSocket:function(F){return Dt.HTTPFactory.createPollingSocket(F)}},Un),he={isSupported:function(){return Dt.isXHRSupported()}},_e=new At(Ie({},Kn,he)),xe=new At(Ie({},X,he)),wt={ws:In,xhr_streaming:_e,xhr_polling:xe},bt=wt,Xe=new At({file:"sockjs",urls:lt,handlesActivityChecks:!0,supportsPing:!1,isSupported:function(){return!0},isInitialized:function(){return window.SockJS!==void 0},getSocket:function(F,S){return new window.SockJS(F,null,{js_path:d.getPath("sockjs",{useTLS:S.useTLS}),ignore_null_origin:S.ignoreNullOrigin})},beforeOpen:function(F,S){F.send(JSON.stringify({path:S}))}}),Ge={isSupported:function(F){var S=Dt.isXDRSupported(F.useTLS);return S}},$t=new At(Ie({},Kn,Ge)),Mn=new At(Ie({},X,Ge));bt.xdr_streaming=$t,bt.xdr_polling=Mn,bt.sockjs=Xe;var Tr=bt;class wi extends kt{constructor(){super();var S=this;window.addEventListener!==void 0&&(window.addEventListener("online",function(){S.emit("online")},!1),window.addEventListener("offline",function(){S.emit("offline")},!1))}isOnline(){return window.navigator.onLine===void 0?!0:window.navigator.onLine}}var Fa=new wi;class vi{constructor(S,D,j){this.manager=S,this.transport=D,this.minPingDelay=j.minPingDelay,this.maxPingDelay=j.maxPingDelay,this.pingDelay=void 0}createConnection(S,D,j,te){te=Ie({},te,{activityTimeout:this.pingDelay});var De=this.transport.createConnection(S,D,j,te),Qe=null,It=function(){De.unbind("open",It),De.bind("closed",Vt),Qe=ue.now()},Vt=kn=>{if(De.unbind("closed",Vt),kn.code===1002||kn.code===1003)this.manager.reportDeath();else if(!kn.wasClean&&Qe){var On=ue.now()-Qe;On<2*this.maxPingDelay&&(this.manager.reportDeath(),this.pingDelay=Math.max(On/2,this.minPingDelay))}};return De.bind("open",It),De}isSupported(S){return this.manager.isAlive()&&this.transport.isSupported(S)}}const rn={decodeMessage:function(F){try{var S=JSON.parse(F.data),D=S.data;if(typeof D=="string")try{D=JSON.parse(S.data)}catch{}var j={event:S.event,channel:S.channel,data:D};return S.user_id&&(j.user_id=S.user_id),j}catch(te){throw{type:"MessageParseError",error:te,data:F.data}}},encodeMessage:function(F){return JSON.stringify(F)},processHandshake:function(F){var S=rn.decodeMessage(F);if(S.event==="pusher:connection_established"){if(!S.data.activity_timeout)throw"No activity timeout specified in handshake";return{action:"connected",id:S.data.socket_id,activityTimeout:S.data.activity_timeout*1e3}}else{if(S.event==="pusher:error")return{action:this.getCloseAction(S.data),error:this.getCloseError(S.data)};throw"Invalid handshake"}},getCloseAction:function(F){return F.code<4e3?F.code>=1002&&F.code<=1004?"backoff":null:F.code===4e3?"tls_only":F.code<4100?"refused":F.code<4200?"backoff":F.code<4300?"retry":"refused"},getCloseError:function(F){return F.code!==1e3&&F.code!==1001?{type:"PusherError",data:{code:F.code,message:F.reason||F.message}}:null}};var ar=rn;class Ii extends kt{constructor(S,D){super(),this.id=S,this.transport=D,this.activityTimeout=D.activityTimeout,this.bindListeners()}handlesActivityChecks(){return this.transport.handlesActivityChecks()}send(S){return this.transport.send(S)}send_event(S,D,j){var te={event:S,data:D};return j&&(te.channel=j),Tt.debug("Event sent",te),this.send(ar.encodeMessage(te))}ping(){this.transport.supportsPing()?this.transport.ping():this.send_event("pusher:ping",{})}close(){this.transport.close()}bindListeners(){var S={message:j=>{var te;try{te=ar.decodeMessage(j)}catch(De){this.emit("error",{type:"MessageParseError",error:De,data:j.data})}if(te!==void 0){switch(Tt.debug("Event recd",te),te.event){case"pusher:error":this.emit("error",{type:"PusherError",data:te.data});break;case"pusher:ping":this.emit("ping");break;case"pusher:pong":this.emit("pong");break}this.emit("message",te)}},activity:()=>{this.emit("activity")},error:j=>{this.emit("error",j)},closed:j=>{D(),j&&j.code&&this.handleCloseEvent(j),this.transport=null,this.emit("closed")}},D=()=>{Ae(S,(j,te)=>{this.transport.unbind(te,j)})};Ae(S,(j,te)=>{this.transport.bind(te,j)})}handleCloseEvent(S){var D=ar.getCloseAction(S),j=ar.getCloseError(S);j&&this.emit("error",j),D&&this.emit(D,{action:D,error:j})}}class fb{constructor(S,D){this.transport=S,this.callback=D,this.bindListeners()}close(){this.unbindListeners(),this.transport.close()}bindListeners(){this.onMessage=S=>{this.unbindListeners();var D;try{D=ar.processHandshake(S)}catch(j){this.finish("error",{error:j}),this.transport.close();return}D.action==="connected"?this.finish("connected",{connection:new Ii(D.id,this.transport),activityTimeout:D.activityTimeout}):(this.finish(D.action,{error:D.error}),this.transport.close())},this.onClosed=S=>{this.unbindListeners();var D=ar.getCloseAction(S)||"backoff",j=ar.getCloseError(S);this.finish(D,{error:j})},this.transport.bind("message",this.onMessage),this.transport.bind("closed",this.onClosed)}unbindListeners(){this.transport.unbind("message",this.onMessage),this.transport.unbind("closed",this.onClosed)}finish(S,D){this.callback(Ie({transport:this.transport,action:S},D))}}class Vo{constructor(S,D){this.timeline=S,this.options=D||{}}send(S,D){this.timeline.isEmpty()||this.timeline.send(Dt.TimelineTransport.getAgent(this,S),D)}}class Hu extends kt{constructor(S,D){super(function(j,te){Tt.debug("No callbacks on "+S+" for "+j)}),this.name=S,this.pusher=D,this.subscribed=!1,this.subscriptionPending=!1,this.subscriptionCancelled=!1}authorize(S,D){return D(null,{auth:""})}trigger(S,D){if(S.indexOf("client-")!==0)throw new g("Event '"+S+"' does not start with 'client-'");if(!this.subscribed){var j=f.buildLogSuffix("triggeringClientEvents");Tt.warn(`Client event triggered before channel 'subscription_succeeded' event . ${j}`)}return this.pusher.send_event(S,D,this.name)}disconnect(){this.subscribed=!1,this.subscriptionPending=!1}handleEvent(S){var D=S.event,j=S.data;if(D==="pusher_internal:subscription_succeeded")this.handleSubscriptionSucceededEvent(S);else if(D==="pusher_internal:subscription_count")this.handleSubscriptionCountEvent(S);else if(D.indexOf("pusher_internal:")!==0){var te={};this.emit(D,j,te)}}handleSubscriptionSucceededEvent(S){this.subscriptionPending=!1,this.subscribed=!0,this.subscriptionCancelled?this.pusher.unsubscribe(this.name):this.emit("pusher:subscription_succeeded",S.data)}handleSubscriptionCountEvent(S){S.data.subscription_count&&(this.subscriptionCount=S.data.subscription_count),this.emit("pusher:subscription_count",S.data)}subscribe(){this.subscribed||(this.subscriptionPending=!0,this.subscriptionCancelled=!1,this.authorize(this.pusher.connection.socket_id,(S,D)=>{S?(this.subscriptionPending=!1,Tt.error(S.toString()),this.emit("pusher:subscription_error",Object.assign({},{type:"AuthError",error:S.message},S instanceof T?{status:S.status}:{}))):this.pusher.send_event("pusher:subscribe",{auth:D.auth,channel_data:D.channel_data,channel:this.name})}))}unsubscribe(){this.subscribed=!1,this.pusher.send_event("pusher:unsubscribe",{channel:this.name})}cancelSubscription(){this.subscriptionCancelled=!0}reinstateSubscription(){this.subscriptionCancelled=!1}}class ju extends Hu{authorize(S,D){return this.pusher.config.channelAuthorizer({channelName:this.name,socketId:S},D)}}class mb{constructor(){this.reset()}get(S){return Object.prototype.hasOwnProperty.call(this.members,S)?{id:S,info:this.members[S]}:null}each(S){Ae(this.members,(D,j)=>{S(this.get(j))})}setMyID(S){this.myID=S}onSubscription(S){this.members=S.presence.hash,this.count=S.presence.count,this.me=this.get(this.myID)}addMember(S){return this.get(S.user_id)===null&&this.count++,this.members[S.user_id]=S.user_info,this.get(S.user_id)}removeMember(S){var D=this.get(S.user_id);return D&&(delete this.members[S.user_id],this.count--),D}reset(){this.members={},this.count=0,this.myID=null,this.me=null}}var Ma=function(F,S,D,j){function te(De){return De instanceof D?De:new D(function(Qe){Qe(De)})}return new(D||(D=Promise))(function(De,Qe){function It(On){try{kn(j.next(On))}catch(Pr){Qe(Pr)}}function Vt(On){try{kn(j.throw(On))}catch(Pr){Qe(Pr)}}function kn(On){On.done?De(On.value):te(On.value).then(It,Vt)}kn((j=j.apply(F,[])).next())})};class gb extends ju{constructor(S,D){super(S,D),this.members=new mb}authorize(S,D){super.authorize(S,(j,te)=>Ma(this,void 0,void 0,function*(){if(!j)if(te=te,te.channel_data!=null){var De=JSON.parse(te.channel_data);this.members.setMyID(De.user_id)}else if(yield this.pusher.user.signinDonePromise,this.pusher.user.user_data!=null)this.members.setMyID(this.pusher.user.user_data.id);else{let Qe=f.buildLogSuffix("authorizationEndpoint");Tt.error(`Invalid auth response for channel '${this.name}', expected 'channel_data' field. ${Qe}, or the user should be signed in.`),D("Invalid auth response");return}D(j,te)}))}handleEvent(S){var D=S.event;if(D.indexOf("pusher_internal:")===0)this.handleInternalEvent(S);else{var j=S.data,te={};S.user_id&&(te.user_id=S.user_id),this.emit(D,j,te)}}handleInternalEvent(S){var D=S.event,j=S.data;switch(D){case"pusher_internal:subscription_succeeded":this.handleSubscriptionSucceededEvent(S);break;case"pusher_internal:subscription_count":this.handleSubscriptionCountEvent(S);break;case"pusher_internal:member_added":var te=this.members.addMember(j);this.emit("pusher:member_added",te);break;case"pusher_internal:member_removed":var De=this.members.removeMember(j);De&&this.emit("pusher:member_removed",De);break}}handleSubscriptionSucceededEvent(S){this.subscriptionPending=!1,this.subscribed=!0,this.subscriptionCancelled?this.pusher.unsubscribe(this.name):(this.members.onSubscription(S.data),this.emit("pusher:subscription_succeeded",this.members))}disconnect(){this.members.reset(),super.disconnect()}}var bb=s(1),Uo=s(0);class yb extends ju{constructor(S,D,j){super(S,D),this.key=null,this.nacl=j}authorize(S,D){super.authorize(S,(j,te)=>{if(j){D(j,te);return}let De=te.shared_secret;if(!De){D(new Error(`No shared_secret key in auth payload for encrypted channel: ${this.name}`),null);return}this.key=Object(Uo.decode)(De),delete te.shared_secret,D(null,te)})}trigger(S,D){throw new v("Client events are not currently supported for encrypted channels")}handleEvent(S){var D=S.event,j=S.data;if(D.indexOf("pusher_internal:")===0||D.indexOf("pusher:")===0){super.handleEvent(S);return}this.handleEncryptedEvent(D,j)}handleEncryptedEvent(S,D){if(!this.key){Tt.debug("Received encrypted event before key has been retrieved from the authEndpoint");return}if(!D.ciphertext||!D.nonce){Tt.error("Unexpected format for encrypted event, expected object with `ciphertext` and `nonce` fields, got: "+D);return}let j=Object(Uo.decode)(D.ciphertext);if(j.length<this.nacl.secretbox.overheadLength){Tt.error(`Expected encrypted event ciphertext length to be ${this.nacl.secretbox.overheadLength}, got: ${j.length}`);return}let te=Object(Uo.decode)(D.nonce);if(te.length<this.nacl.secretbox.nonceLength){Tt.error(`Expected encrypted event nonce length to be ${this.nacl.secretbox.nonceLength}, got: ${te.length}`);return}let De=this.nacl.secretbox.open(j,te,this.key);if(De===null){Tt.debug("Failed to decrypt an event, probably because it was encrypted with a different key. Fetching a new key from the authEndpoint..."),this.authorize(this.pusher.connection.socket_id,(Qe,It)=>{if(Qe){Tt.error(`Failed to make a request to the authEndpoint: ${It}. Unable to fetch new key, so dropping encrypted event`);return}if(De=this.nacl.secretbox.open(j,te,this.key),De===null){Tt.error("Failed to decrypt event with new key. Dropping encrypted event");return}this.emit(S,this.getDataToEmit(De))});return}this.emit(S,this.getDataToEmit(De))}getDataToEmit(S){let D=Object(bb.decode)(S);try{return JSON.parse(D)}catch{return D}}}class Go extends kt{constructor(S,D){super(),this.state="initialized",this.connection=null,this.key=S,this.options=D,this.timeline=this.options.timeline,this.usingTLS=this.options.useTLS,this.errorCallbacks=this.buildErrorCallbacks(),this.connectionCallbacks=this.buildConnectionCallbacks(this.errorCallbacks),this.handshakeCallbacks=this.buildHandshakeCallbacks(this.errorCallbacks);var j=Dt.getNetwork();j.bind("online",()=>{this.timeline.info({netinfo:"online"}),(this.state==="connecting"||this.state==="unavailable")&&this.retryIn(0)}),j.bind("offline",()=>{this.timeline.info({netinfo:"offline"}),this.connection&&this.sendActivityCheck()}),this.updateStrategy()}connect(){if(!(this.connection||this.runner)){if(!this.strategy.isSupported()){this.updateState("failed");return}this.updateState("connecting"),this.startConnecting(),this.setUnavailableTimer()}}send(S){return this.connection?this.connection.send(S):!1}send_event(S,D,j){return this.connection?this.connection.send_event(S,D,j):!1}disconnect(){this.disconnectInternally(),this.updateState("disconnected")}isUsingTLS(){return this.usingTLS}startConnecting(){var S=(D,j)=>{D?this.runner=this.strategy.connect(0,S):j.action==="error"?(this.emit("error",{type:"HandshakeError",error:j.error}),this.timeline.error({handshakeError:j.error})):(this.abortConnecting(),this.handshakeCallbacks[j.action](j))};this.runner=this.strategy.connect(0,S)}abortConnecting(){this.runner&&(this.runner.abort(),this.runner=null)}disconnectInternally(){if(this.abortConnecting(),this.clearRetryTimer(),this.clearUnavailableTimer(),this.connection){var S=this.abandonConnection();S.close()}}updateStrategy(){this.strategy=this.options.getStrategy({key:this.key,timeline:this.timeline,useTLS:this.usingTLS})}retryIn(S){this.timeline.info({action:"retry",delay:S}),S>0&&this.emit("connecting_in",Math.round(S/1e3)),this.retryTimer=new ee(S||0,()=>{this.disconnectInternally(),this.connect()})}clearRetryTimer(){this.retryTimer&&(this.retryTimer.ensureAborted(),this.retryTimer=null)}setUnavailableTimer(){this.unavailableTimer=new ee(this.options.unavailableTimeout,()=>{this.updateState("unavailable")})}clearUnavailableTimer(){this.unavailableTimer&&this.unavailableTimer.ensureAborted()}sendActivityCheck(){this.stopActivityCheck(),this.connection.ping(),this.activityTimer=new ee(this.options.pongTimeout,()=>{this.timeline.error({pong_timed_out:this.options.pongTimeout}),this.retryIn(0)})}resetActivityCheck(){this.stopActivityCheck(),this.connection&&!this.connection.handlesActivityChecks()&&(this.activityTimer=new ee(this.activityTimeout,()=>{this.sendActivityCheck()}))}stopActivityCheck(){this.activityTimer&&this.activityTimer.ensureAborted()}buildConnectionCallbacks(S){return Ie({},S,{message:D=>{this.resetActivityCheck(),this.emit("message",D)},ping:()=>{this.send_event("pusher:pong",{})},activity:()=>{this.resetActivityCheck()},error:D=>{this.emit("error",D)},closed:()=>{this.abandonConnection(),this.shouldRetry()&&this.retryIn(1e3)}})}buildHandshakeCallbacks(S){return Ie({},S,{connected:D=>{this.activityTimeout=Math.min(this.options.activityTimeout,D.activityTimeout,D.connection.activityTimeout||1/0),this.clearUnavailableTimer(),this.setConnection(D.connection),this.socket_id=this.connection.id,this.updateState("connected",{socket_id:this.socket_id})}})}buildErrorCallbacks(){let S=D=>j=>{j.error&&this.emit("error",{type:"WebSocketError",error:j.error}),D(j)};return{tls_only:S(()=>{this.usingTLS=!0,this.updateStrategy(),this.retryIn(0)}),refused:S(()=>{this.disconnect()}),backoff:S(()=>{this.retryIn(1e3)}),retry:S(()=>{this.retryIn(0)})}}setConnection(S){this.connection=S;for(var D in this.connectionCallbacks)this.connection.bind(D,this.connectionCallbacks[D]);this.resetActivityCheck()}abandonConnection(){if(this.connection){this.stopActivityCheck();for(var S in this.connectionCallbacks)this.connection.unbind(S,this.connectionCallbacks[S]);var D=this.connection;return this.connection=null,D}}updateState(S,D){var j=this.state;if(this.state=S,j!==S){var te=S;te==="connected"&&(te+=" with new socket ID "+D.socket_id),Tt.debug("State changed",j+" -> "+te),this.timeline.info({state:S,params:D}),this.emit("state_change",{previous:j,current:S}),this.emit(S,D)}}shouldRetry(){return this.state==="connecting"||this.state==="connected"}}class xb{constructor(){this.channels={}}add(S,D){return this.channels[S]||(this.channels[S]=wb(S,D)),this.channels[S]}all(){return Ue(this.channels)}find(S){return this.channels[S]}remove(S){var D=this.channels[S];return delete this.channels[S],D}disconnect(){Ae(this.channels,function(S){S.disconnect()})}}function wb(F,S){if(F.indexOf("private-encrypted-")===0){if(S.config.nacl)return mr.createEncryptedChannel(F,S,S.config.nacl);let D="Tried to subscribe to a private-encrypted- channel but no nacl implementation available",j=f.buildLogSuffix("encryptedChannelSupport");throw new v(`${D}. ${j}`)}else{if(F.indexOf("private-")===0)return mr.createPrivateChannel(F,S);if(F.indexOf("presence-")===0)return mr.createPresenceChannel(F,S);if(F.indexOf("#")===0)throw new b('Cannot create a channel with name "'+F+'".');return mr.createChannel(F,S)}}var vb={createChannels(){return new xb},createConnectionManager(F,S){return new Go(F,S)},createChannel(F,S){return new Hu(F,S)},createPrivateChannel(F,S){return new ju(F,S)},createPresenceChannel(F,S){return new gb(F,S)},createEncryptedChannel(F,S,D){return new yb(F,S,D)},createTimelineSender(F,S){return new Vo(F,S)},createHandshake(F,S){return new fb(F,S)},createAssistantToTheTransportManager(F,S,D){return new vi(F,S,D)}},mr=vb;class ro{constructor(S){this.options=S||{},this.livesLeft=this.options.lives||1/0}getAssistant(S){return mr.createAssistantToTheTransportManager(this,S,{minPingDelay:this.options.minPingDelay,maxPingDelay:this.options.maxPingDelay})}isAlive(){return this.livesLeft>0}reportDeath(){this.livesLeft-=1}}class ki{constructor(S,D){this.strategies=S,this.loop=!!D.loop,this.failFast=!!D.failFast,this.timeout=D.timeout,this.timeoutLimit=D.timeoutLimit}isSupported(){return ht(this.strategies,ue.method("isSupported"))}connect(S,D){var j=this.strategies,te=0,De=this.timeout,Qe=null,It=(Vt,kn)=>{kn?D(null,kn):(te=te+1,this.loop&&(te=te%j.length),te<j.length?(De&&(De=De*2,this.timeoutLimit&&(De=Math.min(De,this.timeoutLimit))),Qe=this.tryStrategy(j[te],S,{timeout:De,failFast:this.failFast},It)):D(!0))};return Qe=this.tryStrategy(j[te],S,{timeout:De,failFast:this.failFast},It),{abort:function(){Qe.abort()},forceMinPriority:function(Vt){S=Vt,Qe&&Qe.forceMinPriority(Vt)}}}tryStrategy(S,D,j,te){var De=null,Qe=null;return j.timeout>0&&(De=new ee(j.timeout,function(){Qe.abort(),te(!0)})),Qe=S.connect(D,function(It,Vt){It&&De&&De.isRunning()&&!j.failFast||(De&&De.ensureAborted(),te(It,Vt))}),{abort:function(){De&&De.ensureAborted(),Qe.abort()},forceMinPriority:function(It){Qe.forceMinPriority(It)}}}}class qu{constructor(S){this.strategies=S}isSupported(){return ht(this.strategies,ue.method("isSupported"))}connect(S,D){return Ib(this.strategies,S,function(j,te){return function(De,Qe){if(te[j].error=De,De){kb(te)&&D(!0);return}qe(te,function(It){It.forceMinPriority(Qe.transport.priority)}),D(null,Qe)}})}}function Ib(F,S,D){var j=ut(F,function(te,De,Qe,It){return te.connect(S,D(De,It))});return{abort:function(){qe(j,Ku)},forceMinPriority:function(te){qe(j,function(De){De.forceMinPriority(te)})}}}function kb(F){return yn(F,function(S){return!!S.error})}function Ku(F){!F.error&&!F.aborted&&(F.abort(),F.aborted=!0)}class Xu{constructor(S,D,j){this.strategy=S,this.transports=D,this.ttl=j.ttl||1800*1e3,this.usingTLS=j.useTLS,this.timeline=j.timeline}isSupported(){return this.strategy.isSupported()}connect(S,D){var j=this.usingTLS,te=Cb(j),De=te&&te.cacheSkipCount?te.cacheSkipCount:0,Qe=[this.strategy];if(te&&te.timestamp+this.ttl>=ue.now()){var It=this.transports[te.transport];It&&(["ws","wss"].includes(te.transport)||De>3?(this.timeline.info({cached:!0,transport:te.transport,latency:te.latency}),Qe.push(new ki([It],{timeout:te.latency*2+1e3,failFast:!0}))):De++)}var Vt=ue.now(),kn=Qe.pop().connect(S,function On(Pr,l2){Pr?(Il(j),Qe.length>0?(Vt=ue.now(),kn=Qe.pop().connect(S,On)):D(Pr)):(Yu(j,l2.transport.name,ue.now()-Vt,De),D(null,l2))});return{abort:function(){kn.abort()},forceMinPriority:function(On){S=On,kn&&kn.forceMinPriority(On)}}}}function Qu(F){return"pusherTransport"+(F?"TLS":"NonTLS")}function Cb(F){var S=Dt.getLocalStorage();if(S)try{var D=S[Qu(F)];if(D)return JSON.parse(D)}catch{Il(F)}return null}function Yu(F,S,D,j){var te=Dt.getLocalStorage();if(te)try{te[Qu(F)]=nn({timestamp:ue.now(),transport:S,latency:D,cacheSkipCount:j})}catch{}}function Il(F){var S=Dt.getLocalStorage();if(S)try{delete S[Qu(F)]}catch{}}class kl{constructor(S,{delay:D}){this.strategy=S,this.options={delay:D}}isSupported(){return this.strategy.isSupported()}connect(S,D){var j=this.strategy,te,De=new ee(this.options.delay,function(){te=j.connect(S,D)});return{abort:function(){De.ensureAborted(),te&&te.abort()},forceMinPriority:function(Qe){S=Qe,te&&te.forceMinPriority(Qe)}}}}class Ho{constructor(S,D,j){this.test=S,this.trueBranch=D,this.falseBranch=j}isSupported(){var S=this.test()?this.trueBranch:this.falseBranch;return S.isSupported()}connect(S,D){var j=this.test()?this.trueBranch:this.falseBranch;return j.connect(S,D)}}class Sb{constructor(S){this.strategy=S}isSupported(){return this.strategy.isSupported()}connect(S,D){var j=this.strategy.connect(S,function(te,De){De&&j.abort(),D(te,De)});return j}}function jo(F){return function(){return F.isSupported()}}var Ju=function(F,S,D){var j={};function te(O$,WK,VK,UK,GK){var L$=D(F,O$,WK,VK,UK,GK);return j[O$]=L$,L$}var De=Object.assign({},S,{hostNonTLS:F.wsHost+":"+F.wsPort,hostTLS:F.wsHost+":"+F.wssPort,httpPath:F.wsPath}),Qe=Object.assign({},De,{useTLS:!0}),It=Object.assign({},S,{hostNonTLS:F.httpHost+":"+F.httpPort,hostTLS:F.httpHost+":"+F.httpsPort,httpPath:F.httpPath}),Vt={loop:!0,timeout:15e3,timeoutLimit:6e4},kn=new ro({minPingDelay:1e4,maxPingDelay:F.activityTimeout}),On=new ro({lives:2,minPingDelay:1e4,maxPingDelay:F.activityTimeout}),Pr=te("ws","ws",3,De,kn),l2=te("wss","ws",3,Qe,kn),OK=te("sockjs","sockjs",1,It),$$=te("xhr_streaming","xhr_streaming",1,It,On),LK=te("xdr_streaming","xdr_streaming",1,It,On),R$=te("xhr_polling","xhr_polling",1,It),PK=te("xdr_polling","xdr_polling",1,It),_$=new ki([Pr],Vt),BK=new ki([l2],Vt),zK=new ki([OK],Vt),D$=new ki([new Ho(jo($$),$$,LK)],Vt),F$=new ki([new Ho(jo(R$),R$,PK)],Vt),M$=new ki([new Ho(jo(D$),new qu([D$,new kl(F$,{delay:4e3})]),F$)],Vt),XI=new Ho(jo(M$),M$,zK),QI;return S.useTLS?QI=new qu([_$,new kl(XI,{delay:2e3})]):QI=new qu([_$,new kl(BK,{delay:2e3}),new kl(XI,{delay:5e3})]),new Xu(new Sb(new Ho(jo(Pr),QI,XI)),j,{ttl:18e5,timeline:S.timeline,useTLS:S.useTLS})},Ci=Ju,Zu=(function(){var F=this;F.timeline.info(F.buildTimelineMessage({transport:F.name+(F.options.useTLS?"s":"")})),F.hooks.isInitialized()?F.changeState("initialized"):F.hooks.file?(F.changeState("initializing"),d.load(F.hooks.file,{useTLS:F.options.useTLS},function(S,D){F.hooks.isInitialized()?(F.changeState("initialized"),D(!0)):(S&&F.onError(S),F.onClose(),D(!1))})):F.onClose()}),ec={getRequest:function(F){var S=new window.XDomainRequest;return S.ontimeout=function(){F.emit("error",new y),F.close()},S.onerror=function(D){F.emit("error",D),F.close()},S.onprogress=function(){S.responseText&&S.responseText.length>0&&F.onChunk(200,S.responseText)},S.onload=function(){S.responseText&&S.responseText.length>0&&F.onChunk(200,S.responseText),F.emit("finished",200),F.close()},S},abortRequest:function(F){F.ontimeout=F.onerror=F.onprogress=F.onload=null,F.abort()}},tc=ec;const qo=256*1024;class nc extends kt{constructor(S,D,j){super(),this.hooks=S,this.method=D,this.url=j}start(S){this.position=0,this.xhr=this.hooks.getRequest(this),this.unloader=()=>{this.close()},Dt.addUnloadListener(this.unloader),this.xhr.open(this.method,this.url,!0),this.xhr.setRequestHeader&&this.xhr.setRequestHeader("Content-Type","application/json"),this.xhr.send(S)}close(){this.unloader&&(Dt.removeUnloadListener(this.unloader),this.unloader=null),this.xhr&&(this.hooks.abortRequest(this.xhr),this.xhr=null)}onChunk(S,D){for(;;){var j=this.advanceBuffer(D);if(j)this.emit("chunk",{status:S,data:j});else break}this.isBufferTooLong(D)&&this.emit("buffer_too_long")}advanceBuffer(S){var D=S.slice(this.position),j=D.indexOf(`
`);return j!==-1?(this.position+=j+1,D.slice(0,j)):null}isBufferTooLong(S){return this.position===S.length&&S.length>qo}}var Ko;(function(F){F[F.CONNECTING=0]="CONNECTING",F[F.OPEN=1]="OPEN",F[F.CLOSED=3]="CLOSED"})(Ko||(Ko={}));var Js=Ko,Si=1;class Ni{constructor(S,D){this.hooks=S,this.session=dp(1e3)+"/"+_(8),this.location=Ti(D),this.readyState=Js.CONNECTING,this.openStream()}send(S){return this.sendRaw(JSON.stringify([S]))}ping(){this.hooks.sendHeartbeat(this)}close(S,D){this.onClose(S,D,!0)}sendRaw(S){if(this.readyState===Js.OPEN)try{return Dt.createSocketRequest("POST",Za(rc(this.location,this.session))).start(S),!0}catch{return!1}else return!1}reconnect(){this.closeStream(),this.openStream()}onClose(S,D,j){this.closeStream(),this.readyState=Js.CLOSED,this.onclose&&this.onclose({code:S,reason:D,wasClean:j})}onChunk(S){if(S.status===200){this.readyState===Js.OPEN&&this.onActivity();var D,j=S.data.slice(0,1);switch(j){case"o":D=JSON.parse(S.data.slice(1)||"{}"),this.onOpen(D);break;case"a":D=JSON.parse(S.data.slice(1)||"[]");for(var te=0;te<D.length;te++)this.onEvent(D[te]);break;case"m":D=JSON.parse(S.data.slice(1)||"null"),this.onEvent(D);break;case"h":this.hooks.onHeartbeat(this);break;case"c":D=JSON.parse(S.data.slice(1)||"[]"),this.onClose(D[0],D[1],!0);break}}}onOpen(S){this.readyState===Js.CONNECTING?(S&&S.hostname&&(this.location.base=Ei(this.location.base,S.hostname)),this.readyState=Js.OPEN,this.onopen&&this.onopen()):this.onClose(1006,"Server lost session",!0)}onEvent(S){this.readyState===Js.OPEN&&this.onmessage&&this.onmessage({data:S})}onActivity(){this.onactivity&&this.onactivity()}onError(S){this.onerror&&this.onerror(S)}openStream(){this.stream=Dt.createSocketRequest("POST",Za(this.hooks.getReceiveURL(this.location,this.session))),this.stream.bind("chunk",S=>{this.onChunk(S)}),this.stream.bind("finished",S=>{this.hooks.onFinished(this,S)}),this.stream.bind("buffer_too_long",()=>{this.reconnect()});try{this.stream.start()}catch(S){ue.defer(()=>{this.onError(S),this.onClose(1006,"Could not start streaming",!1)})}}closeStream(){this.stream&&(this.stream.unbind_all(),this.stream.close(),this.stream=null)}}function Ti(F){var S=/([^\?]*)\/*(\??.*)/.exec(F);return{base:S[1],queryString:S[2]}}function rc(F,S){return F.base+"/"+S+"/xhr_send"}function Za(F){var S=F.indexOf("?")===-1?"?":"&";return F+S+"t="+ +new Date+"&n="+Si++}function Ei(F,S){var D=/(https?:\/\/)([^\/:]+)((\/|:)?.*)/.exec(F);return D[1]+S+D[3]}function dp(F){return Dt.randomInt(F)}function _(F){for(var S=[],D=0;D<F;D++)S.push(dp(32).toString(32));return S.join("")}var V=Ni,me={getReceiveURL:function(F,S){return F.base+"/"+S+"/xhr_streaming"+F.queryString},onHeartbeat:function(F){F.sendRaw("[]")},sendHeartbeat:function(F){F.sendRaw("[]")},onFinished:function(F,S){F.onClose(1006,"Connection interrupted ("+S+")",!1)}},Pe=me,He={getReceiveURL:function(F,S){return F.base+"/"+S+"/xhr"+F.queryString},onHeartbeat:function(){},sendHeartbeat:function(F){F.sendRaw("[]")},onFinished:function(F,S){S===200?F.reconnect():F.onClose(1006,"Connection interrupted ("+S+")",!1)}},je=He,Ce={getRequest:function(F){var S=Dt.getXHRAPI(),D=new S;return D.onreadystatechange=D.onprogress=function(){switch(D.readyState){case 3:D.responseText&&D.responseText.length>0&&F.onChunk(D.status,D.responseText);break;case 4:D.responseText&&D.responseText.length>0&&F.onChunk(D.status,D.responseText),F.emit("finished",D.status),F.close();break}},D},abortRequest:function(F){F.onreadystatechange=null,F.abort()}},Fe=Ce,Rt={createStreamingSocket(F){return this.createSocket(Pe,F)},createPollingSocket(F){return this.createSocket(je,F)},createSocket(F,S){return new V(F,S)},createXHR(F,S){return this.createRequest(Fe,F,S)},createRequest(F,S,D){return new nc(F,S,D)}},En=Rt;En.createXDR=function(F,S){return this.createRequest(tc,F,S)};var Er=En,sc={nextAuthCallbackID:1,auth_callbacks:{},ScriptReceivers:i,DependenciesReceivers:l,getDefaultStrategy:Ci,Transports:Tr,transportConnectionInitializer:Zu,HTTPFactory:Er,TimelineTransport:$e,getXHRAPI(){return window.XMLHttpRequest},getWebSocketAPI(){return window.WebSocket||window.MozWebSocket},setup(F){window.Pusher=F;var S=()=>{this.onDocumentBody(F.ready)};window.JSON?S():d.load("json2",{},S)},getDocument(){return document},getProtocol(){return this.getDocument().location.protocol},getAuthorizers(){return{ajax:A,jsonp:Kt}},onDocumentBody(F){document.body?F():setTimeout(()=>{this.onDocumentBody(F)},0)},createJSONPRequest(F,S){return new xr(F,S)},createScriptRequest(F){return new an(F)},getLocalStorage(){try{return window.localStorage}catch{return}},createXHR(){return this.getXHRAPI()?this.createXMLHttpRequest():this.createMicrosoftXHR()},createXMLHttpRequest(){var F=this.getXHRAPI();return new F},createMicrosoftXHR(){return new ActiveXObject("Microsoft.XMLHTTP")},getNetwork(){return Fa},createWebSocket(F){var S=this.getWebSocketAPI();return new S(F)},createSocketRequest(F,S){if(this.isXHRSupported())return this.HTTPFactory.createXHR(F,S);if(this.isXDRSupported(S.indexOf("https:")===0))return this.HTTPFactory.createXDR(F,S);throw"Cross-origin HTTP requests are not supported"},isXHRSupported(){var F=this.getXHRAPI();return!!F&&new F().withCredentials!==void 0},isXDRSupported(F){var S=F?"https:":"http:",D=this.getProtocol();return!!window.XDomainRequest&&D===S},addUnloadListener(F){window.addEventListener!==void 0?window.addEventListener("unload",F,!1):window.attachEvent!==void 0&&window.attachEvent("onunload",F)},removeUnloadListener(F){window.addEventListener!==void 0?window.removeEventListener("unload",F,!1):window.detachEvent!==void 0&&window.detachEvent("onunload",F)},randomInt(F){return Math.floor(function(){return(window.crypto||window.msCrypto).getRandomValues(new Uint32Array(1))[0]/Math.pow(2,32)}()*F)}},Dt=sc,ac;(function(F){F[F.ERROR=3]="ERROR",F[F.INFO=6]="INFO",F[F.DEBUG=7]="DEBUG"})(ac||(ac={}));var xn=ac;class Zs{constructor(S,D,j){this.key=S,this.session=D,this.events=[],this.options=j||{},this.sent=0,this.uniqueID=0}log(S,D){S<=this.options.level&&(this.events.push(Ie({},D,{timestamp:ue.now()})),this.options.limit&&this.events.length>this.options.limit&&this.events.shift())}error(S){this.log(xn.ERROR,S)}info(S){this.log(xn.INFO,S)}debug(S){this.log(xn.DEBUG,S)}isEmpty(){return this.events.length===0}send(S,D){var j=Ie({session:this.session,bundle:this.sent+1,key:this.key,lib:"js",version:this.options.version,cluster:this.options.cluster,features:this.options.features,timeline:this.events},this.options.params);return this.events=[],S(j,(te,De)=>{te||this.sent++,D&&D(te,De)}),!0}generateUniqueID(){return this.uniqueID++,this.uniqueID}}class ic{constructor(S,D,j,te){this.name=S,this.priority=D,this.transport=j,this.options=te||{}}isSupported(){return this.transport.isSupported({useTLS:this.options.useTLS})}connect(S,D){if(this.isSupported()){if(this.priority<S)return A$(new x,D)}else return A$(new N,D);var j=!1,te=this.transport.createConnection(this.name,this.priority,this.options.key,this.options),De=null,Qe=function(){te.unbind("initialized",Qe),te.connect()},It=function(){De=mr.createHandshake(te,function(Pr){j=!0,On(),D(null,Pr)})},Vt=function(Pr){On(),D(Pr)},kn=function(){On();var Pr;Pr=nn(te),D(new w(Pr))},On=function(){te.unbind("initialized",Qe),te.unbind("open",It),te.unbind("error",Vt),te.unbind("closed",kn)};return te.bind("initialized",Qe),te.bind("open",It),te.bind("error",Vt),te.bind("closed",kn),te.initialize(),{abort:()=>{j||(On(),De?De.close():te.close())},forceMinPriority:Pr=>{j||this.priority<Pr&&(De?De.close():te.close())}}}}function A$(F,S){return ue.defer(function(){S(F)}),{abort:function(){},forceMinPriority:function(){}}}const{Transports:pK}=Dt;var fK=function(F,S,D,j,te,De){var Qe=pK[D];if(!Qe)throw new I(D);var It=(!F.enabledTransports||ve(F.enabledTransports,S)!==-1)&&(!F.disabledTransports||ve(F.disabledTransports,S)===-1),Vt;return It?(te=Object.assign({ignoreNullOrigin:F.ignoreNullOrigin},te),Vt=new ic(S,j,De?De.getAssistant(Qe):Qe,te)):Vt=mK,Vt},mK={isSupported:function(){return!1},connect:function(F,S){var D=ue.defer(function(){S(new N)});return{abort:function(){D.ensureAborted()},forceMinPriority:function(){}}}};function gK(F){if(F==null)throw"You must pass an options object";if(F.cluster==null)throw"Options object must provide a cluster";"disableStats"in F&&Tt.warn("The disableStats option is deprecated in favor of enableStats")}const bK=(F,S)=>{var D="socket_id="+encodeURIComponent(F.socketId);for(var j in S.params)D+="&"+encodeURIComponent(j)+"="+encodeURIComponent(S.params[j]);if(S.paramsProvider!=null){let te=S.paramsProvider();for(var j in te)D+="&"+encodeURIComponent(j)+"="+encodeURIComponent(te[j])}return D};var yK=F=>{if(typeof Dt.getAuthorizers()[F.transport]>"u")throw`'${F.transport}' is not a recognized auth transport`;return(S,D)=>{const j=bK(S,F);Dt.getAuthorizers()[F.transport](Dt,j,F,m.UserAuthentication,D)}};const xK=(F,S)=>{var D="socket_id="+encodeURIComponent(F.socketId);D+="&channel_name="+encodeURIComponent(F.channelName);for(var j in S.params)D+="&"+encodeURIComponent(j)+"="+encodeURIComponent(S.params[j]);if(S.paramsProvider!=null){let te=S.paramsProvider();for(var j in te)D+="&"+encodeURIComponent(j)+"="+encodeURIComponent(te[j])}return D};var wK=F=>{if(typeof Dt.getAuthorizers()[F.transport]>"u")throw`'${F.transport}' is not a recognized auth transport`;return(S,D)=>{const j=xK(S,F);Dt.getAuthorizers()[F.transport](Dt,j,F,m.ChannelAuthorization,D)}};const vK=(F,S,D)=>{const j={authTransport:S.transport,authEndpoint:S.endpoint,auth:{params:S.params,headers:S.headers}};return(te,De)=>{const Qe=F.channel(te.channelName);D(Qe,j).authorize(te.socketId,De)}};function IK(F,S){let D={activityTimeout:F.activityTimeout||u.activityTimeout,cluster:F.cluster,httpPath:F.httpPath||u.httpPath,httpPort:F.httpPort||u.httpPort,httpsPort:F.httpsPort||u.httpsPort,pongTimeout:F.pongTimeout||u.pongTimeout,statsHost:F.statsHost||u.stats_host,unavailableTimeout:F.unavailableTimeout||u.unavailableTimeout,wsPath:F.wsPath||u.wsPath,wsPort:F.wsPort||u.wsPort,wssPort:F.wssPort||u.wssPort,enableStats:TK(F),httpHost:kK(F),useTLS:NK(F),wsHost:CK(F),userAuthenticator:EK(F),channelAuthorizer:$K(F,S)};return"disabledTransports"in F&&(D.disabledTransports=F.disabledTransports),"enabledTransports"in F&&(D.enabledTransports=F.enabledTransports),"ignoreNullOrigin"in F&&(D.ignoreNullOrigin=F.ignoreNullOrigin),"timelineParams"in F&&(D.timelineParams=F.timelineParams),"nacl"in F&&(D.nacl=F.nacl),D}function kK(F){return F.httpHost?F.httpHost:F.cluster?`sockjs-${F.cluster}.pusher.com`:u.httpHost}function CK(F){return F.wsHost?F.wsHost:SK(F.cluster)}function SK(F){return`ws-${F}.pusher.com`}function NK(F){return Dt.getProtocol()==="https:"?!0:F.forceTLS!==!1}function TK(F){return"enableStats"in F?F.enableStats:"disableStats"in F?!F.disableStats:!1}function EK(F){const S=Object.assign(Object.assign({},u.userAuthentication),F.userAuthentication);return"customHandler"in S&&S.customHandler!=null?S.customHandler:yK(S)}function AK(F,S){let D;return"channelAuthorization"in F?D=Object.assign(Object.assign({},u.channelAuthorization),F.channelAuthorization):(D={transport:F.authTransport||u.authTransport,endpoint:F.authEndpoint||u.authEndpoint},"auth"in F&&("params"in F.auth&&(D.params=F.auth.params),"headers"in F.auth&&(D.headers=F.auth.headers)),"authorizer"in F&&(D.customHandler=vK(S,D,F.authorizer))),D}function $K(F,S){const D=AK(F,S);return"customHandler"in D&&D.customHandler!=null?D.customHandler:wK(D)}class RK extends kt{constructor(S){super(function(D,j){Tt.debug(`No callbacks on watchlist events for ${D}`)}),this.pusher=S,this.bindWatchlistInternalEvent()}handleEvent(S){S.data.events.forEach(D=>{this.emit(D.name,D)})}bindWatchlistInternalEvent(){this.pusher.connection.bind("message",S=>{var D=S.event;D==="pusher_internal:watchlist_events"&&this.handleEvent(S)})}}function _K(){let F,S;return{promise:new Promise((j,te)=>{F=j,S=te}),resolve:F,reject:S}}var DK=_K;class FK extends kt{constructor(S){super(function(D,j){Tt.debug("No callbacks on user for "+D)}),this.signin_requested=!1,this.user_data=null,this.serverToUserChannel=null,this.signinDonePromise=null,this._signinDoneResolve=null,this._onAuthorize=(D,j)=>{if(D){Tt.warn(`Error during signin: ${D}`),this._cleanup();return}this.pusher.send_event("pusher:signin",{auth:j.auth,user_data:j.user_data})},this.pusher=S,this.pusher.connection.bind("state_change",({previous:D,current:j})=>{D!=="connected"&&j==="connected"&&this._signin(),D==="connected"&&j!=="connected"&&(this._cleanup(),this._newSigninPromiseIfNeeded())}),this.watchlist=new RK(S),this.pusher.connection.bind("message",D=>{var j=D.event;j==="pusher:signin_success"&&this._onSigninSuccess(D.data),this.serverToUserChannel&&this.serverToUserChannel.name===D.channel&&this.serverToUserChannel.handleEvent(D)})}signin(){this.signin_requested||(this.signin_requested=!0,this._signin())}_signin(){this.signin_requested&&(this._newSigninPromiseIfNeeded(),this.pusher.connection.state==="connected"&&this.pusher.config.userAuthenticator({socketId:this.pusher.connection.socket_id},this._onAuthorize))}_onSigninSuccess(S){try{this.user_data=JSON.parse(S.user_data)}catch{Tt.error(`Failed parsing user data after signin: ${S.user_data}`),this._cleanup();return}if(typeof this.user_data.id!="string"||this.user_data.id===""){Tt.error(`user_data doesn't contain an id. user_data: ${this.user_data}`),this._cleanup();return}this._signinDoneResolve(),this._subscribeChannels()}_subscribeChannels(){const S=D=>{D.subscriptionPending&&D.subscriptionCancelled?D.reinstateSubscription():!D.subscriptionPending&&this.pusher.connection.state==="connected"&&D.subscribe()};this.serverToUserChannel=new Hu(`#server-to-user-${this.user_data.id}`,this.pusher),this.serverToUserChannel.bind_global((D,j)=>{D.indexOf("pusher_internal:")===0||D.indexOf("pusher:")===0||this.emit(D,j)}),S(this.serverToUserChannel)}_cleanup(){this.user_data=null,this.serverToUserChannel&&(this.serverToUserChannel.unbind_all(),this.serverToUserChannel.disconnect(),this.serverToUserChannel=null),this.signin_requested&&this._signinDoneResolve()}_newSigninPromiseIfNeeded(){if(!this.signin_requested||this.signinDonePromise&&!this.signinDonePromise.done)return;const{promise:S,resolve:D}=DK();S.done=!1;const j=()=>{S.done=!0};S.then(j).catch(j),this.signinDonePromise=S,this._signinDoneResolve=D}}class xs{static ready(){xs.isReady=!0;for(var S=0,D=xs.instances.length;S<D;S++)xs.instances[S].connect()}static getClientFeatures(){return Be(ze({ws:Dt.Transports.ws},function(S){return S.isSupported({})}))}constructor(S,D){MK(S),gK(D),this.key=S,this.config=IK(D,this),this.channels=mr.createChannels(),this.global_emitter=new kt,this.sessionID=Dt.randomInt(1e9),this.timeline=new Zs(this.key,this.sessionID,{cluster:this.config.cluster,features:xs.getClientFeatures(),params:this.config.timelineParams||{},limit:50,level:xn.INFO,version:u.VERSION}),this.config.enableStats&&(this.timelineSender=mr.createTimelineSender(this.timeline,{host:this.config.statsHost,path:"/timeline/v2/"+Dt.TimelineTransport.name}));var j=te=>Dt.getDefaultStrategy(this.config,te,fK);this.connection=mr.createConnectionManager(this.key,{getStrategy:j,timeline:this.timeline,activityTimeout:this.config.activityTimeout,pongTimeout:this.config.pongTimeout,unavailableTimeout:this.config.unavailableTimeout,useTLS:!!this.config.useTLS}),this.connection.bind("connected",()=>{this.subscribeAll(),this.timelineSender&&this.timelineSender.send(this.connection.isUsingTLS())}),this.connection.bind("message",te=>{var De=te.event,Qe=De.indexOf("pusher_internal:")===0;if(te.channel){var It=this.channel(te.channel);It&&It.handleEvent(te)}Qe||this.global_emitter.emit(te.event,te.data)}),this.connection.bind("connecting",()=>{this.channels.disconnect()}),this.connection.bind("disconnected",()=>{this.channels.disconnect()}),this.connection.bind("error",te=>{Tt.warn(te)}),xs.instances.push(this),this.timeline.info({instances:xs.instances.length}),this.user=new FK(this),xs.isReady&&this.connect()}channel(S){return this.channels.find(S)}allChannels(){return this.channels.all()}connect(){if(this.connection.connect(),this.timelineSender&&!this.timelineSenderTimer){var S=this.connection.isUsingTLS(),D=this.timelineSender;this.timelineSenderTimer=new Y(6e4,function(){D.send(S)})}}disconnect(){this.connection.disconnect(),this.timelineSenderTimer&&(this.timelineSenderTimer.ensureAborted(),this.timelineSenderTimer=null)}bind(S,D,j){return this.global_emitter.bind(S,D,j),this}unbind(S,D,j){return this.global_emitter.unbind(S,D,j),this}bind_global(S){return this.global_emitter.bind_global(S),this}unbind_global(S){return this.global_emitter.unbind_global(S),this}unbind_all(S){return this.global_emitter.unbind_all(),this}subscribeAll(){var S;for(S in this.channels.channels)this.channels.channels.hasOwnProperty(S)&&this.subscribe(S)}subscribe(S){var D=this.channels.add(S,this);return D.subscriptionPending&&D.subscriptionCancelled?D.reinstateSubscription():!D.subscriptionPending&&this.connection.state==="connected"&&D.subscribe(),D}unsubscribe(S){var D=this.channels.find(S);D&&D.subscriptionPending?D.cancelSubscription():(D=this.channels.remove(S),D&&D.subscribed&&D.unsubscribe())}send_event(S,D,j){return this.connection.send_event(S,D,j)}shouldUseTLS(){return this.config.useTLS}signin(){this.user.signin()}}xs.instances=[],xs.isReady=!1,xs.logToConsole=!1,xs.Runtime=Dt,xs.ScriptReceivers=Dt.ScriptReceivers,xs.DependenciesReceivers=Dt.DependenciesReceivers,xs.auth_callbacks=Dt.auth_callbacks;var KI=r.default=xs;function MK(F){if(F==null)throw"You must pass your app key when you instantiate Pusher."}Dt.setup(xs)})])})})(Vk)),Vk.exports}var cut=uut();const dut=ow(cut),hut={class:"fixed top-4 right-4 z-50 space-y-2"},put={key:0,class:"flex items-center"},fut={key:0,class:"mr-3 w-6 h-6",fill:"none",stroke:"currentColor",viewBox:"0 0 24 24"},mut={key:1,class:"mr-3 w-6 h-6",fill:"none",stroke:"currentColor",viewBox:"0 0 24 24"},gut={key:2,class:"mr-3 w-6 h-6",fill:"none",stroke:"currentColor",viewBox:"0 0 24 24"},but={class:"flex-1"},yut={class:"font-semibold"},xut={class:"text-sm opacity-90"},wut={key:0,class:"text-xs opacity-75"},vut=["onClick"],Iut={key:1,class:"flex items-center"},kut={class:"font-semibold"},Cut={class:"flex overflow-hidden h-screen"},Sut={class:"bg-[#112D5A] w-1/2"},Nut={class:"flex justify-center gap-6 pt-6 pb-4"},Tut={class:"flex items-center gap-2 cursor-pointer"},Eut={class:"flex items-center gap-2 cursor-pointer"},Aut={class:"flex flex-col justify-center items-center h-full"},$ut={key:0},Rut={key:1,class:"overflow-hidden relative w-full bg-black rounded-xl"},_ut={key:1,class:"flex justify-center items-center mt-6"},Dut={key:2,class:"flex gap-2 py-4 mt-4 w-3/4"},Fut={class:"flex flex-col gap-2 items-start"},Mut={class:"flex flex-col justify-center items-center p-6"},Out={class:"flex flex-col gap-2 items-start pt-5"},Lut={class:"flex items-center"},Put={class:"ml-2 text-sm font-normal text-white"},But={class:"bg-[#F7F7F7] w-1/2 p-4"},zut={class:"flex justify-between items-center"},Wut={class:"flex flex-col"},Vut={class:"text-2xl font-semibold text-[#1B84FF]"},Uut={class:"font-semibold text-gray-500 text-md"},Gut={class:"p-4 mt-4 bg-white rounded-lg border border-gray-300"},Hut={class:"w-full text-left border-collapse"},jut={class:"divide-y divide-gray-300"},qut={class:"py-4 font-semibold text-gray-700"},Kut={class:"py-4 font-semibold text-gray-700"},Xut={class:"py-4 font-semibold text-gray-700"},Qut={class:"py-4 font-semibold text-gray-700"},Yut={class:"py-4 font-semibold text-gray-700"},Jut={class:"py-4 font-semibold text-gray-700"},Zut={key:0,class:"mt-4"},ect=10,Uk=2e3,tct=5,EF=!1,nct=1e4,mct={__name:"Index",props:{employees:{type:Array,default:()=>[]}},setup(e){const t=e,n=gr({latitude:null,longitude:null});let r=gr(!1),s=gr(!0);const a=["Posisikan wajah di tengah bingkai","Pastikan cahaya cukup & tidak membelakangi sumber cahaya.","Lepaskan aksesoris yang menutupi wajah."],o=gr([{label:"Camera",value:"camera"},{label:"QR",value:"qr"}][0].value),u=gr(new Date().toLocaleTimeString());setInterval(()=>{u.value=new Date().toLocaleTimeString()},1e3);const c=gr(new Date().toLocaleDateString("id-ID",{weekday:"long",year:"numeric",month:"short",day:"numeric"})),l=gr(" "),d=()=>{const Re=Math.random().toString(36).substring(2,15)+Math.random().toString(36).substring(2,15),re=window.location.origin,$e=`/api/v1/attendance-employee-barcode?qr_token=${Re}`;console.log($e),l.value=`${re}${$e}`};P$(o,Re=>{Re==="camera"&&s.value?jt():Re==="qr"&&nn()}),B$(()=>{d(),console.log(l.value),o.value==="camera"&&s.value&&(jt(),d())});const h=gr(null),p=gr(null),f=gr({message:"",data:null,type:null}),m=gr([]),g=gr({employeeId:null,distance:null,startTime:null,isStable:!1});let b=null;function y(){if(m.value.length===0)return null;const Re={};m.value.forEach(tt=>{Re[tt]=(Re[tt]||0)+1});let re=0,$e=null;for(const[tt,Ke]of Object.entries(Re))Ke>re&&(re=Ke,$e=tt);const Oe=m.value.length*.8;return re>=Oe?$e:null}gr([]);const x=gr([]);function w(Re){const re=Re.detection.score;return re<.85?{isLive:!1,reason:"Kualitas deteksi rendah (foto/video)",score:re}:{isLive:!0,score:re}}function v(Re){const re=document.createElement("canvas"),$e=re.getContext("2d");re.width=Re.videoWidth,re.height=Re.videoHeight,$e.drawImage(Re,0,0);const Oe=$e.getImageData(0,0,re.width,re.height),tt=Oe.data;let Ke=0,pt=0;for(let Kn=0;Kn<tt.length;Kn+=4){const X=tt[Kn],he=tt[Kn+1],_e=tt[Kn+2],xe=(X+he+_e)/3;Ke+=xe,pt++}const lt=Ke/pt;let Et=0;for(let Kn=0;Kn<tt.length;Kn+=4){const X=tt[Kn],he=tt[Kn+1],_e=tt[Kn+2],xe=(X+he+_e)/3;Et+=Math.pow(xe-lt,2)}const Bt=Math.sqrt(Et/pt),kt=N(Oe),Zt=T(Oe),At=E(tt),In=A(Oe),Un=!kt&&Bt>40&&lt>60&&lt<190&&Zt>100&&At>.15&&In>50;return{brightness:lt,contrast:Bt,hasScreenPattern:kt,blurScore:Zt,colorScore:At,textureScore:In,isLive:Un,reason:Un?null:I(kt,Bt,lt,Zt,At,In)}}function I(Re,re,$e,Oe,tt,Ke){return Re?"Terdeteksi pola layar (moir pattern)":re<=40?"Kontras terlalu rendah (foto/video)":$e<=60||$e>=190?"Pencahayaan tidak natural":Oe<=100?"Gambar terlalu blur (foto dari layar)":tt<=.15?"Variasi warna tidak natural":Ke<=50?"Tekstur wajah tidak natural":"Gagal validasi liveness"}function N(Re){const re=Re.data,$e=Re.width,Oe=Re.height,tt=Math.floor($e/2),Ke=Math.floor(Oe/2),pt=50;let lt=0,Et=0;for(let kt=Ke-pt;kt<Ke+pt;kt++)for(let Zt=tt-pt;Zt<tt+pt;Zt++){const At=(kt*$e+Zt)*4,In=(re[At]+re[At+1]+re[At+2])/3;Math.abs(In-lt)>20&&Et++,lt=In}return Et/(pt*pt*4)>.25}function T(Re){const re=Re.data,$e=Re.width,Oe=Re.height;let tt=0,Ke=0;for(let pt=1;pt<Oe-1;pt++)for(let lt=1;lt<$e-1;lt++){const Et=(pt*$e+lt)*4,Bt=(re[Et]+re[Et+1]+re[Et+2])/3,kt=(re[((pt-1)*$e+lt)*4]+re[((pt-1)*$e+lt)*4+1]+re[((pt-1)*$e+lt)*4+2])/3,Zt=(re[((pt+1)*$e+lt)*4]+re[((pt+1)*$e+lt)*4+1]+re[((pt+1)*$e+lt)*4+2])/3,At=(re[(pt*$e+(lt-1))*4]+re[(pt*$e+(lt-1))*4+1]+re[(pt*$e+(lt-1))*4+2])/3,In=(re[(pt*$e+(lt+1))*4]+re[(pt*$e+(lt+1))*4+1]+re[(pt*$e+(lt+1))*4+2])/3,Un=Math.abs(4*Bt-kt-Zt-At-In);tt+=Un*Un,Ke++}return tt/Ke}function E(Re){let re=0,$e=0,Oe=0,tt=0,Ke=0,pt=0;const lt=Re.length/4;for(let At=0;At<Re.length;At+=4)tt+=Re[At],Ke+=Re[At+1],pt+=Re[At+2];const Et=tt/lt,Bt=Ke/lt,kt=pt/lt;for(let At=0;At<Re.length;At+=4)re+=Math.pow(Re[At]-Et,2),$e+=Math.pow(Re[At+1]-Bt,2),Oe+=Math.pow(Re[At+2]-kt,2);const Zt=(re+$e+Oe)/(lt*3);return Math.sqrt(Zt)/255}function A(Re){const re=Re.data,$e=Re.width,Oe=Re.height;let tt=0;const Ke=30;for(let pt=1;pt<Oe-1;pt++)for(let lt=1;lt<$e-1;lt++){const Et=(pt*$e+lt)*4,Bt=(re[Et]+re[Et+1]+re[Et+2])/3,kt=(re[(pt*$e+(lt+1))*4]+re[(pt*$e+(lt+1))*4+1]+re[(pt*$e+(lt+1))*4+2])/3,Zt=(re[((pt+1)*$e+lt)*4]+re[((pt+1)*$e+lt)*4+1]+re[((pt+1)*$e+lt)*4+2])/3,At=Math.abs(kt-Bt),In=Math.abs(Zt-Bt);Math.sqrt(At*At+In*In)>Ke&&tt++}return tt/($e*Oe)*1e4}function k(Re){if(!Re||!Re.positions)return{hasMotion:!0,score:0};if(x.value.push(Re.positions),x.value.length>tct&&x.value.shift(),x.value.length<3)return{hasMotion:!0,score:0};let re=0;const $e=[30,33,36,39,45,48];for(let Ke=1;Ke<x.value.length;Ke++){const pt=x.value[Ke-1],lt=x.value[Ke];let Et=0;for(const Bt of $e)if(Bt<pt.length&&Bt<lt.length){const kt=lt[Bt].x-pt[Bt].x,Zt=lt[Bt].y-pt[Bt].y;Et+=Math.sqrt(kt*kt+Zt*Zt)}re+=Et/$e.length}const Oe=re/(x.value.length-1);return{hasMotion:Oe>.3&&Oe<50,score:Oe,reason:Oe<=.3?"Tidak ada gerakan (foto statis)":Oe>=50?"Gerakan tidak natural (terlalu cepat)":null}}const C=new Map;async function M(Re){try{let re=C.get(Re);re||(re=new Audio(Re),re.preload="auto",C.set(Re,re)),re.currentTime=0,await re.play()}catch(re){throw re}}async function L(){try{await M("/audio/Berhasil Absen.mp3")}catch{try{const re=new AudioContext,$e=re.createOscillator(),Oe=re.createGain();$e.connect(Oe),Oe.connect(re.destination),$e.frequency.setValueAtTime(523.25,re.currentTime),$e.frequency.setValueAtTime(659.25,re.currentTime+.1),$e.frequency.setValueAtTime(783.99,re.currentTime+.2),Oe.gain.setValueAtTime(.3,re.currentTime),Oe.gain.exponentialRampToValueAtTime(.01,re.currentTime+.5),$e.start(re.currentTime),$e.stop(re.currentTime+.5)}catch(re){console.log("Could not play success sound:",re)}}}async function O(){try{await M("/audio/Belum Memiliki Shift.mp3")}catch{try{const re=new AudioContext,$e=re.createOscillator(),Oe=re.createGain();$e.connect(Oe),Oe.connect(re.destination),$e.frequency.setValueAtTime(440,re.currentTime),$e.frequency.setValueAtTime(370,re.currentTime+.15),Oe.gain.setValueAtTime(.3,re.currentTime),Oe.gain.exponentialRampToValueAtTime(.01,re.currentTime+.3),$e.type="square",$e.start(re.currentTime),$e.stop(re.currentTime+.3)}catch(re){console.log("Could not play error sound:",re)}}}async function B(){try{await M("/audio/Sudah Absen.mp3")}catch{try{const re=new AudioContext,$e=re.createOscillator(),Oe=re.createGain();$e.connect(Oe),Oe.connect(re.destination),$e.frequency.setValueAtTime(440,re.currentTime),$e.frequency.setValueAtTime(370,re.currentTime+.15),Oe.gain.setValueAtTime(.3,re.currentTime),Oe.gain.exponentialRampToValueAtTime(.01,re.currentTime+.3),$e.type="square",$e.start(re.currentTime),$e.stop(re.currentTime+.3)}catch(re){console.log("Could not play error sound:",re)}}}async function G(){try{await M("/audio/Gagal Absen.mp3")}catch{try{const re=new AudioContext,$e=re.createOscillator(),Oe=re.createGain();$e.connect(Oe),Oe.connect(re.destination),$e.frequency.setValueAtTime(440,re.currentTime),$e.frequency.setValueAtTime(370,re.currentTime+.15),Oe.gain.setValueAtTime(.3,re.currentTime),Oe.gain.exponentialRampToValueAtTime(.01,re.currentTime+.3),$e.type="square",$e.start(re.currentTime),$e.stop(re.currentTime+.3)}catch(re){console.log("Could not play error sound:",re)}}}async function z(){try{await M("/audio/Absen Lenkap.mp3")}catch{try{const re=new AudioContext,$e=re.createOscillator(),Oe=re.createGain();$e.connect(Oe),Oe.connect(re.destination),$e.frequency.setValueAtTime(440,re.currentTime),$e.frequency.setValueAtTime(370,re.currentTime+.15),Oe.gain.setValueAtTime(.3,re.currentTime),Oe.gain.exponentialRampToValueAtTime(.01,re.currentTime+.3),$e.type="square",$e.start(re.currentTime),$e.stop(re.currentTime+.3)}catch(re){console.log("Could not play error sound:",re)}}}P$(()=>f.value.type,Re=>{Re==1?L():Re==3?B():Re==4?G():Re==2?O():Re==5&&z()});function q(){f.value={message:"",data:null,type:null}}const Q=gr(!1),K=gr("Idle"),ee=gr(""),Y="public/models",de=gr(320),ue=gr(.5),Ie=gr(.6);let Ee=null,ve=null,Ae=null,Be=!1;function Ue(){return new $z({inputSize:de.value,scoreThreshold:ue.value})}async function qe(){try{console.log("Attempting to set WebGL backend..."),await j_("webgl"),await q_(),console.log("WebGL backend initialized successfully")}catch(Re){console.log("WebGL backend failed, falling back to WASM:",Re),await j_("wasm"),await q_(),console.log("WASM backend initialized successfully")}}async function ut(){if(!Be){console.log("Starting to load face recognition models..."),K.value="Loading models...";try{await qe(),console.log("Backend initialized, loading models from:",Y);const Re=`${Y}/tiny_face_detector_model-weights_manifest.json`,re=await fetch(Re);if(!re.ok)throw new Error(`Failed to fetch model manifest: ${re.status} ${re.statusText}`);await Sa.tinyFaceDetector.loadFromUri(Y),await Sa.faceLandmark68Net.loadFromUri(Y),await Sa.faceRecognitionNet.loadFromUri(Y),Be=!0,K.value="Models loaded successfully"}catch(Re){throw console.error("Failed to load models:",Re),console.error("Error details:",{message:Re.message,stack:Re.stack,modelsUrl:Y}),K.value=`Failed to load models: ${Re.message}`,Re}}}function nt(){const Re=h.value,re=p.value;!Re||!re||(re.width=Re.videoWidth,re.height=Re.videoHeight)}function rt(){const Re=p.value;if(!Re)return;Re.getContext("2d").clearRect(0,0,Re.width,Re.height)}const ze=new Map;function ct(Re){const re=Date.now(),$e=ze.get(Re)||0;return re-$e<nct?!1:(ze.set(Re,re),!0)}const ht=gr(!1);async function yn(){const Re=Ue(),re=[],$e=Array.isArray(t.employees)?t.employees:[];let Oe=0;for(const tt of $e){if(Oe++,K.value=`Encoding ${Oe}/${$e.length}: ${tt?.label??"-"}`,!tt?.photo_url){console.warn(`No photo for ${tt?.label??"(no label)"}, skipping.`);continue}try{const Ke=await bRe(tt.photo_url);console.log(tt.photo_url);const pt=await R_e(Ke,Re).withFaceLandmarks().withFaceDescriptor();if(!pt){console.warn(`No face for ${tt.label} at ${tt.photo_url}`);continue}re.push(new Hb(tt.label,[pt.descriptor])),Ke&&Ke.remove&&Ke.remove()}catch(Ke){console.warn(`Failed ${tt?.label??"(no label)"}:`,Ke)}}re.length>0?(Ae=new F_e(re,Ie.value),K.value=`Loaded ${re.length} face template(s)`,ht.value=!0):(Ae=null,ht.value=!1,K.value="No face templates found. Detection only mode.",console.warn("No descriptors created; running in detection-only mode."))}let St=!1;async function pn(){if(!(!Q.value||!h.value||!p.value)&&!St){St=!0;try{const Re=!!Ae,re=Ue(),$e=__e(h.value,re).withFaceLandmarks(),Oe=Re?await $e.withFaceDescriptors():await $e,tt={width:h.value.videoWidth||p.value.width,height:h.value.videoHeight||p.value.height},Ke=Pz(Oe,tt);p.value.getContext("2d").clearRect(0,0,p.value.width,p.value.height);let lt=null;try{const Et=document.createElement("canvas"),Bt=Et.getContext("2d");Et.width=h.value.videoWidth,Et.height=h.value.videoHeight,Bt.drawImage(h.value,0,0,Et.width,Et.height),lt=await new Promise(kt=>Et.toBlob(kt,"image/jpeg",.8))}catch(Et){console.error("Failed to capture photo:",Et)}for(const Et of Ke){let Bt="Unknown",kt=1;if(Re&&Et.descriptor){const xe=Ae.findBestMatch(Et.descriptor);Bt=xe.label==="unknown"?"Unknown":xe.label,kt=xe.distance}const Zt=w(Et),At=v(h.value),In=EF?k(Et.landmarks):{hasMotion:!0,score:0},Un=!Zt.isLive,Kn=!At.isLive,X=EF&&!In.hasMotion;if(Un||Kn||X){let xe=" Terdeteksi Pemalsuan";Un?xe=` ${Zt.reason}`:Kn&&(xe=` ${At.reason}`),new qC.DrawBox(Et.detection.box,{label:xe,boxColor:"#ef4444"}).draw(p.value),console.warn("Anti-spoofing triggered:",{liveness:Zt,quality:At,motion:In});continue}let he=0,_e="#0ea5e9";if(Re&&Bt!=="Unknown"&&kt<=Ie.value){const[xe]=String(Bt).split("|");if(xe?.trim()===g.value.employeeId&&g.value.startTime){const bt=Date.now()-g.value.startTime;he=Math.min(bt/Uk*100,100),he>=100?_e="#10b981":_e="#f59e0b"}}if(new qC.DrawBox(Et.detection.box,{label:`${Bt}${Re?` (${kt.toFixed(2)})`:""}${he>0?` - ${Math.round(he)}%`:""}`,boxColor:_e}).draw(p.value),Re&&Bt!=="Unknown"&&kt<=Ie.value){const[xe]=String(Bt).split("|"),wt=xe?.trim();if(wt){m.value.push(wt),m.value.length>ect&&m.value.shift();const bt=y();if(bt)if(g.value.employeeId===bt){if(Date.now()-g.value.startTime>=Uk&&!g.value.isStable&&(g.value.isStable=!0,ct(bt)))try{const $t=await vn({employeeId:bt,distance:kt,photo:lt});f.value={message:$t.message,data:$t?.data||null,type:$t?.type||"error"},m.value=[]}catch($t){f.value={message:String($t?.message||$t),data:null,type:"error"}}}else b&&clearTimeout(b),g.value={employeeId:bt,distance:kt,startTime:Date.now(),isStable:!1},b=setTimeout(()=>{},Uk)}}else b&&(clearTimeout(b),b=null),g.value={employeeId:null,distance:null,startTime:null,isStable:!1},m.value=[]}}finally{St=!1}}}async function jt(){try{if(ee.value="",q(),await ut(),K.value="Encoding employees...",await yn(),K.value="Starting camera...",!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia)throw new Error("getUserMedia is not supported in this browser");try{Ee=await navigator.mediaDevices.getUserMedia({video:{facingMode:"user"},audio:!1})}catch(re){console.error("getUserMedia error:",re);let $e="Failed to access camera: ";throw re.name==="NotAllowedError"?$e+="Camera permission denied":re.name==="NotFoundError"?$e+="No camera device found":re.name==="NotReadableError"?$e+="Camera is already in use by another application":re.name==="OverconstrainedError"?$e+="Camera constraints cannot be satisfied":$e+=re.message||"Unknown error",new Error($e)}const Re=h.value;Re.srcObject=Ee,await new Promise((re,$e)=>{const Oe=()=>{Re.removeEventListener("canplay",Oe),re()};Re.addEventListener("canplay",Oe,{once:!0}),Re.play().catch($e)}),nt(),Q.value=!0,K.value=ht.value?"Running (recognition ON)":"Running (detection only)",ve=setInterval(pn,150)}catch(Re){console.error("Start function error:",Re),ee.value=String(Re?.message||Re),nn()}}function nn(){Q.value=!1,K.value="Stopped",ve&&(clearInterval(ve),ve=null),Ee&&(Ee.getTracks().forEach(Re=>Re.stop()),Ee=null),rt()}function wn(){return document.querySelector('meta[name="csrf-token"]')?.getAttribute("content")||""}gr(7);async function Tt(Re){try{const re=await new Promise((pt,lt)=>{const Et=new FileReader;Et.onloadend=()=>{const Bt=Et.result.split(",")[1];pt(Bt)},Et.onerror=lt,Et.readAsDataURL(Re)});console.log("Calling liveness detection API...");const $e=await fetch("https://faceapi.mxface.ai/api/v3/face/Liveness",{method:"POST",headers:{"Content-Type":"application/json",Subscriptionkey:"sshpZNaxdwtwBTxHwM-miBM9ztUzE4911"},body:JSON.stringify({image:re})});if(!$e.ok)return console.error("Liveness API error:",$e.status,$e.statusText),{isLive:!1,score:0,message:"Gagal melakukan verifikasi liveness"};const tt=(await $e.json()).livenessScore||0,Ke=70;return console.log("Liveness detection result:",{score:tt,threshold:Ke,isLive:tt>=Ke}),{isLive:tt>=Ke,score:tt,message:tt>=Ke?"Verifikasi liveness berhasil":"Foto tidak terdeteksi sebagai wajah asli. Silakan gunakan kamera langsung."}}catch(re){return console.error("Liveness check exception:",re),{isLive:!1,score:0,message:"Terjadi kesalahan saat verifikasi liveness: "+re.message}}}async function vn({employeeId:Re,distance:re,photo:$e}){console.log("notifyHit called with:",{employeeId:Re,distance:re,photo:$e?"photo provided":"no photo"}),console.log("Current position:",n.value);try{if($e){console.log("Checking liveness before attendance...");const At=await Tt($e);if(!At.isLive)return console.warn("Liveness check failed:",At),{ok:!1,status:400,message:`${At.message} (Score: ${At.score.toFixed(2)})`,type:4,data:{employee:{id:Re},status:"DITOLAK",type:4}};console.log("Liveness check passed:",At)}const Oe=new FormData;Oe.append("employee_id",String(Re)),n.value?.latitude!=null&&Oe.append("latitude",String(n.value.latitude)),n.value?.longitude!=null&&Oe.append("longitude",String(n.value.longitude)),re!=null&&Oe.append("distance",String(re)),$e&&Oe.append("photo",$e,"absen.jpg"),console.log("FormData prepared:",{employee_id:Re,latitude:n.value?.latitude,longitude:n.value?.longitude,distance:re,hasPhoto:!!$e});const tt=route("attendance.employee",{employee_id:Re});console.log("Request URL:",tt);const Ke=await fetch(tt,{method:"POST",credentials:"include",headers:{Accept:"application/json","X-CSRF-TOKEN":wn()},body:Oe});console.log("Response status:",Ke.status),console.log("Response ok:",Ke.ok);const pt=await Ke.text();console.log("Raw response:",pt);let lt;try{lt=JSON.parse(pt),console.log("Parsed response body:",lt)}catch{console.warn("Failed to parse response as JSON, using raw text"),lt={message:pt}}const Et=lt?.data?.type,Bt=lt?.data?.employee??null;if(r=!0,!Ke.ok){const At={ok:!1,status:Ke.status,message:lt?.message||`Gagal absensi (HTTP ${Ke.status})`,type:Et??"error",data:{employee:Bt}};return console.error("Request failed:",At),At}const kt=lt?.data??null,Zt={ok:!0,status:Ke.status,message:lt?.message||"Absensi berhasil",type:Et??"success",data:kt};return console.log("Request successful:",Zt),Zt}catch(Oe){const tt={ok:!1,status:0,message:"Tidak bisa terhubung ke server.",type:"error",data:null};return console.error("Exception in notifyHit:",Oe),console.error("Returning error result:",tt),tt}}function Kt(){navigator.geolocation?navigator.geolocation.getCurrentPosition(Re=>{n.value.latitude=Number(Re.coords.latitude.toFixed(8)),n.value.longitude=Number(Re.coords.longitude.toFixed(8))},()=>{alert("Unable to retrieve your location.")}):alert("Geolocation is not supported by your browser.")}B$(()=>{ut().catch($e=>{ee.value=String($e?.message||$e)}),Kt(),new dut("15b1130172da3df3b87a",{cluster:"ap1",encrypted:!0}).subscribe("attendance-channel").bind("attendance-barcode-event",function($e){console.log("Attendance event received:",$e),f.value=$e,r.value=!0,d()})}),HK(()=>{nn(),b&&(clearTimeout(b),b=null)});const an=gr([]);function xr(Re){an.value=an.value.filter(re=>re.id!==Re)}return(Re,re)=>{const $e=jK("vue-qrcode");return _s(),Rs(YI,null,[ft("div",hut,[(_s(!0),Rs(YI,null,z$(an.value,Oe=>(_s(),Rs("div",{key:Oe.id,class:W$([{"bg-green-500":Oe.variant==="success","bg-blue-500":Oe.variant==="info","bg-red-500":Oe.variant==="error"},"px-6 py-4 max-w-md text-white rounded-lg shadow-lg"])},[Oe.employeeName?(_s(),Rs("div",put,[Oe.type==="masuk"?(_s(),Rs("svg",fut,[...re[2]||(re[2]=[ft("path",{"stroke-linecap":"round","stroke-linejoin":"round","stroke-width":"2",d:"M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"},null,-1)])])):Oe.type==="keluar"?(_s(),Rs("svg",mut,[...re[3]||(re[3]=[ft("path",{"stroke-linecap":"round","stroke-linejoin":"round","stroke-width":"2",d:"M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z"},null,-1)])])):(_s(),Rs("svg",gut,[...re[4]||(re[4]=[ft("path",{"stroke-linecap":"round","stroke-linejoin":"round","stroke-width":"2",d:"M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"},null,-1)])])),ft("div",but,[ft("p",yut,fa(Oe.employeeName)+" "+fa(Oe.type==="masuk"?"masuk":"keluar"),1),ft("p",xut,fa(Oe.time),1),Oe.status?(_s(),Rs("p",wut,fa(Oe.status),1)):oc("",!0)]),ft("button",{onClick:tt=>xr(Oe.id),class:"ml-4 text-white hover:text-gray-200"},[...re[5]||(re[5]=[ft("svg",{class:"w-5 h-5",fill:"currentColor",viewBox:"0 0 20 20"},[ft("path",{"fill-rule":"evenodd",d:"M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z","clip-rule":"evenodd"})],-1)])],8,vut)])):(_s(),Rs("div",Iut,[re[6]||(re[6]=ft("svg",{class:"mr-3 w-6 h-6",fill:"none",stroke:"currentColor",viewBox:"0 0 24 24"},[ft("path",{"stroke-linecap":"round","stroke-linejoin":"round","stroke-width":"2",d:"M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"})],-1)),ft("p",kut,fa(Oe.message),1)]))],2))),128))]),ft("div",Cut,[ft("div",Sut,[ft("div",Nut,[ft("label",Tut,[V$(ft("input",{type:"radio",name:"attendanceMode",value:"camera","onUpdate:modelValue":re[0]||(re[0]=Oe=>o.value=Oe),class:"w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 focus:ring-blue-500"},null,512),[[U$,o.value]]),re[7]||(re[7]=ft("span",{class:"text-white font-medium"},"Absen Muka",-1))]),ft("label",Eut,[V$(ft("input",{type:"radio",name:"attendanceMode",value:"qr","onUpdate:modelValue":re[1]||(re[1]=Oe=>o.value=Oe),class:"w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 focus:ring-blue-500"},null,512),[[U$,o.value]]),re[8]||(re[8]=ft("span",{class:"text-white font-medium"},"Absen QR",-1))])]),ft("div",Aut,[o.value==="camera"?(_s(),Rs("div",{key:0,class:W$(["flex flex-col items-center w-3/4 text-center bg-white rounded-md shadow-md",u2(s)?"":"p-24"])},[u2(s)?oc("",!0):(_s(),Rs("div",$ut,[...re[9]||(re[9]=[G$('<svg width="319" height="320" viewBox="0 0 319 320" fill="none" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_4556_66742)"><path d="M75.1901 183.482C67.3091 172.565 59.3114 161.532 54.1742 149.097C49.037 136.663 46.877 122.477 50.9635 109.692C55.5169 95.3899 68.0681 83.948 82.7208 80.6788C89.3758 79.2194 97.2568 78.8691 101.343 73.3816C102.861 71.3384 103.62 68.8282 104.32 66.318C106.831 57.0943 109.691 46.4113 118.448 42.5C127.963 38.2384 138.53 44.4848 147.928 49.0382C158.67 54.2338 170.345 57.3862 182.254 58.2619C187.567 58.6705 192.938 58.6121 198.016 60.1299C203.095 61.6478 207.941 65.2088 209.4 70.2876C211.035 76.1838 207.882 82.7804 209.925 88.5014C211.56 93.0548 216.172 95.9737 220.842 97.4332C225.454 98.8926 230.416 99.3596 235.028 100.994C247.929 105.548 256.102 119.033 257.561 132.635C259.021 146.237 254.818 159.839 249.213 172.273C246.178 178.986 242.733 185.525 238.063 191.246C220.725 212.67 188.968 218.742 162.523 210.919C156.218 209.051 150.03 206.482 143.55 205.49C136.311 204.381 128.956 205.256 121.6 205.081C105.196 204.731 88.9672 198.952 75.949 188.911" fill="white"></path><path d="M274.727 211.444C273.909 208.876 272.683 206.482 271.282 204.264C269.765 201.87 267.955 199.477 267.254 196.675C266.437 193.639 267.371 190.545 268.13 187.568C268.889 184.591 269.297 181.73 268.83 178.694C267.838 172.448 263.81 167.136 259.84 162.349C260.891 161.24 261.475 159.839 261.592 158.262C261.708 156.511 261.3 154.76 261.358 153.008C261.358 152.716 261.241 152.483 261.125 152.308C261.883 149.331 262.584 146.353 263.343 143.376C263.985 140.866 264.744 138.297 265.036 135.67C265.853 136.312 266.904 136.721 267.955 136.721C271.165 136.721 273.267 132.81 274.318 130.241C275.661 127.03 276.011 123.528 275.953 120.083C275.894 118.099 275.719 116.172 275.544 114.187C275.369 112.67 275.427 110.86 274.435 109.576C273.968 108.992 273.325 108.583 272.625 108.35C272.391 107.591 272.041 106.89 271.516 106.248C270.348 104.847 268.188 104.088 266.554 105.139C265.912 103.154 264.686 101.461 262.409 101.228C259.957 100.994 258.031 102.629 257.097 104.73C255.462 102.278 252.952 100.585 249.916 100.644C246.764 100.702 243.728 102.337 241.51 104.497C239 106.949 237.307 110.218 236.139 113.487C234.971 116.698 234.154 120.084 233.746 123.528C233.045 129.774 233.629 136.604 230.243 142.15C229.893 142.734 229.484 143.376 229.075 143.96C226.624 146.645 225.164 150.206 225.047 153.826C224.989 155.694 225.865 157.854 224.347 159.372C223.121 160.597 221.486 161.24 220.377 162.582C217.633 165.851 218.042 170.288 218.1 174.258C218.159 176.535 217.925 178.694 217.166 180.796C216.466 182.781 215.415 184.649 214.539 186.575C213.138 189.553 212.263 192.705 211.971 195.916C208.702 189.261 204.382 183.19 199.186 177.877C193.991 172.565 188.094 168.011 181.906 163.925C179.571 162.349 177.178 160.773 174.668 159.372C174.668 159.021 174.492 158.729 174.259 158.554C173.383 153.826 172.508 149.097 171.632 144.369C170.639 138.939 169.589 133.51 168.596 128.081C168.421 127.206 168.246 126.33 168.071 125.396C173.15 122.535 178.229 119.675 183.249 116.814C183.95 116.406 183.833 115.588 183.249 115.18C178.17 111.444 173.15 107.649 168.071 103.855C165.444 101.87 162.759 99.8265 160.073 97.8417C157.505 95.9152 154.994 93.8136 152.192 92.2375C150.383 91.1867 148.456 90.3694 146.471 89.9024C147.522 89.3186 148.573 88.6181 149.565 87.6256C152.367 84.7651 153.652 75.5415 147.872 70.9297C143.202 83.4808 134.387 77.5847 124.872 85.5824C117.633 91.7121 121.953 107.007 127.615 113.72C125.047 114.246 122.712 115.764 121.369 118.04C119.151 121.893 120.201 127.206 123.704 129.949C125.222 131.175 127.148 131.759 129.075 131.817C127.79 141.041 125.864 150.09 124.054 159.196C118.625 161.006 113.196 162.874 108.351 165.968C103.33 169.179 98.7185 172.915 94.3402 176.943C92.297 178.811 90.3121 180.679 88.3273 182.606C87.3349 177.877 84.5912 173.44 80.2712 171.281C80.5631 170.755 80.2128 170.171 79.7458 169.938C80.2712 167.311 80.0961 164.625 79.1037 162.057C77.9945 159.138 76.1264 156.628 74.4919 154.059C70.9892 148.572 71.5146 141.683 70.6973 135.495C70.2303 132.109 69.3546 128.723 68.1871 125.513C66.9611 122.243 65.2682 118.974 62.6996 116.581C60.4229 114.479 57.3873 112.845 54.2349 112.845C51.1993 112.845 48.689 114.538 47.1128 117.048C46.1788 114.946 44.2523 113.37 41.8005 113.604C39.5238 113.837 38.3562 115.588 37.7141 117.573C36.0795 116.522 33.9195 117.34 32.752 118.741C32.2266 119.383 31.8763 120.084 31.7012 120.901C31.0006 121.134 30.3585 121.543 29.9498 122.127C29.0158 123.411 29.0742 125.221 28.8991 126.739C28.7239 128.723 28.5488 130.65 28.5488 132.635C28.5488 136.079 28.9575 139.582 30.3585 142.792C31.4677 145.361 33.6276 149.214 36.8384 149.214C37.8892 149.214 38.94 148.805 39.7573 148.163C40.0492 150.79 40.8664 153.359 41.5086 155.869C42.2675 158.846 43.0848 161.765 43.8437 164.742C42.034 166.785 41.8589 169.938 42.3259 172.565C42.6178 174.199 43.2016 175.834 43.2016 177.469C43.2016 179.161 42.2675 180.679 41.3919 182.08C39.6405 185.058 38.5314 188.385 39.407 191.829C39.5822 192.647 39.9324 193.406 40.341 194.106C40.5162 194.456 40.7497 194.807 40.8665 195.157C41.0416 195.682 40.7497 195.741 40.3994 195.974C39.0567 196.733 37.9476 197.842 37.1303 199.127C36.313 200.411 35.846 201.87 35.6708 203.33C35.4957 204.964 35.846 206.541 36.313 208.117C36.8384 209.868 37.5389 211.678 37.6557 213.487C37.7725 215.414 37.4221 217.34 36.9551 219.267C36.1962 222.594 35.4373 225.863 35.4373 229.308C35.4373 232.343 35.9044 235.437 36.78 238.356L38.7649 238.239C38.8816 238.648 38.9984 238.998 39.1735 239.407C39.1735 239.407 104.498 257.971 139.758 246.471C175.018 234.912 228.783 203.446 273.792 225.98C275.135 226.622 277.937 221.427 274.727 211.444Z" fill="white"></path><path d="M110.219 115.468L102.455 123.349C96.6756 129.245 87.2768 129.303 81.3807 123.524L75.6597 117.92C69.7636 112.14 69.7052 102.742 75.4845 96.8456L83.2488 88.9062" fill="#CB730B"></path><path d="M110.262 115.455C112.365 113.317 108.03 105.646 100.581 98.3225C93.1318 90.9988 85.389 86.7951 83.2868 88.9332C81.1846 91.0714 85.5192 98.7418 92.9683 106.065C100.417 113.389 108.16 117.593 110.262 115.455Z" fill="white"></path><path d="M29.1316 128.015C30.2408 128.482 29.7737 130.35 28.6062 129.883C25.7457 128.716 22.9435 127.315 20.3166 125.622C11.0929 119.726 3.91252 110.852 0.0596043 100.578C-0.349038 99.4103 1.46063 98.9433 1.92765 100.052C2.97845 102.796 4.26281 105.423 5.78062 107.992C11.2097 116.924 19.4409 124.104 29.1316 128.015ZM78.5189 120.66C77.0595 121.769 75.6 122.878 73.9654 123.754C72.0974 124.804 70.1126 125.388 67.9526 125.622C64.0413 126.03 59.8381 125.739 56.4522 128.074C55.4598 128.774 56.3939 130.467 57.4447 129.708C60.8306 127.315 65.2672 127.898 69.1785 127.373C73.3233 126.789 76.6508 124.454 79.8615 121.944L78.5189 120.66ZM110.918 116.106C112.261 114.705 111.911 112.02 109.809 108.342C107.941 105.015 104.906 101.22 101.228 97.6006C94.1641 90.6537 85.5242 85.2245 82.547 88.2602C79.5697 91.2374 85.1739 99.8189 92.2376 106.766C97.9002 112.37 104.672 116.982 108.583 116.982C109.576 116.982 110.335 116.69 110.918 116.106ZM99.885 99.0016C103.446 102.504 106.365 106.124 108.116 109.276C109.809 112.312 110.043 114.238 109.517 114.764C108.233 116.048 101.403 113.071 93.5802 105.365C85.7577 97.6589 82.6637 90.8872 83.948 89.6029C84.1231 89.4277 84.4734 89.311 84.8821 89.311C87.3339 89.311 93.23 92.4634 99.885 99.0016ZM91.4787 101.045C93.8138 103.322 96.0905 105.598 98.4256 107.875C99.3013 108.751 100.644 107.408 99.7683 106.532C97.4332 104.256 95.1565 101.979 92.8214 99.7022C91.9457 98.8265 90.603 100.169 91.4787 101.045ZM93.697 97.8341C96.0321 100.111 98.3089 102.388 100.644 104.664C101.52 105.54 102.862 104.197 101.987 103.322C99.6515 101.045 97.3748 98.7681 95.0397 96.4914C94.164 95.6157 92.8214 96.9584 93.697 97.8341ZM80.4453 97.9508C83.8312 103.789 87.7425 109.801 93.8721 113.071C94.9813 113.654 95.9154 112.02 94.8646 111.436C89.0268 108.342 85.349 102.563 82.1383 97.0168C81.4961 95.9076 79.8615 96.9 80.4453 97.9508Z" fill="black"></path><path d="M218.334 78.9844L228.375 83.6546C235.847 87.0988 239.116 95.9722 235.672 103.445L232.286 110.742C228.842 118.214 219.968 121.483 212.496 118.039L202.455 113.369" fill="#015B7A"></path><path d="M218.334 78.9815C216.524 78.1642 213.314 80.8495 210.103 85.5197L202.456 82.0171C201.58 81.6085 200.529 82.0171 200.12 82.8928L199.42 84.4106C199.011 85.2862 199.42 86.337 200.296 86.7457L207.418 89.9564C206.775 91.1824 206.075 92.4667 205.491 93.8093C205.433 93.9261 205.375 94.1012 205.316 94.218L197.435 90.657C196.56 90.2483 195.509 90.657 195.1 91.5326L194.399 93.0504C193.991 93.9261 194.399 94.9769 195.275 95.3855L203.331 99.0633C200.763 106.302 200.296 112.257 202.514 113.249C205.258 114.533 211.037 107.82 215.415 98.3628C219.735 88.964 221.078 80.2658 218.334 78.9815Z" fill="white"></path><path d="M218.741 78.1069C216.989 77.2896 214.537 78.5739 211.794 81.7846C211.152 82.5436 210.451 83.4192 209.809 84.3533L202.862 81.2009C202.22 80.909 201.461 80.8506 200.76 81.1425C200.06 81.376 199.534 81.9014 199.243 82.5436L198.542 84.0614C198.25 84.7035 198.192 85.4624 198.484 86.163C198.717 86.8635 199.243 87.3889 199.885 87.6808L206.073 90.4829C205.606 91.3002 205.197 92.1758 204.788 93.0515L197.783 89.8991C197.141 89.6072 196.382 89.5488 195.682 89.8407C194.981 90.0742 194.456 90.5996 194.164 91.2418L193.463 92.7596C193.171 93.4018 193.113 94.1607 193.405 94.8612C193.638 95.5617 194.164 96.0871 194.806 96.379L202.103 99.7065C201.286 102.158 200.644 104.493 200.352 106.595C199.71 110.798 200.293 113.425 202.045 114.243C202.395 114.418 202.804 114.476 203.154 114.476C207.007 114.476 212.436 107.004 216.172 98.8892C220.375 89.8991 222.535 79.8582 218.741 78.1069ZM200.293 85.4624C200.235 85.2873 200.235 85.0538 200.293 84.8203L200.994 83.3025C201.111 83.0106 201.403 82.8354 201.753 82.8354C201.87 82.8354 201.986 82.8354 202.103 82.8938L213.428 88.031L212.086 91.0083L200.76 85.8711C200.527 85.8127 200.352 85.6376 200.293 85.4624ZM195.215 94.1607C195.156 93.9855 195.156 93.752 195.215 93.5185L195.915 92.0007C196.032 91.8256 196.149 91.6504 196.382 91.5921C196.499 91.5337 196.557 91.5337 196.674 91.5337C196.791 91.5337 196.907 91.5337 197.024 91.5921L208.349 96.7293L207.007 99.7065L195.682 94.5693C195.448 94.5109 195.273 94.3358 195.215 94.1607ZM214.479 98.0719C209.867 107.996 204.555 113.25 202.862 112.491C202.161 112.199 201.694 110.331 202.22 106.887C202.512 104.96 203.096 102.801 203.854 100.524L207.882 102.334L210.86 95.8536L206.54 93.8688C206.948 92.9931 207.415 92.1175 207.824 91.3002L212.961 93.6353L215.939 87.1554L211.619 85.1705C212.144 84.4116 212.728 83.7111 213.253 83.0689C215.238 80.7922 216.814 79.8582 217.631 79.8582C217.748 79.8582 217.865 79.8582 217.982 79.9166C219.616 80.6171 219.091 88.0894 214.479 98.0719ZM222.01 85.1705C222.01 83.9446 223.936 83.9446 223.936 85.1705C223.995 95.6785 219.733 106.07 212.261 113.484C211.385 114.359 210.042 113.017 210.918 112.141C218.04 105.019 222.068 95.2115 222.01 85.1705ZM234.269 108.93C233.043 108.93 233.043 107.004 234.269 107.004C237.305 107.004 239.581 109.105 241.333 111.324C243.026 113.484 244.66 116.169 247.579 116.753C248.805 116.986 248.28 118.854 247.054 118.621C244.193 118.095 242.267 115.819 240.632 113.6C239.056 111.499 237.188 108.93 234.269 108.93ZM275.425 120.722C274.199 120.781 274.199 118.854 275.425 118.796C278.928 118.562 282.372 117.862 285.7 116.811C297.9 112.9 307.883 104.435 317.34 96.1455C318.274 95.3282 319.617 96.6709 318.683 97.4882C315.822 99.9984 313.02 102.45 310.043 104.844C300.119 112.9 288.56 119.905 275.425 120.722Z" fill="black"></path><path d="M136.663 284.003C136.663 288.79 132.81 292.643 128.023 292.643C123.236 292.643 119.383 288.79 119.383 284.003C119.383 279.216 123.236 275.363 128.023 275.363C132.81 275.305 136.663 279.216 136.663 284.003ZM150.907 275.305C146.12 275.305 142.267 279.158 142.267 283.945C142.267 288.732 146.12 292.584 150.907 292.584C155.694 292.584 159.546 288.732 159.546 283.945C159.546 279.216 155.694 275.305 150.907 275.305ZM150.907 275.305C146.12 275.305 142.267 279.158 142.267 283.945C142.267 288.732 146.12 292.584 150.907 292.584C155.694 292.584 159.546 288.732 159.546 283.945C159.546 279.216 155.694 275.305 150.907 275.305ZM175.367 275.305C170.58 275.305 166.727 279.158 166.727 283.945C166.727 288.732 170.58 292.584 175.367 292.584C180.154 292.584 184.007 288.732 184.007 283.945C184.007 279.216 180.154 275.305 175.367 275.305Z" fill="white"></path><path d="M158.262 136.25C158.612 136.6 158.612 137.242 158.262 137.593C157.853 137.943 157.503 138.352 157.153 138.76C157.095 138.819 157.094 138.877 157.036 138.877C157.036 138.877 157.036 138.935 156.978 138.935C156.919 139.052 156.803 139.169 156.744 139.227C156.569 139.461 156.452 139.636 156.336 139.869C156.044 140.336 155.81 140.803 155.577 141.27C155.518 141.329 155.518 141.387 155.518 141.446C155.518 141.446 155.518 141.446 155.518 141.504C155.46 141.621 155.402 141.737 155.343 141.913C155.226 142.146 155.168 142.38 155.11 142.671C154.935 143.197 154.468 143.489 153.942 143.372C153.417 143.255 153.125 142.671 153.242 142.204C153.942 139.928 155.168 137.885 156.919 136.308C157.27 135.841 157.853 135.841 158.262 136.25ZM39.2887 239.403C41.2736 245.007 44.9514 250.086 49.7383 253.53C50.7307 254.231 49.7967 255.924 48.7459 255.165C43.0249 251.02 38.8801 245.066 36.8953 238.294C36.0196 235.375 35.5526 232.281 35.5526 229.245C35.5526 225.801 36.3115 222.532 37.0704 219.204C37.5374 217.336 37.8877 215.41 37.7709 213.425C37.6542 211.557 36.9537 209.806 36.4283 208.054C35.9613 206.478 35.611 204.902 35.7861 203.267C35.9612 201.749 36.4282 200.29 37.2455 199.064C38.0628 197.78 39.172 196.671 40.5147 195.912C40.9234 195.678 41.1568 195.62 40.9817 195.094C40.8649 194.744 40.6314 194.394 40.4563 194.044C40.0476 193.343 39.7558 192.584 39.5223 191.767C38.6466 188.323 39.6974 184.995 41.5071 182.018C42.3828 180.617 43.3168 179.157 43.3168 177.406C43.3168 175.713 42.733 174.137 42.4411 172.502C41.9741 169.875 42.0908 166.723 43.9589 164.68C43.2 161.703 42.3827 158.784 41.6238 155.806C40.9817 153.296 40.1644 150.728 39.8725 148.101C39.0552 148.743 38.0044 149.151 36.9536 149.151C33.7429 149.151 31.5829 145.298 30.4737 142.73C29.1311 139.519 28.6641 136.016 28.6641 132.572C28.6641 130.587 28.8392 128.661 29.0143 126.676C29.1311 125.158 29.1311 123.349 30.0651 122.064C30.5322 121.48 31.1159 121.072 31.8165 120.838C32.05 120.079 32.3418 119.32 32.8672 118.678C34.0348 117.277 36.1947 116.46 37.8293 117.511C38.4714 115.526 39.639 113.775 41.9157 113.541C44.3676 113.308 46.2941 114.884 47.2281 116.985C48.8043 114.475 51.3145 112.782 54.3501 112.782C57.5025 112.782 60.5382 114.417 62.8149 116.518C65.3835 118.912 67.0764 122.181 68.3024 125.45C69.5283 128.661 70.4039 132.047 70.8126 135.433C71.6298 141.679 71.1044 148.509 74.6071 153.997C76.2417 156.624 78.1098 159.134 79.2189 161.994C80.2113 164.563 80.3281 167.248 79.8611 169.875C80.3281 170.109 80.6784 170.693 80.3865 171.218C84.7648 173.378 87.5086 177.815 88.4426 182.543C90.4274 180.617 92.4122 178.69 94.4554 176.881C98.8337 172.911 103.446 169.116 108.466 165.906C113.311 162.812 118.74 160.944 124.17 159.134C125.921 150.027 127.906 140.979 129.19 131.755C127.264 131.696 125.337 131.113 123.819 129.887C120.317 127.143 119.266 121.831 121.484 117.978C122.827 115.701 125.162 114.183 127.731 113.658C122.126 106.944 117.748 91.6496 124.987 85.5199C134.444 77.5222 143.317 83.4183 147.988 70.8672C153.825 75.479 152.541 84.7026 149.681 87.5631C148.688 88.5556 147.637 89.3145 146.587 89.8399C148.571 90.3069 150.498 91.1242 152.308 92.175C155.11 93.7512 157.62 95.8527 160.189 97.7792C162.874 99.764 165.501 101.749 168.186 103.792C173.207 107.587 178.227 111.381 183.364 115.117C183.948 115.526 184.065 116.402 183.364 116.752C178.285 119.612 173.265 122.531 168.186 125.333C168.361 126.209 168.536 127.085 168.712 128.019C169.704 133.448 170.755 138.877 171.747 144.306C172.623 149.035 173.499 153.763 174.374 158.492C174.608 158.667 174.841 158.959 174.783 159.309C177.235 160.71 179.628 162.286 182.022 163.862C188.21 167.949 194.106 172.502 199.301 177.815C204.497 183.127 208.817 189.198 212.086 195.853C212.378 192.643 213.254 189.49 214.655 186.513C215.53 184.586 216.581 182.718 217.282 180.734C218.041 178.574 218.274 176.472 218.216 174.195C218.157 170.226 217.749 165.789 220.492 162.52C221.602 161.177 223.236 160.535 224.462 159.309C225.98 157.85 225.104 155.631 225.163 153.763C225.221 150.144 226.68 146.583 229.191 143.897C229.599 143.314 229.95 142.671 230.358 142.088C233.744 136.542 233.16 129.712 233.861 123.465C234.269 120.079 235.087 116.635 236.254 113.424C237.422 110.155 239.115 106.886 241.625 104.434C243.843 102.274 246.879 100.64 250.031 100.581C253.067 100.523 255.577 102.216 257.212 104.668C258.146 102.566 260.014 100.932 262.524 101.165C264.801 101.34 266.027 103.092 266.669 105.076C268.303 104.026 270.463 104.784 271.631 106.186C272.156 106.828 272.507 107.528 272.74 108.287C273.441 108.462 274.083 108.871 274.55 109.513C275.484 110.797 275.484 112.607 275.659 114.125C275.893 116.11 276.068 118.036 276.068 120.021C276.126 123.465 275.717 126.968 274.433 130.179C273.382 132.747 271.281 136.659 268.07 136.659C267.019 136.659 265.968 136.25 265.151 135.608C264.859 138.235 264.1 140.803 263.458 143.314C262.699 146.291 261.999 149.268 261.24 152.245C261.415 152.421 261.532 152.596 261.473 152.946C261.415 154.697 261.824 156.449 261.707 158.2C261.648 159.776 261.065 161.177 259.956 162.286C263.925 167.073 267.953 172.386 268.946 178.632C269.413 181.668 269.004 184.528 268.245 187.505C267.486 190.483 266.552 193.577 267.369 196.612C268.128 199.414 269.88 201.808 271.398 204.201C272.857 206.478 274.024 208.813 274.842 211.382C278.111 221.423 275.893 232.981 269.062 241.037C268.245 241.972 266.902 240.629 267.72 239.695C271.398 235.375 273.616 229.887 274.258 224.283C274.783 219.263 274.141 214.125 272.098 209.514C269.938 204.552 265.443 200.407 265.151 194.744C264.976 191.709 265.968 188.79 266.669 185.871C267.311 183.01 267.486 180.208 266.727 177.406C265.385 172.21 261.999 167.774 258.613 163.746C258.554 163.746 258.496 163.804 258.438 163.804C255.577 164.797 252.542 165.088 249.564 165.088C246.587 165.088 243.552 164.913 240.633 164.505C235.671 163.862 231 161.819 227.147 158.667C226.856 159.718 226.213 160.652 225.221 161.411C223.82 162.52 222.302 163.22 221.368 164.797C219.267 168.416 220.434 172.853 220.142 176.764C219.85 181.025 217.632 184.586 215.997 188.439C214.363 192.176 213.721 196.204 213.954 200.232C214.012 200.407 214.071 200.64 214.012 200.757C214.012 201.049 214.071 201.341 214.071 201.691C214.188 202.917 212.32 202.917 212.144 201.691C212.086 201.341 212.086 200.991 212.028 200.64C211.619 199.648 211.21 198.655 210.743 197.721C207.241 190.191 202.22 183.536 196.266 177.756C191.362 172.969 185.875 168.883 180.154 165.147C178.577 164.096 176.943 163.104 175.308 162.111C175.016 162.52 174.491 162.578 174.082 162.403C173.615 164.213 173.148 166.081 172.273 167.715C170.463 171.276 166.785 173.728 162.932 174.429C158.554 175.246 154 173.903 150.439 171.276C150.089 171.043 149.972 170.693 150.031 170.342C149.739 170.342 149.447 170.401 149.097 170.401L149.038 170.459C145.652 174.079 139.873 174.487 135.261 173.32C132.518 172.619 130.649 170.868 129.19 168.533C127.672 166.139 126.446 163.571 125.279 161.002C122.185 162.053 119.032 163.045 116.055 164.33C110.684 166.606 105.897 169.992 101.402 173.67C97.024 177.231 92.9376 181.142 88.8512 185.112C88.9096 186.338 88.9096 187.564 88.7928 188.79C88.7345 189.724 88.5593 190.716 88.8512 191.592C89.0847 192.351 89.5517 192.876 90.0771 193.401C91.2447 194.452 92.5874 195.328 93.7549 196.32C94.9225 197.313 96.09 198.364 97.1408 199.473C98.6587 201.049 100.06 202.8 101.169 204.727C102.336 203.559 103.621 202.45 105.022 201.458C106.014 200.699 107.007 202.392 106.014 203.092C104.613 204.085 103.329 205.252 102.161 206.478C103.562 209.339 104.204 212.491 103.679 215.818C103.212 218.562 101.461 221.364 98.4835 221.715C97.1992 221.89 95.7398 221.539 94.8057 220.547C93.755 219.496 93.5214 217.978 93.6966 216.577C93.9301 215.001 94.689 213.483 95.5062 212.082C96.2652 210.681 97.1408 209.397 98.1332 208.171C98.6586 207.47 99.2424 206.77 99.8846 206.128C97.9581 202.625 94.8641 199.648 91.8284 197.196C90.7193 196.32 89.5517 195.561 88.5593 194.569C87.4501 193.518 86.8664 192.234 86.808 190.774C86.6912 189.373 87.0415 188.031 87.0415 186.63C87.0415 186.104 87.0415 185.579 86.9832 185.054C86.9248 184.878 86.8664 184.703 86.9248 184.528C86.8664 184.003 86.808 183.536 86.6913 183.01C85.8156 178.69 83.247 174.546 79.0438 172.794C77.5844 174.137 76.0082 175.304 74.432 176.472C70.5207 179.216 66.084 181.726 61.2971 182.31C55.7512 183.01 50.0302 182.076 44.9514 179.8C44.893 179.916 44.893 179.975 44.8346 180.091C44.1341 181.843 42.9665 183.361 42.1492 185.054C41.4487 186.513 41.2152 188.264 41.2736 189.899C41.332 190.716 41.5071 191.533 41.799 192.292C42.0909 193.051 42.6163 193.693 42.9082 194.511C43.1417 195.27 43.1417 196.087 42.6747 196.729C42.266 197.313 41.5655 197.546 40.9817 197.955C39.8141 198.772 38.8801 199.94 38.2963 201.282C37.7126 202.567 37.5374 204.026 37.7709 205.427C38.0628 207.179 38.7633 208.813 39.2304 210.506C40.2228 214.184 39.5223 217.745 38.6466 221.364C37.8877 224.458 37.4791 227.494 37.5958 230.705C37.6542 233.682 38.2379 236.601 39.2887 239.403ZM38.9385 123.173C38.9969 124.866 39.2888 126.559 39.7558 128.194C39.9893 128.077 40.2228 128.019 40.5147 127.96C42.0909 127.435 43.7254 127.318 45.4184 127.318C45.36 125.8 45.36 124.283 45.5352 122.765C45.6519 121.772 45.7686 120.78 46.0021 119.787C46.0021 119.729 45.9438 119.671 45.9438 119.612C45.7686 118.328 45.3016 117.044 44.2508 116.285C43.3168 115.584 41.8574 115.351 40.9233 116.051C39.9893 116.752 39.639 118.153 39.4055 119.204C39.0553 120.488 38.9385 121.831 38.9385 123.173ZM39.8141 143.781C39.639 143.722 39.4639 143.605 39.3472 143.489C35.7278 140.979 33.451 136.892 32.3419 132.689C31.6997 130.295 31.4078 127.785 31.4078 125.275C31.4078 124.691 31.4078 124.107 31.4078 123.524C30.9991 124.283 30.9992 125.392 30.9408 126.151C30.4154 131.521 30.0067 137.301 32.2834 142.321C32.8088 143.43 33.451 144.54 34.2099 145.474C34.9105 146.291 35.7277 147.283 36.8953 147.283C38.8801 147.283 39.7558 145.532 39.8141 143.781ZM41.6238 141.621C41.799 140.862 41.6822 140.103 41.5655 139.344C41.5071 138.643 41.3903 137.943 41.2736 137.242C39.7558 136.775 38.4131 136.016 37.479 134.732C36.545 133.506 36.0196 131.696 36.8953 130.295C37.1872 129.828 37.5958 129.42 38.0628 129.128C37.2455 126.443 36.8369 123.699 37.1288 120.897C37.1872 120.371 37.2456 119.846 37.3623 119.262C36.1364 118.737 35.2023 119.262 34.8521 119.554C33.2759 120.722 33.3343 123.057 33.3343 124.866C33.3926 128.719 33.918 132.689 35.6694 136.133C36.4283 137.651 37.3623 139.052 38.5299 140.278C39.1136 140.92 39.8142 141.562 40.5731 142.029C41.1569 142.38 41.4487 142.321 41.6238 141.621ZM45.6519 163.862C45.9438 163.979 46.2356 164.213 46.294 164.505C47.3448 164.797 48.7459 164.505 49.7383 164.33C50.9059 164.154 52.1318 163.921 53.2993 163.629C55.576 163.045 57.8528 162.286 59.9544 161.294C64.2743 159.251 68.1856 156.449 71.4548 152.946C71.5131 152.888 71.5715 152.829 71.6299 152.771C70.5791 150.377 70.1121 147.75 69.8202 145.123C69.4699 142.088 69.2948 139.052 68.9445 136.016C68.5942 132.922 67.7769 129.887 66.7261 126.968C65.6753 123.932 64.1576 120.838 61.8808 118.503C59.9544 116.518 57.269 114.884 54.4085 114.825C51.3145 114.767 49.2713 116.927 47.987 119.554C47.9286 119.671 47.8703 119.788 47.8119 119.904C47.1697 122.298 47.1697 124.866 47.2281 127.26C47.2281 127.318 47.2281 127.318 47.2281 127.318C47.8119 127.377 48.3372 127.377 48.921 127.435C51.081 127.61 53.2993 127.96 55.3425 128.602C56.1598 126.267 56.3933 123.757 55.9263 121.364C55.8096 120.838 56.0431 120.313 56.6269 120.196C57.0939 120.079 57.736 120.371 57.7944 120.897C58.3198 123.699 58.0863 126.618 57.1523 129.303C57.6193 129.478 58.0863 129.712 58.4949 129.887C61.9976 131.638 64.5662 134.791 66.551 138.06C67.1932 139.11 65.5586 140.103 64.9165 139.052C62.9316 135.841 60.4214 132.806 56.8604 131.229C54.2918 130.12 51.548 129.595 48.8043 129.361C46.4692 129.186 44.1341 128.953 41.799 129.478C40.6898 129.712 39.2304 130.12 38.4715 131.113C37.7126 132.105 38.8217 133.623 39.5806 134.265C40.9233 135.374 42.733 135.666 44.426 135.783C46.4108 135.958 48.3957 136.016 50.4389 136.075C51.4313 136.133 51.7231 137.359 50.9059 137.885C49.0378 139.169 48.2205 141.504 48.1621 143.722C48.1621 146.583 49.3297 149.326 50.4389 151.953C50.614 152.421 50.2053 153.004 49.7383 153.121C49.2129 153.238 48.7459 152.946 48.5708 152.42C47.3448 149.443 46.0022 146.291 46.2357 143.022C46.2357 142.671 46.2941 142.38 46.3525 142.029C45.2433 142.088 44.1925 141.679 43.4336 140.803C43.4336 141.154 43.4335 141.446 43.3752 141.796C43.2584 142.613 42.8498 143.43 42.1492 143.839C42.0325 143.897 41.8574 143.956 41.7406 144.014C41.7406 144.131 41.6823 144.248 41.6823 144.364C41.6823 144.598 41.6238 144.831 41.5655 145.007C41.4487 146.232 41.5071 147.458 41.7406 148.684C42.2076 151.37 43.0249 153.997 43.7255 156.682C44.426 159.134 45.0681 161.469 45.6519 163.862ZM44.3092 138.527C44.7763 139.461 45.4768 140.511 46.6443 140.161C46.8195 140.103 46.9362 140.044 47.1113 139.986C47.4032 139.286 47.7535 138.643 48.2205 138.06V138.001C46.7611 137.943 45.36 137.885 43.9006 137.709C44.0757 138.001 44.1925 138.293 44.3092 138.527ZM76.9422 161.761C75.7163 159.251 73.9649 157.032 72.5639 154.639C69.1196 158.317 64.9165 161.294 60.2463 163.337C57.8528 164.388 55.3426 165.205 52.8323 165.789C51.548 166.081 50.3221 166.256 49.0378 166.431C47.7535 166.606 46.4692 166.665 45.2433 166.198C43.3168 168.591 44.3676 172.152 44.893 174.954C45.1265 175.947 45.2433 176.939 45.1849 177.931C47.9287 179.216 50.9643 180.091 53.9999 180.442C56.6269 180.734 59.429 180.792 62.0559 180.325C64.2159 179.916 66.2591 179.041 68.1856 178.048C71.5131 176.297 74.7238 174.137 77.526 171.568C77.526 171.51 77.526 171.452 77.526 171.393C78.5184 168.124 78.4016 164.855 76.9422 161.761ZM100.643 207.996C100.06 208.638 99.5343 209.339 99.0673 210.039C98.1332 211.323 97.2575 212.724 96.4986 214.184C95.8565 215.41 95.0976 216.986 95.5646 218.387C95.9149 219.496 97.0824 219.963 98.1916 219.846C99.4175 219.671 100.293 218.854 100.877 217.803C102.161 215.527 102.045 212.549 101.402 210.097C101.169 209.339 100.935 208.638 100.643 207.996ZM146.295 170.284C145.652 170.226 145.01 170.109 144.368 169.934C140.982 169.116 137.772 167.482 134.678 165.964C132.401 164.855 130.182 163.687 128.022 162.403C128.781 163.921 129.599 165.439 130.416 166.956C131.642 169.058 133.043 170.751 135.495 171.452C138.881 172.386 143.259 172.327 146.295 170.284ZM171.864 163.104C171.806 163.104 171.806 163.162 171.747 163.162C170.988 163.629 170.171 164.096 169.354 164.505C167.719 165.322 166.026 166.022 164.333 166.606C161.181 167.715 157.912 168.766 154.701 169.583C153.825 169.817 152.95 169.992 152.016 170.109C155.927 172.677 161.006 173.67 165.326 171.568C167.369 170.634 169.12 169.116 170.229 167.19C171.047 165.964 171.514 164.563 171.864 163.104ZM172.564 160.068C172.506 159.951 172.506 159.776 172.448 159.601C172.331 159.134 172.273 158.609 172.156 158.141C171.922 156.916 171.689 155.69 171.455 154.464C170.288 148.276 169.179 142.088 168.011 135.841C167.369 132.339 166.727 128.836 166.026 125.333C165.968 124.925 166.085 124.458 166.493 124.224C171.339 121.539 176.184 118.795 181.029 116.051C178.694 114.358 176.359 112.607 174.082 110.856C169.004 107.061 163.925 103.15 158.846 99.3554C154.117 95.7944 149.272 91.5912 143.026 91.5328C139.523 92.7004 136.662 93.576 136.195 99.5889C135.845 103.967 138.18 109.046 133.627 113.891L132.576 114.125C132.751 114.183 132.926 114.242 133.101 114.3C133.568 114.475 133.802 115.059 133.627 115.584C133.452 116.051 132.868 116.285 132.342 116.11C129.132 114.767 124.987 116.168 123.236 119.204C121.484 122.181 122.36 126.501 125.045 128.661C127.789 130.762 132.167 130.529 134.619 128.077C134.969 127.727 135.612 127.727 135.962 128.077C136.312 128.427 136.312 129.07 135.962 129.42C134.678 130.704 132.926 131.521 131.175 131.813C131.175 131.872 131.175 131.988 131.175 132.047C129.949 141.154 128.022 150.085 126.271 159.076C126.33 159.076 126.33 159.076 126.388 159.134C130.007 161.352 133.802 163.395 137.655 165.205C140.924 166.723 144.427 168.416 148.104 168.533C151.84 168.649 155.46 167.482 158.963 166.431C162.232 165.439 165.443 164.388 168.536 162.87C169.996 162.111 171.28 161.177 172.623 160.301C172.565 160.185 172.564 160.126 172.564 160.068ZM265.326 130.996C265.151 131.113 265.034 131.229 264.859 131.288C264.976 133.039 265.852 134.791 267.895 134.791C269.062 134.791 269.88 133.798 270.522 132.981C271.281 131.988 271.923 130.879 272.39 129.77C274.608 124.691 274.083 118.912 273.499 113.541C273.441 112.782 273.382 111.673 272.974 110.914C272.974 111.498 272.974 112.082 272.974 112.665C272.974 115.176 272.74 117.686 272.098 120.079C271.106 124.341 268.887 128.427 265.326 130.996ZM266.435 116.635C266.902 116.927 267.311 117.336 267.603 117.803C268.537 119.204 268.012 121.013 267.136 122.298C266.202 123.582 264.859 124.399 263.341 124.866C263.225 125.567 263.166 126.267 263.108 126.968C263.05 127.727 262.933 128.486 263.108 129.245C263.283 129.945 263.575 130.004 264.159 129.595C264.918 129.128 265.56 128.486 266.144 127.844C267.311 126.618 268.245 125.217 268.946 123.699C270.639 120.196 271.164 116.226 271.164 112.374C271.164 110.564 271.164 108.229 269.588 107.12C269.179 106.828 268.245 106.361 267.078 106.886C267.194 107.47 267.253 107.995 267.311 108.521L266.435 116.635ZM258.379 107.411C258.613 108.404 258.788 109.396 258.905 110.389C259.08 111.907 259.138 113.424 259.08 114.942C260.714 114.884 262.349 115.001 263.984 115.526C264.217 115.584 264.451 115.701 264.742 115.759C265.151 114.125 265.443 112.432 265.501 110.739C265.501 109.396 265.385 108.054 265.093 106.769C264.801 105.719 264.451 104.317 263.517 103.617C262.524 102.916 261.065 103.15 260.189 103.85C259.138 104.668 258.73 105.952 258.555 107.236C258.379 107.295 258.379 107.353 258.379 107.411ZM231.584 143.781C233.219 145.415 234.912 146.933 236.838 148.217C240.516 150.786 244.602 152.771 248.922 153.997C252.016 154.872 256.57 155.456 258.905 152.596C258.963 152.537 259.021 152.479 259.08 152.42C259.08 152.362 259.08 152.304 259.08 152.304C259.722 149.618 260.423 146.933 261.065 144.306C261.707 141.679 262.524 138.994 262.933 136.308C263.108 135.082 263.166 133.856 263.05 132.631C262.991 132.397 262.991 132.164 262.933 131.988C262.933 131.872 262.874 131.755 262.874 131.638C262.758 131.58 262.583 131.521 262.466 131.463C261.707 131.054 261.357 130.237 261.182 129.42C261.123 129.07 261.123 128.778 261.123 128.427C260.364 129.303 259.313 129.77 258.204 129.712C258.263 130.062 258.321 130.354 258.321 130.704C258.613 133.973 257.329 137.184 256.161 140.161C255.986 140.628 255.519 140.979 254.993 140.862C254.526 140.745 254.118 140.161 254.293 139.694C255.344 137.067 256.511 134.323 256.453 131.463C256.394 129.245 255.577 126.91 253.651 125.684C252.833 125.158 253.125 123.932 254.118 123.874C256.103 123.757 258.087 123.64 260.131 123.465C261.824 123.29 263.633 122.998 264.918 121.889C265.677 121.247 266.786 119.729 265.968 118.737C265.21 117.803 263.75 117.394 262.641 117.161C260.364 116.635 257.971 116.927 255.636 117.102C252.892 117.394 250.148 117.919 247.58 119.087C244.077 120.663 241.567 123.757 239.64 127.026C238.998 128.077 237.305 127.143 237.947 126.092C239.932 122.765 242.442 119.612 245.887 117.803C246.354 117.569 246.762 117.394 247.229 117.161C246.295 114.475 246.003 111.615 246.47 108.754C246.529 108.229 247.171 107.937 247.638 108.054C248.163 108.17 248.397 108.696 248.338 109.221C247.93 111.673 248.222 114.183 249.039 116.46C251.141 115.818 253.301 115.409 255.46 115.176C256.044 115.117 256.57 115.059 257.153 115.001V114.942C257.212 112.549 257.153 109.98 256.511 107.587C256.453 107.47 256.395 107.353 256.336 107.236C255.052 104.609 252.95 102.508 249.856 102.566C246.996 102.625 244.31 104.317 242.442 106.361C240.224 108.754 238.765 111.848 237.714 114.884C236.721 117.803 235.962 120.897 235.612 123.991C235.262 127.026 235.203 130.062 234.853 133.098C234.561 135.9 234.094 138.76 232.868 141.329C232.518 142.204 232.051 143.022 231.584 143.781ZM256.395 125.684C256.862 126.326 257.212 126.968 257.504 127.61C257.62 127.668 257.796 127.727 257.971 127.785C259.197 128.077 259.839 127.026 260.306 126.092C260.423 125.859 260.598 125.567 260.714 125.333C259.255 125.508 257.796 125.625 256.395 125.684ZM259.605 157.616C259.605 156.682 259.489 155.748 259.43 154.814C258.087 155.982 256.219 156.507 254.468 156.624C249.973 156.974 245.42 155.164 241.45 153.238C237.422 151.253 233.686 148.684 230.533 145.474C229.599 146.875 228.724 148.276 228.023 149.794L227.79 149.852C227.731 149.969 227.731 150.085 227.673 150.202C227.031 152.245 227.031 154.113 227.206 156.215C227.264 156.273 227.323 156.273 227.439 156.39C231.175 159.893 236.079 161.994 241.158 162.637C243.902 162.987 246.762 163.104 249.564 163.104C252.308 163.104 255.052 162.812 257.679 161.994C257.737 161.819 257.796 161.644 257.912 161.527C259.08 160.477 259.664 159.251 259.605 157.616ZM144.835 197.605C143.784 197.721 142.734 198.305 142.442 199.414C142.325 199.881 142.617 200.465 143.142 200.582C143.201 200.582 143.317 200.582 143.376 200.582C143.493 201.458 143.96 202.216 144.66 202.683C145.244 203.092 146.003 203.209 146.645 202.859C147.17 202.567 147.462 201.983 147.579 201.458C147.871 200.582 147.754 199.473 147.229 198.714C146.703 198.013 145.828 197.546 144.835 197.605ZM145.711 201.107C145.594 201.341 145.652 201.224 145.711 201.107V201.107ZM145.769 200.991C145.769 201.049 145.769 201.049 145.711 201.107C145.769 201.107 145.769 201.107 145.711 201.107C145.711 201.107 145.711 201.107 145.652 201.107C145.652 201.107 145.594 201.107 145.594 201.049C145.594 201.049 145.594 201.049 145.652 201.049C145.594 200.991 145.536 200.932 145.536 200.874V200.932C145.536 200.932 145.536 200.932 145.536 200.874C145.477 200.757 145.536 200.815 145.536 200.874L145.477 200.815C145.419 200.757 145.419 200.699 145.361 200.64V200.582C145.361 200.524 145.361 200.524 145.361 200.465C145.361 200.348 145.361 200.173 145.361 200.057C145.361 199.881 145.302 199.706 145.185 199.531H145.244H145.185H145.244H145.302C145.302 199.531 145.302 199.531 145.361 199.589C145.419 199.648 145.477 199.706 145.419 199.648C145.477 199.706 145.477 199.706 145.536 199.765C145.536 199.765 145.536 199.765 145.536 199.706C145.536 199.706 145.536 199.765 145.594 199.765C145.653 199.881 145.652 199.881 145.652 199.823C145.652 199.881 145.711 199.881 145.711 199.94C145.711 199.94 145.711 199.998 145.769 199.998C145.769 200.057 145.769 200.057 145.828 200.115C145.828 200.173 145.828 200.232 145.886 200.29C145.886 200.407 145.886 200.582 145.886 200.699C145.769 200.815 145.769 200.932 145.769 200.991ZM145.886 201.224C145.828 201.224 145.828 201.166 145.828 201.166C145.828 201.166 145.828 201.166 145.886 201.224ZM152.308 207.12C151.957 205.544 152.074 204.026 152.191 202.45C152.308 200.932 152.366 199.298 151.957 197.838C151.782 197.196 151.49 196.554 151.082 196.028C150.673 195.445 149.856 194.919 149.739 194.16C149.564 193.401 149.739 192.526 149.797 191.767C149.856 190.891 149.972 190.074 150.148 189.198C150.498 187.505 151.315 186.279 152.249 184.878C153.183 183.419 153.417 181.901 152.716 180.325C152.132 179.099 150.965 177.99 151.023 176.53C151.082 175.304 149.155 175.304 149.097 176.53C149.038 177.873 149.739 178.982 150.439 180.091C151.198 181.376 151.607 182.31 150.79 183.711C149.972 185.053 149.038 186.221 148.571 187.797C148.104 189.373 147.929 191.066 147.871 192.701C147.812 193.46 147.754 194.219 147.988 194.919C148.279 195.737 148.863 196.262 149.389 196.904C150.323 198.072 150.439 199.531 150.439 200.932C150.381 202.45 150.206 203.968 150.264 205.486C150.323 207.237 150.848 208.872 151.49 210.506C152.891 214.009 155.285 217.862 154.059 221.773C153.65 222.94 155.518 223.466 155.927 222.298C157.036 218.854 155.752 215.41 154.351 212.257C153.475 210.506 152.658 208.872 152.308 207.12ZM135.203 121.189C132.634 119.32 129.248 118.795 126.213 119.612C125.045 119.963 125.512 121.772 126.738 121.48C129.307 120.78 132.051 121.305 134.211 122.882C134.619 123.173 135.261 122.94 135.553 122.531C135.845 122.064 135.67 121.539 135.203 121.189ZM145.536 184.061C146.119 183.828 146.645 183.419 146.995 182.894C147.287 182.368 147.462 181.784 147.521 181.201C147.579 180.617 147.462 180.091 147.229 179.566C146.937 178.924 146.295 178.574 145.594 178.515C144.952 178.457 144.193 178.749 143.784 179.274C143.434 179.624 143.259 180.091 143.142 180.5C143.084 180.558 143.084 180.558 143.026 180.617C142.792 180.85 142.675 181.084 142.558 181.434C142.383 181.901 142.442 182.485 142.617 182.952C143.084 184.003 144.427 184.47 145.536 184.061ZM144.368 182.076C144.427 182.018 144.543 181.959 144.602 181.901C144.66 181.784 144.718 181.726 144.777 181.609C144.777 181.551 144.835 181.551 144.835 181.492C144.952 181.317 145.01 181.084 144.952 180.909C144.952 180.85 144.952 180.85 145.01 180.792C145.01 180.734 145.069 180.675 145.069 180.617C145.069 180.617 145.069 180.558 145.127 180.558L145.185 180.5C145.244 180.5 145.244 180.442 145.302 180.442C145.361 180.442 145.361 180.442 145.419 180.383H145.477C145.536 180.5 145.536 180.558 145.536 180.675C145.536 180.85 145.536 180.967 145.536 181.142C145.477 181.317 145.477 181.434 145.419 181.609C145.361 181.668 145.361 181.726 145.302 181.784C145.244 181.843 145.244 181.901 145.185 181.959C145.185 181.959 145.185 181.901 145.244 181.901C145.244 181.901 145.244 181.901 145.185 181.959C145.127 182.018 145.127 182.018 145.069 182.076C145.01 182.135 144.952 182.135 144.894 182.135C144.835 182.135 144.777 182.193 144.66 182.193C144.602 182.193 144.543 182.193 144.485 182.193C144.427 182.193 144.427 182.193 144.368 182.135H144.31C144.368 182.135 144.368 182.135 144.368 182.076ZM149.272 96.0863C149.739 95.9695 150.089 95.3857 149.972 94.9187C149.797 94.3933 149.33 94.1598 148.805 94.2182C148.63 94.2766 148.455 94.2765 148.279 94.3349C148.163 94.3349 148.104 94.3933 147.988 94.3933C147.988 94.3933 147.929 94.3933 147.871 94.3933C147.521 94.4517 147.17 94.4517 146.82 94.5101C146.12 94.5684 145.361 94.5101 144.66 94.4517C144.135 94.3933 143.668 94.9187 143.726 95.3857C143.726 95.9695 144.135 96.3198 144.66 96.3198C146.178 96.4949 147.754 96.3781 149.272 96.0863ZM145.769 101.632C145.477 101.223 144.952 100.99 144.427 101.282C144.018 101.515 143.726 102.158 144.076 102.625C145.361 104.317 146.645 105.952 147.871 107.645C148.163 108.054 148.688 108.287 149.214 107.995C149.622 107.762 149.914 107.12 149.564 106.653C148.338 104.96 147.054 103.325 145.769 101.632ZM153.592 103.208C152.308 101.749 151.023 100.289 149.681 98.8884C149.33 98.5381 148.63 98.5381 148.338 98.8884C147.988 99.297 147.988 99.8224 148.338 100.231C149.622 101.69 150.906 103.15 152.249 104.551C152.599 104.901 153.3 104.901 153.592 104.551C153.942 104.142 153.942 103.617 153.592 103.208ZM140.982 96.2614C140.457 96.4365 140.223 96.9035 140.282 97.4289C140.457 98.6549 140.69 99.9392 140.399 101.107C140.165 102.041 139.698 102.741 138.822 103.15C138.355 103.383 138.239 104.026 138.472 104.493C138.764 104.96 139.289 105.076 139.815 104.843C141.041 104.259 141.858 103.033 142.208 101.749C142.617 100.173 142.383 98.5381 142.15 96.9619C142.033 96.3781 141.391 96.0863 140.982 96.2614Z" fill="black"></path><path d="M121.602 50.6121C121.893 51.0207 121.66 51.7212 121.251 51.9547C120.784 52.2466 120.259 52.0131 119.909 51.6045C117.34 48.277 119.617 43.1397 122.361 40.6295C123.762 39.3452 125.746 38.2944 127.731 38.9366C128.665 39.2284 129.307 39.929 130.008 40.5711C130.825 41.33 131.526 41.5052 132.518 40.9214C134.036 40.0457 135.145 38.5279 136.663 37.5939C138.239 36.6015 139.991 36.0177 141.859 35.7842C145.361 35.3172 148.981 36.4847 151.374 39.1117C153.534 41.5635 154.702 45.0078 153.884 48.277C153.009 51.8964 149.915 54.5817 146.529 55.8076C144.544 56.5082 142.326 56.8001 140.224 56.6833C139.173 56.6249 138.122 56.3914 137.13 56.4498C136.079 56.5082 135.554 57.1503 135.087 57.9676C134.153 59.5438 133.394 61.1784 132.168 62.5794C130.942 63.9805 129.307 64.9729 127.498 65.2648C125.513 65.5567 123.528 64.9729 121.777 64.1556C120.726 63.6886 119.792 63.1048 118.8 62.4627C118.041 61.9957 117.282 61.5286 116.64 60.8865C115.18 59.427 115.297 57.6173 116.173 55.8076C117.165 53.7644 118.449 51.8964 119.85 50.0867C120.142 49.678 120.668 49.4445 121.193 49.7364C121.602 49.9699 121.835 50.612 121.543 51.0791C120.201 52.8304 118.975 54.6985 117.924 56.6833C117.457 57.559 117.107 58.4346 117.807 59.3103C118.332 60.0108 119.15 60.4195 119.909 60.8865C121.66 61.9957 123.586 63.1048 125.688 63.3967C127.614 63.6302 129.307 62.8713 130.592 61.5286C131.643 60.4195 132.401 59.0184 133.16 57.6757C133.919 56.2163 134.912 54.8152 136.663 54.5817C137.597 54.465 138.531 54.6401 139.524 54.6985C140.458 54.7569 141.392 54.7569 142.326 54.6985C144.077 54.5817 145.887 54.1731 147.463 53.2974C150.207 51.838 152.366 49.211 152.366 46.0002C152.366 43.1397 150.732 40.3376 148.338 38.8782C145.653 37.1852 142.267 37.2436 139.407 38.4112C137.947 39.0533 136.721 39.9874 135.554 41.0381C134.445 42.0889 133.102 43.2565 131.467 43.1981C130.65 43.1981 129.95 42.8479 129.307 42.3808C128.724 41.9138 128.257 41.2133 127.556 40.863C126.213 40.1625 124.637 41.2133 123.703 42.1473C121.543 44.1322 119.617 48.0434 121.602 50.6121ZM181.03 68.1253C183.19 66.7826 185.875 68.4756 186.225 70.8106C186.401 72.2117 185.934 73.4376 185.175 74.5468C184.474 75.5976 184.474 76.8235 185.525 77.5824C186.342 78.1662 187.685 78.2246 188.094 79.3338C188.502 80.3846 188.094 81.6105 187.451 82.4278C186.109 84.1207 183.598 84.8796 181.614 84.0623C179.103 83.0699 177.702 80.0927 178.053 77.4657C178.111 76.9403 177.819 76.1814 177.119 76.2398C175.951 76.3565 174.725 76.3565 173.558 76.1814C172.799 76.0646 171.164 75.9479 170.755 75.1306C170.405 74.43 170.639 73.0874 170.755 72.3285C170.931 71.3944 171.164 70.402 171.631 69.5263C172.448 67.9502 173.733 66.6659 175.484 66.3156C177.06 65.9653 178.695 66.374 179.746 67.6583C180.505 68.5923 181.906 67.2496 181.088 66.3156C179.687 64.5643 177.294 64.0389 175.134 64.4475C172.74 64.9145 170.814 66.6659 169.821 68.8258C169.296 69.9934 168.946 71.2193 168.771 72.5036C168.654 73.6711 168.479 75.189 169.121 76.2398C169.821 77.4073 171.222 77.7576 172.448 77.9911C173.966 78.283 175.542 78.3997 177.06 78.2246C176.768 77.8159 176.418 77.4073 176.126 76.9987C175.718 80.0927 176.885 83.245 179.454 85.1131C181.906 86.8644 185.291 86.6309 187.627 84.8796C189.787 83.245 191.363 79.3338 188.794 77.2322C188.269 76.8235 187.627 76.59 187.043 76.2981C186.926 76.2397 186.517 76.0062 186.517 76.0062C186.459 75.7727 187.043 75.1306 187.16 74.9555C187.977 73.6128 188.269 71.9198 188.035 70.3436C187.393 66.7826 183.248 64.5643 180.037 66.4907C178.987 67.1329 179.979 68.7674 181.03 68.1253ZM125.571 56.3914C125.396 56.3914 125.279 56.3914 125.104 56.3914C124.987 56.3914 124.871 56.3914 124.754 56.4498C124.637 56.5082 124.52 56.5665 124.462 56.6249C124.345 56.6833 124.287 56.8001 124.287 56.9168C124.229 57.0336 124.17 57.1503 124.229 57.2671C124.229 57.3255 124.229 57.4422 124.287 57.5006C124.345 57.6757 124.404 57.7925 124.52 57.9092C124.579 57.9676 124.637 58.026 124.696 58.0844C124.871 58.1427 124.988 58.2011 125.163 58.2011C125.338 58.2011 125.455 58.2011 125.63 58.2011C125.746 58.2011 125.863 58.2011 125.98 58.1427C126.097 58.0844 126.213 58.026 126.272 57.9676C126.389 57.9092 126.447 57.7925 126.447 57.6757C126.505 57.559 126.564 57.4422 126.505 57.3255C126.505 57.2671 126.505 57.1503 126.447 57.0919C126.389 56.9168 126.33 56.8001 126.213 56.6833C126.155 56.6249 126.097 56.5666 126.038 56.5082C125.922 56.4498 125.746 56.3914 125.571 56.3914ZM141.216 43.4316C141.041 43.6068 140.925 43.7235 140.749 43.8986C140.633 43.957 140.574 44.0738 140.574 44.1905C140.516 44.3073 140.458 44.424 140.516 44.5408C140.516 44.6576 140.516 44.7743 140.574 44.8911C140.633 45.0078 140.691 45.1246 140.749 45.1829C140.808 45.2413 140.866 45.2997 140.925 45.3581C141.1 45.4165 141.216 45.4748 141.392 45.4748C141.45 45.4748 141.567 45.4748 141.625 45.4165C141.8 45.3581 141.917 45.2997 142.034 45.1829C142.209 45.0078 142.326 44.8911 142.501 44.7159C142.618 44.6576 142.676 44.5408 142.676 44.424C142.734 44.3073 142.793 44.1905 142.734 44.0738C142.734 43.957 142.734 43.8403 142.676 43.7235C142.618 43.6068 142.559 43.49 142.501 43.4316C142.442 43.3732 142.384 43.3149 142.326 43.2565C142.15 43.1981 142.034 43.1397 141.859 43.1397C141.8 43.1397 141.683 43.1397 141.625 43.1981C141.45 43.2565 141.333 43.3149 141.216 43.4316ZM132.401 48.3353C132.577 48.1602 132.693 48.0434 132.868 47.8683C132.985 47.8099 133.044 47.6932 133.044 47.5764C133.102 47.4597 133.16 47.3429 133.102 47.2262C133.102 47.1094 133.102 46.9926 133.044 46.8759C132.985 46.7591 132.927 46.6424 132.868 46.584C132.81 46.5256 132.752 46.4673 132.693 46.4089C132.518 46.3505 132.401 46.2921 132.226 46.2921C132.168 46.2921 132.051 46.2921 131.993 46.3505C131.818 46.4089 131.701 46.4673 131.584 46.584C131.409 46.7591 131.292 46.8759 131.117 47.051C131 47.1094 130.942 47.2262 130.942 47.3429C130.884 47.4597 130.825 47.5764 130.884 47.6932C130.884 47.8099 130.884 47.9267 130.942 48.0434C131 48.1602 131.059 48.277 131.117 48.3353C131.176 48.3937 131.234 48.4521 131.292 48.5105C131.467 48.5688 131.584 48.6272 131.759 48.6272C131.818 48.6272 131.934 48.6272 131.993 48.5688C132.168 48.5688 132.285 48.4521 132.401 48.3353ZM184.357 94.5119C184.532 94.3368 184.649 94.22 184.824 94.0449C184.941 93.9865 185 93.8697 185 93.753C185.058 93.6362 185.116 93.5195 185.058 93.4027C185.058 93.286 185.058 93.1692 185 93.0525C184.941 92.9357 184.883 92.819 184.824 92.7606C184.766 92.7022 184.708 92.6438 184.649 92.5854C184.474 92.5271 184.357 92.4687 184.182 92.4687C184.124 92.4687 184.007 92.4687 183.949 92.5271C183.774 92.5854 183.657 92.6438 183.54 92.7606C183.365 92.9357 183.248 93.0525 183.073 93.2276C182.956 93.286 182.898 93.4027 182.898 93.5195C182.84 93.6362 182.781 93.753 182.84 93.8697C182.84 93.9865 182.84 94.1033 182.898 94.22C182.956 94.3368 183.015 94.4535 183.073 94.5119C183.131 94.5703 183.19 94.6286 183.248 94.687C183.423 94.7454 183.54 94.8038 183.715 94.8038C183.774 94.8038 183.89 94.8038 183.949 94.7454C184.124 94.7454 184.241 94.6287 184.357 94.5119ZM127.323 29.1291C127.498 28.954 127.615 28.8373 127.79 28.6621C127.906 28.6038 127.965 28.487 127.965 28.3702C128.023 28.2535 128.081 28.1367 128.023 28.02C128.023 27.9032 128.023 27.7865 127.965 27.6697C127.906 27.553 127.848 27.4362 127.79 27.3778C127.731 27.3194 127.673 27.2611 127.614 27.2027C127.439 27.1443 127.323 27.0859 127.147 27.0859C127.089 27.0859 126.972 27.0859 126.914 27.1443C126.739 27.2027 126.622 27.2611 126.505 27.3778C126.33 27.553 126.213 27.6697 126.038 27.8448C125.922 27.9032 125.863 28.02 125.863 28.1367C125.805 28.2535 125.746 28.3702 125.805 28.487C125.805 28.6038 125.805 28.7205 125.863 28.8373C125.922 28.954 125.98 29.0708 126.038 29.1291C126.097 29.1875 126.155 29.2459 126.213 29.3043C126.389 29.3627 126.505 29.421 126.68 29.421C126.739 29.421 126.856 29.421 126.914 29.3627C127.031 29.3043 127.206 29.2459 127.323 29.1291ZM178.987 70.3436C178.987 70.2853 178.987 70.2853 178.987 70.2269C178.987 70.2853 178.987 70.402 179.045 70.4604C178.987 70.402 178.987 70.402 178.987 70.3436C178.987 70.402 178.987 70.4604 178.987 70.5771C178.987 70.5188 178.987 70.4604 178.987 70.3436C178.987 70.4604 178.928 70.5188 178.928 70.6355C178.928 70.5771 178.987 70.5188 179.045 70.4604C178.987 70.5188 178.928 70.5771 178.87 70.6355C178.928 70.5771 178.928 70.5771 178.987 70.5188C178.928 70.5771 178.87 70.6355 178.811 70.6939C178.87 70.6355 178.928 70.6355 178.928 70.6355C178.87 70.6939 178.753 70.6939 178.695 70.7523H178.753C178.87 70.6939 178.987 70.6939 179.103 70.5771C179.22 70.5188 179.279 70.402 179.337 70.2853C179.395 70.1685 179.454 70.0517 179.454 69.935C179.454 69.8182 179.454 69.7015 179.454 69.5263C179.395 69.468 179.395 69.3512 179.337 69.2928C179.279 69.1761 179.162 69.0593 178.987 68.9426C178.928 68.8842 178.812 68.8842 178.753 68.8258C178.578 68.7674 178.403 68.7674 178.228 68.8258C178.111 68.8842 177.994 68.8842 177.878 69.0009C177.878 69.0009 177.819 69.0009 177.819 69.0593C177.761 69.1177 177.644 69.1761 177.586 69.2345C177.527 69.2928 177.527 69.2928 177.469 69.3512C177.41 69.468 177.294 69.5263 177.235 69.6431C177.177 69.7599 177.177 69.8182 177.119 69.935V69.9934C177.06 70.1101 177.06 70.2269 177.06 70.402C177.06 70.4604 177.06 70.5188 177.06 70.5188C177.06 70.6355 177.06 70.7523 177.119 70.8106V70.869C177.177 70.9858 177.177 71.1025 177.294 71.2193C177.352 71.336 177.469 71.3944 177.586 71.4528C177.702 71.5112 177.819 71.5696 177.936 71.5696C178.053 71.5696 178.169 71.5696 178.344 71.5696C178.403 71.5112 178.52 71.5112 178.578 71.4528C178.695 71.3944 178.811 71.2777 178.928 71.1025C178.987 71.0442 178.987 70.9274 179.045 70.869C179.045 70.6939 179.045 70.5188 178.987 70.3436ZM192.18 64.0389C192.355 64.0389 192.472 64.0389 192.647 64.0389C192.764 64.0389 192.881 64.0389 192.997 63.9805C193.114 63.9221 193.231 63.8637 193.289 63.8054C193.406 63.747 193.464 63.6302 193.464 63.5135C193.523 63.3967 193.581 63.28 193.523 63.1632C193.523 63.1048 193.523 62.9881 193.464 62.9297C193.406 62.7546 193.347 62.6378 193.231 62.5211C193.172 62.4627 193.114 62.4043 193.056 62.3459C192.881 62.2875 192.764 62.2292 192.589 62.2292C192.414 62.2292 192.297 62.2292 192.122 62.2292C192.005 62.2292 191.888 62.2292 191.771 62.2875C191.655 62.3459 191.538 62.4043 191.479 62.4627C191.363 62.521 191.304 62.6378 191.304 62.7546C191.246 62.8713 191.188 62.9881 191.246 63.1048C191.246 63.1632 191.246 63.28 191.304 63.3383C191.363 63.5135 191.421 63.6302 191.538 63.747C191.596 63.8054 191.655 63.8637 191.713 63.9221C191.83 64.0389 192.005 64.0389 192.18 64.0389Z" fill="black"></path></g><defs><clipPath id="clip0_4556_66742"><rect width="319" height="319" fill="white" transform="translate(0 0.5)"></rect></clipPath></defs></svg><h1 class="py-1 text-xl font-semibold text-dark"> Kamera Belum nyala </h1><p class="py-1 text-sm font-normal text-dark"> Nyalakan kamera untuk melanjutkan proses absensi </p>',3)])])),u2(s)?(_s(),Rs("div",Rut,[ft("video",{ref_key:"videoRef",ref:h,autoplay:"",playsinline:"",muted:"",class:"block w-full h-auto",onLoadedmetadata:nt},null,544),ft("canvas",{ref_key:"canvasRef",ref:p,class:"absolute inset-0 w-full h-full pointer-events-none"},null,512)])):oc("",!0)],2)):oc("",!0),o.value==="camera"?(_s(),Rs("div",_ut)):oc("",!0),o.value==="qr"?(_s(),Rs("div",Dut,[ft("div",Fut,[ft("div",Mut,[H$($e,{value:l.value,options:{width:200}},null,8,["value"])])]),ft("div",Out,[(_s(),Rs(YI,null,z$(a,(Oe,tt)=>ft("div",{key:tt},[ft("div",Lut,[re[10]||(re[10]=ft("svg",{width:"18",height:"19",viewBox:"0 0 18 19",fill:"none",xmlns:"http://www.w3.org/2000/svg"},[ft("path",{d:"M17.0918 8.23193L15.8933 7.01561C15.8097 6.93369 15.7437 6.83562 15.6992 6.72736C15.6548 6.6191 15.6328 6.50292 15.6346 6.38589V4.66062C15.6335 4.42426 15.5857 4.19045 15.494 3.97262C15.4023 3.7548 15.2685 3.55725 15.1002 3.39132C14.932 3.22539 14.7326 3.09436 14.5136 3.00575C14.2946 2.91713 14.0602 2.87269 13.824 2.87496H12.0996C11.9826 2.87681 11.8665 2.85481 11.7583 2.81032C11.6501 2.76583 11.5521 2.69977 11.4702 2.61617L10.2631 1.39986C9.92685 1.06378 9.47098 0.875 8.99568 0.875C8.52037 0.875 8.06451 1.06378 7.72824 1.39986L6.51253 2.59892C6.43066 2.68252 6.33263 2.74858 6.22443 2.79307C6.11622 2.83756 6.0001 2.85955 5.88313 2.85771H4.15872C3.92248 2.85884 3.68879 2.90665 3.47107 2.99841C3.25335 3.09016 3.0559 3.22405 2.89006 3.39238C2.72421 3.56072 2.59325 3.76017 2.50468 3.9793C2.41611 4.19842 2.37169 4.43289 2.37396 4.66924V6.39451C2.3758 6.51154 2.35382 6.62773 2.30935 6.73599C2.26488 6.84425 2.19886 6.94232 2.1153 7.02424L0.899595 8.23193C0.563683 8.56836 0.375 9.02446 0.375 9.5C0.375 9.97554 0.563683 10.4316 0.899595 10.7681L2.09806 11.9844C2.18162 12.0663 2.24764 12.1644 2.29211 12.2726C2.33658 12.3809 2.35856 12.4971 2.35672 12.6141V14.3394C2.35784 14.5757 2.40563 14.8096 2.49734 15.0274C2.58905 15.2452 2.72287 15.4428 2.89112 15.6087C3.05937 15.7746 3.25873 15.9056 3.47774 15.9943C3.69675 16.0829 3.93111 16.1273 4.16734 16.125H5.89175C6.00872 16.1232 6.12484 16.1452 6.23305 16.1897C6.34125 16.2342 6.43928 16.3002 6.52116 16.3838L7.73686 17.6001C8.07313 17.9362 8.529 18.125 9.0043 18.125C9.4796 18.125 9.93547 17.9362 10.2717 17.6001L11.4788 16.4011C11.5607 16.3175 11.6587 16.2514 11.7669 16.2069C11.8751 16.1624 11.9913 16.1404 12.1082 16.1423H13.8326C14.3083 16.1423 14.7644 15.9532 15.1007 15.6168C15.4371 15.2803 15.626 14.8239 15.626 14.348V12.6227C15.6242 12.5057 15.6462 12.3895 15.6906 12.2813C15.7351 12.173 15.8011 12.0749 15.8847 11.993L17.1004 10.7767C17.2674 10.6094 17.3998 10.4107 17.4898 10.192C17.5799 9.97334 17.6258 9.73901 17.625 9.50252C17.6242 9.26602 17.5767 9.03202 17.4852 8.81396C17.3936 8.59591 17.2599 8.3981 17.0918 8.23193ZM12.5997 7.94726L8.36627 12.0879C8.30657 12.1484 8.23539 12.1963 8.15692 12.2289C8.07845 12.2615 7.99426 12.2781 7.9093 12.2777C7.8238 12.2765 7.73939 12.2583 7.66096 12.2243C7.58252 12.1902 7.51161 12.1409 7.45233 12.0793L5.40891 10.009C5.34607 9.94909 5.29591 9.87719 5.26142 9.79753C5.22693 9.71787 5.20882 9.63208 5.20816 9.54527C5.20751 9.45846 5.22432 9.3724 5.2576 9.29223C5.29088 9.21206 5.33995 9.1394 5.40188 9.0786C5.46381 9.01779 5.53734 8.97008 5.61809 8.9383C5.69883 8.90652 5.78515 8.89133 5.87189 8.89362C5.95863 8.89592 6.04402 8.91566 6.12297 8.95166C6.20193 8.98766 6.27284 9.03919 6.33147 9.10319L7.91792 10.7163L11.6944 7.02424C11.8156 6.90308 11.98 6.83503 12.1513 6.83503C12.3227 6.83503 12.4871 6.90308 12.6083 7.02424C12.669 7.08503 12.717 7.15731 12.7495 7.23686C12.782 7.3164 12.7983 7.40163 12.7975 7.48756C12.7967 7.57348 12.7788 7.65839 12.7448 7.73732C12.7108 7.81624 12.6615 7.88761 12.5997 7.94726Z",fill:"#17C653"})],-1)),ft("span",Put,fa(Oe),1)])])),64))])])):oc("",!0)])]),ft("div",But,[ft("div",zut,[re[11]||(re[11]=G$('<svg width="178" height="58" viewBox="0 0 178 58" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><rect width="58" height="58" rx="24" fill="url(#pattern0_6102_60519)"></rect><path d="M69.1477 24V12.3636H71.2557V17.2898H76.6477V12.3636H78.7614V24H76.6477V19.0568H71.2557V24H69.1477ZM81.054 24V12.3636H88.6222V14.1307H83.1619V17.2898H88.2301V19.0568H83.1619V22.233H88.6676V24H81.054ZM100.335 12.3636V24H98.4602L92.9773 16.0739H92.8807V24H90.7727V12.3636H92.6591L98.1364 20.2955H98.2386V12.3636H100.335ZM108.956 15.5625C108.903 15.0663 108.679 14.6799 108.286 14.4034C107.895 14.1269 107.388 13.9886 106.763 13.9886C106.323 13.9886 105.946 14.0549 105.632 14.1875C105.318 14.3201 105.077 14.5 104.911 14.7273C104.744 14.9545 104.659 15.214 104.655 15.5057C104.655 15.7481 104.71 15.9583 104.82 16.1364C104.933 16.3144 105.087 16.4659 105.28 16.5909C105.473 16.7121 105.687 16.8144 105.922 16.8977C106.157 16.9811 106.393 17.0511 106.632 17.108L107.723 17.3807C108.162 17.483 108.585 17.6212 108.99 17.7955C109.399 17.9697 109.765 18.1894 110.087 18.4545C110.412 18.7197 110.67 19.0398 110.859 19.4148C111.049 19.7898 111.143 20.2292 111.143 20.733C111.143 21.4148 110.969 22.0152 110.621 22.5341C110.272 23.0492 109.768 23.4527 109.109 23.7443C108.454 24.0322 107.661 24.1761 106.729 24.1761C105.823 24.1761 105.037 24.036 104.371 23.7557C103.708 23.4754 103.189 23.0663 102.814 22.5284C102.443 21.9905 102.242 21.3352 102.212 20.5625H104.286C104.316 20.9678 104.441 21.3049 104.661 21.5739C104.88 21.8428 105.166 22.0436 105.518 22.1761C105.875 22.3087 106.272 22.375 106.712 22.375C107.17 22.375 107.571 22.3068 107.916 22.1705C108.265 22.0303 108.537 21.8371 108.734 21.5909C108.931 21.3409 109.032 21.0492 109.036 20.7159C109.032 20.4129 108.943 20.1629 108.768 19.9659C108.594 19.7652 108.35 19.5985 108.036 19.4659C107.725 19.3295 107.361 19.2083 106.945 19.1023L105.621 18.7614C104.662 18.5152 103.905 18.142 103.348 17.642C102.795 17.1383 102.518 16.4697 102.518 15.6364C102.518 14.9508 102.704 14.3504 103.075 13.8352C103.45 13.3201 103.96 12.9205 104.604 12.6364C105.248 12.3485 105.977 12.2045 106.791 12.2045C107.617 12.2045 108.34 12.3485 108.962 12.6364C109.587 12.9205 110.077 13.3163 110.433 13.8239C110.789 14.3277 110.973 14.9072 110.984 15.5625H108.956ZM113.023 24V12.3636H115.131V17.7102H115.273L119.812 12.3636H122.386L117.886 17.5852L122.426 24H119.892L116.42 19.0114L115.131 20.5341V24H113.023ZM123.851 24V12.3636H128.214C129.108 12.3636 129.858 12.5189 130.464 12.8295C131.074 13.1402 131.535 13.5758 131.845 14.1364C132.16 14.6932 132.317 15.3428 132.317 16.0852C132.317 16.8314 132.158 17.4792 131.839 18.0284C131.525 18.5739 131.061 18.9962 130.447 19.2955C129.834 19.5909 129.08 19.7386 128.186 19.7386H125.078V17.9886H127.902C128.425 17.9886 128.853 17.9167 129.186 17.7727C129.519 17.625 129.766 17.411 129.925 17.1307C130.088 16.8466 130.169 16.4981 130.169 16.0852C130.169 15.6723 130.088 15.3201 129.925 15.0284C129.762 14.733 129.514 14.5095 129.18 14.358C128.847 14.2027 128.417 14.125 127.891 14.125H125.959V24H123.851ZM129.862 18.7273L132.743 24H130.391L127.561 18.7273H129.862ZM136.365 12.3636V24H134.257V12.3636H136.365ZM144.972 15.5625C144.919 15.0663 144.695 14.6799 144.301 14.4034C143.911 14.1269 143.403 13.9886 142.778 13.9886C142.339 13.9886 141.962 14.0549 141.648 14.1875C141.333 14.3201 141.093 14.5 140.926 14.7273C140.759 14.9545 140.674 15.214 140.67 15.5057C140.67 15.7481 140.725 15.9583 140.835 16.1364C140.949 16.3144 141.102 16.4659 141.295 16.5909C141.489 16.7121 141.703 16.8144 141.938 16.8977C142.172 16.9811 142.409 17.0511 142.648 17.108L143.739 17.3807C144.178 17.483 144.6 17.6212 145.006 17.7955C145.415 17.9697 145.78 18.1894 146.102 18.4545C146.428 18.7197 146.686 19.0398 146.875 19.4148C147.064 19.7898 147.159 20.2292 147.159 20.733C147.159 21.4148 146.985 22.0152 146.636 22.5341C146.288 23.0492 145.784 23.4527 145.125 23.7443C144.47 24.0322 143.676 24.1761 142.744 24.1761C141.839 24.1761 141.053 24.036 140.386 23.7557C139.723 23.4754 139.205 23.0663 138.83 22.5284C138.458 21.9905 138.258 21.3352 138.227 20.5625H140.301C140.331 20.9678 140.456 21.3049 140.676 21.5739C140.896 21.8428 141.182 22.0436 141.534 22.1761C141.89 22.3087 142.288 22.375 142.727 22.375C143.186 22.375 143.587 22.3068 143.932 22.1705C144.28 22.0303 144.553 21.8371 144.75 21.5909C144.947 21.3409 145.047 21.0492 145.051 20.7159C145.047 20.4129 144.958 20.1629 144.784 19.9659C144.61 19.7652 144.366 19.5985 144.051 19.4659C143.741 19.3295 143.377 19.2083 142.96 19.1023L141.636 18.7614C140.678 18.5152 139.92 18.142 139.364 17.642C138.811 17.1383 138.534 16.4697 138.534 15.6364C138.534 14.9508 138.72 14.3504 139.091 13.8352C139.466 13.3201 139.975 12.9205 140.619 12.6364C141.263 12.3485 141.992 12.2045 142.807 12.2045C143.633 12.2045 144.356 12.3485 144.977 12.6364C145.602 12.9205 146.093 13.3163 146.449 13.8239C146.805 14.3277 146.989 14.9072 147 15.5625H144.972ZM148.527 14.1307V12.3636H157.811V14.1307H154.214V24H152.124V14.1307H148.527ZM159.689 24H157.439L161.536 12.3636H164.138L168.24 24H165.99L162.882 14.75H162.791L159.689 24ZM159.763 19.4375H165.899V21.1307H159.763V19.4375ZM169.773 24V12.3636H171.881V22.233H177.006V24H169.773Z" fill="#003C77"></path><path d="M70.4659 35.8182V46H69.233V35.8182H70.4659ZM75.8812 46.1591C75.1653 46.1591 74.5488 45.9901 74.0318 45.652C73.5147 45.3139 73.117 44.8482 72.8386 44.255C72.5602 43.6617 72.421 42.9839 72.421 42.2216C72.421 41.446 72.5635 40.7616 72.8485 40.1683C73.1369 39.5717 73.5379 39.1061 74.0517 38.7713C74.5687 38.4332 75.1719 38.2642 75.8613 38.2642C76.3983 38.2642 76.8822 38.3636 77.313 38.5625C77.7439 38.7614 78.0969 39.0398 78.372 39.3977C78.6471 39.7557 78.8178 40.1733 78.8841 40.6506H77.7108C77.6213 40.3026 77.4224 39.9943 77.1142 39.7259C76.8092 39.4541 76.3983 39.3182 75.8812 39.3182C75.4238 39.3182 75.0228 39.4375 74.6781 39.6761C74.3367 39.9115 74.0699 40.2446 73.8777 40.6754C73.6887 41.103 73.5943 41.6051 73.5943 42.1818C73.5943 42.7718 73.6871 43.2855 73.8727 43.723C74.0616 44.1605 74.3268 44.5002 74.6681 44.7422C75.0128 44.9841 75.4172 45.1051 75.8812 45.1051C76.1861 45.1051 76.4629 45.0521 76.7115 44.946C76.96 44.84 77.1705 44.6875 77.3429 44.4886C77.5152 44.2898 77.6378 44.0511 77.7108 43.7727H78.8841C78.8178 44.2235 78.6537 44.6295 78.3919 44.9908C78.1333 45.3487 77.7903 45.6338 77.3627 45.8459C76.9385 46.0547 76.4447 46.1591 75.8812 46.1591ZM83.801 46.1591C83.0652 46.1591 82.4305 45.9967 81.8968 45.6719C81.3665 45.3438 80.9572 44.8864 80.6689 44.2997C80.3838 43.7098 80.2413 43.0237 80.2413 42.2415C80.2413 41.4593 80.3838 40.7699 80.6689 40.1733C80.9572 39.5734 81.3583 39.1061 81.872 38.7713C82.389 38.4332 82.9922 38.2642 83.6816 38.2642C84.0794 38.2642 84.4721 38.3305 84.8599 38.4631C85.2477 38.5956 85.6007 38.8111 85.9189 39.1094C86.237 39.4044 86.4906 39.7955 86.6795 40.2827C86.8684 40.7699 86.9629 41.3698 86.9629 42.0824V42.5795H81.0765V41.5653H85.7697C85.7697 41.1345 85.6835 40.75 85.5112 40.4119C85.3422 40.0739 85.1002 39.8071 84.7853 39.6115C84.4738 39.416 84.1059 39.3182 83.6816 39.3182C83.2143 39.3182 82.81 39.4342 82.4686 39.6662C82.1305 39.8949 81.8703 40.1932 81.688 40.5611C81.5057 40.929 81.4146 41.3234 81.4146 41.7443V42.4205C81.4146 42.9972 81.514 43.486 81.7129 43.8871C81.9151 44.2848 82.1951 44.5881 82.5531 44.7969C82.911 45.0024 83.327 45.1051 83.801 45.1051C84.1092 45.1051 84.3876 45.062 84.6362 44.9759C84.8881 44.8864 85.1052 44.7538 85.2875 44.5781C85.4698 44.3991 85.6106 44.1771 85.71 43.9119L86.8436 44.2301C86.7243 44.6146 86.5237 44.9527 86.242 45.2443C85.9603 45.5327 85.6123 45.758 85.198 45.9205C84.7837 46.0795 84.318 46.1591 83.801 46.1591ZM98.4125 38.3636C98.3528 37.8598 98.1109 37.4688 97.6866 37.1903C97.2624 36.9119 96.742 36.7727 96.1255 36.7727C95.6748 36.7727 95.2804 36.8456 94.9423 36.9915C94.6075 37.1373 94.3457 37.3378 94.1568 37.593C93.9712 37.8482 93.8784 38.1383 93.8784 38.4631C93.8784 38.7348 93.943 38.9685 94.0723 39.1641C94.2048 39.3563 94.3739 39.517 94.5794 39.6463C94.7849 39.7723 95.0003 39.8767 95.2257 39.9595C95.4511 40.0391 95.6582 40.1037 95.8471 40.1534L96.8812 40.4318C97.1464 40.5014 97.4413 40.5975 97.7662 40.7202C98.0943 40.8428 98.4075 41.0102 98.7058 41.2223C99.0074 41.4311 99.256 41.6996 99.4515 42.0277C99.6471 42.3558 99.7449 42.7585 99.7449 43.2358C99.7449 43.786 99.6007 44.2831 99.3123 44.7273C99.0273 45.1714 98.6097 45.5244 98.0595 45.7862C97.5126 46.0481 96.8481 46.179 96.0659 46.179C95.3367 46.179 94.7053 46.0613 94.1717 45.826C93.6414 45.5907 93.2238 45.2625 92.9189 44.8416C92.6172 44.4207 92.4466 43.9318 92.4068 43.375H93.6795C93.7127 43.7595 93.8419 44.0777 94.0673 44.3295C94.296 44.5781 94.5843 44.7637 94.9324 44.8864C95.2837 45.0057 95.6615 45.0653 96.0659 45.0653C96.5365 45.0653 96.9591 44.9891 97.3336 44.8366C97.7082 44.6809 98.0048 44.4654 98.2235 44.1903C98.4423 43.9119 98.5517 43.5871 98.5517 43.2159C98.5517 42.8778 98.4572 42.6027 98.2683 42.3906C98.0794 42.1785 97.8308 42.0062 97.5225 41.8736C97.2143 41.741 96.8812 41.625 96.5233 41.5256L95.2704 41.1676C94.475 40.9389 93.8452 40.6125 93.3812 40.1882C92.9172 39.764 92.6852 39.2088 92.6852 38.5227C92.6852 37.9527 92.8393 37.4555 93.1475 37.0312C93.4591 36.6037 93.8767 36.2723 94.4004 36.0369C94.9274 35.7983 95.5157 35.679 96.1653 35.679C96.8216 35.679 97.4049 35.7966 97.9153 36.032C98.4257 36.264 98.8301 36.5821 99.1284 36.9865C99.43 37.3909 99.5891 37.8499 99.6056 38.3636H98.4125ZM104.715 46.1591C104.026 46.1591 103.421 45.995 102.901 45.6669C102.384 45.3388 101.979 44.8797 101.688 44.2898C101.399 43.6998 101.255 43.0104 101.255 42.2216C101.255 41.4261 101.399 40.7318 101.688 40.1385C101.979 39.5452 102.384 39.0845 102.901 38.7564C103.421 38.4283 104.026 38.2642 104.715 38.2642C105.405 38.2642 106.008 38.4283 106.525 38.7564C107.045 39.0845 107.45 39.5452 107.738 40.1385C108.03 40.7318 108.175 41.4261 108.175 42.2216C108.175 43.0104 108.03 43.6998 107.738 44.2898C107.45 44.8797 107.045 45.3388 106.525 45.6669C106.008 45.995 105.405 46.1591 104.715 46.1591ZM104.715 45.1051C105.239 45.1051 105.67 44.9709 106.008 44.7024C106.346 44.4339 106.596 44.081 106.759 43.6435C106.921 43.206 107.002 42.732 107.002 42.2216C107.002 41.7112 106.921 41.2356 106.759 40.7947C106.596 40.3539 106.346 39.9976 106.008 39.7259C105.67 39.4541 105.239 39.3182 104.715 39.3182C104.192 39.3182 103.761 39.4541 103.423 39.7259C103.085 39.9976 102.834 40.3539 102.672 40.7947C102.509 41.2356 102.428 41.7112 102.428 42.2216C102.428 42.732 102.509 43.206 102.672 43.6435C102.834 44.081 103.085 44.4339 103.423 44.7024C103.761 44.9709 104.192 45.1051 104.715 45.1051ZM111.14 35.8182V46H109.966V35.8182H111.14ZM118.101 42.8778V38.3636H119.275V46H118.101V44.7074H118.022C117.843 45.0952 117.564 45.425 117.186 45.6967C116.809 45.9652 116.331 46.0994 115.755 46.0994C115.277 46.0994 114.853 45.995 114.482 45.7862C114.111 45.5741 113.819 45.2559 113.607 44.8317C113.395 44.4041 113.289 43.8655 113.289 43.2159V38.3636H114.462V43.1364C114.462 43.6932 114.618 44.1373 114.929 44.4688C115.244 44.8002 115.645 44.9659 116.132 44.9659C116.424 44.9659 116.721 44.8913 117.022 44.7422C117.327 44.593 117.583 44.3643 117.788 44.0561C117.997 43.7479 118.101 43.3551 118.101 42.8778ZM124.744 38.3636V39.358H120.787V38.3636H124.744ZM121.941 36.5341H123.114V43.8125C123.114 44.1439 123.162 44.3925 123.258 44.5582C123.357 44.7206 123.483 44.83 123.636 44.8864C123.792 44.9394 123.956 44.9659 124.128 44.9659C124.257 44.9659 124.363 44.9593 124.446 44.946C124.529 44.9295 124.595 44.9162 124.645 44.9062L124.884 45.9602C124.804 45.9901 124.693 46.0199 124.551 46.0497C124.408 46.0829 124.227 46.0994 124.009 46.0994C123.677 46.0994 123.352 46.0282 123.034 45.8857C122.719 45.7431 122.458 45.526 122.249 45.2344C122.043 44.9427 121.941 44.5748 121.941 44.1307V36.5341ZM126.509 46V38.3636H127.683V46H126.509ZM127.106 37.0909C126.877 37.0909 126.68 37.013 126.514 36.8572C126.352 36.7015 126.271 36.5142 126.271 36.2955C126.271 36.0767 126.352 35.8894 126.514 35.7337C126.68 35.5779 126.877 35.5 127.106 35.5C127.335 35.5 127.53 35.5779 127.693 35.7337C127.858 35.8894 127.941 36.0767 127.941 36.2955C127.941 36.5142 127.858 36.7015 127.693 36.8572C127.53 37.013 127.335 37.0909 127.106 37.0909ZM132.934 46.1591C132.245 46.1591 131.64 45.995 131.119 45.6669C130.602 45.3388 130.198 44.8797 129.906 44.2898C129.618 43.6998 129.474 43.0104 129.474 42.2216C129.474 41.4261 129.618 40.7318 129.906 40.1385C130.198 39.5452 130.602 39.0845 131.119 38.7564C131.64 38.4283 132.245 38.2642 132.934 38.2642C133.623 38.2642 134.227 38.4283 134.744 38.7564C135.264 39.0845 135.668 39.5452 135.957 40.1385C136.248 40.7318 136.394 41.4261 136.394 42.2216C136.394 43.0104 136.248 43.6998 135.957 44.2898C135.668 44.8797 135.264 45.3388 134.744 45.6669C134.227 45.995 133.623 46.1591 132.934 46.1591ZM132.934 45.1051C133.458 45.1051 133.888 44.9709 134.227 44.7024C134.565 44.4339 134.815 44.081 134.977 43.6435C135.14 43.206 135.221 42.732 135.221 42.2216C135.221 41.7112 135.14 41.2356 134.977 40.7947C134.815 40.3539 134.565 39.9976 134.227 39.7259C133.888 39.4541 133.458 39.3182 132.934 39.3182C132.41 39.3182 131.979 39.4541 131.641 39.7259C131.303 39.9976 131.053 40.3539 130.891 40.7947C130.728 41.2356 130.647 41.7112 130.647 42.2216C130.647 42.732 130.728 43.206 130.891 43.6435C131.053 44.081 131.303 44.4339 131.641 44.7024C131.979 44.9709 132.41 45.1051 132.934 45.1051ZM139.358 41.4062V46H138.185V38.3636H139.319V39.5568H139.418C139.597 39.169 139.869 38.8575 140.233 38.6222C140.598 38.3835 141.069 38.2642 141.645 38.2642C142.162 38.2642 142.615 38.3703 143.003 38.5824C143.39 38.7912 143.692 39.1094 143.907 39.5369C144.123 39.9612 144.231 40.4981 144.231 41.1477V46H143.057V41.2273C143.057 40.6274 142.902 40.16 142.59 39.8253C142.278 39.4872 141.851 39.3182 141.307 39.3182C140.933 39.3182 140.598 39.3994 140.303 39.5618C140.011 39.7242 139.781 39.9612 139.612 40.2727C139.443 40.5843 139.358 40.9621 139.358 41.4062Z" fill="#4B5675"></path><defs><pattern id="pattern0_6102_60519" patternContentUnits="objectBoundingBox" width="1" height="1"><use xlink:href="#image0_6102_60519" transform="scale(0.002)"></use></pattern><image id="image0_6102_60519" width="500" height="500" preserveAspectRatio="none" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfQAAAH0CAYAAADL1t+KAAAQAElEQVR4Aez9B4Bdx3UfjJ8zc8srWwEsGgESIAn2KlKkClWo3mVLFtUtucmJnTgu+aLEafQ//hwnX2wndhLHjmM7spXYlGXZ6h0qFNVYRBKsAAGCKAvsAtvLe+/emfP/nft2QYAEQWDbe7s7gzl35s7MnTnnN3fnd8/c9x4MhRAQCAgEBAICAYGAwLJHIBD6sp/CYEBAICAQEAgIBASIFpfQA8IBgYBAQCAgEBAICCwJAoHQlwTmMEhAICAQEAgIBAQWF4HlTOiLi0zoPSAQEAgIBAQCAssIgUDoy2iygqoBgYBAQCAgEBB4LgQCoT8XMqE8IBAQCAgEBAICywiBQOjLaLKCqgGBgEBAICAQEHguBAKhPxcyi1seeg8IBAQCAgGBgMCCIhAIfUHhDJ0FBAICAYGAQECgNQgEQm8N7os7aug9IBAQCAgEBFYdAoHQV92UB4MDAgGBgEBAYCUiEAh9Jc7q4toUeg8IBAQCAgGBNkQgEHobTkpQKSAQEAgIBAQCAueKQCD0c0UstF9cBELvAYGAQEAgIDAnBAKhzwm2cFFAICAQEAgIBATaC4FA6O01H0GbxUUg9B4QCAgEBFYsAoHQV+zUBsMCAgGBgEBAYDUhEAh9Nc12sHVxEQi9BwQCAgGBFiIQCL2F4IehAwIBgYBAQCAgsFAIBEJfKCRDPwGBxUUg9B4QCAgEBM6IQCD0M8ITKgMCAYGAQEAgILA8EAiEvjzmKWgZEFhcBELvAYGAwLJHIBD6sp/CYEBAICAQEAgIBASIAqGHuyAgEBBYbARC/wGBgMASIBAIfQlADkMEBAICAYGAQEBgsREIhL7YCIf+AwIBgcVFIPQeEAgIFAgEQi9gCIeAQEAgIBAQCAgsbwQCoS/v+QvaBwQCAouLQOg9ILBsEAiEvmymKigaEAgIBAQCAgGB50YgEPpzYxNqAgIBgYDA4iIQeg8ILCACgdAXEMzQVUAgIBAQCAgEBFqFQCD0ViEfxg0IBAQCAouLQOh9lSEQCH2VTXgwNyAQEAgIBARWJgKB0FfmvAarAgIBgYDA4iIQem87BAKht92UBIUCAgGBgEBAICBw7ggEQj93zMIVAYGAQEAgILC4CITe54BAIPQ5gBYuCQgEBAICAYGAQLshEAi93WYk6BMQCAgEBAICi4vACu09EPoKndhgVkAgIBAQCAisLgQCoa+u+Q7WBgQCAgGBgMDiItCy3gOhtwz6MHBAICAQEAgIBAQWDoFA6AuHZegpIBAQCAgEBAICi4vAGXoPhH4GcEJVQCAgEBAICAQElgsCgdCXy0wFPQMCAYGAQEAgIHAGBBaA0M/Qe6gKCAQEAgIBgYBAQGBJEAiEviQwh0ECAgGBgEBAICCwuAi0PaEvrvmh94BAQCAgEBAICKwMBAKhr4x5DFYEBAICAYGAwCpHYJUT+iqf/WB+QCAgEBAICKwYBAKhr5ipDIYEBAICAYGAwGpGIBD6Is5+6DogEBAICAQEAgJLhUAg9KVCOowTEAgIBAQCAgGBRUQgEPoigru4XYfeAwIBgYBAQCAg8DQCgdCfxiLkAgIBgYBAQCAgsGwRCIS+bKducRUPvQcEAgIBgYDA8kIgEPrymq+gbUAgIBAQCAgEBE6LQCD008ISChcXgdB7QCAgEBAICCw0AoHQFxrR0F9AICAQEAgIBARagEAg9BaAHoZcXARC7wGBgEBAYDUiEAh9Nc56sDkgEBAICAQEVhwCgdBX3JQGgxYXgdB7QCAgEBBoTwQCobfnvAStAgIBgYBAQCAgcE4IBEI/J7hC44DA4iIQeg8IBAQCAnNFIBD6XJEL1wUEAgIBgYBAQKCNEAiE3kaTEVQJCCwuAqH3gEBAYCUjEAh9Jc9usC0gEBAICAQEVg0CgdBXzVQHQwMCi4tA6D0gEBBoLQKB0FuLfxg9IBAQCAgEBAICC4JAIPQFgTF0EhAICCwuAqH3gEBA4PkQCIT+fAiF+oBAQCAgEBAICCwDBAKhL4NJCioGBAICi4tA6D0gsBIQCIS+EmYx2BAQCAgEBAICqx6BQOir/hYIAAQEAgKLi0DoPSCwNAgEQl8anMMoAYFTEBARvl0k/P2dgko4CQgEBOaDQFhQ5oNeuDYgMAcEdu7bV/r1P/vEuis+8YloDpeHSwICpyAQTgICswgEQp9FIqQBgSVA4M5HBzs/+6XvXNhRSs273vWubAmGDEMEBAICqwSBQOirZKKDma1H4IH9+3v/+utfeEHfui7+9fe+7RgzS+u1ChoEBM6EQKhbTggEQl9OsxV0XbYI/GBgYOPvf+5rP9a9rqP8mne+9XGQuVu2xgTFAwIBgbZEIBB6W05LUGolIfCRP/rkpv/2V5+9bWhssh5N9n7jRuaw1b6SJjjYMmcEwoULi0Ag9IXFM/QWEDiBgH6S/d1/9KmLDpP9lQFOu3dceNnnbv+pW2snGoRMQCAgEBBYQAQCoS8gmKGrgMDJCLz9v/7VpiPHB39yeHzMXbZh45/+h9teO3pyfcgHBAICi4nA6us7EPrqm/Ng8SIjsFMkevP//OwNI2bNf2zEaypXdl7xb37vtlcfWuRhQ/cBgYDAKkcgEPoqvwGC+QuLALbZ7e997GtXHB059ssTU5ONS7es/W9//PM3hnfmCwtz6C0g0HIE2lGBQOjtOCtBp2WJwN0i8Wv/8hsvO1CP/3ct3ZBeuaH6z//8vbc+uSyNCUoHBAICyw6BQOjLbsqCwu2IgJL5Rz/+zev2P9X/K1PTtcOXXLD2v/7FT75+oB11DToFBAIC7Y7A3PQLhD433MJVAYETCLzyjp0dv/zXd77+aD35OHX1rb9mXfIv//btN33rRIOQCQgEBAICS4BAIPQlADkMsXIROCBSFpu+9lD/gV+bmBwfu/SCzf/3E++/9Ucr1+JgWUAgINCuCJwtober/kGvgEDLEFDP/N1/e++7++v2T6l36yW9tv47n33blb/fMoXCwAGBgMCqRiAQ+qqe/mD8XBHYfVy6bHn924cOH/kll+cTjvirW7es+exc+wvXBQQCAgGB+SLQHoQ+XyvC9QGBJUTgNXfc3f3+r933s09MyZ+N9Wy+qj46+qlb1skvf/rtt4wvoRphqIBAQCAgcAoCgdBPgSOcBASeGwERMXcOTm62lc6fHT565KclyzNrzf237LjgE//nLS8bfu4rQ01AICAQEFh8BFYDoS8+imGEFY8AyJzf+bnd237tm4d/fddE8puT66+80k9P7+rNJz76V2+48tsrHoBgYEAgIND2CARCb/spCgq2GoE7ROxPfPnxSw/W5BfHR0bfyn7a+PrYgZu3bfjEtRs6vt9q/cL4AYGAQEBAEQiErijMR8K1KxoB9cz/7+cfveipCf/Rg770Dwar6863/thApX7gdz/xmu2/9xevv3ZyRQMQjAsIBASWDQKB0JfNVAVFW4HAbZ/Zu3XvuPv50bGJWyWbSiibPEq5+cyrzjvvb5jZtUKnMGZAICAQEDgdAoHQT4dK+5QFTVqIwIc/ta/n4eHJ9w5I+pOjHesuiKjWMJP9n3n15spv/smbrj3YQtXC0AGBgEBA4FkIBEJ/FiShICBA9OWnJjcf9O6Do+O1nzBkush732jU73zjZds++cHXXh9+oz3cJAGBgEDbIRAIve2mZAkVCkOdFoE7+sf7fvuHT77zofH8o7J2441xVEpc5ga78/y//KNXXvS1W5nz014YCgMCAYGAQAsRCITeQvDD0O2HwGcOHDvvD+898OFHR6ff5+N4jUDFqfGhJzo4//N3bl/7/RuZMxQtWNQP3UHC3+GCIRo6CgisXgTCQrJ6536xLV92/d9xYHTN793b/9YHJvOfn+ruvcmVS+WM2dH06KfftNn/53//msuPL7RR99xD0Se+ezANpL7QyIb+AgKrD4FA6KtvzoPFp0Hgk09ObvrzHx1578OD0+8TSTYZSoyrjY/bbPSud1299XO/8Morh05z2byL1q590kZThyvfPXgwnXdnoYOAQEBgVSMQCH1VT/8yNn4BVf/4/pHeP/7RE294cKT+EamuezFxZ4UpIc4n93dkQ3/8kUvO/95VzI0FHPJEV2PlshXu7KAxKp8oDJmAQEAgIDAHBMwcrgmXBARWDAJ/v3diw8d3HbvtoePuQxmXLqS4HBmXkx8fOtjp+a/ffdHmb16zgaYXy+CuNI0lNt3VhCuLNUboNyAQEFgdCARCXx3zHKw8DQKf33286789sOeV9x+d+KmsvOYlWdrd0ZCIIqJGlRvfum3Huv/7my+/6CAz+9NcviBFrh4lsTU9YigQ+oIgGjoJCKxeBAKhr965X9WWfxbb7H/w0LEfe3CQfzaLOi7PTRwbEUobU9MlN7XztkvXf/xXXrK1H2SuH3RfNKwSayKT2A4xSSD0RUM5dBwQWB0IBEJfHfMcrDwJgTsGBjp+5+79L7t/YPKDvtT10jzt6nI2JVZCJzfQ4ep/+dYL7bc2M0+ddNnCZU/qCQ8MTMamjnxKIQQEAgIBgXkgEAh9HuCFS5cfAn8/ONj5J3cNveGhYf4H9fL6G+ppb5pxTJGvk5sceCz243/2zis7v/XKvr4l+U9XnIi3zNaISZcfmkHjgEBAoJ0QCITeTrMRdFlUBL505Ej1P3/zqZc8dHj4vRx3v6SW9PROmyq4NCbvGrWU8++8fUfPJ26/4cJD8JwXdav9ZENtZNLJeqNrp+AF/skVc8uHqwICAYFVikAg9FU68avNbN1m/717pt/2YK3yT6c6el9eT2zVcE6pq1E0NTwd10a/+/6rej75yzefvw9kvmT/ixr+ADli7mw4d3Ff//Dm1TYvwd6AQEBg4RDAerJwnYWeAgLtiMDOfVL64+8cvfHeo5PvkaT75Xmpc51LYvCox1Z7TpWIxntK5mu3rO24Zyvz9FLaMI2nB/jlFZPYbc74TUs59pzGChcFBAICbYtAIPS2nZqg2EIg8Gcg8998cO9rHhyP/mkjLb2sTpSwLZP1CSXekc+OHU/9+N/85KXrP3Pe9vWL8mtwZ7KjLCLsvYki2xtz1HWmtqEuIBAQCAicCYFA6GdCJ9QtawTu2CXJ/7r/gWt/dGTwXc4kL6G03CtRRMSWLMVEzlESyxNvu2rtp1//gvWP3MgL+x+v0FmE3IvzYhwzl0YnJ1f7r8WdBWKhSUAgIPBcCJjnqgjlAYHljMAdIva/791704Pj8UcbnZveNF3u6axRSigm73PyXCM/PXR3tT7x327qTX/QCjJXfDOHbQKWnNkm9bqr3n234ElDa4IEBAICAYFzQyAQ+rnhFVovAwREhP/oU49e9MDA8Z9wHL/YJx3r6mQjD8/ceyEhR7nkWRLzd993zcZvvv+CnuFWmVWpimeBGDxtGO7YvLk/EPpiTUboNyCwwhEIhL7CJ3g1mvf7ByaufECq/5IqW99jo7VrjShbZpQyttiNkJkeHShPHPn4L1zR8fEfv37T4VZjMOgeswAAEABJREFUxNYykS2LN93Hskr4PnqrJySMHxBYpggEQl+mExfUPj0Cn+8f7/uT+468brLhX0EmXU+Mt+ReiMURzYhlP9hB8pUNZB9s1Vb7rPZeRLyeMKVkqINL9URPgyw7BILCAYGWI2BarkFQICCwQAj87ZHx9R/97rEP7B5NfyaKezbXibhBDTi/uM2x3Z74BvHIwcdLY8f/8Beu3vDln79x86L/tCs9T1BCZ8G2gZiU2GxInO19nktCdUAgIBAQOC0CWOlOWx4KAwLLCoGdAwMdv/WtQy/ae7z2pnJSuijPJSZjyFhD+rkz5xw1GlkjiZKHfvJF277/azdsOt4OBiqhC5EnppiN7RGKOtpBr6BDmyEQ1AkInAUCgdDPAqTQpL0RuOuAlH9t5+ite+rVj0altbfgXXQSk4PDW6csmSYXZZRQRJXM3dWR1f9wS+fkg8wMHm29XZlzHh66Jzx6MNtuYRsIvfXTEjQICCxLBAKhL8tpC0rPIrBLJPmlb91/9WPHxn5McndZHCclYyxbZsKLc7i+jqzFbW7stGF773tu2PKjX9qxA7vx1BZhjYjg2cJBWzKR6ZDIV9tCsaDEakIg2LpCEMBKt0IsCWasOgSUCz/8149csocq/zru7XuvTbt6nOCWjhOasp48pORrJEOHjvLxvf/r5y+O/uy3rt94rJ2AyvM+L2wyMfDTjSl7MeHHZdppgoIuAYFlhABWv2WkbVA1IHASAl8+erRv38TUu/N6/Xpro3IURQYpZVlObJq3tse78yg2I9XE/oAaWx9luMMnddHybL1Onsk3oIiDbqVjw1NlfVDBeYgBgZWBQLBiyRBornpLNlwYKCCwMAjcMT7e94s7J381TjZ9xHSev2k07qHhyNB4VKfphKhhq+SlQjLhnipNT//Jz23r/sztt3K+MKMvXC+T28h74gYJg9DxDt3Thv7+/uClLxzEoaeAwKpBIBD6qpnqlWPo/UeOVP/V3+x99fjQyKsS7/rgjRsvQvopNxUD71w9cyKmJCkd/+D12x67/dbtI9SG4UoiZ4WnoX5mLHdih2H9OHVU2lDVoFJAoB0RCDqdhIA5KR+yAYG2R+BLR6T6ti8de+8B2/WfhtZue+HhnvU8DgLnKCOSjMp5TJ11T2umj+al44/8IBo9/Jvd6bEvtath2GZ3m9d2jLpcpjxhmyFJbqKILm9XfYNeAYGAQPsiEAi9fecmaPYMBHbv3p3+4ud/eOPxkeHbuiI+L03TooU1hsRLkffiyflcxJjJNC7t+tD123bdftVV+o66qG/HA9so86K/gENkre3iKOluRz2DTgGBVYfAMjM4EPoym7DVqu7dIvHbvjN+86C3v9PZt/m1HJeIGnUy+p+V5Y6SLKKUYsqsfu98uBHVj//wPdu6/vfv3rzl8XbHzEmWMzG2GKApUzV3PnwXHVCEGBAICJwbAoHQzw2v0LoFCIiI/ZmP3X/VSCYfKRu+NEpL1MhzslFEqCvEWoPUk2UkbIbiOP5ub7X0cAvUPechjY+wpeCV0IWYy4PDk936AHPOHYULAgIBgeWEwILrGgh9wSENHS4kAiBsvvIv791+NO76z43S5vfnXZd3DMCBHS6lNBVje51zMpFQJDmVXQZPfWoqnRj9yjvPr/7J7TdubqvvnD8nLqZeF5IJ1AveqXd44r7uoaEyzkMMCAQEAgJnjUAg9LOGKjRsBQKXfuz+zcO5+UXXqF9q4ogyl5MxlmIbk8tBfYbJY9udyJN3cNudP9hb6fje77/soqdaoe9cxpQ8rrMT/Y9iPJEk8NJ7IpeGT7rPBcxwTUBgFSNwCqGvYhyC6W2IwLdHRnqH0urt9XTtL2TVNRum4oRqMVHuhUw9oZQrxCYnb2pEPE22NnKkc3L0zz6wpfTXtIyCRL7uRSYFbjrIPMUDyza47OuXkQlB1YBAQKANEAiE3gaTEFR4NgJ3DkrnT31233unG7VbjI0SY2J44J6cOLKRhSPLJPDQjSdKiclnjTyKzOGXXLxm1+0v2Tr07B7bt8RmeFegTyQknoki2LfZCfW1r8ZBs4BAQKAdETBLp1QYKSBwdgjoB8Le/bl733jYVn+tUS5fVosr5KVEBLrLo5xyk5FkEVV8Sp3TlrpruY8bU/3Gj3zyJVuzr57dKO3TSuJ6nSifIMbTCjNxHG8ensi2iIhtHy2DJgGBgEC7IxAIvd1naJXpBxIzH/jEgzcempr+QMLm/HJSJsJedCPLKIoiisjgHxN8dnjrAnSYxPFklrm7X75tw3d/qY3+JzUod1axK1vnQOMNEsJ+A3JseoTtpocGCcafVRehUUAgIBAQwNq4QkAIZqwMBG76+13nHa7zL/HGLW8eTzsjm5coAm+bOCYHuoszS3DQ4aU3qB5l2GxH7aQ50JNN/u93DGy9azmiMLSJcsGWuxA1PBvyxlSdkfNTO92zHO0JOgcEAgKtQcC0ZtgwakDg2Qh88cDomv5G6ack8y+MTMyxsWgEEUP67pwtkwHrWdC4z+t4Gs1FTDZRSd3D77/2gvtvu40dLcNwJZG3RupEnDMzEXHExm6BseE9OoUQEAgInC0CgdDPCqnQaLER+PxuSX/hW3vfeIS7/rHv3XohZ8y2kZP3CfahI8oIeeMp8oZSUsnI+rG83hh88pL1tc/99os3PbnYOi5i/y6JuUYkDSK8QoAQmz7DZg2FEBAICAQEzhKBQOhnCVRotngI3A4/+5/dt+vlR6ey9yQk3S7z8M7LZE2J6r6hVE4xtty98+SNo9xnFOFcPE12cvadl27s+s7iabf4PTOzdFXihghlwhiPmbRocirrFClKUBhiQCAgEBA4MwKB0M+Mz5LUrvZBvvHphy98arr2i2nHutdZ9nEalYgbVSJXpTzyEAeCY/jlQs40QOoZOYLj7uipa7rtn/3r69fvpmUeWPCiQaSBNwpUULgxHaMTtd6HiOJlblpQPyAQEFgiBMwSjROGCQicFoGPPTmy/VBNfs6k1etzm0QO/JUL2Np6qrkGsYG3KkL6nXMG0zFo3ZB3bmrscK9tfOX1aysP0goI3liPHQenn+hXMYY7nZhNnaOjeLJZAQYGEwICAYFFRyAQ+qJD3OoB2nf8z+4f6f3te469oz/vek+9tG7LtC2bjMvUgMqZzUkSMDsccQbTISEjIHfH5Bv1hq2N3HtFxf3Zr75k6zSaL/toLQjdkOgfpIG9xtgOZ+x2qlHvsjcuGBAQCAgsCQK6fizJQGGQgMDJCNyxS5L/3339bzw80XhbaswG49goYVsSsizETMT4ZyQiViEEdmQ4dz6fPrqhHH3jxVdHT6B0ZUTJG975mhrDzJpE8NLXOo7Cf6WqaAQJCAQEnheBQOjPC1FocCYE5lr3sb2PXLVvvP4ejvmmzNjU+piMJzJ4O27hjjM6ZpwZn4DQ8RoZBayETo3c5ZMP7uiNP3H79u0FAdJKCB7vz73UBK8XZszhyNh1xLZ75jwkAYGAQEDgjAgEQj8jPKFyMRD4s0eGt+1p2J+WqONGOKDYWI9A4YaMieCTC5E4CBV5xvZzIWghAi6fHt13fjX+/OffePEhWklBCd25OpPaD4FtJrIbxurZOpA8HmdQEGJAICAQEDgDAoHQzwBOqFp4BP7oiaHu/3jvE2883Eje3LDdGzxXweQJOQFncYQBQebw0osbUzzp+2QlOQNCJ2xL57XRe3Z08N8xY18erVdKNNZmJL5Os+wNTx1b7usmJusb9uyhZKXYGewICAQEFg+BYt1cvO5DzwGBpxG4Y9eu5I/uP/iWw7l9j7elDd6kJveWGEQOQiPn86ZnruReXCaoy/FOPQOxZ568H9xcrXzhc2+68mhRvYIO7AWErr8Wpy560zDDXPVCm0rrx8In3ZuQhGNAICBwBgQCoZ8BnFC1sAj81QG69snp2gel3HWTs6WyNwnYS/9bVJ4ZCAROhhhCRWBqvjfPyFLmXVbbuyNOvrBQ3nkxRJsc2EnGIjVY7GdVwnNNQpHZlE8lXbNlIQ0IBAQCAs+FgHmuilAeEFhIBP6/h4euenTC/gyZ3huwzZ46YyhnT1lE1ICwb1CMcwKZO88gciIG3XvnKaLc16dG9m2K8zu+dNuVQ7QCg7CbZqIxJmxTiHI6k7BhsnarL/t1FEJAICAQEHgeBAKhPw9AoXr+CPynxw6v+/OHnnrzkTq9TkzPGhA6e2Zy7Cm3BGEyeEduQWQebikxbkvkSRz4zGK73bksqz9yXkx/R8smnJuisYmmWPwQiW8wSXGxAAdj7QYiG/7XtQKRcAgIBATOhIA5U2WoCwjMF4GP3X+k+hcPDb/tyWn7DmcrmzxbY8BXsbOU5IasF4ijzDpqqDCRpAk22BvwzDOK4Z1PjU3u35Lav/rH77h8gFZoyG19irwcE/FTBaEDB2IcjOkZGq31iIhdoaYHswICAYEFQiAQ+gIBGbp5NgIgIf7dR/uv2zeRv82UOq+QuFoCoRPjX+SZVJTc1Tv3LORw4rDL7BikDu/dsiNxmY8MPfzRl2z9/G36Qv3Zw6yMkqE1daL8uHgHQm+ahOceImOqY1O13oMHT/2ke7NFOAYEAgIBgacRCIT+NBYht8AI/PS3n7p8ty//dD3tfgmbatnAycxB2uqJ69fRIu8pdZ4SR9hw13fqlsQy5S6nKIooqtd9bWzogU0p/+nPX7RmdIHVa6vuLr4YWxEio975yaZijI13JhB6GRD1+c7RUrM8HAMCAYGAwOkRCIR+elxC6TwR+P3dx7u+c2jopZmJXuqSyjqhGGzNeG/e9MQZ7qeFRF6w5a6DGRAYbkcREosURcblPia366de3fNVnK7oyNh96O6pTHov08wELJrmsjEpG7vO5EmlWbIUxzBGQCAgsBwRaK6cy1HzoHPbInC7iPnzXYNvGMjLH4qo4/yUyuxB3h7etyUDAmeqxxlNJQ2qR0I5ttmTPKVSIyXrDKWMVpmXzJuDfaX0L/+fjRtnvNa2NXlBFEtiW/fisfWu3cFDB2bMJiJrN+SUd2ppkIBAQCAg8FwImOeqCOUBgbkiMHX34R1PTdZfY5LSFZbTss+EjLWUF59cJ1A6k74vz61HSthuZzLe4p06uIvQrt4gdkJeeP//+8rL76RVEmIvDSKpEwuoXI1mHNjEUbQFXvuK+V/XYFSIAYGAwCIgEAh9EUBdzV3+waODmz99xL9nPO179Vjc1ZnjDousBzmrKDIOh5zIp0SuQuwTnDM5m1FupykxdSrnE0RTw3sqMv4nt23lFfHfo8LI54+GjovIEbwzd4RNd8ajjuAhKErTS44OZVccPiyV5+8ktAgIBARWKwJYbler6cHuhUZAf9r1D+89fM3+oamXO07Oy22iH2QnBjkJnE5mQ4XPiXOCJ04UgbdMoYawkBhP4jOKyVHeqB/tKsdfLypXyUHIjpPIcS+CJx41uumox8b0NYSu8en0Gi0NciYEQl1AYPUi0FxNV6/9wbmPEuoAABAASURBVPIFROBbjTXXHMr4J00UvaBMlFSdo4QMMYi8oCa8K5cir2V1Iq6TcJO7LDzRGNvslDlia+G/Z3f8u/dcuuJ+s53OEKSW18nTBBNleNI5qSXbKI4uz220/qTCkA0IBAQCAqcgYE45CycBgTki8CcPHVjzhQePvBivf28op6Vu3FhMDmQNz9xhD9kj9R4eeMHsoCwSUs+dWJojItHSyBgaz2Wgp5R+fUV/77xp9SlHSesNw2YCXnqmWJxcaQxvPjY4rP+VKqA9uSbklxKBMFZAoJ0RCItDO8/OMtHt93fvTv/jI9k7B5L1v+Aqm7ZPc5lzYWJmOJzgdbEE55wsyNuIIfKWPPKOM2I4o4YbsJTJ+IiMy0d58vhn/seHrthDqyyko31K5KN41qnh+eaE9YCSxPCaesOtf/JJbHqcqAmZgEBAICDwNAJYXZ8+CbmAwFwQGBwvX3Z0ov4qY+LzycSxVwYCmRsIgbLZGLLWwvFseuigeioC61GpS9BK80yT0/XRalL+6huJlOW1cNVI8eMy2HL3Qic+CKifPRAwPKCqOvZ91DMSfmBmxd4RwbCAwPwQCIQ+P/xW/dW/+/jIhf9z99QHpsudr6jHaTkzMTlIxglNS0R1MuQgotvvPgNenvSnXT1FoKmYIsnIohVLs10+Ofzx//H6iz/PzILGqyrCZre2uzyMVxXjhmA+Ioi8iYHlKhtzKVEp/EctTUTCMSAQEHgGAoHQnwFIOD17BO7YNdDxB3c9ceP4ZO1lJWs3eCLO9X05XExiJmNt4ZkzM7xzoSSOycBbpyIoVakQNY9Ejijr7en6wbv6aIpWaxA/AfgmBGQO0E5GwWDz42JmHz7pfjIqIX/WCISGKx8Bs/JNDBYuFgK3P9B/03jc+Y/T6qYb2MdGf5edY095KpRbAR8J3ol7YvFEbCjzDNIW8jhnJxSrb44y8Y4SnsymRvvv/NKbL9rJYC1qw/D7n/98uthqseURyv1x9uKYiZiZPBFJFDEn8aX7DwxfvFtk0fXAkCEGBAICywyBQOjLbMLaRd0/fOzYeWPZxMvEN7Yzm8gYSwbkA+opVFQHs8jgAF56+miYYnjqKKA8zylC3oDsJxrZWLUSfbu7l2pa144ydGTqvJ2C9wiLqByTm0D3w0Kz30XHGaJ67MaaHjJ+azQyUkZRiAGBNkIgqNIOCJh2UCLosLwQ+N0DB8q/fe/B14+naz8sScfmnBuUs6WMSoQX6GTxvjySBjHejVsVvCd3HFHDJNQQhoeu3jm24JXQPZHzaNX/5F299eE/2sFcb0c07rjjDjtUn6p0EsyixQuJM6Ps3BE8BNUsHpCQEjPjjTpy1la9jS5nLvUungah54BAQGC5IhAIfbnOXIv0FhGeHkl21Bruddj33WysZTAOueI75oIsTgXKqSCZjc1TEJMIZVlWePPWWgJTafRRtfPx//7T14/Mtm+3dLfpvLIj6h68gShfTN2qMj4pxAPi5ZT/kAYeOym42N24UMR1UwgBgVWEQDD17BAIhH52OIVWMwj83u6j2//LA0MfyqONr3LSl0xLhbIohfdN1AA/R8RUdkSxF5A2aEg/rF6IdmAoiWIyeJOuO8oxOyrDe6+PDj26KfV/+hZ6+uta2rpd5P/70v3VA+PTN/7UO26ZZlZjFk+zTZs21cX7o15kDA9PxecQNGWgJgzsomjroYPH+1AGtCmEgEBAICBwAgFzIhcyAYHnQeDP9u0r/ec7919RrzdeHIn0ePjWbAzehWuOyLA63ILSmY6kmc4kOEGdfiCOGbTP5OHV5855XHjwP//E9Ud5kckSCswp5jR9WV2MwS6EzKmDc7gIGLg13eVjPvejJ1+mA4PEyVjTC8Q29/cTNkhObhHyAYGAwNwQWDlXBUJfOXO5qJaATHjvVOmiCWPf56t9N48naVxPIsq4gzLppQj8kvgaecnhqettZSnCu3ESS44ZujkC9RO7jGKwk7AUe9cTtanDVW587OpOmkCjtowjDX+pSdOJrizD3sPiq4hHh1H2bgwQiQA6FWJDHhlr406Kom3cOVFdfE3CCAGBgMByQkBX3uWkb9C1RQj8l10D6z/+gz2vjzl/obHWQMAxhpx+AM5ie90ICGdGOQFjw08XiPrsWgpeKrK4kBjkpCe4+UBRcnRLZ/zAxUT6qzPatK3kP9x5Z+fAyFiFbfTk4U2blkRH7w3I3A0Ds+IBghk5RQWwsjEJx3ZH5lyXFgUJCAQE2huBpdQOa+pSDhfGWo4I/NHdEv/ne4++6Eiy7R/VOi+9uGFiytlQDuI21hFTjZx48iYhRrkFkSuZe7iYKgQ+MvDULUQ8U06GIrIUZ/U8mTr2l//p5ZftZWZPbRbuELEjU/ZWb7zpS3j3jcxLQuiVUnY4ksYTTJm+sweaFsJkga1jpqhavvKpQ1ObBfpRCAGBgEBAYAaBQOgzQITk9AiANHis4+iWCfGviNms896dpiFcxzOVqh+O+mYrBp0TeWy918UfvXjDhu+NbsATAbVfeOIbP9p6fDq7FBsStdfdck19qTT0x3trzvNxET8FJj8xLJ6fig/JGcNbcvbb+gnvOU7UhkxAICCw+hA41eJA6KfiEc6egcAnBger/+nOgy+uefumUuQ6RU4ldEb7WUEWUc9wW2lSSHEoeAm8jnrBO3SIq7usMfLDf/6yvidvY3aoaLtYN8lLsji9ipN0YEtf35J45wrCxRdTFhENivNjih4BPWbNYd8DrI5jN1m6bGpiokPbBwkIBAQCAooAVl5NggQEno2AYEv3wMHGRblN39RRqmzy2DvnyIBeTmoLgikK1P0uRIlH65tpUaSnEBARuEnIYCu+nmfHSrH5foettuXvtt8tEk84d1FOHAlF/XjHn8OEJYmM1w/lrtIx7/woAGuOqUAipwnq4yiyl/K070ZRiAGBgEBAoEBgoQm96DQcVgYC//6+I2t+657xNzaitW9qxB1ddRuRAxkLiB20TAapgaknS5PGtURzSv4QZPVT7WgO7ndkJaPGxOBjV3Ty59+4htry0+3fuGvf5iG2VzeipHR+b9dxkKiDqUsWTU7HxLshxiY7hFg8KX6E9+jElmySXnj0+ET4PjqFEBAICMwiYGYzIQ0InIzAzn37Sv/1/mPXTXu5NYmizgz75R6EnnuwMxoqySBpRkEyK8hqFLCPaOZkgTfPeCDIfSO3bPZ+5CVbB5nb78Nw+/ZJaZLkxlKcbrLEk7fddPGSkrlCJokcFyeDyGfgdCREwEoPhVhrN2YsWw4SJRRCQCAgEBAAAsuL0KFwiIuPALbazT3jndsmbMeHo+qaW3IbR1lcpilOyRnlD6aTCZ2h0qwgW0QpWujtpTVUnDWvyakm48OVSD6/bbLalj/1+pmjT114PKMf6zDl3iqVDrJzDVriIDUaApH3s0jN4EEIeUSBFkxe0TS2W4gv8KOjJRSGGBAICAQEsGsaQAgIPAOBTx+j6u/ec/QlruFemMRxhbDN67wHoWjDJkETSIWKIDieJJpFiUY8GCBBgW4Xg5QYYimXRlY//ML13U+8chstOVFCoeeNtcTeaBJ7eWTYpLF5wtVqS/YJ91nlOn33NDYz+kX8xCmIA0NqYp8i3SJxHAidQggIBAQUAXWhNA1CFDAAAiJivn14+IJpk74trXZdWDeWMhCI4L2t4PlPsPVOSAllNBvAPHjJSyqgbyLBbaUZRpEK3pzrN6ktHgqMr9cjV9v1T15w3gC34Xb7bpF0zNpXUTW9HA8xeZr7xwb7+mq0xGHbNqrHsTkoWT6kD0JAlAwDTOihcyDMlqNo6+RkXkVRiAGBgEBAgHSdCDAEBE4g8Dv39K/5iweOv408X+XFgYcFdNwkEj2qFI2VsE9ktI0KETOToJGIEOOfkpDVlPRxwFNtcqK/bKKdXenkKLVh+OKDBy8ZrbmLjJg0z93E+T3lkVcSLfk7dGaG820GyPsRJg9wNQoQYyLmAs04js8fPDIePhhHIQQEAgKKQCB0RWEpZBmMoV/V+oPHxq6esJ0fpqRykRgGdzARR3C+mSz4hImJiudARjobUaFZLTJKNnDS9RwiDlyY58TeUSQ5yfTUEzdvKH3/pevWtd2n2/EQYoZq/kWJjbcasTZzbuClF60bY5ArTFnyiHfnx8S740zeMSjc4yHJQwtmPGfhNQg89C2g+QvDD8wAlBADAgGBYmUOMAQE8H5c+LP3Hegbzepvc+Q2+iQhsTEJiIPIE+M9uApIpkBL9FgcNKMCaiEhj3YCISV3rYdzqU+NEZoY4nopqTzw4evO10+3ay1K2yf+jweeWDcylV8XGdtt8KfhyR+IY7fk2+2ziKTkhojkKGAtPmsgIHTEmWpoaG0vW3OJHx8vzxSGJCAQEFjFCJhVbPtKMn3etnyBKPkfDwxcP+Gz10mFOxuxpQZILcf+OWgaOYGHLkU6O5hytoqeoxnpd821raaMCr25IjwQJPDaLUg+y/LRShJ9MxqsDus17SZZnlxq4+g6y6YDzzCZYfN4WuuYbpWeeUnGoMdBkPiJD8YRnpTwjESClMgmUZJeOTHluyiEgEBAYNUjoGvuqgdhtQMAz4+/dl//xlGO3h1VKud5dpRLhhfHEXkQMrxEMoYLCgGTPAMuwfmsIKtMXgjyaFzcYN4TyDyr5Xn/67Z3HX7XlZRpbTuJ/kcso1P5NbGx58Ezt9PODTsr+/J1tOSfcJ/F5cq+vunImoPYdj/xeQOFVusVcQ984yS+cPDo+HrModXyIAGBgMDqRaBYb1ev+cFyReAbT1L6v+8+eAtF1debUke3ErqjnChKse1uieBdM8hDBXvzuIQhJ0ell+a55kSrVWauYe8JTwNTNvaPvGNHZZhb9E6azhAm7juyZgyEbm3U60h40uVHLu3tOHAlte7hAzi5NI37vffADM9WzMTMhRV69HDdTWQ2NYQ2P0kUFxXhEBAICKxaBMyqtTwYXiAgIvYzR49eN04d743irl4nJTjk+hVn5QfGu/OiGcqQgq0tJHJESu658eRAMCIR2jEZEL9BDSujiwEtGspZL8XjwfTo0bKb+lpH7I9RG4YjE9lLTbnjeuG0DMV91pjef/OWtGUfiJuFSCQ7KrkfIPG5QaEB/gwiV4i9MeTxHt1buah7mDBpaBBiQCAgsGoR0DVi1RofDCf6jYcGy3/80PBb4461L865GhPr15pT0HJMHuQB7iAGcRDyRgzeoxuK1eHGeW69uo1g7BhkzhCh4obyTOqUezYE7sf1Qnlj/MDLt5Tvfk1v7xidGlp+9rH7j1QHM3q5pB07ck5iEs5Z8oNxlrVsu30WlJLLj4qXA+R98YtxBhPCwB6RxFrKjU05SS49PDoYPhg3C1pIAwKrFIFi/V2ltq96s/W98Z9+f+C6hvOvriRJF3lHBkwceSIDb5uL3eamF+5A8QqYEgn4mvQUDjoRoTHeuWu5gM7BN6R1Fpkoz8k6h84iHyfJEh38AAAQAElEQVTlx161o+sYt+F2e+7kAhtFl0D9iichJ64WeTmYJknLPuFOM6HK64axi7LXCY0JE7QjhRc7Ikg9FSFJ08v6R6c2oZ0tCsIhIBAQWJUIBEJfldPeNPqubzzZOVKbfEN3Ob0SZBAlFreDkjCIwoKhDeUkLOThaXvmgkj0INy8Hq1xKmiDC1BPpHzCZNFPhJoIZA4nnhqeJ+MoemBj4kZoqcNZjFcjfzEb3krMuvkAZ9jVUpF+qdeLr4udRReL1mTLFqpFkX3SiT+BHRP+YRJwxLhMcRJdwszX9PeHbXcAEmJAYNUioGvyqjV+NRsOArd/dzB7oyTVt9lyV7UG75wjBiRCxhuynsmKgyfoCCUkzORQjWLyhCBctGOkwg5lIHYQDRxzIhwsPPzIeUqZJMvrx9580Zq91NfXsq+A0XOEz+/enQ5M+es4ijfCQ4c58NCzfCgSf6DW19fyLXfGjkaamn7vZdgTYD6NHWLNGluKX3YkP9ZzmupQFBAICKwSBAKhr5KJfqaZ//Cuo2uP1RpvqXT0Xt7ghAXvyXOfwbtm8JohA6K2IGZDcNVRIiBrJXMhIlThSGhjUIoso5SRoh2jBO98yXihCNezSIPIH37J1o6h2xjMr83aSI5ORJvG8/xKY203CJOgPuVZY8hkbuBG5uf7eh0tRfBejmLLfRD6OR2PcZgVZDEfHCXl5KbhodoWEbFaFiQgEBBYfQiY1WdysBiLPn9uz9Ct3lRf6ZOOqAGa0F+Fc7GhBgncQCYGaxvwtJKy/qcqhHL9VHuOQkG+QBFtNItmJOxxHSiHuaB1h5StpUajNpTmta92Ch2mNgwTJrlGomSHNxyrDYy/CNdwwzddsKFtdhO6KvkAER/FA1VDsda5KAQnQgzsDZk4vsBbueogUUIhBAQCAqsSASxfq9LuVW30h752aM3w9OTLKtXuzdO5EHFEeN1NDZeTtyAIkAQh6M0B/sbWO6FEyKPAM9oT4Rykj6PmNClKUSeEnEYwIzOj32w0Ndm9a7PKELVZ2LlvX+nQ6OSl2JZYT9bAOiLscJMXN7VlTZJTq8PM+BevWTOBaToi3j/9kAGMuahvHsmYDmPNVfkIpUVxOAQEAgKrDoFiEVt1Vq9yg79+vPaOpHPdaxuUExgMFAwSB/l6ivH6u3lLeJzn8LU9Mf55Mtg+JwS0LM4FeRVCGxK9Rs9yQgdEnsmjvo4ddu+mH3vHju4n33gxnH+UtVPcP1q6aFLiG02a9jooJtCafV1ROBZHCV4VoLANIjP7zkQOiXNjDExFZ4y50EzEA3JDnq2Jy6XrB48dOU+kmJCiPhwCAgGB1YOArsSrx9pgKX3kM4crxyemXxWZ+ELl4igGiYMgCr42lohViAR8IWyQMghcZgTVREWeisA4MjH4g5FDpqhjHFUyQw2bmIev2pDq/30u2qSdxEV8kcF2OxQrqb3ETOSdWDbjkrusnXSNiAbgoY+AzL3irLoxQ19kGPNEyEdpcsXYVONyFMWQ54uhPiAQEFhhCARCX2ET+nzmfHF0/MWUrn3NNKWR8gBRnRzuAg9CMI7hiZuCL0By1DBMIGV4f03/NdJ63yQREAs51lZCWsJgRE1JCEFQ5qiR146VEvPA9ryv7f4zFt1u3zPmruOkvBX7CoZgKyIIXWqA4lhnqb0InZ3vZ++OkLhM4JUT+xmcdb4YeEfENl4blUuv+u7DB/XXgVAfYkAgILCaEDCrydjVbusbP787HRg+/opSpXudiUsk+OfAW8rRrOwuQAjCSIiYhCGEwEIMMcTFP8KRSIpEuEiKEmSLE/X2lXS85ONvvqjj2Jt2cMu//kXPCPsmkr6pjC611nYzXp/DmqKFF5pC/phpNNrKQyfKDoPHn8Sc4T06jjiBnoXOzYPBlLBN4uTmWub1R2ZQ0KxpyTEMGhAICCw5AuGPfskhb92AT0z5VzdK5bfrz59lIDEGGxcC4mZQcuQN3h9byk1OwjkZvGNneIKePBXkgXrCNTkT6UMAjrjKEaGdlpNLCg/f4Bry2ZR1tV1XddijaNB2MbPJNZG1l1riyAALrwSJJxHvbE28DFJfX9u8Q1fwRreu099z3+WdG2l6500P3eJ1h/5mgOLv9HVJmm6rk7kU11hIiAGBgMAqQiAQ+iqZ7HfddaC8f+D4K9d1dlziQFw5CIzA0gxKZuYCBcZ5M0ME3kYNQVCIahyRZ9IUGa2gZhCcqjBSvZ0YFws5cbWY5dFyR9R2n26/68CB8t7B0cujyKgnC7Ph8TYtoyz3Y+LNyJWkTylNC9vheCtzXk3skySiry8EICMKQXlIE3PSGcCOg7HRhQeJIlq5IVgWEAgInAYBc5qyULQCEXhw/8TNjaTzxxppd2qjnJgdCAHT7yLinMmSBiEvDu/OQcjGUYzteP35VoY7LmiRwwN0xpIjJg/RK9AJqDBHgr58ijQibzLK3fjxEme71tJ02xH6kankkrpJXhhZ0xPjwQbvp6lpjqHMyfhrL+udYGZPbRYSw3uxk3CISIrXAQLkQeWF6iKMFHPA1sZp8oI9Dw12t5n6QZ2AQEBgkRHACrDII4TuW47AG/Hu/MlDB1+9pqtnawNs7BwImIgsyJnZEiPPOBrDoAjQBIMykNObQ0twWrQg1hwEKfgDZURaTwgoRb55BTLowNUS4mPv2rKlhuq2ilBoOxtzCewt2QIDhspNybyf6O6yBWG2ldJQhnM/kDvahxmawumJyMiJCBnAj9cFVCrFNzay7EKUWVSFeK4IhPYBgWWKAJaAZap5UPusEXgytx/M1mx7jzNrE+/LZCguCKwGBmhEQsQZ6LtBwg2UO0qcocjHlHFCDkK4wsAnN1SnSOqU+Bq8dw/STrAvXUa7DsoZtxKPk6Uxqsg0lbPpJz94+ZpBZt0UprYJ+tvt9w6OXU4lu2WKrZkgWGYS8rA5B1sy++NdeRWc3zYqn1Dk6vO7Rzpivs87f9zhiUowf7nx5PDPiiPrdS5hT5Rs59S+7UnCRJ+4OmQCAgGBlY6AWekGrnb73vqZw5V9Q8Ov7Kp2bHUefA0CYyQqwgwSB0I8I5ogzzP1hPpZYa2DgMUJVxXSvFhvIRVUgrsZAs8wT6L4YF9PdQSlbRVr3NmdibvAGuoiPIQUGEBDRp6gPDYparFgHx5l7RYZ+nnJn1RCh67uhH6YHNSRwEsvythEabl005MPHFpXnIdDOyEQdAkILBoCMyvxovUfOm4xAk/VRm/xLr2BbRJnVGdj/fw04hk6RwoeITiIEE9MngwIxQhRrdEYQ/axxHn9ANf8xlvgqycbbotnvsCzjYUM/lkSPOkYPIhYQ/oRgYZLYcwCj7tQ3UV1+0Se5U9CaWypeOiPnnUiMB+CWRDN46kkTuLLG0SXgOTD3zggCjEgsBoQCH/sK3iW9d35vqf6b1lbSrfATGYs9Fj3kZ1nLDphYnQzK8g2I5g8d76OJkMb62vabuvaWLORDfVBWaiOiIy+dwbxIUdkmLPYt6eHrgrG1cbxhpM9XmSSREuKAxEAp5nAzBRZ7jOWrkVR+BsHCKsmBkNXNQLhj30FT/9Iw7wzWXPBB2p2XSXjhDlmauAd+PxMZlLPttmHJ6acTPEO18NDZ7zHJbJEYz9/w3nHbrsKL+WpfcKX7j9S/cGh0StNUt3iOCYvDP0N9GfoLkTiHXa1607a10O/duPGya44eoidG7H63FEIVCfCLAjmhojxxOKZbJTEL77zwac6KYSAQEBgVSAQCH2FTvO77jhQvndv/3VJFK0DbTEcZ3LOEZv5TTloD6TBQI2JiyMVaZNSSJnQ2Tg+XinHk9RmYaKS9zKZrZZNhTQ0jSEDTJgZdnmCMVkuypLUtsGS7IOyx6EgHkB0FpBDZEZebUJeYylNXjSd80UieHLRgiABgfkhEK5ucwTmt7q3uXGrWb2DVLup1L35xyeirqpPStzAYp8pIDbS4zxEiS8Cn4A8lL5PiMDL9ZTn2ThL9mBHo9Z2vxA37qNL86Ryo48qnZ5iYgM7QIBMBjxOBKOcEannvs0JvR7vBtD72OcN/cyCzkSTsw0pdXsRchyRTZKtcbn0TlhmICEGBAICKxyB8Ie+AicYHpk5NjF0c0e5tM5aY7KsURAWM8NL9/O2GBxY9KFpU5pHLQSX6P/ncixlntDzdpHbRcz39g1tZmP7gE+hFrM+nBTZmYMIttxduSJq0ExZ+yXd5ui4y9wTeOzALsjpVVUbmZniJHrpN+7p720/K4JGAYFnIBBO541AIPR5Q9h+Hbzqc09cPxitf8skVapiE3Imgx9dI+KIvMxvypU+8H6WVJpPCSjhGSF4hvn0uMkmHi0l47olTO0Srnl0vDcqVa+ypdIm4RiqG3JgRALpCXnipiihNzLRinbR/Nl67Nixo16J/UOW8lHysMILiTQFU9C8QBzlmJa0o3pFXrKvaBaGY0AgILCSEZjf6r6SkVmmtmFhN6N1f6PL6htFvPHewRIhZibDhqyxNP8gRRegkII/9EyFmmeNrsROVrdtK3b4i4btcEjqa61hvD/n8qnqNDUvygTBSw7ETiosatruIMY+LiJHmdlBivmdTQtlmYvZIPFrjY1ejLbhb70AJhxWKQKrwuzwR77CpvnNn39y/UNT8Tt9qfsCjhjsnZNEDot7gyQnYj//KTfojciT4OWtx0OCiiBv4dimef3Qu6/o67+NGbxIbRMGam5rjcw2x5F+5ZwMKBucR7phIdC9UNRLjrJaop8eLAra9xDldk+eu8cxDzUzq3+hruDBjUDwmHoylImltFR+zdfv699KIQQEAgIrGoH5r+4rGp7lZZyI8Eg9v7kUxRfEcRyBcomw2BtjSJTAcGAIzSMUft9sH+hTu5pJCKmLIjtYsTKm5e0id98t8X1PHd8EGNY+rRO0hcbNIyGHGhaPmDkAibO2jnsv7J3I6tkj3vtJndxit0TnBXJCfcw94QklSeMrTMS3ojz8vbf1rAblli0CbaJ4+ANvk4lYCDVu++rerh8NTLwus6WNDZuYuskpNw7viokYW+0xM0VY8GkeQTnCgv4s+pm9eQReOvxCypwft2TuL5XTQ/MYYsEvPbRmYE1cqlwZl8obCAYwdhcs6QYCHnlw7mcERK6vnadLcH0XXIkF7lB3QMqleLc4N0bihfXJpBjD4+nEwUykBgWYc29MHFeid9/1wNF1KAkxIBAQWKEI6J/8CjVt9Zk12nDXJpYvxSKfYEUnE0Wk28neCzEInUDC4rHQzwcawcXoB0cQR3FspijPxU1RbAZ6h3tP+d/AZlq1LIkkXm9tvD2xtkzQE/wNndWnRaIF0AzFyIkjcfVans8TJHS4BJEzfhzTeRhD4VUBEzMVolbpXMMgagbRT7tfX6PaVc3zcAwIBASWEQJnrWog9LOGqr0bfnjnvtJ9g/nrkuqa6yPmkjEe3jlRA66bB5kLp0R5gyJ4p/OxhMES6uWrhw7+QFd6NMT458VPnAYd6AAAEABJREFU9lXMyM/fyG31gbijU+4Cb6LLmLBtQUSAhAxpEFLXVhieeqE/O2Tr3ZObnNa2u3T1+KfwsLZLiKdZPBk8aOn8NAmdYKeQBjWGE7vORPa1O/ftK2lZkIBAQGDlIdBc11aeXavOolrOl0823BUNMamSq+6ze+dJhUFfWuZJiO38plyIikcCQZ8E91/JkeHYkuSO2U2+7uLOGpq0TbxjlyQ/6h/faJjXYqOCBMSt4pGqkqwkCCnIEAChLq9fjGZa2eZyWV/fuI3obkzykJDzeEcOxTHTeAWCI7QHvcM2QikZa9KO0mujyfhSVIQYEAgIrEAE5rS6r0AclrVJd4jYJ6bqN/qeTS+cLPdW2SSU5EyGI7IWu+8SUfGl5IQpm6fzrESYsSVB38bHFHmiRGrwDqfqTLX9XaZ+jNoodKQT3VGUXBinlTUOenuIw45FboAJnkYsHkYieLcpHn6ssKG8jZQ/C1Vi577n8ulHhbPMY3tBPOySBFfGJN6SUEZsHNWFWSqdV/koeguIH43QJMSAQEBgRSEQCH0FTOcXvvzE5kf6R69kcRUlKGwkk2MiFkyvCsHvJH/SOc0zYAR4fqxjaN9IvXj9ObrD1qRt9V+mOuN7yPjzDPv0+Yw2xAaOrEVDWPR8rdujvqNDDoHK7wdJTzExnHEpBDkyxkBA6ijSPHZrIpskt9z5UP/m9tA+aBEQCAgsJAJmITtbmL5CL+eKwP6Gu5HLXS9MSKoxeNWzo8xgSYenZiQlQw5LPVxPeOos8bl2f0p71m5ZQOMO5Q79SiHi8jr5+sGyzduK0A9Njq8Tyc9juKuqO5Q+bRTYBUOMkImjJ5E7bav2K9Rt98jy3exlxILKDVTH9BSKMjPmickLTvFg5z2ZJEmudUI3oCTEgEBAYIUhYFaYPavOnI985nDlnoH6TWlS3m4Mga09KTkJFvOCo4ROBMaiTqKlJ4rOOVN0hy6U0jFE83p46+LzDNu/w6biJpuFrT/qq4iHj4xt5MhsOL3ZMKRQs5kys2ExyfG0f1n9XWAzfVeeuSdIfIY8LNLZIezJFLOFc7XPkDF4yjPUS4ZvufvuJ7pREWJAICCwghBYVgvXQuC+0vqYims7TNL74sxU+7yIYQNCL2aVCe5mIeqxNQnNEJOl+QSlCI8OxBAJ3tkyoQTvoE2eT2/rKQ2NbdlSR3VbxI49Q1WxdIFJo/XCSmrPVAvaswHxNcuZ2DCbpBRFsK5ZthyOW6O1+8m5e0nyaZYcfN0kdCmUN8RskGMyJiZnOI6r6Str5fI1FEJAICCwohDQv/QVZdBqMkY/wX1gvPbS2ETwzqMoY5CTMaBYBgy6nDuk2GonTLMyMGrkBH2hak5RiJkhIHTR/j3ezQtZQ5M3X9A7cTuD5efU78JflFrT66NkuzVRBSoT6xCCw8mCU0KNQNDGCEsyYWENLZ+wdStPR0LfxXPVIInHc52HNZgfmCAQxj2BqUcZEMBJlEQ7JOJXHzkiVVSHGBAICKwQBLDSrxBL2sKMpVXiy8f3n3ffcP2FubM9nmJyUUINtuTATATiZsrIQAhuKqFelGtV5qOmMgSu1yEEhM4Yx6CMvRuukB9BVdvERmTW+zjZQSYqg8pAaHSK0CnBEHERktQYnNDyCo5+KN49QOIaAmZXe9UAvA0hFcKdgHfo5Nmwt7ZMqX317mOHLtY2QQICAYGVgcDyW7hWBu7ztuJ2bK8/OlZ/mUlL1xorJXE5lmyLxVunFH44O4yhIsT6T4iU0H1Rjqq5RkY/2hcEOYzn0ZP4iMxgWUxbfSBuz8jUOm/MFpCYdcBARJVWgcqnRCYtZQKSQmnSAkLfKRLpb87THENyydoB3AM/NCRTRE6Kdy0zVs12KThHBQkbG8XxDjH8wrtlnp+SnO08pAGBgEDLEdDVv+VKBAXODoGTW41/o3/NIxP5rZR0XMJRlFh4ZeIZtBWjmb5H90TqjUOMMNZ3Q0rmHu/YaR6BSW8ZBpETsWZJyAte3DId7ShFbUPoSo73D45v5DjZ4LBr4cHYAl31IYROBEbOoBT2ADni4hMIad2Y+X3QAL2eayzv2VOZTh7sONfrZtvfyJxZ1/gBPPSjzOKFhdQ61rnHnOnDjOGihDwZJmu7cd+8yu86vJFCCAgEBFYEAsWSvCIsWWVGjEfZZbGJL7ZxXMqwTjvLIG2IA22xkIcIYXqxoDOpf5qjjMjT/AODKnimG+UIEETuyY5l9Wh6prjlyXDvcCWO442JjTtJcVBFoRVDTo5y4gQ1zJbZJGBznJyoWJJMmbk0PDzds2uXJHMdMCfa1WhkD8CIzGPHBraQEnmzP7UUgkikDzA2SUrJzVnMr9i3T8LPwVIIAYHljwBW/OVvxGqzQLdnHzw6fInztNGztXXQdA4KslioI3jpumarh0YgMoYYELqKMJE854zTWQXGGAZ9srZmjISMJ84x7Dj1jLTNz75mqXRCz02WbPE7MQK9C5X1MCMykzYTgxYGMEma1ZbeQ4+jyA6P1Hpq8eNdTX3O/fiSizYcc46+T+InBU46ZpuYQd5qKOOgUuxHYNLYGrLRZomjdxzJ+ref+2jhioBAQKDdEDDtplDQ5/kR+NvvH9q4e8RdJY56xHvKsUhnWKwLsta1WiLstkfoCIs5MeieCkEBoWmRzOtQPBmgK/HYbi/EiZjpK364LZtXvwt4sffcA1s34w2D8V7JDLc6yO10Q6AWTQlIFS8R0gYXKS1liLM0T0pxeWC8MefvhzOzt+S/lzXyA3g08eIdgbZ1omCKWklkmHEOIUvCNoGffmMufOuBA1JGoxADAgGBZYwAVrllrP0qVV1ELvZJ6SrmqIN0ncaq7SyRBx4OJMtisf0eE88yPMo1gvNJl3LNz1242W9B6kL6D3zpX7SpI7vttuf+xN3cxzv3K4EPP9w/0WvFrAehk0BXKSzn03emxU2xeBCIIyZDSxyMSRtJqRRNTNXW7tq1a87b7qmJH27UGz8wLJnHFg6IvbCEMfkqmLAZJGAwR0as7aM4fuPhqYFLiobhEBAICCxbBJZ84Vq2SLWJ4p/fLel3jzVe4OPSxWKi2GJ5TrBqW+iXg09zZFg/c+5A6KB4xna7hzfmKALJC8FdRct5RCEQOsiAmoExPhPJtWsrqGmWtfp4zz0U7R+YWBcZs85Av8IrhWd6egWhPdpQU9iLiw3XtJCWMpTLtSyCw1yOqptdaV3PXMe+4cLeMTzTfcs5P4TbQuSE0R4WSiFK6kUOmJCxiUmT62qWXnP/kSPhe+lzBT5cFxBoAwRMG+gQVDgHBHYOP9n75Hj9Ss92A9nIKvOwrtoQh5VaIotFOwZxxyBeXbaxJQ5Cx/Yq3E5B7hwGO01THQ/DYAwmNhBmtGKJWTwyLYqnDjt+/mDKEa2xhjsUDaPMBo0B0akNUUYnieDEEUX1WmEULWWYnJx0JolNnCZbKEnWz3VsZswF5XfX6/nj1hqHXXdCGR65sJeiU6SCLRXtX5gJ94XhyKwjNq+eHKYLtTxIQCAgsDwRMMtT7dWrdd2nFxNXLhJTSTPWH5KJii1lK0wWjIQ9YyzSDfKmTs5YysFsxJ4I3jphK74QnM016oftvMmp+Sn6GN2yMy47DGoYmGufC31dWjfdkpYv8mncWbd4oAEuAIWImTwxSSGGDHJGv3Enjjw7cng8ytj2SWyX/FPfF198cU5ipjhJ1w5O1C4+fFgqNMdwXrp5vzTyr7LzUx4+OiIZzD17vDeH7Ugox7uI3Ah5rADCURKVSlc12Nx6+PDhOY87R3XDZQGBgMACIYA/5wXqKXSz6AjofzZy55PDF2TOrCeTWCVrx6AlvCs3WKitEBZuHNiBGxx5JTC2hCoIygv/HOc09yAgQUH/HqnHuBjEYxv/OJ4q2uY76GSTThdHWyQ2pZyFvJqr5iuFAxOghBIDEZR4wCMk2g51nu0a702KyhNxKTLM7Nas7RyXKJLpPD9vLD8252337du5Fov5SpZl+xjPLxDYaWEn7hWGwHQBmavoPSLMhm20zsbJG56aii9fCnvDGAGBgMDCI4A/7YXvNPS4OAjc9+0ja54aru1wXk672AuG9ZBnRnAVqTyzfH7nQuAKgvfnWGTCGG6b76Dn4uFlyjoSSqAkKaGB0eiZIDAx0YyoNZpH29K3dg8l1ILQW0nHicwkiHVzbqK++ahwcefaXY16Y2fk89wyNlLQ2ey9ofeC8UyFCCohsD9N0uQaL/Z1jw4OdlIIAYGAwLJDIBD6Mpoyz24zGXORNQaE9WzF5dlFJ0qwbBfUdaJgnhme6U08HGBjJ2Nr2uY76DmZspDrJRJ9y09NVU9Fh2k2aK4pgiaxjSpPjU+X8KCyRH8bs3oQ9k/sJN5615Io2nJ0tLZ5Pjps3sxTkrmvOJ8fxgOXgLOpwIEJgZF9WkjP2JgoitaxNa+eGHZXUAgBgYDAskNgyRetZYdQmyis2+1f7h+7UcodN3CcVtXbAv/ACQVtwa0ULMrPVFU9aAbfokWzSpCoIJlvxJCkN49InpFvDFvKJufb50JcDxLkb+8/3oGHnm4DFgOZnehW8PRBJ+NxoqaZEdTFkekg5u57iGyzdOmO4zQx5b2fspbWZC6/6NFD43gomfv4Jal/L5+o7TR5zXuGdRDtjXFg3EAnBDgRG/LWJJzwJdPCt+waGOhAsxADAgGBZYSArsnLSN3Vq+qPvj+w7qnhyUsaXvrEmOgEEro66wkjo6L5kwSlpDJbdHJ+tuxcU2YmZhUhxqa78b7GzraFhw4ijo6PTXXHxnQY+Of6xCMiZ21iKTIdkVBffBTb9Wd91cI0vGHTppp4P2rYJNj+vszbbF6/s/7iK7YM51n+2TzPD2CiqBBCAByYPZw2j4oRppGcELO1fVEcvX56TK5FyxADAgGBZYRAIPRlMlmTUWObTzuuobSz23GENRhUClLFGnwWFgjawCWDB9r0UHE6x8i4rnD0BH1CxDUa5OrDeTzdFu/QxwcHU7F2rbVJB+kHAqGvAC1i1Rwnp4mCKliDVkLGsH6hfkutMr7kn3RnZr9pXcewiG+kqb1icLRxxXw+7Y7+JJbazkYt+wyRIxhYSPPDk0QGRjOMZ4J3TlzcHWJsSqm9ui7ypocOjK6hEAICAYFlg0Ag9GUwVbfvlOizD+zflrt8i4nSmLD4EjMRQTRVoTMENNOmJ+QMTc+6SsAGEBYv1rhG2Zba42df81IpYniZlstcGHyWFjHawSQmiTz7tVwzwBllSxyjJB52WT5iI97sSa6eTIfmRaovu+aC4Ua9/mknblRN4cJGOoEMI8fUDKgi5Xc2vM4m9jXHR0dfKCJnWCOa14VjQCAg0B4IhD/W9piHM2pR6uzfPESdN3LcvYHhTRULLyHMrsTInhy1WOXksoXLq78LqoE/V3yr2WVTnNeGp/Oj9YUbYx49seuQyJ4X2SjxAqRmgAAxUfO5x6PzGUG1MhgKiggiQ+rZkawZjYCKX3QAABAASURBVExLPukOlfvJ8x4Sm8Rp+UX7j+aX3y0yr4cLa+LvTU9MfzfinMjXmzh4T+wVHMwnBi3wITzOMHZ/bBJxnF7i4/Q99z01dBlACTEgEBBYBggEQl8Gk1TzdotwvMOQqZCSkDKTrsVn0F2rVc7QZO5V6JgZB+3BO+/zvHHFw1c6PW21iLcpyKkLHGUKQgdeM5oWqmlepTgBgZEK2lARtAYnTJ1Z1pgXiRbdzeFQd2Pj3vunQLdTUWQvFvaX9g4PV+bQ1YlLbr1q/YTL3De9c2MGf/Ei6B12N6eQiZnJoAKWk/dCnojYmK44jV48NpW9dN++fUv++oGIKEhAICBwbgjgz/vcLgitlxaB27Hd/rG9E9e6qOs6Y+Mye08suvQ+Ww9GkQqS54ynv/I5mz+7AmMbdGKJ8Q4WGZdnr72kr3Zbm/zHLA2yVTJJn8feMakQbnHGO2IAIwx9yRORpkhmosAWX4iQtomSdOOXHx7oFCk6mGm1NMkNmzZNb1rT8aRzckwisyFK01syql4w39HLtexTvta4O0VH7DMQtpA66CrCAAf2kwAZCHvFzBoTp1slSd5+zHTfgMtCDAgEBNocAfzltrmGq1y9eN3A2pGaXCjE3QYBJANEBPLsOLMs69L87EotmW2g+fmIYHwVEsKy77vLcXt45yL8tQcPVoWw7Q4VZ03UbIGbZmYLT0mbwDSrmdLErqnVXM83iOwpzZbghJnFMA3mXgaFKY4ivvrwwOhl+/bJvLzkrms2721M17/mvZsGbZPg38k3Cs+eKAgQJkNRFJXjJL56bMq9eOV9jY1CCAisOATMirNohRk0SfGGUlS6JI1LXVlsqRF5wjvellkJwinG9ti2JQhbqqWRaYuvrCkB18h1sUl6PLxy4iZNMTT2IDBfeOhCTB67HChEjgqhmeCRCkVx2stxtGXNUVKHFmVLGx3zoBMeII6Fo3RT7vnSvDQxr19vu5E548z/LUj9AQMcHO4ix54Ukxzz6MWBwokixQzigYvnCFCWzrPl0juPHnEvW1oUwmgBgYDAuSJgzvWC0H5pEcima5td1tgkQoaZyVhMmTIUtSrMDA6FNGeNyYyNG63S5uRxp/eQJW/Kxpji/TeDlIp6wRHY4VhExrEpzSNOmxGnzEwAOvVsN3JptCUfjKu76jiY9pgQ143hKsd2h49lLc0zbLl6076pev2zwjQtp/Ql5DGfWsbMhCx5vNrRMiK2UWwuMym9+f6Dx7dQCGeFQGgUEGgFAmCHVgwbxjwbBP7o7sOVOx48epHkjfUR5VTDy+tpi/fB5tymzWOwkwWn84hCzNwUeL3Qpm48tYWH3tVzLOEo6THWgpCJPPRrGjqjc/PkOY+Al4hJQ0mMPa/WiFI9WWq5cTNP5Z4GXS6TxCaOS/E1+49MXbJLZF4PGBcTNVjcp+qN/F7BpOk94YAS4XYyMFzttyi0YHwSQ04IfjwRW9sdl0svGxquvXTXrvnpQCEEBAICi4aAWbSeQ8fzRmDE5D1eaJMhUa+TxGP5hec0744XoANjmszH2Lw29gRzLkDPc+9C4jjiyFYMsxW4mdDtRGcoI2KmM4ainomJIueo11sTnbH9IlZu6Y2P5Lk/Djs4ic12E/GN1cHJeX0nnfF+fvsV5z8xOVn7KvrFrooUnrgxhhhGk2KGDDPj/BSBDtHFUcm+Q7qHw9fYFnHez67r0CogcHoEzOmLQ2k7INBIK5dRz/pX1rt610/YhKxUqJSXyfpzmzZtfbLMxzYhhk9nyKkHRxFlHFnOfMuI7xRbppLOemwvJGs7Y7idgucMb0BM0Nk0hGxegtveRZ6RRGOUmzqEyOIdcupy1CfUyKuUmS7bKFWu+dN7++f1W+qn6HauJ3ntB3Fj6rvGuWkycVfa1fHjewbHX37kiFTPtauT228jaiTCfyMN/6MIrJ7gaYzx1EggcWdRyY6EPel7dsUFbXC5pcxWKlTpfumR0drb7t9zZD0KQwwIBATaDAFd59tMpaCOIqD/Gcv//tGxTbVGVvw3mlh7tRjrLhdpOx3ydlHGmIiIK0R0hvtaUE3UPBbZ4qDnKkYfAEBupTjtM176doqgz6LJkh58ZsZ9LgPQqaZzH0W0jRO+bsROddM8AjP7Sy/fsLc+Vf8iHPLiVYn2f3KXGPPk0yKvbfDotrFcKb16YDy7AudcVITDikMgGLR8ETjDwrd8jVoJmh/ZM1St5Y2tdZevMTYiXT0dCzxKT/5ZdNQ6i0+3+LdKG7aNmMh0MlGklA3yOqEKypBXbdVv1zMLTJkAKXlm1BmIJy0QvExOI7OeouiKTceoTC0I5Ub3VO6yw3jNMmYx31Cpo1Qq3XzgyNC836VvIqol4j/pG9m9Mdzz5u8aABtEwrOQZ0MCIZWTbEeZjdP0qjhN3vbA/lE4+ydVhmxAICDQcgR0FWu5EkGBZyMQSbbOMp9vmMtKQc9uEUqeiYBzJsF74C4msgS6ppMDMzVxLFhL+f7kWtThFG1wRF7IMCUNl2+bKk1gn15Ll1Z27OC6eD7ovQxjZFGt0zi6gqPohnh8vAtlc44ML/2yS9fvrdemv+i9H2dGV8UIT8Oi46k8XYI2wBQ7GOtK5eh1wyMTt9x9+LDuhmhFkIDAWSIQmi0mAmYxOw99zx2BQyNuY83wJZLEVbz+JcJMecI/uJQMtpl7zwt8pV/g/ubRnbHYlDbcRWyMJwZaEBBVk8i1Y0/EENQRwZkXU+QY/C8Mpx7vj4kbIPSMyDpiG11+dCKa1ztrmkfoW5s+hQeUI2oFQ1MxdmNcTt6494mR7djyNvPomvAeZwps/Ek/PfXDxDe8BU6kY7Al9dBhPXAgBKV1IWYmYoMdIuBUKl9iq+X3cV66Yb56UAgBgYDAgiEwr0VhwbQIHZ2CgL4//+v7D/RlWWMdYxElwmKq4j3WdyUkap+Atb5dlBmv5zHgKrNidZJSIB1iZiLEE+Qu1AwFkTX9UC06UY9aG5m1f/fg/nW4Hh4/CpY4RnHc78U/5b3UdWhVNUnjy6PEXv3YMZrXgwbDS794x9qD9en8C+j/SBMBjNIEAZnnjrg2TkrJDaOjjTfuOjx03nO3DDUBgaVFYLWPFgi9De+AQz8a6Zy2lQszW13nbEJkYvJgIziU8Jo8YZFvI62FPEO5NtDocw8dBVi2ItjBEG4qBDIuMoydjYK0ilQro0JpvC0uiqk4IyoSVDPEJMmWnONL+vv7U2pBcH5inHK/TyQfId1FIOwqmGQDl9JbwfEbYRvPR611RBPV2NyRTdW/aH3eUCy0w0L0MNs5niSa79kJc20JmJCPS31xZ8db+wfrr7j/yJF5PVzMDhPSgEBAYH4IBEKfH36LcrVU62uI7QUsXPYOhIkF1YunyFoycEHB6osy7pw65YIC53TpQl6k5ObIg6VnP5XOp8CEegw3434q22sWJRo1e0KANbOWEhljSt5GF9TLZTwoNMuW8njNhg3T0Hs/SL14j94cW2xaSl5weGD42n6a3wf2GE85my5ac0wk/1wjyx9ubv94DAM0gAMBQYGgAEeUIaNHrRJMO3YLLk7L8VtNo3Q59GzJLgZUCjEgsEQItP8wpv1VXH0aPjVKF7pS9UWlUmevhWcGZiE2hsQLWQHRMLcFKMyFHszFU0bLVeLI2NgwR4AJXGSgEBNImZpq0kwAgMgxGWpq74kYZThRnscZyAuXg7XiOO6ui7l+Okla8kl3Zva9FbPP5a4f2hbcKmQpStNLbSV++8hY/TwQKdM8wlbm6as3rP9Gfar2KeMaI0YywOEVgKJX5Ah7QgVWgARlhshY8hBnbCmuVl40MFZ7zUNPDuK1PKpDDAgEBFqGAP46WzZ2GPg0CNyxS5I7dh1fP1VrrHEeFAMiZ7QrFtPigJP2ilAvb7lGnyDwkAXLMDfvaWhFCKBqHDVqTkXzkJlswZI4bbI4MgzP3gsZdKMPB3FsN/UfzyqoaUnMDB8WR085kWkiJmYm77wtldMXHekfu36+XjohdHXRWIexX6g3su+h88ziAYcLQKgYj5kJDA9B1HvwBHZENrJbSh3lNw+MZTcdPiwtwwmahRgQWNYILITyzcVvIXoKfSwIAsf8aNWZaFsepetyi3emIBYBr1MhBNYSYmptgFdYKKCpJwEHFCt+UdaqA9xDvOb1lthYAWaesKOhSAEsAUGdICQoqKd64wt0n61DM5zp0WoLXI08YhrHF/z1w0fOb9UPzBDVjuV5vid3btxDcYF2HvcC23gbxfZ1Y0drGzAP0BQVc4zMnG/rXfuITE7fYbLGU9Y3sBOUAz0h1BVCOgI//dl3HUpxdmxNhFcAcbX0/iP5qP7gjEKr1UECAgGBJUYg/PEtMeDPN1xepjXWmm1pHJWJmVzxyXYsrMTEzIQDtUMAiRRqGKiGmwiKFactPSjPEc36lkTI0umDoFiFQOLNVHMMGidIkaKYiagU83oxdE3fILXk++g3bNpUY2OeyHN3XHWESmQZiAtFcRq/5MDx0WsOQk0tn4/09dFUNTV3Zo3si+LcRBNFIS9CiM2ugcnTGT1BHQpA7JW4XHrJ8FjjNffsP7YBRSEGBAICLUAAK8NzjBqKW4LAriPj6xou3854P5mBUXLVAkSOrOaIkC+E2iNgWWdhPqFea7WyIGhmoVk6Or02qmyzBfYX0FqJUssIzC1w8q1EBCYjg8IoylOR/AWPjx1tyXYyM/uecroXD1ADxAInXUDo0B4sG8fJDpPGbx4dnu5DPbQ9vb1nU6rj3HDx+qdKhv4qr9d/aMjnGAVkrsdmDzqAnjHeqqsQ0AaZk+OIJE63xB3ldx0bzV4Stt6beIVjQGCpEQiEvtSIn2E8/f75lx4/sibPar0MUiKD6bGGmI2unVhcCTwDrwiL+Rm6WbqqQg8s6Y546QY9/UidREDJnaUeQqRkVBxxQF7BFZghol1AhHBGpFMQJfairz56aC1IExNBSx6cj+CE82EMnKmehbqqHXMUlaJb+g+PXP4Q6Xfa0GIekZmzDevSh7OG/5TP5cDpuxKMLKhSQVJE0Dtww47BZXEpecuhfPjCVmFVqBMOAYFVioBpkd1h2NMgUHvgaAmEsh400gWB50OU6wwxkcUyakzhgRZr+mkub0kRM9xa41XLlox/8qAOzxbM6lefXPrsPJOQgcDjJfAQEfvinIEywdvU1BATnNRCSuXS+S4pbwdpwnWnJQ9rpTJMDgQrNKV6ifdEeNLIhShKogt9Gr0iPTIxr/+0ZdaoLV1dI+XUfrley74qzk8wG1QxpBkVN8VvVrTUQw9PKDFxpVypvGJsNHvZg0+NLog+2n+QgEBA4OwQ0L/Ws2sZWi06Allqu32cbueo1OkwmhQrpZD3WCwpIsNMloVAotS6IERY36EKMTNZsfG+0XpLvqdNJ4XSQ8TGCJ57sGdOQooYK1vjeYMhMtsWGUGtEhCRIa2j4pxIyCHnipRYewB9Yfs9jsvdYkvXrx+ir1pnAAAQAElEQVSklti5fTvXEvZ7fZYP426A+g6aIxHB/RClpbT8+r0jtZv3icz7PT8z+/O2rzsQx/x3Wa3xffZZHSgQERNBhDTgKB4ZB9EU5waCJjaJt6bV9B2Do9MvClvvgCfEgMASImCWcKylG2qZjtSw0Yas1H2NT7p6PFsyEEsWTGPhlcfknceSmkGweLbQRmaBDgTNGDqa9AdPjZSxxcrUwpCmBD/bR2IbMRWfxvZkhCHqVBsqFCYqEoHX6YAtgawNhGAJOB+VORma+S13ErSNcF4httWuRly65RuTgx3UotAV293kGgeJMyjpiKRBkc4Dnl/iqHQNJemHjx0bvwDzAGPnp+Rm5qkN3XyXq03+X6lN7jHeewFOAjQAKSnSjIcfEgeMHJHxeKvuSf83QMccReX0xXEp+eChxsil0Ac3MIUQEAgILAEC8/7jXwIdV80Q9wzUe3NHm63hSBdOAamo0GyKBbxdwBAoglWeXJ7ZPHfRbxAxtUE4OyVU+2fL7LUCUwS2CFKCwBGmclK6+Nt7RjeBoFryN8M225s7/6j3NKX6kJIrbhLNM0i0Wi7dMnis/vJ+WphP42/r6RmrVKpfx/v0v3V5jm6xK4D7jwkB4zIeiAyEoAeKyQgRQxnNQ59qqRy/YqJWf/MPnxja3CrMKISAwCpDoCWL0zLHeFHU37lToq88MdzTqDfWsDGRxyhYN0m/J62C1RIlbRSZSAk9c844n9srPkEoaa1+AiYhOttbGgxEzxToz0xqiejhhAgIPdoCvrpyD83/w2c0h1Db1NtvDT3gvR+hQi/dCDdEyDMzRZb78D79jYNHR+f9vXRCYGZ/0wXdT3VF0SfzzH1NJJ/GjOM29BgRDbClgVFxbsgIk/FMrEIIzESR2VyqlH5iZLr+ij1DQy3b2YA2IQYEVg0CZtVY2uaGHrj8aJr5vNeJK+mSKVgUBTo3Rf10zaGgTSKWbCLV0eA1OlPp4b4nY2pxMEwMFfTlN5KzjArrrJy4RLuhk+ieCX2XnMhN9+0dnvd7appDuJE5K1l+yOdyGIrpPjcRXh3onVFYTWLKFXtz/9D0y54kSmkBAjO7vu09j1cj/lReb/xIfFan4t254oOlQxhDzwoRSpqgYWyBbpTEl9pq6V1jY6Q/ONPy+wNqhRgQWNEIFH+DK9rCZWLc9GilHEXcF8dR2TPjnSRj3YYw1kgG4yBFro2sYWIs2sYkEZm4o9TpF4REFsJARicqSE6JWnbyDa/nzxS9gImJuOkBC2iq+dlElMXx1d9+7NA6bCHjhJY8JOz3YDvkCdwOdcF2txR6qhqgdRBtZMymUin+ifGjo7rNvSA6bmWeXlsy3/O1+id8lu8R8Y51XJC5eOSQGpyrMFRRIZyL4mf0t95LLzs27d78wycH11IIAYGAwKIiYBa199D5WSOQW+nxwtuTKKr4Z10lIHc4ZVouemitCPaeVSMlPY7imKK0x1FXpbVaNUdvEkoz/+yjgidKN4U88wGpsKuwjfBA1bxakEjRmilNy9uzqHzNPUQRipc8dmVrjlljHxNP47ghMD4e+HCUQgRaGk5LyUuODE+/fM8eWrBP5G/rqx5bU00/52uNT5LzB/CuHChRoYLeq744gxKIel9oWUHoeOhgE/WmHaW3Dk/4Vxw5IuG/WQVGIQYEFgsBs1gdh37PDYGv7R/oamSNrYa5JLgUjg+OhEWaEIoS5AWC07nHBbtS13BduNnamOO4yySuvGCdz7EjeK76cYNZ6J6jF8WwKc/RgJTYta7oSJ8QGAdIlJQ25Ta+aQO1htD162sxy2Pi6Bjw96JK4o7QVKAfIW9stLZcKr3jicbBrbADitO8AzPn157XubcURZ9qTGVfdsXP0ILQDePBB6IKYBTW0TAJHnp43dlQwbv2OEkuT0rJe/dPDVwMnSyahhgQCAgsAgJmEfoMXZ4jAneI2LufGllb87LeiTGE7UoWxrLIWDUhiISlE0xD7IlYqKXBFKMzCTOxTVLieI0XarmHDk8RPIdY6PfcB4UPMD53g5maZju1U7ff1dYoIZO88Mv3HeudabLkSUTuYcn8btwLeJ8NDZlIvWLWewYESpAkSV4am+THHji6cD9Xy8z5lm14n56Yv6pPNb4qPh9lvSdVmMhD9Bv8HtrgjMR70ns1YiY2NilVyy8br/O7v79nSL8pwEsOXBgwILAKEGiuzavA0LY28eDBJBe7zpPtEoYDI7reNYWJZ1SXImeK40xRCxLVhqEDY2whQ2SiCITelUlUIZS1KtYvBpMINqOVTZ5HCdF61sOpwszE3JRmDSOZERCmN5ZKaXLlPYeP6/erYTyqlzhG425/I8/uF5FxgskE9dQefYwR3DfFnLBdAwJ91/Hjsg3t0GJhlNTvp8elnh9ktdpfZbXsbpB2jfB0qbes3gqqC83gx4xhoRh2E8hDL47iNeWO8rtGJqZe3t9PLd/NWRhEQi8BgfZCoCWLUntB0HptavWeTheVt5m42ikckS7MjEVQvw7EnnXNJGJPzcDNpMVHZnitWLSFjcWmQheUbrmHTmScEJxFHBhiIJryDFY4JU96BgG+M8VnnXi0jON4bYP4NZ946KEIp0ser7yyb6pk+B7OG0cYjCpqFOZBuV2zpPZZQ1Fir6Q0evcPDo2voQUM127kyc295W83arWP5bXpe41v1FlyIjA3Hh6KkQzujcgYKhYXeOpaqJ67jeILKt3VDz41dezmXSIL9o5f+w8SEAgIUPNvLgDRWgQc++6Mou3WphUp3B3GsgwB6Zgi11yqm1oyEhUkLYgFgRTjMhVaMYM3ubNBtNgfeCpGfa5DDZTivTj46MWnB2cRKtJCUb1Sz54pWn52gi19smB0G5kXfPWgacmntpnZR4l5iFy+FzPQkGJCYFNhI1LMSjPL1SSJ3j0yPPZitNGKszPyLFpdubV7qLciX8mn659wjcZu7/NcCkL35EHg4qEBYmSYlNh1cCEc2cRpmt4ymcv7hvcOb1xovc5C9dAkILCiETAr2rplYlzD0JoG8yVsk7KQJS5I/WnlBVkPD90zz3iYKGhZFMJCXIwuBH2gq6eoSmyqRWGLDrr/bIhBLFQQ+nOpoToLKp8pKDqLCMJiR5XujquYzUuBgzmLixa8yTo/fDhv5D803o16JVJwJWEeWJ/P8RDIM6TOkd2edFR/+gf7R7fRAocbLlg30FuKPpVPZX9usuxRuNt5BD0MMXk8ZDiIx9MV6RZJcdfivoHn7m3cUeqovLU2XXvHdx47Fn5wZoHnJXS3uhEwq9v89rD+rx4d6ciF+5htTFiUGQsfYWF+WjvQD8MFLQqYhHBS5Ft3wPIMPQhLNZZsTyV4ZWnrtCEaJDxnkAGhg+GeSxEGboWgAbIFjJrilM5CGB5n5jOKS8nGBttX/PE999izuGzBm2zfvr0WWb7Xe3cUZqs/TML4U4YwjBIlUozKxsRJmrx6dNr9uIigAQoXKDKzu357z4GOSqyffP+kazj9Ops3rBrgHi0IHXcJUp0Z6EmCsVVPGycbknL5/aPjUy+CXi15dQFVQgwIrDgEFvSPfMWhswQG3bFLkkeONdZ6a3ucsXAvsRhiUSYsjERMGpTb4Rs2F8SZMi1vjTR1KpSBAgJ9PHHymT3DcNJQ0KL4LsKzheHMC2XPr4LaoPL8LU9uYYzHqacG2Sju6H7lA0crm1HQklgy5hEn7glirhM1bREYL7iDCEE1JfXaTdJVqpY/9JWHDl2D4gWNzOxvPL/7qY6U/7o+3bjDZ+4gZsGjnFQIu0qkL2RwszCIXeCtezx0eOhl0spVcVfHT9/1SP95IPWmAQuqXegsILD6EAiE3uo5Xz+YeOPWkuGyJ5C5gJmw+BHyTwtRcUoaWrv28czw8L3geEFZ6CrEdu9ILW7lwszM4jw3wGmZonRmUSNUztzqmbUezr+1hpwwVTqqO4jczc9s8xznC15ciycG6jX/sBBNNe8NwVa3xzhCwAJ5Ao0SsbGUJOnlcRz9zJ2PDnbSAgdmzl9wwdrd1TJ9vFF3f4dX6NgsKYZujgQSZ0BtIFCMcLuA85lMHJc6quXXDtez1xNRBAkxIBAQmCcCZp7Xh8vni0A9TTKyXWRNqWEb1Ihr5Dkn45kMVj+mnCzW6chZ0jXRwesRal0Q7NwKzTjjXCO2jmI2Zeu46w/27JmpaI1+b9nW7bxP8hxeYGYcSYFjTuodUoEeEel29AnRc8hzRkENwKemMOzOM8ZUJWTFps5Gb/wPdz664CRJZxFevGVLLSH3PduoD9o897hdyOnDBmwX2Kp3i0U/AluFJY67un5ijPwH9DcPULygkZnzG7b0Plq1/IeNqak/lWz6gJHcE1s8WBigZ7FvYInxIGRwRngwYnZEiVlTXtv5C994vP/NojfWgmoVOgsIrD4EzOozub0sHs3w3lx8T2RNCpYgMZ6wHiMycUHoujwTGZTMVBQJtSgIxhUszMQMwvRIPNZlm8TGdAzVu2NUtyyu7Sg7aJSRkpqBGiwELSHgccG5SJFnZJ8pKHr+CLuNUWcSVyOfJnzNwGTjvOe/cOFbMHYkShQ/LN7vJ9HvjWEMuMFQi9RK1MNW6IkzQRWxWV/t7vpg98MHb9TThRZmzm7Y1rk7je1fTE/nn/C5x/t9DE7FRCCjuhB0UhGcQxjvatL4Cp+UPvS1B59a8A/uUQgBgVWGgP61rTKT28vchneduXNbLBljsBpbuFoGy56HJwPPCkzU1FdQpkJIqQ0CPKoTWrDl2DB3dI3VkxOFrch4uIXeTRJ51xyeZxJB6klA6MjMOTonFOH5y/scfWSUVLsunxLzBpy0JHLH1BHJ5SErMmVgIp5foIeBNO1GEfLNiFIum+iaOCl/5Ht7j25oli7skZndiy7o2N1h7B/Xp2ofk9rkwchnXh9SHZTzOhwOrPe4N8TekuEorlZLr6mx/enP796dapMgAYGAwNwQMHO7LFy1UAjkDVeq12rdrGuwrsAq2rmeI20mejxZUNGiqFrMDq15VRcpe8krWUlKs3UtSa3kUGQavp9nhlbwA1UPzWm6EOKwB6A2E/qO4rjsLb+4VdvuN2zaNG2JdkGnUeiDx8FZC59tsTWWxTm8+k/eOlHL33IOW++znZ5Vysz5TRd2PlGx7k/r09lfuCzfL+LxKNS8nKEaU/MfQWOGeO87unuqt7lR+4pmq3AMCAQE5oJAIPS5oLZA1wjeG/7Rj57qgSe+nrDSgYxIt9kJjAFHBgljJN00JtLz4gx1qEB5i2KhBLQpUkOCBRmrNXvidRO5tOw3zhUNzn2NfP24OJeJEq9ASeCq2Gr9fMWyJYGxJrLUwFvhuk2oY+3a1xyZzF9JLQiMbXeocR/s3WfFZxbvptVT11sE84F7hotbRc8tMaE9i03WpN0d/7B395FF21nAOO6mC9c9UYlLvz89NvXvaLrxoyjPGywZ4WGLxBjCExcRY/nhhHIXUVrp3F5d2/OrPbqGhAAAEABJREFUX77vwA4KISAQEJgTAviLmtN14aIFQOATD1E0OJl1YZVLQO4gR116qZny7ACagSBqiSYqmm+VMDc1YAJhQGVR8a677n1LPiA2i0NsfcMaHgWWHjJbfCKdUfvE+blmrDGwmMlaS84L5d6TNaZ7ymcvv33nTn25TksdKjE96XK/CzdNjU8ZHGdqMBIoTQJdjTG41cjEcaSfen/fd/YcWX/KJQt4wozt9ws7jlYT+8np6fqf5LnX9/0NJXRMjupBxX3jdVAoySYqV5JXNDj/wM6d0hIsVZMgAYHljIBZzsovd927usc6qFK62Far6wkLmyFDkRisv548fF547qRBHU3RjMqJjJ60QrAkwxMkgcLQlNXLMkx4R9r31/cfaMnPoc6ikJOdjFzjsKFGw5AnBnBSyGwLEMdsdg6ph9cf24jqIuTgnZMxIHZjou51bx0zG2+aQ5fzvuS6bT2jMbu7TF4bNj4TKzn6xBwRgzTVXhUCGjNiYs59VI7Lna8ba9D7F2vrHUoU8UU71o5dfum6/21q9V/x9cbnmepTjhuUkcM/IkBJli2hiNhHae+aNT/ZWHvw3cXF4RAQCAicEwLmnFqHxguKwKSLUmGz1hiTenh8uvQa1iOGmUmQa8aZ85mkWdayIwhj9sEC+jKDPMQlI7W8escdYlulVmfdZZHlCWaTK07MTMzQDdSmcb56OecIc0WNrEE2iihJEsK8cUcp3TbtTEve/zKz+Mzd63O/F/ZlkJnISE8WkCdKisiG4SX3dHZUbuvbc/SFRdkiHrYyT99ycc+dPpffn665L2NSpqACMVYfvd8jayhr5NCAuVIubS13lP7h1+8/dCkK5hvD9QGBVYUA/qRWlb1tZWyW+J68VL06ikudpF6KieCxYBHmGRIi5OFhqqfZVNwjUUHSoijq67Eng0VYvCXx0JENmUrHWiqXtz9x2VNdLVKNJkx3TWr1o3ljetJE0A3Y5YCLoR94D2oJZB4RfTawO1HiiGwOJGpCbCrU4HLsq73vvv3bj1wyj97nfGlpYt3exnTtO8Y1phjTYWAvIaPer756UMlxnhMqFQ+khqzFfXcVJ5Vf+M7ewxfMefCzvJCZ81dc1PMtU8//RWN0/ONRY/J46rCj4B0ZIYpjzBf0ns5J995vsB3pL3/1kYMt3fE5S9NCs4BA2yBg2kaTVaiI85zmuethYjgqIHGswDLrSnITEMbi28zNHHkmbVHCqg/zqaPjHCQSSRR1WlNOT61curNkC15rixt3Ig0Clk1VoSvyUJFU5qPN7PVM+q/ZEzPyTKacxBdP5PnLqAXhxhs5i5i/7Zz0g7wdpNCCmYu0OGh+9hQEqpCgXTWJ7Rsm6/Yn7j58uFK0W8QDM7tXXrL2MVPz/2F8rP5HtXq2Hyp5CKZLCPUg9pjxqJHYxL7JRMnbF1Gd+XcdeggItBkCgdBbOCFjbKoNic8jjiNhU7xTdEixtNEsrzfVE5yra+VJ4B0T47xZ0bojvF/S3XXBrgIZipJKF6WdV2WGW/b75jcQ5YbyIZc1jjEYC6ABLxyVMWj+ATNAHn0leE+d+Jw8JZiz5lfvI3Klibj6U//irscum/9I596DsPmur2X3UF5viOA+wfwI5gXWgygJujYfFS0xqRikToi9MWvTrvIvHh2R94ngIlrcANKWV1+94Yl1k32310fGPphPjf4du6lJpkxyPIdlHs9iDC89Lm2OS+Wf++ZDA9dTCAGBgMBZIWDOqlVotOAI3C5i/u3OQ1WpNcqChfWZAzDJSUWC5bd5KiiXZrZ1RyiseqgCmqo+4Dmb53lf7vNuLW+FKFm89uqtdS/6uTUpMDOmeYuDrBZIJSn6gb1FetLBVNPShQ1nFv2d9EljnsjeclnfuGf5GmyfKKYHNTyjJBdIUOEFo5iYmRQXFWY2UWS2VCrJh76x5+jNwIlpCYLuKrz2us131scbvzYyMvEH0PuwYXYeW/A4EJSI4ii62kf27Uul0xKYfS5DhLYBgXNGoLnanfNl4YL5InDFQxQ5H3eI6Sh5isljCXPM5CyT159/BXFTIYQaavpaLKgTlDZJhVoZRG+dGBpY8nDsnInYRemmaW/XobBlscyuZiQfZfHQQXVkpBpxDqbT3NwFfQB9FkMqhFlT0bxwzD4qrxsypdv++bcfaMn38XPvvwk+fMIQOdxKhZm4ZYr7hzFHjJyDzp5hBzuQusBbNxRxGpeS6rU52V+4c++xJf0e+K3Xb3qynozfPnn82Ed4YvxbZZc3yrijrPfAWEqlavltX3vowKL8XC2FEBBYYQjgb3+FWbRMzOmrkmGikjGRIfAzY7Fl5qb2M2lxVtSheN5khD4WITLzjOfHWICp8j/uO1RpqUeVR3UmOwa4EEmhpQULrD3pA9Wp/QrmToXh7HaVkhewT1/cCgzianYkz/lujF2HpiJeiHR+gAITF0qjsJgvteJEHg8/1prOrkr6hlrdffD7S/xhtDft2FG/9eotX5war//zian6n+S5P+C9z7yIYfYXRxH/xN13P9GynR9aiSHYtCIRCITeomkd6zgWM9s1VVuuikTE8JUExxyLrydSciw+/asTxF6oWI1Rh0xLoxJBUwEQBPRlUg2JPBvipNxBNu79gxb+r2sxxdPM9jggy0kDaJ0Bn36SWjXWormLI4JnmxlLjiLMWI0M1/DiPqacS5idiBPLa445/4HfvvPBHlri8JKtW6clz7/lnBuAMuBrIVZvnDy0ZehLJABDUOaR4qy4z1BNpLVRaW3aWXn/sLPvXYoPyWHQE5Gh6Kuv2/qD6mj+/0yOjv+T+nT9Sxn7CWcljlPz8omSfYGI8IkLQiYgEBB4FgLmWSWhYEkQmMzS1LnGGkO++amqYlTBGjsjxTlOZ9JmDusZqnE8UbrUmVPHZhAGFypALYospxHTmtSsLRWFLTgI5zUic8wT10EApA8gqhuR7iTQAoRmbzofs/TCgjJEffdrTBR3VErXTkn5mgUY7Jy7iG1+b5a5B1h8LvC8acZuxYEQQJx0QgiYoIyYsckt5L2YOIrOK1fS99Smo1eKyEn3pjZcfLnxxs1Tr7x809/X65MfddO1/5XVGw8YJvJZ/sLvPvxwS15lLL7VK26EYFCLEAiE3iLgM8orU35qc2YnDYEFMzh/ERiiA4tw5LGAcQovMAYhMcFLKYRRH3l489K6aWMQVyRCoADSd/0O+jK8Ow8P3Zs8yjnfPtFwG6hFoSKdU4aTo97H06AocuxIQAjMETRCBse5RrWZSYg4J2cd+o4KSX1Oqc9Qbii3VetsxwVHvbzv9p27OmiJw0t3bHiCp6f+xuSjIxE3RHReCI+N0FsweQUCuL+MhyVaZ3F/YcfBmxjzGZNwkqSlynXeJL/4vaeOvxykrsAtqRXMLK+56oKHX3nhun+ajI59qD409THK3ETW4PC99CWdiTDYckOgdcyw3JBaYH1rua6geWfRLTMZ/TS2UPF+EweaDSiazbZPOqOU0Oy/GdXAnNjuXZvnWct+XKa+hTJ2POq9rzEzIc4ot0AJbEeE5Zgr7RIniMgx6Y/t5FlG1thSJS3dTEnpJmpByMV9q9HwDxg2Dgg0NVAlMT+F4s2S5rEohy2iGRQxERuulpLoRS7jd3/34PDlIHVLLQjM7F589bbHSg36uPXuK6mJp1ugRhiy3RAI+jwnAoHQnxOaRa5weexd3o2ltIhYvIq1Fotnkerouv4SFtiZpVaL2kAYKuG2UeXg8Xm8nFZRamex5DLZuH+ytqZVit7KnHdVeEh8NmyhWwEuCSm+KvPRi8UQq7fLBG+WqICAiODsFhKhlpyQRcDe9YVHpmo/3govPRrcdDir5V+1JNMMhaAutOYZMUVKM4FxRiREmMumzHjuhtdE5egt9Vr+vh8+MdSy3xbAnMmLXrRj7BUvumL3i67dcZBCCAgEBJ4TAfOcNaFiURHYOzppfZ7jHaUut1hQdbQZLwmLGM60TAVZJYrZrJ62hahCKkoHSNUM6OlyKX/i/kPdf3S3xK1S85Zt3dNeaASaKddCK1q4AFMJPWqiHEgI+jCj4jFoMXdsQOpxqVyyL3QxX48mSxpvvZVzvAn5Ot6lPwEMsNOu2s6ooFl9EinSmbJTErVEK5mYTV+Sxm8dzepvuG/f8JJ/yO8UtcJJQGBpEFjWowRCb8H0wQvn//X9wymWzBLh/TPOCy2E4B3BY2JmnAvEQ6TpOKGcdCFGSftELP7s8d5YKMedxBJRnHavzdOO7bY81nyd0AJl8aQ0wnm+n1xeN2A2RXMh1GDMgYFgRoiQzhK67lB4nLDODySHJ++iNJZKx+WH6/6d/+HOR5cci5418lBWb3yTXdaIinc4mCDcX1wI4WgKIQSGFBEPlF4F958zlryJrYmTHaVq5acHpqfecPcS/DxsoUc4BAQCAnNCwMzpqnDRvBD4BJExLCBzEzOW1VlCxzpKzFrCcKyaQwhJM9NOR6gEDaFZUzucIq8KMkVREnuOL6gTtWzbPXLRuCU56LyvzQI5i7FqOR9RW9V2NbhItTMtRMoGD2TIe5C6CrMtV0rpS6YdvRDjL+nf2o2bN081svwLPneHDJSFWjg20ZjNQ+XnjMxMbAzEJklsrymV0/dJlrzksEjlOS8KFQGBgMCZEVjkWrPI/YfuT4fAQ2Rzm3RQFFcIi7/SomevWbRmCFHziKUX74GxZ0rtEtQLNWRm9CO8OxbyhkhQJmIpics9PirdVLN+K7Uo5PHYiHWNJ3yeT1DhoQuBUOetDWYDdhIZT2RxwugRpsNyKsShVuDZOo4o9wmJrcRR0rHjaM4/9jv3PL7kDzidUfTdfLr2LSMuE8YcQaByMyKvZc0THD2MQsKMCsyuwCIHEY5JTFpJ09LLJh3/3MGDIy/cJUv/dTaoFmJAICDwPAjoevQ8TUL1QiOwpRv77GQ6OYoT7HCie11EkehCCqJoliGDIlARjqhvnmJVxmkr40mqwB+FJk0NkYH2TEoCeI++4eHByXUg0ZbcX6MbNtTWVaKjLm+MMnBr4qkazk/QFSgbfQAD7Re5mdiscYKHMvXSQYpaYikCJcZVsPqLJuvJS4GHnblgSZIX7Vg7Vqtnf5dn7iBBc4yvRwiRbq3PKqHlmmccZkUbqY1qB8EKZtuTxvGtk9P5e8b3H7tqt0hKIQQEAgLthAD+UttKndWhzGRjOBGbrLVxqcPrigkCeNpyRlYwMULMIAhdVVFCKCG8my3S4rw1B8Gws56dEjrjXCOrfnhOyeGdSlJee8eeoa3//aHBlmzP3sbsLt/UcYQajcOWgCERCTBW3ZGdcxSCxazPKEzYOMEZIRSlRepA186iDbaqCZ66zWOy6qVXu6/A/v+7/+P392xCwyWNa8rlb05PTX5TxDkCFh7qOxY8eAl5TB4zE3NTVDG1q7kDgTJhItxzejeygS1x2pdUSj8+mfmfHnhyUL/OFuk1QQICAYH2QAB/3u2hyFjb274AABAASURBVGrSgtMo8jbqNWxTZkPMIAGSYltY6YGJAQfOZ46CFNVFqWZbLYU+UIKRUU1VN5wWicAWY0ziyZ7vUtuyT0bH1oyDnAagl4NKSMBN83TVBcYKekK/p84F+mXI7IwpEAU22hgXibXltJxeP+bo1t27l9azvfGiNaP1nD4l3h0n7CAQeejOxMywhFTVE6I6FydFzcwBNjTL0Z4N2ThaX66kb5/KsvfddeDoZfDu45mWIQkIBARajIBZzPFD36dHYFqiknC80ZqkRFgklQiwbpKwEjsEafNKlOpqqmspPCUmbha3+qhqQPTmMcJk8I+gm3p8DuW66udElw1lfj21KJQsDwPaJ533NdVzIdTAbGCO6CTvvNmr9s/I6mcddC6RLdoYzBlJRFlkjcTx1uE8e/Nnxp5Y8s8WrK+m384atXuZHNQDoUNZZhygaGETUo1a8kyZtc1gfgX2eLZMUbwlLpfeNzHlPvT9p4Z2gNStXh8kIBAQaC0CprXDr87Rk7iRENu1lu0p3g2zLqfA5MQqO5vRFOVtEFUTDz3gkBLjxKigQPMC9T0quFj8efOPBkY33CHSksW+4ccnvPMHc+cnwWLQeAEiax9CHsbCbD0pBOaTnhsvIHIhqxhAdGtb26I5RWxLSVK6Zngqf/nOfVIqLlyiw/Xbe0fq043PwUMfNt5h3lRbiEboOauGwIqTpVmORsj4mTrC3BJbipN0c7mj+q6R6cZ7vntwcHsgdQohINByBJYxobccuzkr4J1JyJg+a5GiFyyGRMyITEXAIqs5leK8nQ5QSolbVbJY660nirwBkaECUQnBoJKjZP2X945tSx871pL36G/ZtKm2ubcy4L2MEvCESk/jqydzEhgMdtadCORO9ADHlQABxSD0GE5whFS34B2AUEJXgjfYdzdx5fwhb9503+Cei05cvEQZV2982WX5vVaU0PMZUseEzYyvOdED7EMlkeZB4gTx5PHO3VOzHkaRRX2Cx9HS+ZVK5X0TY/ltd+0b2YL7WCsphIBAQKA1CIQ/wBbgnhmO4Dl2ijCCTgFWT5mlCOQLnYS0RKU4Lc6auVYfVadCS2RYuFj/Vb1CYyZCpDiyJYnSy6bSqCX/oQaA9Zf0dR7PhQbAr3jsoHkHLuxtdoOsmlycaF4z+n3vQjCXikGO7Qv90RkLBYziZJJyKa2+4HiDXrtzYGBJ/+OWS6rn7W80MnjpNKIPG6ofFUFzeM1T5JsHtUfncvYVQpFHFUzAsxHOtIHOMluOk/SCcrXy3omp6Xd8f8/QZpC6dojWIQYEAgJLjYCyyVKPuSzGW0wlv7JnKnLiqlgXmclgaWyugeABIj0zOJ9hj2IRPUEdKEe9tqEWBehMhQpE0LwpDCW1XODJMQsIXii1EewzV9e860PTlsSUsiFsuz/lSBoETGWeWhh0oKLdqEeuKYqK2dG50/8lT71x+K+kxJ5bIYcLYlRaYEScGLHpxvHcv/qhp6Yu0euXSnbs4Hqeua/mDfcjA30wTcXQDE1ZJ5TVF6cT4QSZo5xwlzLw00oQtiYg9qKChKMoKpUurXZUPjham3zr9/cNrEcbrSzahUNAICCwdAiYpRsqjKQI6GJ3x77RknNc9Vgkm/+9p65/KqRrJ8nMPwIJsLfYzjaktUKePIOeSGmEWhJUDx3es6fc5NBHdWHop14eqAz7zx4NPNsI5HXBF/ZP9MFm0wplS3kyaPLawz6fxrY7OB1KsEBXqMyaPyEC/SEF0c2mqBRIswYW6RU4R1nh4aItsihAOWwmEKNjQw7k54CN4mPgmTMa5UW5JUGdN1Fqyr3XHs7sW796dGJJ/5vZtT1+73S9/vd4yDkORobGHg9f+YwgT0K+KNXHkaao/jp5LFwwPo5Nm2GLICcsJMbEcRpfUemofnh8sv6O+w4c24Q5bzZFmxADAgGBpUFA/1aXZqQwSoHAJ4gMi6kwRanHotgkdAJtYMHXFRKLqi62WGVRxiDziBikzjgTEIXol4S5aEitCoyBBTrk1pESF0M3Ir2VYAPynomcsWTj0vqvH6xv+Wx//5J+CAzqFbFnqDrE4h6mvDbIkgFLgZYMDekZIjhvSpPGCO0IgQspajBXOEE7mhEhDc2jRdaCzC3wYAgeaYCPBenDQaectc6Qx5Vi4KXHnZvGpPTGb+05euPdsnT/ic0NmzZNN+ruC7WG+wExe4N7zbKDrSqFduShq6iQ2mRQRwRTIAJBnhj/6EQQ4KJXemvTpJxeV+ns+Nnhsdo7vtMkdXOiYcgEBAICi45A+INbdIhPHeBCIuNd8dOZfGrN8jvThV619nooRHAUYnikBIkMl1F3yUAet+T76DfeyNlFvaUj8CEHmBn0VTiZRQq9aFYEWp8c9Vyl2VpbNc9ObnOuee1BpDnlMeVw0/2O43X/jrsfOnTFufY11/bMLJd1bd5fr2d/S94dVUQEigkxsGDgovqpvbMC5DCYzAiSZ0dUol/0gKWEbZKk8VV4p/4zjdHJ99+9++g2eOr22ReFkoBAQGAxEMBf4WJ0G/p8LgQG9oDQDaXCcIOeq9E8y5f8cm5SX5MScEIQZmI21uWNC7O6aQmhKw5bu5Pj8JL7mcBZWgABB+H4PBEXkMrzNDv7anSGKdeHIEs5xYZ6ojR51f6xxmu/8sRQ99n3M7+W27ZR3XH+1UYju5NEGh5gMB6+CPMlqiK6R0JN0cpTCnDSjM16RjsVKh4GhAwRmyRJ4qsq1fLPjmfZB76/d/BCkHpEIQQEAgKLjgD+Ahd9jDDASQiUI4KfRGnEFJ1UvOyySkwMBvDE2GomEsbiD3ePsah7vFP2HvTORDUn2z712GDLvo9eLqXH2fm9PncT0BKs7gkqE7Q9IR4FKoJUhZ4VBCUeMvcIKNC7Xg+vF1g5GxmTdm4ccclbvnl4/GVLtfXOuPu2XrbxcK3e+L9Znj2hmAgbYDGrIewUj+11D2UFeBFEU7xGQCsUNqNCMitoKsgXgocWsvpBufJFlc7qT03kjZ//4ZOHrgKpx80LwzEgEBBYLAQCoS8Wss/R70RKBjyYMIP5aDmGp3VmpSgmgj0oFD2DgMiV0JHzRZ3p/e7h8S300GAZjZY8Tg91jnmf78syNwxNCWqREAJ003xToDMmhE4WNJmNs01nz+eVojN9+PHWkrdpKU6rVw015PUPPHh0yX5B7irmxqae0l1TU40vMfOkEjEVtyMTkChkluKFUcKwWKWJHOrpFAFZw9knIjwYkM69MHm2Fr76BdVK5f0Tdf8P7nyi/5qlemihEAICqxSBQOhLPPGJIfhIEhshs8RDL9BwSoeedH1nzaJX9d+UpIh8ccZY2BmemmBxTyvVPp9Ubql1JC35+tptV3Hjyr6u/ZTnT5E419RR9Wx6nGrCrBQPILDg2bHZnmYI7dn1Z1Oio2B4AJdxQp4jPNl5iiLbbavV1+6dorfu3De8ZK8mrlpfHcqc/7vcy0MntIeKDO/c0NP2CkHhQk60ejojBE+eCzFFGyaHNFfBPeCMZU5LG9OuznfmbD9a2zvw1p27Bpb0+/cUQkBgFSFgVpGtbWGqErohibHeLV/suQklY+EuOI71HKs7EvFCDOOIsbgjHydp1Tl+wf+87+hZETq6WPB4Xkd8FA8fTwpJnVRXldlRND8jMlv2jHSmurj0GVXndCogSx0D3it5YTLACJ1GNokvBLu+4atPHb9CBBW0+IGZs4vOSx+anKx/1YuMNEcU0pty1t5mGWOKtaR5dvKRobyKwXxrSjgXRnuDOxxlHudK7iaK15UrpTd5a35l2tffvpQPLhRCQGAVIaB/v6vI3NabOm2HjJB+JgoubOvVmacGTFiziWaWfJxRsaAj47wnwqKem4SicufFDx6fuvwzhw9XqAWhYuMjUq/vco3GsP6oCuiGDHTEVgm2il2hEYgUZsgJ3xTaF+ULdRAS8haCcY238M615xwHgS4cx2ly3XEfveP/7B7djsIliZd0do64Rv7prN6424r4CDqSBx6YO4aejMlFMXQR1ICocY4T4ETwygkBd3KBGLKo07OmAGHc3h7z7zWlhMSUq1HacWNHd9ev1eq1n7vrsWPnyRI9vKh2QQICqwEBsxqMbCcbYwaNsEQglGWOPQNWlWZyYrlHETw+EICWM+VY4dnGXbnji6a5s4rSJY+vPq9zZNu6zj3e5UO6pSzqKUOoqWWhD6aFwEmFQGVajCDAphgDGQNRVsTdQDp2HEd9IPVbHxgYvXHXruJrjYuhwil9Ytx882b7WFarfcHl+SCebgCJWg8CFxVtPpvOKq9lRKeeEYKWaIKUIWiBRxUikLoUpG5JOCrFaXp1R2f1H06Q+5lv7BkKpE4hBAQWDoFlTioLB8RS9TTBzMazZaZliX1zuce6TwzfzICTDBk4deybi7gmufFEeGKxZIm8ISfWNNi84Pe+s69Vv+vuzu9O9hqhPSD03MIDNUroIC2GHaRGkQaDA58kyC5Q1CFkZixLGXK+wK45tkPC1qaVy8YkfvcPy2PXLtCwz9vNdT09Y9yof6E+Pfl147KGwbwRSFhfCfgzXK11cqJecyjRZFZQx8gzigk3hQiTMCNrIxOXLih1Vf9BZuhffWPP0ZtFRIHHFSEGBAIC80Eg/CHNB705XosFLALwiHPsoG0uUxOYmscmEWINJ/24GYMYmA0xxNiYvPfnPXJ0bNNOkYhaECIXHQad7MHuQc2qbsT4R4UQqdazeSYqSjWlcwpnbqz9qRDwEio8c2L8a16FEjI2qiRReuMjh8de9a3+8SX5zAEz+yvXbtrv6o2/y73fC3+ciJmIIEiZWXN0SmCcqSB5Zjy5mHGlShNeRlMmYd2Ox2NDZDeVy/F72Nhf/8ajR16+c2dr7gsoFWJAYMUgYFaMJcvEkPKEgaMoMThlWWOvBKSOlXph6u1qWnhhsM6zIxAnUc5kyVBMREm56/xGtfu1g4OT63C65PH8kY5h50W/jz4SiZC+LzbqqZOAz1XOpBLISCAgqDO1OlOdXm3hrWqaw211aOyBjkreJDl47Ew2TTaNx6UPfubJkbffOTjYSUsQNm2i6W0bu++anpz+tM/9uM6rEq/qajA+OB3HZhQkKgBtJqdnpwoDUwbGs2LwiGcoB3oCIWJmYtwVbOPuqFJ9talW/v1k3+GPfGt3/5I8xFAIAYEVioD+va5Q09rTrClmcJ+PmcB07aniWWpVLNtFWy6OemAs1ETgJ9KAnQgCs4OohNI46cy8uTHPa0v21SzVYVb0Z2Cv3thxoOHcIed8pnqpCEidQED6/hgcNNv8GSnjXAXJPKL2oKh5zRT94IxxAtGxCyGK49hcMpa5N3/2wdFLgCEaaOPFE8YtWV9THmjk/ov1TB7yHn66ABUoVOCDPOnMqiYqNBM0/0xB1TOLYKVejZqnI8YkYUtsbCVN4ht6uysfrTn6p1/b/dRFT7cKuYBAQOBcEDDn0ji0nT8CJcvq0CbMs7Qo91c3AAAQAElEQVQ3/z5b0YM6rMIMsubiE9u2WPSJPB5Xiv9AhogMMUXekfU5SZxGPu667j98+9gmkJRB9ZLHPkP72ftHc5dPk+oFDQwx/hExI4XQKYFxpoJknlG91ea7eyKBZ54bQw1L5JG3eYreY8oNQfDCIuI47Sy/fMRGH/70E2NLQnD6YzOX9HU+XKtnn83EH/HQiGC6etesnzfQ82eI4Fzbgf6LHMOapoheWtwXRgh5T4xdG4t+LHA3zpNxQow7hDiiOlx1KZW2VHo7P8JR+fe//uiht999t+jGDoUQEAgInD0CWELOvnFoOX8EakyMxS1iIkRa5qFpQvOopjAcXRCSbwoMJYaXh0JivLhOy+naQ+PTF3356NGW/GocZVE/9NmH1wE11daAVA0zJgKCVMtOFcapCpIFiEVPgo4wlj4MCQoEeQaxqRDyhDITGYqs6cHpy76+f+D6nftk0f+3OkLYvr56PGs0vjg13fg+1KwzMzEz4UDNgDypNM+ePqI1TrTmZEFR0frpMrSbuR+Ke0Jr0b+JIsq8N5iXns5K6VXlUvpvjycHfyp8X10RDBIQOHsEzNk3DS0XAgFrTQSftTPniAQrHSgQy7m+Uc2xvOkZCpErKrUBvB7Rd64QQkvjLEiSF0KVOfXB0Ml4C+9Ldcgot55qlqgOF92rF4a6BB6nYUOZ8TQdW5qMY6qLgfaxmWjIa475tCXv0X/8ss7hF643P3BZ/qQwHECQCQsePhxwh96RJ4rhPbJiXojOSU4GJKSeJoGP5gRacZHiZTGzlizGs57JQAghN47EeuBD2M1gihpMcZ6YrrTzikbU8Q8/tW//q3bu27fopM7M+QvWbXqEGlN/LLXxu8lPUwa9dNfF4CGNgU8TA0ZiIAztNRocZvME5JoCMylHsWNDjizEkEdegIIwKoAroV+TCyX4ZymljEqplLqurqzt+42GRP/1i48ee/vO8IE5CiEgcDYI6F/i2bQLbRYIgbzORli/Z4wF7aQ+nz7THGPJ46drNasidGo5LX1QNXhGC12TVQNhHGeEi7rmEVnSOikactEIfNn3G194vOd2AcOjZCkjM/uytbvJRLtzEbxOB5mLkLEWakA/5HFEHlEzKshqPCmrp3MU7YUBC5MCw80cIYHDisnF+PogZFCgdVEUxZUkvq7GyXtN1L2DliBs3sxTl67tvAde+mdByAehCqkwkSaFUBGeWaLnRcWpB1by1zoI8jQraIUSelqYmI2WIoM9ChttqFZKP16qdPyb+trDH7zroQNrUBliQCAgcAYE9C/oDNWhaqERgPPFhn1Lvrq10LbMpb9Kd9fVx0388pcODy/JJ7ifqWP3pO+nxvQuyetDHi6nx06JgW+sHqgD2WQQUGtxWeSF9L0v0Swp0TyDx/UqSE4Tm+MyeYznUC/GUhxHPZUkeuPf75v4sa8endiA4kWP2Hof2Lyu8qnp8amvWdeoR5IXDxyCBw6VkxVQnT0KVDSP7IJETAP+TrgcJ/bazr6u/1irlP7wyw/3vym8W18QeEMnKxSBQOhLPLGWibHLaJd42LYZrhxH3dNTjSvHxtKW/Azs66/dOHnFlq49zHzMgjAZ4jEhKgVIzEXSPAioVXNapqL5xRLGWEwnEybeKROD1qqldI1ruFd+9kcHr1yKX5FjZtngOg/mjfwL9Xq+p9CJn7YbvP60nieVP91iwXJQhay1Zm1npfy2zq7yb413Dn7k+4+MnfIDRQs2WugoILDMEQiEvuQTWNPFcPnirgs4PFs8llBThM4c1NTiomKbuRZV4npnx+v/0Vd2XbxTWvNjIhVn78mnx7+VZfmIE9XNkTWePFTNGaTKQgbv1o2aBhFi8ihHcmZTz7JWdwaEfdFacJwVjwE8QQnsGni2lAnhnbJAiKu9va+Ucse//F9HH78OBKtK48rFixs38uRla7u/kY1O/gXVs0OGhPCyiIo5R54QZFagjUD8jBDwI7VP05m2aDqnqGPUOeGaTVNKq1dXenp+s1by//MrD/a/+f4jR1ryU8JzMiRcFBBYAgTMEowRhjgJAUvMZHTpo1UUsNJTU+B1cjWJ1o3n+fVjx4615NPupbz70HTd3zPdcIMgRzJGZ0X1w5RgenA8TZypP03NQhSpHur5al/ASB/6iJmhm1IpEcpMOYquds6+5SsHpjbREoQLN3QcFW//fqKWf1mIJwgQMA4qzeGlmSzqkclaS94LZ3lunHfd5TR6c1d3+beHRsw/+v6jR7YDO6ZFC6HjgMDyQSAQ+hLPlcNSbdQLW+Jx22E49YAzjsmX13ZMJ5V3//Tf7m7Jf85x21XceOmmnvsTL3ut93h1nsMDhyijqqsJsNS51Mcu1VnZYtZbR9XcIjrRrlWe7sAjq4JEY9GGKUc+Z0MOROZMhDSmKcJ5pbNPOrt+/u8e7//A5/uX5qdhX3f1pj3G019mjdp9seQe2hAX3rfq/XyErvVn0w4GnyFyxhRTBGJPgI3lGsdJXqpeFfd0/tupUunjX37s6D+++4mh80HsYT07A46hauUjEP4AWjHHPM99yFboPI8xdVlX0S6w6JJ4Tyy+r2GjHXv2UKLlSy0Vm+xjw49CkykPfVQKHaAoz7Ausk9PlJJ90WDuh+YPsGivz+xDQJIE4UKMtSAvA6/UE7xScs5RFIFKvaNqGq83cfSOz95/6Iad+xb/++nMnO9YW360Pl37Ypb7/aQTSEsbdEjnPAYVSpKI4jgm8UJMVK6U4hf1dFb+7RT539n58OG33n14bB3aWzReFjEoGRBYSATMQnYW+jobBErwtc6m3fJog0W1sEdvpJNFywsLNDMrghIQY4RX553dm3ZMxV3/5IE10y35/e7bruweurqDvy/10QNsGsIRkQVFWKhokBLDI54Rhs72aWpHi7lE0DlDntEPoyt9vmsKTjRiPPAVkbHEUUykYtAC19dNQqZz3c1U6vjVv3v0oavvELF6yWLK+X3Vw5t60ztqE+Ofk7w+EklDYuhimBWpQhZrfEbHEXYEIoMMRsqdkPPAEdg4m1DDpuzj8pq02vnj5e6u/zY1Vf/dnY8cef0D+0d6QezFVXplkIDAakAg3PAtmWVdploycBsMysRs4Hk6smK2/+KnHt+8FKR0OsMjy3s8yW54wdNSeIBoBTItOFcfPvQU0owzBc2TeR61LwjiibGKfHFA37MpsjNRdxDYwGsXT8xMXWl8DZn0HZv6h5fktcVAX9eT8Ir/plbPvocZzEhxgm4gTWShL+IJW1C+kBH0PdPdzCCaaImmKsgzs41sdF6lnN7W1VH6rdF6/gs7Hxq4evfx413QcdEfeqBCG8ag0mpDIBD6apvxFtoruNuMhacJD8txiZJ07YXYKn1rY2io2gq1Nrv8YduY/hY1GsfgoOMBw8NLB2ESQx2QJ9x2DyF2VAgJzTto1/BugUIxSnGKTpsp+i+IEinKTo4e1ziINYZiT+SS8oaoZ80/uOOR0fd+o3980b/GdSu23q/o3Xi3abi/kFr9odjnrvidfuhroG5Tf0wwQXBOCM0yKuykOQYlc7Xdw0vXLgCBjkAWGCSQ2DOxN3iosOQ5JmfLaR5Xro06O/6F7a7++aEh+rWdjw9cdffhwxUQO5TTXoIEBFYmAuEGX5nzuohW6Wr9TDnDcM9oaoylRg7vHO+Eozii8amJ6//ppx9fg8WWz9DLolTpd9K395UfNsRHsX0MelD6oIK2Ve1i0JlMs6YomdNBu3mmPD3SbM1M18UpDiBLMBWaCRnsagAjgpdMxhoiJXZre0jkzZ+6v/+mpfgKl36VbeP6rm/Xs/zTee4PiXjQKRG8Y3pWgPqnAvmsFudeoH0WV2lGpTgpDjo/KnrCwMYYUy2l8XWlzvSXktT89sS4ef8Dh8d3DIp0iuijpbYMMh8EwrXthwBWhvZTaqVrhAXw1NVo2Rms6p8sZzKAUam3WVMEPnDG8KasgTclFHWtefG0iV/zDaIUDZc8ruH4fnLubp/l455zeHkCMRBLxluKIJ4deZMTMS1c0L7U3QTrmRNCQKcpjJEY5U8LWkEXl+fEuM7ZhMZNSqU1619mqh3/4k/vH7thKX50ZsfaysHejtId09OTX2SXjxjxBTsa6Pt01LOTRa15uvZccnplIbjdihQXz/aM7IkoqEckhxJHTI6NfiKechP3mHLnG0o9Xb895tx/fXD34E89dGTisiMi1UDsACvEFYWA/m2sKIOCMe2JgC62Kh7qWRuRx79cMuquVnoadXpl/+PjHaha8phevm6AyTzQyP0xIbATWEP1VAFvkgqBWFFH8w3ap8pp+9GKgpWKDChJ06dbQjNSL91YS5lXFAnnTMRMSRRf6Wz0/j898ui2pSCpdGPHE3jG+dssc/dA5bq+3wdEM1jRggedA1iq01CIItMUnRXBnSQkaKRlzEXLQhcUIW2eo8GaUpq+plop/frxyenffOSxo+955OjEFYfHRD8Vnyy40qHDeSIQLp8LAmYuF4VrAgLnioAutvptsJwMOROTsw1InVxcNpWo79Zf/fpjFy4FGT1T79uY3WW9yX1C/LgjbngDb7wgBUNWDEUQMQIPXUj/0XzCDLc8VxeMEQrGQqpNT/njBHNavTBOqAbv0ztHMc5r3lC90tMbd6/5YN2UPvyFIxOL/j59B3N968bk+97J3/jcPc4iueqrYqDTgkbcNDFsjCBqv/YvGED3+h0KcsyNK4QwRwzkCHcYkcUzT+SEIm+JfUIiCWUuxj2Xbkg7O3887e34jwP1xn97bODoP/naw/03PzZWfN0tQtchBgSWLQL697FslV+OiifKCuqeYoHWhelpGxhZLWmKNiMsT3qGRLNFfbMc2baJqvfzKaNWNEXEwRYVJsMRZbmQjeLOSeZb/ri/f9H/i1A6TejrruxJme5nL6Ps1a9TlD0JQ+D/IUOkDEJnY+tpBpgtUgg0r+ms4Hw2e7oU1UXUOlVBvWHLXHxH3Ysnwl+wQGUbmbJYfv3ndx18+d1PDHUXFy3iYXtv78iGjtJXfZb9rXNuL4nPiYQ8FEVEbmbw4qQ4oEyeIXpFU2ZanzaBlbiu2U57OtEIJ4w5McBDBTAUVR5/WzpzqC6uKwpxMMW7dUuEByJms6ZcLr28VC3/47Sa/MbB/qmf/foj/S/Z1z+8bWBAOvBwyRTCikVgpRqG5WClmtaedsFpEDbssCQXCgrruqHTYIix/FgC2TG8RPUU4XkQa7khC09R350Syml25Sp6WOrD0/oSGQzOkDNE1RViVGCf4YwsvHP16axPUVKlSZN0TsXpu//lZw9sacVC+o4tXcc3JO6LNJ09GmWUqa4CnDNukFjo6yMyeUSsDHEGU89UxZhdgzlUYeCmQkhVBCluCvKYa02Lc7Q/eThnGIpRURqDsCLLBH4i3BjkVdfYUtTd9QJfLv+rP9176NU79+1b9IejSzaW9nak+f9yU5N/Ja5xCCTqcfeC1A2pHdCwwIxxKQNt1gAAEABJREFUTxsIkSct0AcQMSD3QogAC6mtejfNCtNMQCZHoYpHXiBaowkuJxXWblW0QoWZPPBywEjbG6Cm7bXKo8BLBB0TyiklZ8rdttR5a7mr69ejavW/7Jtw/3rX8WNv23W8cdm+Yelpxf2oegYJCMwFATOXi8I180QAe5Tz7GHZXm4Yiz0WVQNhISzxWIlBRqU02VJjfuU9RFErjEti82gjqz/kfDbF6vmCNC1YQLwQgzlVWqHX7JgMymPoREjlhJDyYyEuy0FbhrpKpaviOP7Zv989csNOAXPR4oZrt6w9GEX2b7JG/lUSGS5mlzGn0BVkSMRMTAZqMxFyUJ2KIDieJFqLkiJqsWY0VdH8/OS5e4F6xMxkjemspMl1HR2l91U6Sv9meHTqN54cGHz/kyOT1/aPS9/dIjGFEBA4KwRa1wh/aa0bfNWOLOCxVWq8FO6YxfvfiBj7FI4d5YlQqdSxebohb/reo4e6WgHNL1+94WjJNL7rXa3feOet98UnzgWvCDwxeX0QwcLfCt10TAuCjCBgRuiCG4gJKYHMmazHDg4QNZxSw0RRR6XyGpukv/rZL9x3CUgVLWlRw4sv7H0kMfR/pFH7vpVsWn/ZDcQO7hYieMo4AEELXQ1SCO4BJqQ4YyKU04mAK3AdbNMSrdR0XoIe9cnxOfoCPngOkWJMUX3YlKLIXFopR+9My+m/fGqo8VuPHD7+c8O7jr30keHpbYcPS2Ve6oSLAwKLiIBZxL5D16dBwGHtYFIX5jSVq6AIPIll05ABQeoqqouoh93ORJSa5Mp/u/Opl2GRbcl9eVFH9UHv8gfxOnjKQjmGXmwMeRCpF5y0W5zVCSkDTxEmtil5E8fVpPRKSUs/96WDYxctttrMnK/p7L7bCP0fn7n7jPgaUCOexRA5Ut1UEeiqCWk6I9qOTirQYm2jKS7T7Dyl6Al9NFM94mQmNkfX+dX7UFRXtkSY+CSONpXK6RvTavmX48703/Ufq/8/D48df8fu4cb1B45NnbdLJHw6nkJYagTONF5LFs4zKbTS69KSYEMXbulKN/S57IM3SR4LJlZqAEFiLeXMVOOYOnvWXzzp5N2//uih3ue6fDHLr+5d/1iFGt/mrHbcisOrXkdY18nrIg9iX8yxz71vpR4QuOpGhhxeMAtF1MD7/nrSQb7UtaZS7fjAF/YM/MzfH53YcO79n9sVO9by2OYe+bzJGx9ztelHjMsaVrvwoGrMNUFHRmqgLwvheLIIalE4S+qMayBFI1rAMNvnbFp0DULHw5BnLubZQROPgX2RGvJxiTgt90Xl9Ja0WvqZpCP9f/vHpv/97uGpXxh4dODWh4enLwheewFkOLQBAqYNdFhVKuTFWoV93FVl9dPGGiychAXTwVXHZgVyhliUkDx5kLtNq9f84V39bxZ1N2lpw63buba5I/6Byxu7BYQEFbEdyxBZWkVOMxq4EITTrIAn3Pww2IxaHsUM7HLcVvpJbo9XGWISMiZdRxy/6ysPHf/QzsOH16HZosYLenqGezpLn/WZ+6s8y/cQQCQ8tamaqqNg7psp/gigiZarILuo8dljPF2iOdED7kRiQyoCMhd46SqqP+wgy0zWcppE0flpEr+uXC79g7ic3t4/MP5Pd48NvufRobGX7h6pXfTo4GD4JToKoVUI4A6e59Dh8nNCAA66eGHw+jldtnIa66JJIEl4SeBxrJeM5dOSCOP9r6G0t++Kiaj84d/YM9RJLQg71ttdZcq+7V1jSPCo4aRJPi1Q5ZQhPc50c4ORWugUzQhOSctVnJ4ATaaE6s5S3ZQoqXZdFFXL/+jvH5t8/R27JCmaLOLhsr7q4ZTNXzXqtU+6rH4QM+2gEulce5CizMw/IU9qjMoi6nNijOccBxXQhdmS6uahbE5MOVKHMvI4U8GDCZE+ghrYEjHHyZq4XLm53NX5c3Fn9TcGxt1vHRqc+NX+Qffu7+wZuun+41Nbdouki2la6Dsg8EwEzDMLwvniIlD34rHI1Rd3lHbu3WNZdESGibCQGrjB+oEvS0we5xkWUbGly37nq3teTi0Ib928eWptHO+s17MHhKgGtTRCcNYCfZ4eEng9faLcgjPVSQrdxDl4kSgWPScqHgCAJcUJRXGylZL457599NHXL8XX2W64sPdAxNFf5w33WfHZUSI8w0IjgejWQkHuuAsEAuVxxNzPWIMEzQmPUlSkOC5IFPSigqTZ78yJwT2nUpQXh0Ir6ETktQ3w1EWSUcJQlpmJ8PCpdRBmE6XGxluStHRLWqn8ZNLZ+VGJ438zMlz7JwP7Rm7bfXzqxXsPT19w4ICUi+7DISCwiAjovbqI3c+765XXge6Lkq2tPMPOziJhUI0BqWNdJDIUE1OElTEiwnJvKYsS4lLXpqmGe/Ov3HWgJYvg5Vuje2Lvvoqd6zHCAm6ZQDBCSKh1QUfXP1eIMiKwm9UFPiOpjha6apnowVhyBu/U0S6zCdlS5WW2HP/aJ3dP3qDViynMLC+9eM2jkfF/mWf1r+c+G1UA9fkCKXkGaaoZMEl1FWZwpCGBriooLtTTFE2L/HwPxTgznWi/M1kkWoNkNkIXNkzMhhiimKpmBGKHgjOtUAJ8BQZ5ishxBJsSI1HSYZP04qhUfn1crf48Jcm/PTw2/RtPTU780uPjAz9x5+4jL3qkf3jb4cPF//zGM52FJCCwYAiYBespdHRWCCTOe2FSD/0ZK8lZXb78G7EjwYYmCW49sVjfHTHOBQupIOdzR6m1FJeqt/yf3cOva4XB6qWvKyd3ZvWpJ63P8piJjBcqFvVWKIQxi/fmHsSHvAN0OROIhICfFGLEkwqTJ31oUtJUIQQWIs/MaVq60SXJP/onX3/8ZhQvasRwrm/72vvxwPZnrl77ppF8HNQn4jO8ks6gqxDakHfQV05VBaYRkxR2aXpq7bmdCZqrIHl21AoVjEWFoImeqyCr0ZMlB/EFeRvyeOjw0I6kqWXzOjygoLHirPcIdDaGuTOKoovScvVVSbX6U3FH+V84W7p9cML9sycm0p+7e9/IW3cPTr5g38DERpHF/70AqBfiKkAAS8MqsPK5TGxBedrpPZzUOh74pQXDt3xIJRv9FTbBwkjwbrhYIpXkDdZIi6XToJSoo2fdleO5/cDtOxf/F8/oNOHa880Dsa/9wPh8gl0u+t76NM2WrMiAQCKvJEKkhI5X5IQdBKUWsriZmuKhDwgSN5gHu3jTvMWKhA1nFFWqnV1vaXD0D//Z1x+9FI0XNepvvq+5oPs7Mfk/cY3ad3w+PWnESaQKeeiJ1wRsDBGrXSpUBM2hlHBHEFPThqJijofT9aBjqJyuSy2fFa9EDg9ccFcKq0aQk/UFzlCy6KZ5jRSnmteco8iKiXujpHw5tuRfm3Z2fCjpKH/UWfMbx8em//WRkYlfvG//wNt3HRy+btfAwMal+B/zCmXDYUUioH83K9KwdjUqEwRjG1h683bVcTH1KtY/GM8iGAaLOlY+jyVQid6Tw7JpCU4c+bhMGaU3/48njr8aDZc8qpe+xtCn65Oju8Q11KUkKhZyalEQjOshzVicKXYAVPBQRDPCMykpEWqjZnOyICbDMQPXiq12vHY6Tv7x3+w7dtlM9aIlSuprq+5bxmf/3U03vmZ9NpZAORA7nFlPpsCUoa0KKqCJWilIlyICQgKEMyLNnQMMrvcnY9cDWejW1EvzzZyHaioo0ftYBa1whmOzheaJmCyZmX/FSIbIVNjYTTZNr7OV8ptttfqRBif/aqThbj826v/ZQHzkZ7+/f+gtDxweueGxw8V/GINrKISAwFkhEG6Ws4JpTo1Oe1GGHXfvqOFF3GkbrPBCXTxPvukEi55gURclIlRawcKeC+U2Ya52bx6ZnHzbr9x1YE0rYHnx9vS71jd2krhJqAkVBNK6yCcNrZoUby2A2UnFRVbbzUpRgIPSCnFEdY6NlCobTVJ657f2Dr3zjgOji47tZX1941vNuq9FOUh9qr5TsmzCYpqtgberrzKgHynAuA9IhZqkiGSB4iwamp7apZbo/Tgren6yFK1PLpjJQ31qCiFtiuhczNQXhYQA3seGSWEQF4WwmQw53OeObSxRvJ5L/3/2zgIwiqMLwDMr5xd3EtwJTo0a7i7BCU5bihR3glNcijsUKW7FabCiQQsUd4vL+dr8b0PDn9IkBAoVOsu9zO7ImzffzM6b2T0SXSnOaKgDj+Y78Ub9AAcmEfEucdhji63b6dsxDS48Sipz5W5s4J07d9T/JINBK/1QAhkSUMdxhgk08u0Q0Mk+ioIVCeYxuNXfTh3/ZK0MTGSMAnMSlpECIoOTkWFfjrEE052ARIVFrNaIXE4R6TQMwxo9Kq6/n9jy72hT9YAAm4+O3SsS5bGCYBn2dxjxvE4Cuz8FdpAgCgjsClX/oYADlBiMRAYh9RE8QxBiYGSlSWo65HGpToTlEThVpCWE0fI6H6LVNztxO7HDlpvxIc+reUsnISHYkdMYeJRR5LmSIBwCc+0cAmsVMBg+0DhweviZPLcBGpKa8DzilU+eq86gJNQGsWoOqAd4/r8qNe6ZMEhGGNbefxA1HgQhBYqpfYMgxEgC1hI8mldFhlB97QFDGinQRzJUqIraJ0RNU/uEYNDAQlmWxQwP7911OXVaY2mDwVyDN5m+cPKa4YmCPDZOYkbel0wDzj9M7nTxSXLNXx7HFbl1K8Fdfd4HjaAfSiCVANxXqSH98RcRMItIgfnBKSMk/UVV/qOqwTCBMQR2KRgmQpjP1YmNgFNHMDlicPAKw8MZjwjkw1jBvNkjb5JdbNT98A3fv6Mh7+U2nkNEOU0Icf0d9T+vE4ODAYcAH6TetIAOqVEKLINkBiMZIhVIhAAe86JneaAwlEKqM4F3BkgEpupfamPg3bWCWE6jMxVheG2HI/eS/5L/zhYUhO2qU0eCPF9wSqeILIsM7NIx2KkKgragPxzkDzGvHPFM+e+KqVHP5P/6n12jVCuen8NjdwZc7ouCwQUjVVIzgg4IAS9SVEcNTl2BVxwyhDDUEfktjajXIApCSBWi1gT5UKpwCMF9gEEQ4hiEeS2r0QZwBkNJjdFQjTPpWvMmbQ8HQoOsLmGUzaGMjFZcPX++9KTB2XvxRS/DkxYYoyzK4KBR/x0CzH+nqf+Mlj5MhrmXwTYiMzIHdzUnK4gFD49hh6re3xKGqQImBawwiIVZmgPPzxCCCAIHSGAiAIHLLBsjQwYlvUBuqAo0QHk4RzChI9jl/UFAN1SEXi7PZihCwFZQDHMe+Dwopp6rjQD7EQgBt0LgWkkVlFq/xDJIZGFHAumgBWECOVIV6MEcA5JYGYmMhAj3TDdPEKPFfOj315I7Dth3y101/68UdZfuKYkrUMKDM4pkFRiWIFkB+whCzyZfFuxmfjsngE5GBEM6iPoEQgGvq07sCkptLUKvGRJgqUDZNEFwgGoYOwixiioYWGIkQx4JBKJSeatjhzQa5JsAABAASURBVIG+ZrAIJQSkOhgFYyRhDTh6A0c07vkE3rPLzrtsx623o/0h01v9qE69gKf/ISw6Zsoux3FOcYksEqB1ItQrIjANQoRgWID9z7iq568rCPoJpT4FgL4BJfB5phvi1WiFYEgGgVrlDEQByxSAlpEQiCcKRihVoDBAxwpBz0RBKnf1f+BDBSi1UkJ+CyFv6gf/Fk0QvIlDUBQEziGbDBcK6FWFEIYhmNMjrPHCvC4P1hnLIoOpLja4fYnczSMsCjc5RiATD95MGRb12N7jzBNru7OP7Y2v3LeEqu/h6RftUmH/J34w/4lW/oMa6VsM7lnM2BWERfANSBWM4AqEwOyjwIxGEIZpBBw6hCwIA3EMgxFmGYQZiGEYlNWBMUYovaDfH2qSquFFgVJIld9mmd8mH/JCqOpSc2HIC6I6ZhCkCsSg1AkSQSMRgpIgGAqkCUIyxkiESzVNzYEhBwOCibor1yAZOCgspKrGQcAihE1avafCaRrsjrGUQX/D8VmOXMf1SNzE8cgOm0rEcSxioB8kUUEM5hDGDFLAG6jzNQL7SZpgtTXqlRqLssZKXj1dVYgV8psDATAEQc3phaBnCyYIwRYMokAOuIKfLLDmkcjoNbzBVAr4djl0K6n6ugdv///++/piS16T3z4kCLMk0XWOIaKMwSJ4IoMQUaAhCGGMEYGxJMGCF2Oceo3xmw1BKVTEpBMM5y+KOgIzFwx9/0wwjAWMWJQmKPWaSbMZ4nGapMYxCGOIAUHoWYgxhlMGRA1B1HikXrMQpwqHCIw3gjVYYTQ6wmkDGK2+BG8wVtcYjS01JsPXDsT3s8n8EKvMjIS9w6g4hzwokY9rd/pBQs2ou7Flzt6PDXrwRvsY0eMfRABGyz/Imv+AKYcQAp/NuRQGEwnoy6rAvStB22WswCQrg6ihKnBORCQTKVUURQJHKSECkx7GUAjKpH0IIRD/TJ5P4hAHkShNiKIgVRSYhGQonyZgkGoUglQEGhBiMEKQjiB4JgSunwkBpyAjeG8AgmAXilVhZCgiIxZe3KrXDKQxYDejCLBLeSasIiIW7NeAA9LCnK2VCUoVsEkD3pCHUH0czKo2wxMEVrUEnlxIYAMB76lnuAIuBddCf8Oh/o53HWfcI1sctziXU9ZKArTFhTDMsSoPBewk0HeIIYiBfxwIC8IRBqnnDEBkMEYMtOXPiarj9YRTdEgVBmnAGhaxYC/LiGCTgOBREM8ZtYUkjfark9ftrdbBu1n0lo+AAGzz9vTbS5zCRMUpnOJkSeGAIwOjn0EKAsMQGInUkMCY+C8K3AIIQdvTJDMGkK4u8fUwtrzhYX0wzzH5eZ4thnhtTVava8cajQNcCj8OnP1Uh8RPf0TcJl146hhy/lFKh1/uJVU9/zC2oPrInu7k3/Kg/wvUM39BHbSKdAQiMFZg0hLVDZ2C4X6FNJi+EIHzVIcKoXqO1J6BczUE/4sYuGUZFkOI4CBIUSA33OzqTQ4RCGOMMNzRaj71Ok0YjFGasAyDOHjcLUFZ9bG8Kql1o2d2YIwRKErVrcCiQVH1I9WRI4QgCYFNah0InEGqILBBFZiIEUzERA1/EwzxaQJrFyhKEAu6GHXH9Zs8O5cRVq/BqWNw9ixmQDV5Vh3YixkWNCGs4Vg3wen6oPvOs3/Lu/SGnxW4ZWCYE2aNRmBhwUFkCXE8iwRRgMUWtIFVAamYMMIEqb4dQgyixqlCoE1/RlQdf0IIPEkAQbDIAKvAFgVEBoUySl2UMIxWq+VLEpZrc/Lm04qRkWpm9FaPwrBTz+fmt1tyuCZLgnicSBJBMO5UaAqEBGrHMAbUMf3fFIwYDEvENHlFFgphdApmvRiey8vptCV5nfZTTq+tx/B8W5cs93ARZbCNKKMdIp6QJIoRCZqnPY/efBJ++m5MzeN3Hxe5dCnGBPMLi/7Gg1b9agSYV8tOc78JAj3KeEiMQkR4h576C0t4BSENzK2pO1dwalpwcBpRQRpJfibg/nlBRLwLBEKNLCIt7IDThFdciJddkNeJOMkOaS6khTgdiFZyQLwDpYaiHfGCDRmhEQZEkCp6cKQ6cE6qqDtPVYzwRCBNDFCXXnShVBFcyCA6kRvsts2ygIyg2yA6kBEkNYRrNxB3yYncoS430aGYBIeod9pcWqfVrnFYLDohPsngiknQumJiOUf0U9YW85CxPn3AWB7fZ1Pu39NbHj3SpTx8rEt+8MRgiYkxpMQ9ZeOfPmGT4++TpMSkU9cfBIL5f/knFGPBqMjf2y2Ws3pFlIzwNAK5LIiFpxMaLYMIEZD6dEGVtD+cwkNf8uCYOFjksBAysOj5u4RFIiyoBASrp1RhkBOchR1xjAVCKxKQCyGDQYuNprKSztD9tPlOJfQXHOpOvaB34F7ZZhsuORw7GUm0ccBJFQTjECEJsQqVrBgwwAdnIOpiACOY4mERBws5TGC0EsxqCcObEaf1w7wuL9YbyjJ6Qw3OYGijcTP3YgymYS5WO1rAuvExejLy8O3YficfxH198m58x9P3Y5ufvBVb58SNpx+euvkoJCoq9VfYQgWIHv8QArQz/oaOCPXSK7AZFhnYisBT2tTdHAOT/3MhcOulCkJsakhQqpMAW2GfBfkVlP4GZsApM+A0VOGQAmVkmLxBIE695iEuNcSEcJjIqflhl8nIMmzOYLsuwTNkWRKIpLiIJLtkUXTIouiAXZNdFESr6BSTBZeY5HKJiQ6nGGezu6KtducTi9310OJwPQC5b3EIdy0O8bZdJDedCr7uIuxVEfNXZFbzi8Jqzyuc7gzhdKcQozmKWP4gw2j2Y16zh9dod2q1uu1GvWabUcdvM2nZrW4avMHMcxsMHFlpZNECs0E330PLzfHQMcuDOOMjwPC3fMp8nPscFp07nE5nNCOLME3KCMM0iYCvDIsiBIskVQAzeiYIYcD77Bz6DJw6/lNCEIbx8HoCtkLdqn0I7MXgKDE4eVUQhAqMFZHAsOQ1Rk6rLRZvkz5d/cvtt/4lOQSHnx+2uhfNcRQ5hZEOq2254HJeI4psRQgaC/wQ2PYnBHb9sirwOAkGPAFRUkWCOtIEmg4dqsA9oEiwcU0VJ1Ekh6JI9t/EBqFVkSWLIospcJ6cKrKUJMtSYppAelKqKFKyouZT8yuSFfLaQOygU9Wr1iEQRVZFrVsiYBe0UbVRtRWaLoMof0qAHtAFFQREPYMQphmkfuFOhkQFqc/OMEcwoycYe4AEYZbJy2q4EpxG8xmv0TVEGk0LJ+FaOxHTxi6xrR2IaWWXmRYpdtI0jhFq7r9wv/z+s/eKHjj/IMfuYw+8jh69al536ZJGre6fL++ehcy716R/fovMgnKfS7w/zhl3c6jl6dVx9kdXp9gfXplhf3R5uv3xr9MccG19eHWi/cmN8Y7YO2NdcXfHiHH3RwkJDyPE+AfDSdzj/ij2aW+UEN0LJcT2YJPjvmaTE75iLQlfMskJXzApSV14S2Jn3prcQWtPCdfZ7a01TlsLrcvRXO+0h+mcSY309qSGeltiQ4MjsYHOZW2os1saGFwpDQzOlPpGp6WeKmZXcl13Mbmuh2Kr66VY6/gQR+2a/qjOygo+ddZU8Ku7tqJ/gzVV/Rusr+rfcF1Vv0Y/VPVtsraCZ9O1n/qGrf7Up/n3FT1brf7cIxyk47rPPLqu+dzz6zWVfXuvrBTQf3WVwKE/VA6MWFE5YOyaSoETVlXIMXFVzeCJiz4NnLCyRs5J82rmmji7et4p02rkmz2/ZsG586oXXja1Wck9m7pVTvi7ergWxi43Iiy1JceOs8RHL+edKftIUsxRlBQdpXUknkOW2LNKSswJISX2iJQcc0hIiYkULDE/SclPI6Xk6EjREnNQTIk5JCZHH3xRBIhLlaTog0LS08hUSY75yZUUfQBkvys5Zq8rMXq3KkJS9C5VXIkxu11Jz8SZFLPHlRy715UUvU9IijkgJMf8BOFBMUmtL/awkBx7VLYknMTW5KvYmnKdWGy/Eqv1LElKOoSSLQd5m+2ImBh3jNisF2CX/KstxWa59jRB+1exVp+AlC8Wci7IVzPeEZ/UwxIXP9CZnDRVTLEsEe229ZLNukWyW7dLVusOkO2i1bpFsFg2iRbLeleKZa3TkrLKkZSywpmcvNSenLzIlpQ835aYNNuelDjLFp84w56QON2WkDDNDmJLTJgKMg2up6piTYDr+PjJtviEyZaEhInW+PgJlrjE8SlxCeOs8QljbHHxo1Li40ZYYmOHWWLjhyTHxA9KiYkdkBIb39cSG9fbEhPX2xYT+40qyTGxvVJi4r5Jhjgo3yclNrafNTpugAXK2GIThljjE4dZEhKH2+KTIuzx8aPAjjGOhIRx9oTECY6ExIn2xKTJzqSkqa6k5JlCUspsIdk6T7SkLID2LgRZJKVYF0P7QWxLRJttmWRzrJStttXE5lin2J0bFbt90zNxrsdO5yrkdKwmDts6ZLdvVBzOjcjl3IIF5w5GcO4mLtc+4nLuJy7XfkVw7VUE4UfZJWyTnSCCuF+WpNOyKJ9TROmcJMnnJUm6JInSFYi/I0lynCTKTqdNkK1WC4qPTWbtlgQuVnSwtthYhhCC/6qxQ+v5PwHq0P/P4i87q5bPFNe/Uq51Q2sXnDe0SfFpQ5uXmDi6Zenxo1uUmfBts5ITxsP11JYlJo9pVnTqtMaFpk9oUHD6uAb5Z06vk3fW9Dr5Zk+vmXvhd81DFn/XNHjplMYByyY28F8xt36RlXPqFv1+Tr2iq6bWLrx6Uq0iaxbWKPTDtMoF14/+PO/GsZ/m27Lwwzxbp7bJu2N723w7trXL9+O29vl3bmuXf/eadnn3rumQb9/qdvn2z2iff//09gUiVencvtDBTu0KH77fruDRe+GFjt0LL3B8Y/WQk01yGqMa5jKeUaVxDuPZeiD1cxjPqVI72HS+RrDmgio1/bUXqwdoL9UI1F6uGqT9tXqQ9mo1P92NWv66W1UCdLcrBurvVg0y3P88h+GBKhW9DQ+rw7ka1oLzGr7GJ9UDzDEfg3wQ7BZf0c/Pip9tif+yvnqxoiFVikfX+iT/KjMhIxmbfbDG4eyvc9j7qaFGcPbjQPSi0F/rcvXnRAeE9v5aAUIQ1uHoyzodfViXs+9zsVr6siAcCGOz9mPsqtj6c3DOWVP68zbLAK3LMYCz2wZyTttgreQapBFdg1UxyK7BBsk12OQShhgFcYjBJQyGuCEmRR5sUCBNFgcbFXGwXgCRJTUcqJOFPjri6KNThL4aF9gpksEaSOcdTghdg5HV0g+lpAwN1vFriwWWfYr+wgP6Virg7f3Qv2Seg3kCQ1bmDjBNDAgyDgvwNPQN9DZ9E+hl6hHoY+oO0iPIx/RNkK+5d4CPqS9c9w/0Ng/Mm8s8OE9Ot2F5Q8wj8uQ0j8yd0zwmZ4jbuJBc5vHBOc3fhuR0m/Q7yeU2OQQkZy63KSG53aflyOU2DdJnBuVyn5Ujt3ltI+n+AAAQAElEQVR24Vw55hQIyTEvf87gBQWCzYvzhuRcmjskeHnenCHf58yRc3VQYPBav4CQdf6BIet9A3NuUCUAQvU6ICDkBzVdzRccDG0JCV6eOyTH0rzBQYvy5QhakC8kEPTmmFsgOOi7/DnNM4NCTNMDQkxTcoSYJgUFm76FcFyOEOOY4BDDqBw5TBEhQQZVRgQHG4YHB6miH5YzyDA0Z5BusG8Ow0AfL10/X09tbz8vQ6rAed+QANPAnP6mgf4Bbv38A819AkEC/M29Avz47gF+5m4+bvyXSrLzC1VIkusrxeHqYZRRryA/jz4mXtfPjTD9cwbohwUFGsbkCNRPzBvkOz13DsP84JyBK4vkzbk9f968h8vmyX+hZEix23mrFHviWa1EQoMKpSztKlRw4b/5PkX/gOPvMIH5Oyr9r9cJg12JCPWzDsrlkRgR5BYXAQ5riL8pWpV+cK5Kj0BzbF9I6wryNTgzVTqFuCeo0j6PZ1Jrb+8UVTr6+lpUCfPD1jRpG4BtqtQNwvawEOxonwc7ValVALvC4F1wOYzF9FIRYylNIF1OkwiMFVXAXqLKf73f0tpf1csreUSNUvfGVA09P6lG8dOtq4Qea125yOHWlYoebVql2MkxVYpEjale7Oy3VUPPja9W/LwaqjIZzv8gtcucn/ybTK1V+lyapMWp4cTqJS5MqVnyoioTqxb7JU3GVyl6UZWx1YtcGF+t8HmQC+MrFzs3plLBs+MqFj3TuHLhqIaVCp9uXLXQqcaVC55oXiX/sfDP8h4I/6TAvvDPCh5oWbHokYaVQk83rlw8SrW7VdXix9pXK3KoWc1ipwZUKfYgLBTDS/e0Vv91obpbL+CNU/KbzTGFjcbH+bwM9/N46u++KHk99ffUtPzehgcFYAEYYjA8UiUnlMltND7JYzI9zWsyRat60ksBszk2Iynk5hanShE3t3hVQtxxQi4PnKhKHk/PpHxeOFm1SxX1C32hcM+VhHstM1HT1XyqqGXU8nk8cZIqqk5VvyrBUJ9aryqqXaqtqt2q/Wo7VFHb9KKobQ02GB7mNxgeqBxUUZmoop4HG/DDHAb8IJ8B38+rx/fSJI9efzeXDt8u4KG79XFx/+fyacGA26XzeN5V85UJ0t8rk9fznqq7kMHwSO2HPCb8VLWtiBuOV+1X2xUUhO15YH5R5xN1DoF5QgYhiB5/CwHq0P8W7LTSfzsBddICkVRRHVCaqBObGvebqJPbXymp9vxWt6Takl5UGwvAa4M0Ua/Tp6vnaXGgg07K//ZBSu1/hwlk3DTq0DPmQmMpAUqAEqAEKIF/FQHq0P9V3UWNpQQoAUqAEqAEMibwphx6xtppLCVACVAClAAlQAn8JQSoQ/9LMNNKKAFKgBKgBCiBt0vg3+HQ3y4Dqp0SoAQoAUqAEvjXE6AO/V/fhbQBlAAlQAlQApQAQtShI0THASVACVAClAAl8K8nQB36v74LaQMoAUqAEqAEKAG6Q3/7Y4DWQAlQApQAJUAJ/AUE6A79L4BMq6AEKAFKgBKgBN42AerQ3zbht6ufaqcEKAFKgBKgBFIJUIeeioH+oAQoAUqAEqAE/t0EqEP/d/ff27WeaqcEKAFKgBL41xCgDv1f01XUUEqAEqAEKAFKIHMC1KFnzoamvF0C/0rt6whhL126pLlxI97t3Lk7HlFRjw03btzQqvH/ygZRo58TWLeOsMeOPdBfvRprVvs1KiqKJ4TQOfI5IXryTydAB+tf3EPqhLH72M38P528XXL3kdsld514UEKVHT/fDD3w84185+7c8Xgdk86evRq0B3TsPvmw5N5TD0vtBv17f75TStW7O/Jy/sjIO7rM9MKkxR74+XaurSeulth5+m7pvafulNp57G7pfeo56IiMvBL609Ebxfb8fCU0VeBaDX86ermYKur5j8d+Lb4Lyv/486VSe09dL7X7yLWS+0/cLgETow/oz3ScqZPm3kPnCvwE+SPBbrVO1fZUOXqv2IGo+/kiL8WYMrP9ZfH7T/7qve/YxeL7Tt8ofejErQIxr6hLddQnf33oHXnxTuH3qw8rOfTDbh81Dp/5ce2wPvWbtBsW1qzLwOo120yrNqrqoE8PXXxQPOpKbOCdO3cyZZ2ZvbduJbhHHrtWOBLYH4i6W2b38btl1D74CcbIIWB7+PCVQODIZ1Y+s3gow+w/caPovmM3Su8+cqnkoUO/FDlx4hd/iMeZlVHjIZ05fPaGr2pP5Mn75faC7Dlxr+yB44/KpMb9fCV0/+FLRQ+fADl8o6g6Pp7J5WJ7Tqvj5ELovigYE2eulvjpwu1Ce8/eD4qEBZCqV9X/KgJluAM/X8ml3i8/nbhX9qcz98r+CONyP9w7+w/fK3rg2LUc6qLqFXXiE7AoA5tybzl8tmiFZmNDe4/tVLZZ58GfVW3YvVbD9gOrNmg/u3yuEp1LrwVmx84/yKEu5F6ljsePHxt2AvtDUbeKq/fmDtCz59jFwvuOXy+SJjvgXM2z5/TN0P1nHpTYF/Wg+KFjD4pHwvVhKHv09NVCqkRG3Sl8CPIeOn63iNqfP526UUwN90TBmDlzM/+JEzfcgBPOjn2Qjzl8+IbvLrg/1T7dc+Zx2R/h3lP17T16NgjSs6UnO3WpzHbD/HMAxvOB0w/e3w3yI4ylnTAe1Tb/+PPZXNnRQ/Nkj0CmE232itNcr0JAvVG+GbcsuEajfoOqdJi+pkbXaT/U7DhxTc2O41bXCY9YVDmsX+/xU3YXexWdaXm7DF3dsFa7qXNqhE9ZXbvNlB/qt/9ube32k9bXaTV6YY0mvfuMmL/KNy3vi+Hl2Fh9zVYDWtRvN35ZrfBxG6t1mLyhVqeJG6u2m7iuWoexi6t2GDeiRruRg+qGjx5Yt+3ofg3bj+pTv/mQ3jWb9utVJ2xonwbNRw2q32TEyJoNh8yo3Xz04totxn3foMPE72s2GbawTqvBFQ8evKtBmRwb9j01NQwfO6hW+7Grarf/dn3t8Bkb67Wfta5e+LS1DTqMX1qvZcT48Haja+y58NSYiYqMoyE2AnZXvXrO+bxhk3HzmzWduLJDlylf7zl3PQckvfSjOvJdx3/NPaNuxEet28/o2KLF2Gk3b9+ZmZJs7+bmrasVlMe3YHA+31xmH91HiVZL+MOYuJkNwicsrd9pct/a7edU2Hritv9LK0mXYdPRi0WrtRg1vGLb8Wsrd5y2pcaXszfV+nLOxkpdpq75vMW4OR0GzK0JHF+ZQa73uxSp0qzfrKrh/VfXaD9sXo02/b/sM3ZZmbCw9Vne+8ePP9R2HbK6UsU241dW/2Lu9trdluyo++WSbbW7zttare20FZXaTRpXq/34flVbjOlVrf3ob+q0H9e7TsfxfWp1nDS4RosJY6u3njSraouJy2q1nrqqbstJc1q0m9y/RfspLWdtPlV83aVLmY6HdEien565nWis23ps60btJ65s0GX2tlrtvtvaqOvc9XXCp62q2Wb0rMbtRjVf+uO9bC2E4R5kdsJCpXaXOSXrthzZuG6bb4eEdZrx7YnT53sZ3LjagTm9yoYUyJHLP8SvVIrT2fCpxT6iY+fJUxu2G9f3syaTKmyHxQPKxgH14JlrDhWq1WLEzM9bRCyu3mLY3DotIiZWbzhsaK2GA/rWbTqoV92wgT0bhw3o2ah5xJB6rSbMrtZi1PfV245d9Xnn0d/DOFj6eevRkyuHjelXOWx0jxpNBveq0mJ4/0otBo+o0nzEpErNIubWaTNqfpOWE+bUajhwbJN2I8uAWSzISz8XL0bra3YYV71ei28XN+o0a0ujjt9tb9x+2rqqYWPm1Ws2rsNXg1Zni+VLK4IMS3ffcWvaeeSA+h1Hr2/y5cxdYd3m7gnrNmdHwy4zNlRvPHx2k7AxTSAb/bwhAlne1G+oDqrmNwIYYzJuUCtBZzTo/bxNhQL83Qv5+piL+nmbC3u5G3LkyBGQ+PlnZW/9lv2VgsAc+W77eHmZA7zM+f383Av4ersXDvT3yudu4P307p7XF48eEpOpwhhfwdsr53UPL58Qfx/vXAFeHvkCfDxze7ubgkxGc1zhQiVXt2zUdHmrJk2XtGrSbH6rxk3ntAlrNrd507B5LRo3mNekQb0F9erW+KFKpY/35Mud86xJz1mMWmTWarA2b4HcyRUq5HZlVveEQXUSc+Twt3qZdT4B/t5+/r7mEF9vUwF/P6/CPt5upd3Nxs+TUxK7f919avXMdGQWH4GxEt6pnovXIsRpiNCqbaNTbdp8ci2z/GnxUVdiA+eFTf88vNPEiKs3b8yxpDzpqEhO4aNypfc2b1Tr21N7Zgw8uGnSsEObpg05v3dB/1ZNmkV88ukne3kOmURXUvt7Tx6P7NBlYo9SVQeXgicUhjS9WYU6vf6pl4dnvK+7McjPyyPE192cy9/TLY+7UZtDq9VYBvRsd6VixTxJWel4MW1X5K+5rRZbH7NO4+em0z+sUP7DQ23btp718/Ypu9avD5NfzJ/+unz5EEePHo2ijXqtxsukC/A0aPy9TJqgVHE3kdIlSx1t1aLZylbNw5aGhzVdEt6q5cKObVrNa92i2arGdWvtqVDhwzO5cvha/D103h5uug81GtLGJTn6DBsyb1z3ZrOqr9t92Ut1eunrzOzcm0l2+Xj5XzcZ9f4eboYgH1+vHN7e5nweHqa8RoPe7aOPPng6rleV6MzKp8Wfu5PoEdZjdbnmbb794sDBExOTkuK7KrLLq0Ro4TPN6tVeumz10Amnds0Yd2zblIlROyeP7N215ZjPK32yR2/Ucjwvh8nEOblNhwn9l2y5/EFkZCSXpjej8ODBg+yiJbs8dAatydNs0np7uiXlDAm8VK3yx4cb1a25uVXjuquaN2m4qnlYk9VlPvhwv6+vv+Tv7VnQ38eruL+fb6inr0/RoIBgR4VPKhxq3qDu1qb1625s0rDWplrVKv5U+bP3zgT7eT00Glh3oxEV0utxIb3ZXcnIjoziRF+FaHQ6ZHYz+JhM2mB3D1Ogh6c5r4+PuajGZCjnlOTSGZV7nbgpfevG+QX4yCajwddkMnoa9LyHyajx9/fzyMOziq5O/RoHXkcvLZMxASbjaBr71ggYeUmrM1oYHjMKERGrYRADU4OkiJaPPy53o1vY+09fp24vL8/7jJaREEs4iYgYYQUxLMJOhzO5SpWKu/LnR0JmeosVQwrD8Ukc5+WBkInhiAFpFB1mXLLsxjA3mnzYd+uyifX3LZ3Q6Kel3zY4tnBK49MLpzQ/vXxmuzOLZ4WfWjmr5aFN8zv8sH9V7wkjvmk9pGxonllGTjkpCZa4Tm1rudSFTGZ1q/FanrkuC4lPTXr2B1FOvsEgO1EkCXFaM8fqPPw8fHKXT7A6vw6tOTSfmv9VhDPgBMQ47imMNcrdU7r0srJ7Tj0KGTh+a8ebdx7PcXP3b+nplasoIdrHFSpXnL5jde+J08eFnccYy+n1zIyoc2nad+FDWEVZBS434wAAEABJREFUb9TpdZ5eBd7XGfz6PHyaMumbscveS583s3MTr0nkGTaBJ5jlCYtYWUI6RUF6SXCYWPag0UhuZlY2o/itxy7nb999bDdZUvIyhD9cv1r1kQdXDBg4f0yrGxnlzyjOU8OmmDHzwEBEpFUEpJHtSKNYJV52XW9c94PdS8fU+2nJ+EbH54+ve3xuRNUTs4ZWPrUooubODdOazzm49Ou+3dvVHm4k0nqk8Fbe4Odl8gjJ6+kTUktBaGaPPjPq3r2LtBnV+2Jc7ty5RcwyDxnCsBKRkMzKSMYSjHHC6njNE/8gnzMvlnnxeh08Yh43a1+DA0cuTNLq/fp6eQZ+aNToreXff2/JvMHhE5dPb/dz+ZAQR/pyEeCM9i35arZep13ikEXZOyhfqNnTr0ff0UsWN++5pmz6vH84z52bUxSFU5yWq25avKFBnUqT+o7oGbF3df8FPyzssmPxjHaHl01rc2T5lFaH69cucQJLrhgNp2Ex1iEZaRnEGbVavflUzxafb10+rfne72e03LdmWtvt2xd0XnBgxTfDv2jXoF+5MqEzZWfiCcGeFP1emeJPEIKi8ONlH2+XS8GYdWFWMmIdh2QMwxkGn85s9tabjR9cunX//chIArPSyzRlL91s9IznNWaFEAUTJCKoFzGSnbAwjtbN7nwxe1poruwQYLKTieZ5cwQkzIu8Vp+MFA5hpEFEZpBLUASZaG65eftde92aFNlpVxTWhTBPOI0RyQpCoixLMmLuTx/Q9AnGcC9lrlwGj/7E5RJcmGEQQVAYKQR0CAXz57JGRGA1IvPS6VLaNioZs3/tkNU9u4fPC/T1OajTsonpkjM8lV32BLvNduf9kvmGffTxp9OcTvsTliNQvwi2sGAJw2p0+lCL1dlnP7wTz1BJJpG8jF1IllJyBPhfC8kbnOXTjx8PXMk1ZMziry/9eq29zHJ5FfCtLsH5pGq1qkunD615EhiKmVSD8iMkVKv0+bJkm/166lTIIY3GwJd7khjTdM/PF/wyK5cWrzB6WSTIJRIMfYaQghkkKgoRJNmWL3/I9RZ1ysan5c0qVHeOa3aeL92185gvXXaLvlbtKmuatKw/bOWU8KNZlcsoTYPBc2JGgOkeKQxGMowNBWMFIxTHSVJcRmXSx/Vt9/nhr7u2mWY0m09JssspEwXJBCOTu1uwKCntD545k5sQiEhfKONzBdY3NoJ5gcDqV1YkpMDIwAwWzW7mh7VKc1kuUiLm7vHr9NXElgd+OtRNo2PK8lrGTVKkpLJly+wcMrjByXLlguwZV/sstmP1alslhTspSpJMeC0ymsyFbaKz9+qtv/g/y/HHn742mxJa0PdpzUqfrOn3RficxWObHe5Rq4DrjzmR2ukeTsHliVTICoOQBG7PKdpzBHs+qlkzvzWjMkO/rPxoz9K+i5o3az6fZTT7erRvGg3jk2SU98U4m83IyYrgDgzsSFGcJLWDMZwyCHM6w80bj4psP74z74vlXveasFoHzEPQ+yxiGA1i4J/kkqz+viGHQGe2bIZ89JMNAkw28tAsb5AAlgWOSMRMJD04dBNCigFhxSDznDFGz3MPX7cqwcUzBDYsBOsYWWaQAvOk3SFYNXrTOb3eM1NHpNanTgQY5kgZlhcKBt/NwBkSCc/zVr2bV6ya51WlT8cKkf17tVxaMIfHvZeVlZwuzmm1PWn3TVX75m+bLJQF11qXlGSVYDeGeROSWD3GnMkHZoUmvYaurPkyfb9LJ7ChFEW5QtXy0WEVQzOcHNX8kXfu6EbN3dL0fkx8S0ljziPpfHkXLI6csvhzr66V9wUFZT3pqwwn9asULcnCeUXHIJEHkgatOdEiVBo7edsnah1ZCXHB5pwhvMSwxIVZpPAaJLMwyTLMk+Ytq8Wr+rMqr6ZtPXrV3GXY1gpf9Bj3ldPpsoe1bDNj9fSOCxZHhCWo6a8qAgMvKhjeTWIw9AEGexgkYVaRFCXBIemSsqPvm/Yf3c2Vx3+dorieEMwSCfNIwEbO6O7/3vBRSyvevAmr2pcrYhCLPRkenlOwWrCBIIUhiBDFUap06NOwsMxfH1y6dEkTdflpRdbo1o5zdy+DdKwR6znikl3nWzf7ZF/FQkEvXZhERNS1G7X6MxLLyjbEIUFjYBgd+2H/UXMqZ2Z6aGiocHjrtF+2Luy15+vwD7JcjEkyG0AUTTBCehYrGsQTLWJFYm9S/z0b9DvckJnVgtCsiOZ7u3XpsOqDD7xsmef6fcqPJ6+7JVvjyzhslmuCzXWeVTQydDAstrSI03m6ad28PhMUttLvS73+FeY5vYw0GDF6RBQeEQkhh9WZaOC1Z6F91KGjN3dQh/7mWGZLE2EVLUGKH4ZJEiEC/xQky6Lg5WWK/jRPzphsKckgk8TIPgzH6uCOSU0FX4AEyZVo1OuuJAQiuIVSozP8QQhheI4zahge5klwIpBLUiSCMWM36k2v5dBBBfoyvPKjcuXyJavnWQk8oAhkMYk3y7Ki5uvasckS4lBO8pIoiYoTEQwLDLjzEcO7J6ZY2y7ddilbj7FVXTB5GBFDsFnHZOmAflh4Lv/tmw/LI0bjxWk1GHwPsjlTbBpWF6lTiEXV9TKRJHg5qaAnoj3ZxiNZJILDAU8fLLKsboGyLk1YowHzOg+GY3ikyLCHwYjBLNZpdNGeen2WtiM4th26mmdQ/+/qRz++37BK1c/O92rTadL8MU1uALbXnjAxIiaGYWCscjBUFVgkKrDME0lw3hyOEV3KOqDabH089NpDouC8B7rgOTlCmGUQo2UNdtERajdHg3KU5XH5MmIxy7ljDdYqKhtYnnISlhARn7p5GK9nVXhnVHLIkZ9PVcQMyoc5Xq0YiQ5Z1iLdKSPLPsqqbPo0eEMWh1yOJB0WHcSRZMWyFCeKztdmm163KBMfwiEfgkSE4fUGCyGDiB1e3wjp82V2Pm5IY/UJ3MsHGSi4dIlovp22JJQVRW8fs8faD8qELnE5kqNZBsuYsDAXISQjxeeXq9eKR0Xdcocif/ojS4KvgiROvY9l2Ykwg5EkuCy1mnx2/08rpwp+R4D53RW9eOsEBJFoBUkIRAgmSLh1ZLh5JdnhDC2cKy4sLDRbN3BGRoqCw58oiha8AGYUGVb5ChJtySnwOOB2MZS1Q4cXkKyiKL5aBWlZxCDCMAjubjBQTNa+wqSXkV3ZiZOJlIvjNdFuDn9ZzT++R60rjWvWnM46xUcKYwd7IJrTIMQaNbLO4+OxMzf0XBd5KUDN+zJxEsUdMxqi47ksF0sul6swq/MqTFizAexBkmJHNjklUSD2y1eK+WbLedlsSOYY5S4WXBeR036Z2OzHPDSatc3qfn7qZXYiTvJCWi4Hy2Geg+7C0IdYYZCG4WM1spSSWfnIyEhu7ppDpXv3m9728dMnpZs2qrVzQu9uiyIiamVWJjNVf4hnXcREWC4A6MMkDCODY9VpWalQtayEMSZ/KJBJRLGGOR/rtNxTQmTY3EuIwIQuwNN8hygEGXiezaTY8+gU94esghUPSStrCCFIJ+sQ5ySi5LI8IsiR5RMgQti8Gr1HSUavN4uIRQrSISRqBSIpt6+cKPrShVKaETwmD4jDdoS1Jkax9qQDjENc2Lpto31p6a8bRkYS7trNaF9s0HgojIg4RgArBaTj2Cc6hsm2fdmpH9jhfacPBmGFbRgcGHJ9YLtaqzu2LnfQbok/JwuCEykswowOMTyrv3LzVpG1kdeLZkdvVnnWrSOsJSnFDzHg0Bm172E0YRlJSEj4ok8dS1ZladqrE2BevQgt8WcIHIq8zsEyWI9kCbEYIwy7NxYTl9Gk/1MTsMPlCIIbVo8QRgroJZgFp0SU2rWqqI9bs5x8ve8iVlCEHJgjGtWZMTDhghoii2IKGKh+2Qa9rWPdunWsALsFjdYUY8uNlLR65o6r/6OIyBKnNSmawSKCCQcx0CYiK1qrNeXD4eNWt9q+PcqQlj+jUJ0sz567Y+R5jVOjMSZmlCctjhARM7ILa6DhjEQQB5ObWetm4jhjUd/LscA1LWfmYf78SPqybePjXdo0nNWuRb2JXdo2ntanX9sfenSu+NJXKUTmPYnCBmDEwqFFCBEky3aFKHIcOPoUiPjDZ3vkNZ++Y3bUGTR4esekxASlTatWKxZN6rinQAHs+kPmV4yAscQeO3vPgBl1bQhjSiYIEwZpGa1Vp+EytAdlchRFvjqt0aSRZBkzLJ+aCxafgiQ7k12y/LzPUxMy+OFl03FOwRmICDw0gnQY3ghjsFCRbCyLXvI4W1BkwSZhWVCQIsDDD0DDM9AUNqRAuV+yvQPt1K7Or21bN1nQsmW9ye1aN5rapW/HNVP61n3p43owN8vPrdjjbsdPnPHhAAzBaq8jpCiyxDPsEw3mX4lzlhVB4pMnT/SjJy+uote43Pv1ar+5R49aLg8vXQrH8mcFwWZh1fphIQmjHxb4TM6TUeeLqQ4Zir72Z82O2R5Wm8OdwSyDFIJYhkMEM0irM0ZDT5DXVkwLZkiAOvQMsbydSJiCmA1rdxpZhugZQpDqzHnoAYNWY3EzGKL/TK0Wa4qPIAgaBeZH0IwUDLsRgqxtwytaMcYkK90uUxzvkFLyEo6wCqydJcmFGJaTYQuUzDOCuiDIqvifSlu856G7U5TNBq0+Gp4kyOmVdepSax5x2vYhxSZAg1IdCsvC9KPV5oqNT2k1ZeXh8unzv3j+yHHTcOzYGQ+G5a0M5hNfTE9/rdfqn8L2LxmeUig6okG8xCAjZ/LELNNq176L9WevORWybl3W/38aOMvj+tW/OLZH5TWqjOldY3f3Fp88Tl9PpucK44MUNggRniEKhmwEycQplSxXICbIGP+HncyGPRcLR4xf1vJJdHwTs5vvnS7tmi2aOarhRbBBgsJ/+rP3YrRuy4/7vWFxp87AwJ4DYRCPuAQ94TN/2oH+eKzacLZYitUVrA4qBTNIVmCUOZwOs1Z/EPn6Cn8s8fsY2ajhRZczJ0awg4Ty4PIQLDwVSXQmiwhnaQsrkxhGcjxmFJcIZBEDu0PCyVqZFattP3K55uRVP+daujRSB/emCh1ldgzsWvX+xL7V903sU23b+N5VjnzbtepLXyVlpit9vCjr3aBiT8RCwzCGNYuCZEl2wSB4xHPCH/o9fdlXOYf2sbN3/FJKEG2V/HzMW75uU+6sWl7QyUmYuE65BEsix2CEwekSBp5isHqv67/eKnbl7k5fNd/rih1rAjSc1gNjmPVgUYgQtBEhpNUYb8H9rsAp/bxBAuBO3qA2qipLAjdv3uQ5rAvgeJ0Jwf2LwM1ighWW4a08o/lTjtMlyRrEyAxm4B6B14syhLDVe+QBz2uzNAoSBTsPOyBHLowVMItBGHZRMiGyu6cpudZ7H2Vr4oIJg1m06JjXzMW7S0ZduQuvFEBxNj48a8yNNVodo9Woux0lfZERX1SL/bJzmyX2pJRfdNAenLp74JGCdSyrNeaNTu17DOgAABAASURBVEjpsvbHXwumL5P+nBVlk8zovQnm7RqXI8vJUYM1111O2yWnkGLBrETUh4Iy5pCMcLnvv981eOK0DcP7TVo2YNTio1/MWfdL7e/Wni84Z9URz/T1/Zlz0Sl6IUX2wwwLw0LFoAp2Va1W3FKxYsXnTjoqKoqfPv/EJxNm7uz34HH81waPgHxmv9xWs5eXFupnQN7Ih9hELUHYi2FYFjMw0YNmGBIyg0gsxzGv9L0KO9LUYjhDToRgeQALTg0DW+uUhFst2tY8AZO6+DKDbZJL4xQdeQiG2jFCBINTAL/n6e2Vkhs1SMmqPIeUJ4okX5GcjngMJwjKKkhhWK2mzM5dR74ZN3njsH6zdw3sPmVf1ymrTteatvZMkZnfn8j2b13Lqu7spAmiZBJlyQ0RhDAD7YMT2KG7EHE9hUGY5ZhFr3BMW7zHfdbURY293cwPu3ZpvyetaK0CBVxN61W9wRByXUZqVxDEqH3EaYyMRlfGojAl0/K+TsgonD9mORNDWGgcq3YekmUiajntddAHrYaf9PPGCMBt+sZ0UUUvIRCPvLQyIiG81uimQF6MMFIUQiSXIFy/dpv9bvlJ7zRZtO6YV2Yyf12UuzrpzJ8fZVB3F4MXnvCPS0zyYliFRVhABN5VCUR08RrtFUYvqHcp1Jb5J94JJUWXL2bAfWGMCGaRyyXKRJEdT4VH/OLFR81qnap8D5Pd7HWRJlXmr470mbH0UIGJC/d/WqPl6CZDJ03pOGLMrNbHz17P9n95IQxbEGFe07xlvWSM8e9ucPW6Zo/KR3QKP0dx2pMY2NnJCswL2IARY3C3ONHnYyauavz9zhtuKIODZ7CbwvA+RYoWFtXHixlkeR41Y1z96IBA3zWC5DgvEaeA4FmFwmoQ4j0MnM5cFPHaTrKGGzFn8bZxY6etGjFu2oq+Iyet/OqbqVvDhy/YWXPC4p9Kzl53yYRe41Afax48fsPMsbyBAYcOwwJB2xFm2BSGYexpKjftuenXcdDmOuO/WzEwNtkZpvUIKiBrTB84Eeo1ZcHqtoOm/ZiLEMKk5f8zoYjsekmUvRGMBgTLGkJEJEsuGZ5fP2VkKdtPk77bEPXB/fvRNRlGD+OLYxjoYclhi+MVsrZzh0oP8At9npHNthSWE2TZnyAWKQiDQC6MXblz54yPiMAKXGX66dOlQnzpYoV3whv3Q0iSrAqREWIw4g3uHnp333Ias0dHXm8atm5z5NgJs1YPGz1hSa+IcQs6dxm5odnQ2btrjF0QWWrC/KhsP5rP1JBMEhzE6SGJkhcCLgAXQfOQLAuiItgfx3rYslysoGweUVGEHzdxaTUeEf8ePTuv6hpW7neL9BZhZZ/yGB2SFBfhOBYcOkEM4jSSwuU/dvJc8Z07b6iLRfQ6h0sS/BHm9RiGJQatioKQKEoODcfeROhZV0JIP2+IAPOG9FA12SHglPSizBRgtVqdyGHkYmCvwLPIKbq8Tpw4+dmoCbPCxkyY2WzM+Fkthg6f03J4xIJWERELWw8ZvqDV0OHzWg6CuKFDZ7eIGDKtxYTRc5qMnPhdtcFjvq8wd9LSxskJ1rIa1gA3DgeP7VjkEhWHgdNf1yb7ii8zbcuGUyzDcGYENx1ReKRIWoSJFsdFxwaNGTmv5bBvF4SPHzGn/bjh33UcNGZu53GjlnUdPWrxF8PHLeo6ZtqiryfMXDEg6tLloUTLdcMcV5RhYHp4WaW/pTtsjnwy4oXmbavBK7XfItMFFTGWevZrv1UShE2Sy5bAgMNTZAkxnAbMZT1iUmxNtv54rn66Is9PnTBZioJo/vijkpn+d7XnmeFkUOewI/mCA6bJ1uSNtsSHv9hTHsYgkiwJyIVklkWI1bMMo/WUWamUzEjNBJb0XLhs06hZCzaNnr5o2+hpc9cN/nbh2Y7zN1wsDOqy/bForxlOnj4LixIJK4qKQUYE5joNZ4zTcuYkVdGG/bdLTJq9seP96Lj+RM9VkDjFKANmB5GxVbAXcBEmfOHyXb0Gjz/wZp4aiJxBlMUAhBhEMEIEnLqsiKIiO6OR4FKfpqhmZSrr9t1yH7ngWPW5i3b2TYp9XIhnRFZLnOCnYh+INusP3buHbyrh7+/IVMFvCYQQ/MPm4x46TmvC4O1UIQSe3RLZpuV0L/2Wurpg6DOm/sWPypWaqzhdP7gs8ReJLSGOFawwyhXEg04GDpZHXiClWS1uirRc73Wb9o+cs2D7qFlLdo+atmR9xMAZkZ3GLTlcVLXnN9PeSOB0SR6SLHoRhSBCwNthIC2L9vc/LJXUtVy5l967LzOCAL89J34qLstCw5xBgT/2afPphRfLVCmb19IirNolh+J4omAX9LiIMEaI0eo8bt95WPLUr/dyvVgmu9eCrOQkhNFiWIgzBF7bIIwkQbISrH2EMTQ2u4povmwRoA49W5jeTCbCKXpRUvIRluFFDiGJZ5CIYUFOlGgOydewwjzmEPuE47jHWhAeM49ZjB+VKF7sYYECeR/C/P3wvfdLP2ob3uxJ7pDg6AoVPkwICgmwMpzWTadzC2QRp8GEBWNBm4IkDa+PfpgfZmKIyeyj3vCbN+8wajU6E1IIIhILt5wB8aybXcca7nAEZmLCSRiEJbyMGUbkEIcZpMGIaDBm9CyrMWkYrbsR8yajRu+RgjXZ/4KfNSUhhGV1Cb4SPE/PxMhBbd9P/KprgznwHvU8VvMQ+EEIUjCv0Zi8Qq/dvN92/rqLxSH2dx/RKZhFQWB5Xv9SB6QWDAsLFfq0GbKjZ8+wcUHexhGs6NjssiXfEYic4FKgnxBPCNYjxHM8YzC6aTw8fQ0+fjm1bj5lWZ2xjk2Qes1dsW3YuKmLu3eftLW2+vRE1fsyYTjJyLAI3jOqrlNBGMtQmSiziHt45MhdW/9vfyz37bcrO9y987AVbzKXYMzuRpFVsIBFWGoQJHFaVu8VkJfR8s0XrlpV7cYNokV/8nAhp0kUXPDqBCMwCMFDGxgesiQKYooVmZ8/NUDpjnXrCBsx84Tb4O8OlBk7dWWbeUu2DUq2CNW1PGNmZIci2i1PsOBY3a1rw3mju1e6izFW0hXP8PQMQtymzbtzGAxmNzAAMQiGHULg/5QUrYZ/mGGhFyLVx8rh1bof69ur6eSSBXJH6BS0RnE4r8kOZxKC7TEBR6qSR7xWqzG6e+rd/IKMHv4FDR7+7yG9uTbSm7ovW7Nr+MSJK77qMmxzbfQGj717o0zQGhOGOwpD62DFiDBRksp/VsSG3sDRb/Jew6z5K9t5e/s/GvRF+M6MVKr9UK9qsQdYw56RsJMwjIIwJghrDQaR1YQm2m2vtEBNX4dTdITATaPFBEMLWWghRrKiODt8WTkxfT56/mYIMG9GDdWSHQIOwaEViZyDITzSSBjxIlEUuyMhX+4cx8f37r3l6dXl2x5cWb7lwS9LN99V5dLiTfcuL9m4b32/zUe2R2x5/Ov3W7Z/33fLt0PrbT22f9yPqxd/cbhu5JhjBYsVuM+xWJAlB2JgcmIwQUhhBJYhiRXg7CW2sQrS5WQ53g1mEsRgARHZKhHZcbtovvwbRoz7asOoid3Xjhn29aoJo3utnDG2x4ppo7osHT+q65Lp47ovGTu86+xRA9uPq/Dh+8M4kczWYOagUVGy/OZxenvs1hR3Lae/7zRIUvr49OfqhNPoy09+adO61mxb/MMrPKvI6qM7gmByZ3g+NjGp9PwVe7p8v/NCcPpyFrtDQ2QhhWHQS3dyaeXCwrA8sN0nl5tVnLr12xFdZ434ptXgAJOpn9blGotsKatdiU+PJkc/uiokJD6GPhRZASNWRAjLPFDX6xFnCEkRUNjy1TuHf7tyfyf11Qh6yQGPsk2yQjyhORipP9SpDwQrksfBfXtrLvhuYas7N6+YkOQ8xgquDbIl6aiUkvQYw3sRLVIQLysIybAU1Hq4SxpNt9lbdpchJHVlh173sNkZnaBInpIiI6zw0D494hkj+EL2k+27d/foNHRNt84Dl37RZdCSL7tFrO/Va+yuQZPWTBkzb+2GCYtWbRvzMD66J+blDxTFydqtCVdctpQNLZpXHzliRJdFI76upv7/eDk7tvk/fMhhrMmp0WrNMA4QSf0H/Y+UBL2GyfILcen1q/3av9XnN3o06rtt7MBw6NfmQ4oWyNWPV5SxrMu+TEpOiXTEJfzqSIy9LztTkhlZVgjcSwqB52jYxXI6UzCnd2+6btOBiK9H7u05acUeY3r9r3OuLviuXbvlw3JaI2Z4aBmG1TchHMc/0Wk0ia+jM30ZQgj+funyWrJoDR4+/MslYS88ak+f12DSRWtc0gHJ5ohnEIckAkMKBDF80Mkz197b8/PNl/62Q5TB8ehptBdBmEMYIww8WQhhfkrpWPUTuGsyKECj/hQB6tD/FL5XK7xm9SUOpl43jFjEKfBTQgoryon58+V52LVrORFjTF4U9JIjAmPF7MF7S4pdy2AFNCtw48C0R4jcuV0dC+hTslJx8yZiJQXlZjneiDHkxHCfKQ5ZEhzRufIF/qq+b2vfsHRSq1YlEsPCiiU0hPNGjT6IDwdpUb/M486Nyv76ZdP3Dq6b1XHtuIiOc74d2HF7+dK+2doRQ21IcNo1Wo67Y3S5JPU6MwnFWKhfu+RenijLnbaUJAQOT1EIUjADKyOt19P4+Orrd5yrlFYeJjNm47ZIeC4vprB6TXRafHbDiAisdGny/uVvWn+84cre4Usm9OwwZcyAFqOHD2o2xBNr+utkzRxO0O8lTu4BzPnJjAKvOrABOUQGXhf7+Bg8fcskWx1dV2/YW+NldRIXchcFpw9BCkzqCKntwgizRHLlF12O0EqVKv46cviX88eNbj915ODWY4d902xwnuDg1ayEHrCiKPGYQQzSIsSaNLzJUG7JyvWtB3673vSyejNLV9mt23bcyHDYjDBCWG2bxCGW1Wsxy5f+5fKN+itX/1j6h02RAas2HCi4eM22ekvWb/36bmx0L6TTdkFabQ1eb8xvcHNHJjfPpW07NBg8dFCbUV82qL6iW1jZmxjjbDlzBIfNpoN1IglGLKeBcoiAUyCIKBBaFcy9stNTHXv7JqVvfNHqw617V3dbPGp4namjBzYZM6xf+NDe3cL7BXn4TuEVzRYi4isOWGxLRFAQ7FgVxoD1Jn8/d68cZTduOtBv4rcbm4B5r/L5Q16bu8HIMlpfjuN0CEATgpCkyDLDsI90svLKbUMvHAOm/1jYZk+q4+vlvbxtnZKXXkj+3eUnxXMmt2hcOUpxyTcVGQyBMYUYBml0Rs+HD2PeP33pQcHfFcjGRd0u8w1Wm8uMGZaFPoMSBMELHKRjdQ9g+a5ABP28YQLUob9hoJmpI4QwPx0+687wnFGG+UxhRERYAeZuKVGj5V/rD7Kk1SU4lBxY0ZpYxgBTHYeQjAmRFWutT4uCd07LlXFoNsPaguDiBq2bGcsaKMuCR2GIt6+vVMC7VbbePauaYbJV2jbMfpwyAAAQAElEQVT6OKZFi08eFyiQ8e+sVvOll9mzI03JyUkMS/DdhITALB26Wq5CMV/74P5ttihOx25OdroYLMDjOwdCHMKE5YOvXrvfYtoPpz9W8y47eFBz8fI1A0GyUydxf/rxZevWBVI6hpW81qvVx4cfX168fdr4LovHDW0eMWZE6x6sJA5xWmKPYSHexrAOhHmCFKw2C+d+eD+hjtpO1abMxIVEL5GQQIKAv8JCY2BxIEmi05H8qHbdytv79m+3oVv7CqfbNyl/tUujD673aPHJkdFDWs4L8nXbKNmtT4jklGG9gxCsDFjWoOG0xoZL1h1uFEUIn1mdWcWrfzr17OnLgVqtyZ1Vd46MBG2SkCgkp0j2pCNVPy0/b9qEb+bOndp3xdxv+y+uXuGz+TySo5DigvGGWUS0MBzMSHYxDKPwzsoflD31NSyOCrzG/483GjU8PDPKB53MwkpHdXtIHdyi7LJpCJuUVTtelgZGkta1Pkxp17DcrZ4t3j82ouvHP04Y1WXlt8NaTxrdv0lfX5O2h5xoXSsnWx8j0a4Q7EKwAkesmQlItiVX6zI/6rX4ptnFKHp3zPGBLKfVEfChCNApChY5lonlGI01Ld/rhisWrf/K3z9XQsTk8L0v04FhY1CxfN47GlZ7VEasqJoDAxEhluEExBXdv/9CqaioV2uvgJA7r9F6YJZhCIZ7giFIFJ1OA8tdCgxE2V7Uvcx2mv5/Asz/T+nZ2yRw8+ZNmPMUf06jMSrqWAanTjA82GIVm0mvy/Yj6oxsvH3nqQfDaDUMUjcxHEzsjMJxXJzJrJMyyp8+zuFI4u1OZyjLaHREYeH+5RGDWeTn66tEROC3uore9fPpQNHl0rCs8KhYMfRSW9VJ5/O279/p2qn1UklwPWZhgsCMgtTJguE0eovN9f6CRTtbLNlwMa/R5WdADIEJE8EmT0hJ3+aXnUdEEOZlecJqhz5tUbtwVKe6RbfMGdls6ZDBbYaKonCBZUUkqL+ulmEwYVje6ZC8D0b9os9Kn82FjZKkuGOsgY2oDskwLESny4Zlaff77+X5sXwx94QXy9cql/NW/2+az/f28TmFiOKC+ZiIog0hhcVms1egzW5pvmDkjnywkMQvln3ZdYKs6DCr8Wd5nYEQjBQigjiRINhiSpYuvLNHj/obvgore6ZVnRK32zYqeWnA0BrbPv7ovcWyJF9BBCkcY0QY65HgEDT2lOTas+ZvaaT+6dKX1ZtRuiiyvCyJuRHCDChFiEAFsqwEBvvbC8zM/oITZfOo82muxJb1Sl3u0KTUnquRI1dPHN51tJ41HFBcdlEhAhIkJ1J4jHktz5/ZseNPOXRZ/XY7ZoIwy3MI7jnMMEiRFREYJug8WXs2TX6W7YWfuUJb1yZErBIQXNB2+uiTIgPHb849ZMzGXIMiNhUcMGp1scFj14YOHL8uP0jZ/mM2lOs3dnOpNWuOhfAYqc6cUW98GDsIMSxmNXq/G3cefrD3bFKeF6rJ+pJgL55n3aFdLGEQkhUJybLk0HDMHSioVgEB/bxJAoD5TaqjujIjIMseGhjOORgtpydwxyKkwAKYELhzrBxveG2H3qH/VrPNajUhRl1WOxEsEmDSsaXA1HAVczIskjOz6Fm8k2fhkbsQqMgSmAQ2MYggRnZxPPqDE3lW4s39hJkrWEYi6tW9ZTwGj5QdzeUwFuvVyneaQ/JUZ1L0TcyA3bBAwmA2YTXuCRZSb9aKgy3nr9vjoRDGvWSJIo6I9hWdWeleuPUX/zb9N7Zp3O37iU2++n7GvO3dh9RpN6MATGjZuj/q1i1nrxdW9jjHu5+URFbikQERkUU8a1AYjrfbXZxqJMroUH916+aNRz1YXmtSCLyDkUXEcSwiGMfVrl/tQpdGZaMzKqfGNa9c4FZIjqCVNmvSJUWyiDrY6GHZiGTBjPQGv/c3bNo9EF6pwLZfzZ19YXjWqHB8TobleZlgGKcMwhIrabD+SrkSxY5VLxkAK4f/6ysfEuIY3rHJoeIFCu2UnfYYLEHPChL4Xw4pDMp7LurSF+Mn7fr0zp07uv+Xyt5ZkuBgMcMEIERAnwJCEGKIFBgUYInAWMlKy549F4xhPVdUb9Bj+ai63RZOq9nxu5Gtei59T/3yXlbl0tJgTJKuTUpcNet1PxEsJGK4N4AJUhQWIQVJZgv8TMv8GqGsEG8BnswgxKqaYa2C4ZG7IstESUKxVxyvoTK1yOCxm0KtloTmomRNvv7r8VwL5i5tPm/+koazFyytP2/x4qaLln3fdt6CZeHz5y1ot2jB4pYLFi9st3Dhwvbbd2xqnJD0KI9AYP5gZcTCrhpoIwKLFydmP9i689QHEdlY7KYaAT9cohLCYGyE/kJE3cAgEbnsSfGYKOpfx1MgC/28YQLMG9ZH1WVCIJm4NC7JkQvuEhYmKAR3L6zGZUUh2GpkxNd+X6ZlWF9Ow8HuTmYIgiUD3DSyLLg4Dt3hHKKYiTnPo21PrZjnWANCGGxS7zECp0TQGfXZ/sIRes3DYbMUxDKRP/y44EsXHumr+CC/l6V/97BthLAHJGgseBwEK3+EWZ7FvCH4aVx8/UtnrzVDjOJdMLTASxcm+w6e/3zbzn0dTpy60PHk6V86JqdYmxyLuuS7fr0KJX3NmZ/HP0GM3WEJwYzOBRsRMAmcmUSIp4eXY2Tv9zN9fPrIoTfcvfvUh+M08NpUQUT9EhpUwzFcTLHQwFj8Eqc1bECDnwKDAve6nPYEuJnB/WqBBY+MRl8PmUVVekyYU40QiEbZPxQimQVFyIsZWFmAF4MQ2sMQluGfmjhdhn9Qo1w5r+RSoQV2EYFEKZLkZAEdz8FaguU1Wp2uSOTBo+27jfnRP/tWwHAEu4dO2OTNazTPvg9AFNCKCJgl6A1uL+3XyF/uFd2+60D4wVMXupw8e7nTz8fPN9+z92i+xMQzgCr7llgsCV4ES9AVUAYz4NAx7DaJNTJyhAtiXvsjyJKbpEieCNqJ1NsONEEgNGpS0xEWlvlfkINsmX4ipm32WLZiVVs3k8e1STOG9x07uffsSXMGrZ80d8iBaTMHR86cPXTXtFnDNk2ZG7FxxpwR22d9F7Fu6qwRq2fMHbJ2zneDN3z5dfj3LEK7JdHlAMeLFGAuYYyRhg+6ez/6U6/cx/JkWvkLCYLdEkII0SuKjAmsvTDHIJfLbuck6S5kVUDo5w0TYN6wPqouEwLWRJ3O4bLnJqkrVQbuYU2qMJiVXVo5yx1kJipToy2SIyeDFC/EwEzD8Ui9S2S4C2HVEJdsdEmpmTL5ATcbM3jypnycgdETDTh0hoAzcMGTQCFOp+NvZ1IsW9Hqr0l92U7I6bSHKoQokqKoZmdLr5oJZlbSs23ZJ4O+brnWaXVcVkTY0zAcIizsbBFMHgxbFBtMXRCjyWfAfJYLk5k7d2qPn75QgtXoimJO58FoDUa9u7sXwxt8TKVvcmp92ZEx438IZFltCcll12pYJ+EYi91pS7js7aWLLFeuXKYLK8KY/TitoQCnh9WIBjCkPnEQwYEqNlbhXvrY9ZPCvpZxw5ouNum0kQ6nxSKxEpF5eD0J3enp5udz7NQvw1r02VgqO21IywOPFMyKJOYhJC0GTogsYlmyGiVBTIt9MWzWOvRS2ZIFtxHReo9gh2LFAnLqeCQZTLBkNFWKOnMtbN+tBPcXy2V2fRkh/tTZS6E6vc4DweNoQtR2wYBRFJtGo8nyqRYhBK9ftz0YYaWoTm/w4XRmk97o5afRm3yCglC2H5V3H7fT1yaiihLn5i6xRhhjHLLbUqLdTaYD6jjMzPaXxavvo9ds+MmbYVk3hMGFqksVBCGjcRXK558p45fpXbFicweXy1UoYvrgFR1rljvaudaHJ7rU/Ph055ofXmzfoPwvbep9dLZt7Y9Otof4trU/PdkCzjvUKX8svObHx8Prlj/1calCP8uWlCOixRrLqs/JYRyJ8KoB8Rod5twqbdwWVV5l+zI71HSb3ZETEVlLYKOBYN7DHIZNjOjq27tNCsYYBpWai8qbJMC8SWVUV+YEJs1cyYuCIwBWq88yYQ4cOoMwvGrVO8TXHtxxsY8LyrLTH/SCD1cnBBBEYPqDSFnOUi9MmNzZi+dKYR6ZESYIs3DDKSLcr4qFZ5hs/R/fZ435/c/FK48WGj9nTj3FdAbeff4+Le1q0qQ9xscPHgUqCiGwACFp8dkNMcZilXIB5428caUgkSQFwbKGEIRZFiGWM8iMxp/hdIJJo8/0kbVaV/eaNcWC+QsmcBqDyGoMjIxYhDHSQ7/kAgY6Nc/LJJIQLvLAkWY6rSYnx3Icy8jE6UxJdjMbjvUd3GJbVuVdshwkK2IoPE3gEVaQ2gcIlmUMp86A2VvoNPyoyN1g/xyrJQndl5AkExYhQXQhWClpTe4exTfv2dkpKxvSp60jhJ04a7M3TMLecvrqFZkgAp7URwNeNX2J/5+rj94L5s+1RRSdxxVFdEowppyw9VRHt8Zgdrc5LXVGD1maFwYYWPj/cpmexcZqREkqA32hAa4IYfgwGMyQFZZjs1wEY3AYZcp+lMDx+iSCGVZWEOJ5rY7FfC6rwnigbB6wo6+v0WhLIUYHyy0WO0VBlGR0dt70gXuyqSLDbGeuI/dHD6KDeK1Gh/BvOKB9DGZkhoW+z7BU1pFNO0yvl5QUV8nb3Xdf2yrFXuv+bVAhtyWsab27sstpg+05whh4q8yBIcdpc96+c6/C3NVHX7pLj5i62+vh/Xu5ECJaBOVlWIzBmICNPm+vWCXw92Mo62alpkZGXfOpHxZRZfL87T6pEfRHhgSYDGNp5BslcOPGDe3la3dL6ExGf5ZwCCsEsfC+lCOSJLmsTgtMT69T4cyZO7W/XLiVU2JYd8LCDIZgYY9FxBBRYGWJPHiJUucTxKXYLeUNWr1BkVww9QqIKIIkWOLui1bntZcU/0Py0qWRujqtxjecumBVRFxC4oeiCI39Q65nEcd+uVECYW0gw+rNPMu81jgsVSp3yrcDWmzjZfsK2REfwyD1CagEbRARzBgEczqLRstk+U1ojLEyoEeNtXmCTUtTrPevSCTeqdVyblC+9YiBG2GXSmCafWZzRj/BOeExnb8fhDUoXKtxaLCS4nTFPznnxfNz5k5pN73RB8GZ7iTVsovm7g5EBOflsJFFRIOQwiJGXVQQomAmvUfNqPb/x00a0/ZQoEm7lE+yPtaILoWwCnIxBMkMpzGb3MIqtp7Z7/+5Mz9zO/7Q/c7dB6W0Oo2n+gU/BtsQltXXuYRFGDFeFgdBWRyzBteK/eS9UutlR3KUm5zs8pCgPJKQpGWR0SugzK/Xngw9eDk2W3/wwxav07oY9Ali9FgiDCLqfSOLCLy8QlJsWdqhmji6Z92zDap+staZEH+BhXcSPJI0ouD4fPqcLYXU9JdJhyFbW1ls4pd6ncbPrFhc9keXL+LkuJnLxn7Vr2HFPFmOq5fpljmcixCmNM+wOgKMm4KB9gAAEABJREFUFSYRsdiKsDMFK6KY5ZjLSHe7fj/UOnz8TGeF6N2mTO25GWOsZJTvZXFQTi5W0C1BdCQ9lRWXC+YRpBNlpEUEYU7iBCyXX7J8T8WtR6+as9J15nbSB4rOXBTWKloOCUgn25HWmejQ87qbDgmWRFkVTpd24elTY5NOC+v36j930omzv9Z/dDVaSZdMT18gwLxwTS/fAoFYwc9od1k+0up1Bth8wYSNEJFlhOFCxzGMh5HhXqfa84/tOZyCFMhp9CzciEhRJFBDkJbnMEToNCyb5cQwou8ELcuiYKTILIPVrAQxLEM0LOPUM+h3v+8ZFGf6Uf9ISdVWM6uNmr1m6Imo890SEpPLsgxvNWhxpt8uT7E7qiCW92dYzWu1XTUGY6yENwi9N7hnq/WKpFzHABWnTjzgezC0iEEOu0N8aTuqlcn5uEBwyBzFJa9yOYWrMHXJHI9Dr16+3b5y80nqjjLD+6TpF8tzlGs4YeilC+e+cDeb8wiC0yYK0nVfr6DvFk3tN68m7JxVOzOTbduumR4/ifNXFEUnCCImCoI+JAjagmTBpVEkWZNZ2Rfj1UfvsyZ8sSLAP2S96HTFshqtwvAaxHAahtdqvS9dudSieuvpjV8s9+K1gzg9nYK1FHDkZUVEGMuws2URy3KEY3k+AcHc/mKhF65Hda97qHDhgttsSYn3FadNUkCPS3QihteYtLy20jc9p7W9dCnm2XvxF8qmXRLwdt9ELMnLsjiYIFjrwF0D/Y04+MEzWKO4HPq0vJmFheF1RMnCIRt4gcwVHdJ5SZRSQE2O23fv1/u4xtBCEVBHRmV7Tdvs8VHjsR327trTjeOYogzDooSY2BsGzjhv7Xf9pzSvU/DXjMq9Slx8jBSoyFJ+YMpiliCEJYSRhDhFZh12hUGvcHQY+EOV3bt2dRBkqYBGa7ySp1LJ2Fco/oesOq1iU2QRHLokMGAVC4JkCSlEwpjDQXcfPKh882p0/j8UTBdhddrKIYYNZDmegT5DGBZisIkRDDptglPyVdJlTXdKcEREBKNK0y/m5qjcdHST5q0mjd1/9HDPJ7Epn+TMl1f70UcdX3o/p1Oonv6nhPlPtfZvauyAiNmsYEnkrDH3f7HH3T5ljbl11hp/+6Il7t6vkjUxUUyWspzcMjP70a2bRVwp8ZLtyYOTlsd3D1kf3z7piLl72pHw5Kot6aHOlMKzmZUlhLDHj5+tzEjSo7iH906kxMVcsCfEX7ElJd50Ou1eew7uHpnv454TC3/Wc0bRCj3nFq/cZ3GJqgOXFavcZ2nhKn2WFP70qwUFP+48q0D5ztNHjV8w8tSJY+3ikpM/FmTR3WG3PVUk8aYJ8xk69CFj1oRcuXA8WLDHxzuscfa+vWbwmdn5sniMsdTg43JnenWqO1KIebhJib4TJT29fVGIeXy+bNH817/tX8/6Mh1q+vfT2zw5sCxiwcdFi3aXY+OXKwkJl2SX/f0zUVdHf1B/Ut9a7ZfUqd1mUWjtzkvKq+flG06acPDwkel3L1+ub4t/FJsU++gAp+CB/h7ubZYt7LOpYrmgOFVvVnLPkhSSEP8wn9Py+Kot5vYlZ+ztq2Lc3WuOuFtXXMlPrdbkFG1W5V9MqwJPA+ZPbTXJ04T7JD26tDn+7rljtsfXr7GW+PuyNVF38ucjLWo0m9j0xXJp11FRjw3Dh8wrjp12Xyk5/oGUEv/QmRT3IDn27s3EmF/PW5Puq21yS8ufWViyZIBt0vAOy/LnyzsxJT52qyvmQZQUc+eqnHT/qiPl9sMbv/7yaevOY8KrtZlkzEzH3bt3Ned+/rkCscVHO+Ju3HTEX79pjb35a9zTm78kxty/Fff0Ec6sbPr4vl0rxu1eMWZtu4ZVugnJ8d9aE6JPOly2POev3Ry0qerwHvXaLaxav9384g07zCtZt9PcSh+HjRu8cvGmGRfPn2vndFiNluQnx7AgjHM3mdv8sLLvmhqf5X6SXv/rnG+OPOexcuUaT8kZf88Sc/OCGHf/siv24UVb9IOzTkv8L6sXrcv27v/Lgas8N6xd9YnVGuPmsMTd0vLcpmIIVgavY9hvZbREG88o5FRK9MMoS/Sdy0Li41uuhCe3XQlPbxNb8gPJZjUvnb+mwLrISxnOWxER6zSXz5xGzsSnd62x92/a4p/cFKy2a/Zk+x1rYkL+1k16DCn88dfjzbkbTzXlajTLlKfhd6Y8jee752+2aPr315fOXHltyYHte0efPRHVNvbeo89Y0RkgWJKtjCwnqb8Y6DczaZABAerQM4DypqMqF/soMcjTe46/u/8Qf5NnP1+De18fo1ffIA/fof6ePitlo/O1frGMl6fnST9/97H+bh49A908OvnpPXr46ty/9Hd36x1g9Nl4sZBPpl+qAkcoe3kEHBo+tP9gb5NbuLtW39FNa+rqqTf39TV5feut9dyKXJqtkmjYJEueW0XFc6dAPPYqyGuPIrntUZD7TkU07JAduh0Gxm2rp8lnubfBd4KXya+fp8l3SLeu7X+qVq1EhvVfv/AkTseYZrsZPHoG+ASO/rpVbdVRvDb2PHmws8mXlQ8P6d+5v7vR3M1D597D2+g1snThwgehnSS7isuBE+6z4qsT2zZMGFG2eMkOPmb/+Ua9e+L123fLHTx6tPPeI7uG7v1pd/dDRw63vnb9dn5e4xZr1Aes8Db7td+2fkKXNSsHrvxl/4hfPizgneFC5kU7HC7pgbe79zIvg9cIH4N3Hw+Nd18PzqOfp8ZzoLvR9zuNhr3+YpmXXX9Y3BS9anXnzdu3je+5fNXkVoGegV3ddN6Dc3jmGhTsm2dpTHTyg6ZN17EZ6dHpEqTkZOt1H7fAGR46715unFtPN9bc203j9g2M1/7eGvfVyKzPVl99UMQtfvL8Lj8sWT6xZ/HCRTqbGbfBRsU0yMi59fbxDJrqsIhH4q/cEDKyQ407fTq36OXmsQ/G1Cg33n2gG+M2wEPj0ded8+jlafIe4efpe0DNlx1Rv4E/cUSti7t/GDZv3frpPWpWrzfbzeR988HDp4UPHDncct/hyJ4//rSvx6HDR9veunGvhNHo4woMyL/L0z2oz+z5QzsvXzBw5oMz03+pWPrPPWZPs1WMLWWpUPnT/UHevoN93fy6emq9OvsafLr6Gj2+8Hf3Hlyzds2zaXlfFlYsw6fkzpFjDTwV6uvvHdB3zvgxR2HMZ7IDfpm2Z+mtG5WN6dm5zQY/d48RXnr3Pu56t55wT3X30Lh946Zx7wXzwzAFMYd9UazzWYnf/xwxoqlYNH/e7fmC80UEBeTs5WMO6OVl8PzGw+g1yMfdZxoS2H2KwOwP9stzIF+eIkeLFCoXVTz0w7OFi3x4pkjh904VLFjuZMGCJXcXylNyVd6gIjNyBRQZm8uvwKjC+Ytu/X1N/4Crf5gJ1KH/BR0SEVFRunph4d0bUd9dWDN3+vEf5s84un3Z9EObl808fPnEzGvTeoc5XseM1fO7xN8+s+D+rfPf3bh5ZtatJdNnnr15Zsb5m6fnXrkSNe1pGIbnpVkovnluVuyAzh8+fHh+wY17UG755Mkndi6bfGjzwunHt6+cfOKHeRNPrZ017tiOpSMi960YsvOnFW237F02eOuBlR227VnRZfeuVV8f3Lay6+Ftq788sm9Dz4M7Vs2K3LBo7s/rlyw80f/rqk9hYiEZVb9+fW/H7avLLy+csTRq2cXlp8PCyr9W+9PrVn81bK92H967dnrqmbULpx7b98Pkg00HVLmaPk92zitiLH1Y3D9694Zvrvy8u8/6Q5v7R5zcNeibU7uHdP9pw8j+P++Z1v/Yril9f941qseh9f1G7F03YOnd8zMvfF48x4NP4BFvZm3OqO4BHT+xLDs/85ftqzoeVGX/+q779278au/ejT32HtjY62j/DlVfa6FXLijIXrlQyKMWH+W5+/2sicf2rPt686bvu+7evKrr/h8Wjjm3fn3G/yUqNDRUWD513vXIzd/s2f9Dt10H1n2986f1X+848MP0fZsWzz558/Ls2y/7P/3p2/mJr68lrHzIo583D754ZHvfXZHb+uzeubb7oY3L5x+dN2vOlTNnFojp86c/V3di389ecOnw1j57j2zq/uORLT13Rq7vfmDr8tlHNy+Zc2LTiq9upM//snPoF6V06TxJtT4Mfjiub+vDe3aMnX1kw9iIszvHDT22adKIU1umDz+9bsKQg2vG9P5p1aihe1b0n7Pmu/GHWn1a8PanJTwSoXyGY/ll9WaUrrZt/thGT68cn3bh+vFJUQu/nXb6xomZp6+dmn322tmZl8YNqpyQUbmM4sLCwuQLR+fcuH1m4aW7v6y4VrdukD2jfK8SB22Vvx3R6PHmBXNO7FgxPXLPqkn7ty2buH/Xuil7Nq+cdvj65QW/XD41O7pixYpSRnqhPJk8oN/ltTNGHlo3c+yBbcsn7N+6cvJPO1ZPjVy9YOaJDcumHftxdfejO3/odmDX6m7bf1zRecPSJe1WL1/SZuXSpa1XLFvR9vv1KzpuX7+q87Ytazuv37H+i81bfui6q9/X4aczqo/G/Z8Adej/Z/FWz9RBDiKXK4dFVUJDsaCKGve6FUPZ1EkmLaxYEUtwLoMoIKlp2dGt5gWR1fKqTWn2qaEq6q/sDAnBjiBwFGoYEhLiyJMnj7NAgQIu1Qmo8uwcC2p+VUBflrsESE+tryI40OzYmJ08oJOApDJWbVZ/CU12ymWUB/SQgIAAW4ECgbGFQkIehebLd//TcqH338+f40HJAt4PC+f0faymqe9pIW+Wbc1If1qc2n6Vnyoqw/TyZ/Sm6Vf7Qu2v/+vFrrS0jMKKMIbUvk0vqSxh3L6uPWq5NH1qO1Wb1Hoyqj99nJonrZwaqm1Qy6oCOjN0JunLZ3autqdELo/E0FC/p4Vg4VOqVMgjVQpBCP35OH9+c0y+fF7Jaj2Z6fiz8WB/6liFMPU+UMN0ku17V7UDyqn3e6qo129CVJ1q+9X5QOWVPoQ0dY7J0sa0smnlVB2qpMWrfan2qTqn+Pn5WQvD4i+9qGNWFTVdFTWvqutNtO1fpOOVTaUO/ZWR0QKUACVACVAClMA/jwB16P+8PqEWUQKUACVACVACr0zglRz6K2unBSgBSoASoAQoAUrgLyFAHfpfgplWQglQApQAJUAJvF0C/yCH/nYbSrVTApQAJUAJUALvMgHq0N/l3qVtowQoAUqAEvjPEPjPOPT/TI/Shr4SAUJItn7jWHbzvUrlqk5VXrXMq+TPbl7VDlUyy59VWkZlMsufWfyr6MgoL42jBCgBhKhDp6PgnSKg/tnWVt1nukVFRfEZNUx1KDduEG1sbKy5+7h1vrlLds89feF+/1u3EtzVeDU9fTlVT4VG3wYXfO+bPPk/6B5cpGyvQFXyvdc7RJWCH32TI33+rM5BN/P06VPj0s3nPIJLfpEjV5keRQqU65F30Lj93pCW4a95hXj28ePHhueJ12sAABAASURBVBvx8W6dun8fnKvU10XVsuv2RbnfIUQH6TijOsvWjTDkLdslp2p/Runp43buvKEt+N5XeVp0/y4wfXza+eKtR835SnUpMGnSHr/ncYuPmot+3CNn4Q975VYZBL33VUie0t1y5S3bI2eR0n1yqbwKv9/NO/2f0K3Tdm6OvO/1Krjzxo3M2opT23oj3i0HlM1dtlvh0rXG5LqVkOD++DExpNX9Yrh0aaSubbfvvB88eJDh73ePmL/dkCe0k/+KFXsy/VWzL+qk15TAv5EA8280+p9nM7Xon0BAdR69J0yutGXbrvkLN0RVftEmcH7csFm78pav36FryHvdFs9buHlVjC15cf+xizaVrPjFtgp124Wv33PFM325YTMO17h64+rWZHvS9qdxj76/G3tn5YOEpxtjk2JXx8U/WhL79HHP9PkzO4e62SWbLxcv/MmAb7/sOWZ9dPzDFU/jrk57mnR/+ZKVK9YOmrS90YtlLxGi6Tthd5myVccNK/Ne97VrtmxdlGhNnJdkt2/9svvCTZVK9+u+46frQaD7D07dlWLrmJgQs7xJh3llM0pPqwvS2M4Dvy2dYrFvTExhOqbFp4WQjgcNnFsl3mmdn4DFmmnxd6IfV3z06M7cJymxa59aY7dZnSk/JYnW/RanfWucLXZtfPyjpfFx0V3cAn59vgiItVrGJNis2wd1XFwU9P5u7lGvg4p3KxxaeWREaKUvl0c/erzkXuydaeeuHF9WvHyPH2t0GhVxKSbmD787fN2xB/p+E79vsHrHT9uKVRowuM/k7T5pNqaFN27ENroTfWf6Iyv5KC2OhpTAu0jgdzfVu9hA2qb/DgFf38t6DjEBWp5nDQaDI33LwWFoRk798f25s5f1ILK9fK4gv6iSBQpMKlEgX6/SRYqN9PQwX7LZEz79duTcHOnLORy2IEQko6dX0ObSxcoNKVfi4/4flP6wZ7niZUDe61m69Huz0+fP7Hzj9tOFv+oRMZTnZFORfAVnFc8f2rVkkfc7lSxYZmyBPIUPBfh4/O7XfT54QPRLxmyqsXLFqkGSZCkTHBD0c2jhYlOLFwjtX7Rg4Vk6LU602Z6Ef91nUrsDB+48d5pp9TtkMVgiipe32fAYY0zS4l8Mjz98qGGQnIfTsIrRoI15MX3XrpNmhmOCeA0vMxxnTUvPlz/3qXJlykd8WObjfgULlVvg7uF/12DwfJQvb7ElH5Qt3/vDMp/1KV641Gofg/357363pCSZZULEmQt6JYFNz3+7HvQNl6PUlyXt9pQpRLAWL5Q3/7FyoSVnvVf4g4El8pVY5u/n8/jB3atV2zQfOeAqPFlJs0ENTZLTpDO7hXh6moK0Rr5ObLIl7M6dOzo1TZX586P4PTv2GXU6ntHpXu9Piqp6qFAC/wYC1KH/C3qJmpg9AiLPuQkMkwvrdFYtr3uUvtS3Sw+Xm73kh+5Gk3vQyMFffHft2HcTo/aO2ndyd8TFk7uG7e3XqXHvqh9U7BJ1bNbl9OUSHTF5FEVgiGjdfXjroBNHdvQ/e2BTr9M/bfrm7IGtfa/8tKnvvfT5MzpXH3v3GbE0p8ndLednVaqdOBc5ftvZgxNunt479sHPu0bsOrpz8JheHT7bk77skl1Haq3afKC3l4cHKpY3z4hfj00ee3JfxN5juwcfP/Xj4OVtmzXpyurQ0SRnUpuuA2Z+dOOFx9gOjf5jl2eA7/z1A5871PT60841glEjEzGngCwprJa9nRafFiazRnfEcjm1Wp1dr+Nj0+Lbh73/9MCmQaf3fP/VkQbVy10QHIJVEeznen5VYfuONV8c37mxe9RPO4feK1eunKiWqdAuQvfwYSzPcIaUYF4jo3RHvg8GlIpLjvsOK07xow8/7H/x0LhJJ/ZE7D+9L+L8xQPjl29cPKAbFoULTxIc9foM3twuXVGEec7IGdzz6dw8fHUeHvn37zvWZsaaSzUIISyCw+qmBGjNPoX1BjPRsZwVouiHEnhnCTDvbMtow/5zBCSF9RAlKQ9DsE3H65PSAKjvxh89ii4pOKx+HTuFre0WXvFoWlpa2KNHLdf69b0d6XeOaprVluTvdAmKxSHifT9f84+6cjfw0p2YgFOXYgLS7wTVvJmJDraG/kEBDItl05Onj4vujLqfL1XPpUsmcDzci+VUvXcf3S/lFGxePXu0WXlwV8SJF/OMH1wlvvR7H+7jeW0S5tk8DOP9fFeq5pVEgZEkkhiEMnwtrmZJFZ4IWpcg5mJZ3sEhJjo1Mt0PzAgmUXb5MoRYOUYbny7p+angFNxdgsDJEnmkdegszxPSnZhsbt4cg/QGnfExy8qpTj4t2SY4WvEcNpYt+eGgnau6/5IWnxaWzh+QEJK38BynILM2uzVXWrwayopsctjt/rzW7Y6Pf56fFcURsPqHjfX7TtlRQE1nFN4bc7w/r9En6ThjohpHhRJ4VwlQh/6u9my22/XuZJQVyV0mbD6zu5eArKbnDv3QmWMFNq//saxOy97y1OJfs9vidbDLEyQt7AA99AqnHRrWZfKoyvWHRnxatfeQGvW6D6xQa1TR7OhS/yDJuIh2v3p7Gg7/evlC8WZtRqyt2Hj0xApNprYI+2L+e5cfJHul17Nq/91SO7bsKwjO7xRvZjL9q2IajJNYIskykr0Fwf58YVC0QoTJkRDN6xG6FxiIFJTVQSSNJEq5GYXFjCL87rG/WswuEDdRcPpIoi1Gcab84ZG8mkcUmSBZZL293D1jpYJyhg7dgeScCLm0Wpa/ZWM1z/9ATP6a3bV2a/wnHOceu39Lnwz/Oh7GWO7Vo5kDaUz+mNHkVutME9mF3CVZCTFw2tO5/H2H5AgK3iRrtRVWrdvRYdrSSA/EagI5jVsendYjWcAcdehp4Gj4ThKgDv2d7Nb/ZqPsTlnndDk933uvDImISPenHTHjjjDx5FhNrCKjDHeZGRFb2GKif0pcohvHscmFCuV7UrZ0oYRSJfJby5QpZClZolB86dIllIzKZRRX5b1ct+dMGzasUoWqiz/55KOoXLm9vWTW0WbfgT2Tho9c2vHcnUSPtHJEFr0YovjyLG9BmLWkxb8YghMPQbLIYVl+hLFWSEs364S8Og3nZja7P4W4TN+fQxqySywnu6x+guh0JSBHrBqXJvD0gL37MM5HkVw+Rr02wVvr93yRlJZHDQXJ5eFyOnWdOjW0hIWGPrdDTUsTWXLkwkQy8Br8mLUJz3foGofOk2EZDa8z/q7utHJqqL5O6DtwRj4thx1Go+muGpcmTkHRy6LD54P3Qp1bZrY680WXeut5hrkkuayVbt6La/LoaXJOweWE/meSPDnBllaOhpTAu0iAOvR3sVf/QW36K025efcRx2ENY9Kbnenr1XLIwXGci2FQPpZhQ9KnZXXuYXQLNrOcByM4D02aFN7nwKp+/Q9tjOhzYN2wwZFbRo3esvqb81mVfzGtYrmguI1zO3y/a2GXLycP697m/XKfL/L2D1HOXLjZ8Medlz5Ny2/W6OPNnJtFo/AhWifrnRafPvz5wlO/2If3PpNcTlv+4IAjhQr5WNPSiaLJyxIi6zjdNYhTQDL9MIILy0hEEpFEncKY0mfcduCSz8LvNpZmOS2qXPnzu127Pnsfnj4POH3m3p1HRoxYbDByEsrkcEmOYIeQJMliym2WTXru9D8pmD+FwayoiM7ggwdjDS8WB/34yD1HDkWy1ZItT34xKcr69Hlu33rEsRgzWhal6nS3ljkdaDTOEB2OxM3bDjTftGF/fUYhvgG+vs4rTT9ypS9LzymBd40AdejvWo/+R9sTGRnJLVq0Rc9zKMVg0Ks70+ckfH3dnwQHBl0TZCXP5dtPKu07citnVFSUQS1z7Ngx/Z5DV/P8GHm91K1bCe7PC6knnCEPZjgTg7iHxCGKUIZX/2ucKqqjQdk8jh17oN8deTl/ZOQdD7WsWqz6R8FJH5cvck6SpeuS5HRgLD93hkEhnk98fHzuOgRLvgvX75ffe/RqkFq3au/Wo1fN2w/dKtBn4PTO9x/cDQ4tWmLX6FnhT3C6b7KLsiWfJIg68HOPd+26yUQQwkQCH1XHpUuXNGr9aYIZXmJ5XTzCnE9sgv293ccue6n51PDitejSDtn5vrenz9ViRfNGpZVJH05c8rMx8tBRI8/jFA3PZroDFkVboCS7NHnzhTzJnz//8x36ggVd7Xqd5pYsJAa27jGi5uGzN3xVXirfo9DWzfsvFR70zaQwRrKUNOn1pwsHmc6l1b8O2jJr/g8eOp536bRuD9X4sDAsDxr45ekC+YtuUSQxSBLjPiWygw1rXtkWgem33FVGVN5dAtShv7t9+x9oWfom+urg0as7clkfwW7tTvqUGp8VffJ1t8Y7A/LkvvbDj3sbNftqVK+abWfVafblwsoNOs+v1fqLiX3Cu47tc+LivTzpyxGkKcAw7lpJIj6RRy6Va9BlbuUvBzau+PWQZhVzFG5W3r9w0+Lp82d0rjqmxuGDczdq3f+bFl+NbPn1kFYVP2405MO+U7Z9MmPG7LpJiY9CPL0MPxbJ53kmrXxY1dD7det9ugOz6O6SlRvCWrQf9WXVxhOqNOg4q0KHTmMbt/1y5LDrN69/WqhYib3TpvVc9kFwcHxaWTW0OqwhrM6kkSWpSPjQCRW/K9Lis8Zfzq1cp/2kKo07TPlk587//2IXxqBPMbn57GcMbv5Xbt7p2abbjNZVW06r0qL9+GYTpy9q6HRY7OU/LLutR+vPrqi6XxSHLcVdEh0MIfY7DKskvpiedp1sTfKUFVHqMzAsARYfv3tqULVuhYkEiT9b7UmDmrSeGF6v7aCqXvmblW/Y5dsmX/Se0UsQHNXdTF7runRoOTsiIix1J67qDUw0GxlF8mNkZzTP4sdqnCphVfMlD+vXbk9A3pA9gpASKziTb/FEjlbTqFAC7zIB6tDf5d79j7WNw2yC0Wg8bdLyv3PoKobmNUuf7tu91bycOXPsI4qklYlQy6UI4S7BViskp7dUv26VjYVK5PpdOaI47QzDXCHElWtcxNTw5MS4Fi4ktXMpjg520d7B5bBXU3W/RHCtOp+LZUoXTVCwVB4ebnc8f/biF3NnLmil17F+FT/9aEvfnm03NKpe8ndfOBvydZV9tatUnpMz0O84waKfyDhbSYrYUpIcH+cvEGypWbvmoqlT+y0sUyDwD++eiSwkgIe94rIlFIf3x21ciqujjMUOgiS0SbYl1T516tzz35hWNq9nSp0a1daUK/feRqS4EkXJXlFUnOGy6CjmadY9qVnps2X56xfckVkbOUkmBOFHWk57jkUoLqN8ERERjMNqv6/nDFFuPPrd7wdQ8y8f3epMeKsWcz75uNwBUbDldhJHTReSwyXF+RHPKZa61WssC6/fYcbgHrV+19ZklIwURbZoNJozehZfV3WlSf2K+W/27NLwhwA//60s4g5gRvndu/e0fDSkBN4lAtShv0u9+R9uS8Vok4BwAAAH7klEQVSKodZGrcIOdmhZbwmy1szw29Jtqhc/dmHb2GFdW7cY2jk8fFrndi1ndW3bZuKCsd8MXjylzZZy+byS0yP8rGze7Q3qVx3dpmXTqR3C237XoXXb7zq3bT2zXXj4jPBWree1bRe+Pn3+jM7V3ejiaZ1uLp3WZUx4i2Yj24c3m9GyRYulrVq3nBsxsPuoLYsGzg2vV+5+RmXnTwzb1+DTiYNaNG4xuG2z1jNat2o5p03rxiPmDmvUa9X0zhtetBf9djRvXG9VkzrVBzRtVGNwi6aNx7du3XZ6h1Ztp3RqB2G7dssjIsKef5sd7COLJrZ+OGhe15GtmzYY2LRZ/UlNm9af27xl02kju4dP2Ly49+6IihWl31T/Ifi4tCm6ScO6Gxo1rLw2p9nyfJecPiM4dKVHh1YrO7RsNt1DCsnQ6c+KCDv144o+/bp2bDmsddMmC9q2bDK3Q/OWgx+dW9J3xcxOYPMfbbA/KZ5Sr1bdH+vWrDrj/cLBf/jvbu1rlTzR/+umYxs1rT69eLB0Ob1N9JwSeBcJUIf+Lvbqf7RNk/tVt0X0axQTEYGVrBBMGFQn8duBNS5MHtzo+MRh9a+VKxdkzyh/zy8+vzEton7U1IjGJ2aMbnxalWngeGYMb3Jyxujmp2eODMvQEWekq0CBAq5Jw+remDq08YmF41seWjiu1flOYeUTMsqbPk5ty+zxjeLnTGh+ev7YFlHfRbR4XK7cH7+clr7MmP4Nb80a3eTcd8Mb/DIvotGlucMbnpk2tOGpiQManhrXr/7F9HnTzitiLM0cWO/+wqFNjy0d3/bQgjHNb7VvX/F3Xy5My5s+rAjOfsnEFo8XjWsZrZ6nT0t/3r9Hw1szx7S/ERqKnz8yT5+edq72zbwJLc7NG93i3JSIuhk6/7S86vvyeZMbxUyPqHO7Vq0CGX7hrWXdcnFzIsKeZmVbmj4aUgL/dgLUof/be5Da/y8lQM2mBCgBSuDNEqAO/c3ypNooAUqAEqAEKIG/hQB16H8LdlopJfB2CVDtlAAl8N8jQB36f6/PaYspAUqAEqAE3kEC1KG/g51Km0QJvF0CVDslQAn8EwlQh/5P7BVqEyVACVAClAAl8IoEqEN/RWA0OyVACbxdAlQ7JUAJvB4B6tBfjxstRQlQApQAJUAJ/KMIUIf+j+oOagwlQAm8XQJUOyXw7hKgDv3d7VvaMkqAEqAEKIH/EAHq0P9DnU2bSglQAm+XANVOCfydBKhD/zvp07opAUqAEqAEKIE3RIA69DcEkqqhBCgBSuDtEqDaKYGsCVCHnjUfmkoJUAKUACVACfwrCFCH/q/oJmokJUAJUAJvlwDV/u8nQB36v78PaQsoAUqAEqAEKAFEHTodBJQAJUAJUAJvmQBV/1cQoA79r6BM66AEKAFKgBKgBN4yAerQ3zJgqp4SoAQoAUrg7RKg2p8RoA79GQf6kxKgBCgBSoAS+FcToA79X9191HhKgBKgBCiBt0vg36OdOvR/T19RSykBSoASoAQogUwJUIeeKRqaQAlQApQAJUAJvF0Cb1I7dehvkibVRQlQApQAJUAJ/E0EqEP/m8DTaikBSoASoAQogTdJ4I8O/U1qp7ooAUqAEqAEKAFK4C8hQB36X4KZVkIJUAKUACVACbxdAn+1Q3+7raHaKQFKgBKgBCiB/ygB6tD/ox1Pm00JUAKUACXwbhF4txz6u9U3tDWUACVACVAClEC2CVCHnm1UNCMlQAlQApQAJfDPJUAdevb7huakBCgBSoASoAT+sQSoQ//Hdg01jBKgBCgBSoASyD4B6tCzz+rt5qTaKQFKgBKgBCiBP0GAOvQ/AY8WpQQoAUqAEqAE/ikEqEP/p/TE27WDaqcEKAFKgBJ4xwlQh/6OdzBtHiVACVAClMB/gwB16P+Nfn67raTaKQFKgBKgBP52AtSh/+1dQA2gBCgBSoASoAT+PAHq0P88Q6rh7RKg2ikBSoASoASyQYA69GxAolkoAUqAEqAEKIF/OgHq0P/pPUTte7sEqHZKgBKgBN4RAtShvyMdSZtBCVAClAAl8N8mQB36f7v/aevfLgGqnRKgBCiBv4wAdeh/GWpaESVACVAClAAl8PYIUIf+9thSzZTA2yVAtVMClAAlkI4AdejpYNBTSoASoAQoAUrg30qAOvR/a89RuymBt0uAaqcEKIF/GQHq0P9lHUbNpQQoAUqAEqAEMiJAHXpGVGgcJUAJvF0CVDslQAm8cQLUob9xpFQhJUAJUAKUACXw1xOgDv2vZ05rpAQogbdLgGqnBP6TBKhD/092O200JUAJUAKUwLtGgDr0d61HaXsoAUrg7RKg2imBfygB6tD/oR1DzaIEKAFKgBKgBF6FAHXor0KL5qUEKAFK4O0SoNopgdcmQB36a6OjBSkBSoASoAQogX8OAerQ/zl9QS2hBCgBSuDtEqDa32kC1KG/091LG0cJUAKUACXwXyFAHfp/padpOykBSoASeLsEqPa/mQB16H9zB9DqKQFKgBKgBCiBN0GAOvQ3QZHqoAQoAUqAEni7BKj2lxKgDv2liGgGSoASoAQoAUrgn0+AOvR/fh9RCykBSoASoATeLoF3Qjt16O9EN9JGUAKUACVACfzXCVCH/l8fAbT9lAAlQAlQAm+XwF+knTr0vwg0rYYSoAQoAUqAEnibBKhDf5t0qW5KgBKgBCgBSuDtEniu/X8AAAD//99vBYEAAAAGSURBVAMALLSUHnHzX1kAAAAASUVORK5CYII="></image></defs></svg>',1)),ft("div",Wut,[ft("span",Vut,fa(u.value),1),ft("span",Uut,fa(c.value),1)])]),re[19]||(re[19]=ft("div",{class:"flex flex-col gap-2 py-4"},[ft("h1",{class:"text-2xl text-[#1B84FF] font-semibold"}," Hallo & Selamat Datang "),ft("h5",{class:"text-sm text-gray-500"}," Data anda hanya digunakan untuk proses absensi dan tidak disimpan ")],-1)),ft("div",Gut,[ft("table",Hut,[re[18]||(re[18]=ft("thead",null,[ft("tr",null,[ft("th",{class:"py-2 border-b",colspan:"2"}," Informasi Personal Karyawan ")])],-1)),ft("tbody",jut,[ft("tr",null,[re[12]||(re[12]=ft("td",{class:"py-4 w-1/3 font-normal text-gray-500"}," Nama ",-1)),ft("td",qut,fa(f.value?.data?.employee?.name||"-"),1)]),ft("tr",null,[re[13]||(re[13]=ft("td",{class:"py-4 w-1/3 font-normal text-gray-500"}," NIK ",-1)),ft("td",Kut,fa(f.value?.data?.employee?.nik||"-"),1)]),ft("tr",null,[re[14]||(re[14]=ft("td",{class:"py-4 w-1/3 font-normal text-gray-500"}," Departemen ",-1)),ft("td",Xut,fa(f.value?.data?.employee?.department?.name||"-"),1)]),ft("tr",null,[re[15]||(re[15]=ft("td",{class:"py-4 w-1/3 font-normal text-gray-500"}," Jabatan ",-1)),ft("td",Qut,fa(f.value?.data?.employee?.role?.name||"-"),1)]),ft("tr",null,[re[16]||(re[16]=ft("td",{class:"py-4 w-1/3 font-normal text-gray-500"}," Waktu Absen ",-1)),ft("td",Yut,fa(f.value?.data?.dateTime||"-"),1)]),ft("tr",null,[re[17]||(re[17]=ft("td",{class:"py-4 w-1/3 font-normal text-gray-500"}," Status Absen ",-1)),ft("td",Jut,fa(f.value?.data?.status||"-"),1)])])])]),u2(r)?(_s(),Rs("div",Zut,[H$(qK,{type:f.value?.data?.type,title:f.value?.data?.status,message:f.value?.message},null,8,["type","title","message"])])):oc("",!0)])])],64)}}};export{mct as default};
